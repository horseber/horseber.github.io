<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>horseber</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-09-19T10:03:59.878Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>horseber</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>neo4j的java开发</title>
    <link href="http://example.com/2020/09/19/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/5%E3%80%81%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/Neo4j/8%E3%80%81neo4j%E7%9A%84java%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/2020/09/19/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/5%E3%80%81%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/Neo4j/8%E3%80%81neo4j%E7%9A%84java%E5%BC%80%E5%8F%91/</id>
    <published>2020-09-19T09:15:44.000Z</published>
    <updated>2020-09-19T10:03:59.878Z</updated>
    
    <content type="html"><![CDATA[<p>Neo4j的嵌入式模式与服务器模式：<br>依赖引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;!-- 服务器开发需要的jar包 --&gt;</span><br><span class="line">     &lt;groupId&gt;org.neo4j.driver&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;neo4j-java-driver&lt;&#x2F;artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.5.0&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">   &lt;!-- 嵌入式开发需要的jar包 --&gt;</span><br><span class="line">       &lt;groupId&gt;org.neo4j&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;neo4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;version&gt;3.3.4&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line"> &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="服务器模式："><a href="#服务器模式：" class="headerlink" title="服务器模式："></a>服务器模式：</h3><p>Neo4j Server是互操作性，安全性和监控的最佳选择。 实际上，REST接口允许所有现代平台和编程语言与它进行互操作。 此外，作为独立应用程序，它比嵌入式配置更安全（客户端中的潜在故障不会影响服务器），并且更易于监控。 如果我们选择使用这种模式，我们的应用程序将充当Neo4j服务器的客户端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class App </span><br><span class="line">&#123;</span><br><span class="line">    public static void main( String[] args )</span><br><span class="line">    &#123;</span><br><span class="line">        Driver driver &#x3D; GraphDatabase.driver( &quot;bolt:&#x2F;&#x2F;localhost:7687&quot;, AuthTokens.basic( &quot;neo4j&quot;, &quot;&quot; ) );</span><br><span class="line">        Session session &#x3D; driver.session();</span><br><span class="line">        session.run( &quot;CREATE (a:Person &#123;name: &#123;name&#125;, title: &#123;title&#125;&#125;)&quot;,</span><br><span class="line">                parameters( &quot;name&quot;, &quot;Arthur001&quot;, &quot;title&quot;, &quot;King001&quot; ) );</span><br><span class="line"></span><br><span class="line">        StatementResult result &#x3D; session.run( &quot;MATCH (a:Person) WHERE a.name &#x3D; &#123;name&#125; &quot; +</span><br><span class="line">                                              &quot;RETURN a.name AS name, a.title AS title&quot;,</span><br><span class="line">                parameters( &quot;name&quot;, &quot;Arthur001&quot; ) );</span><br><span class="line">        while ( result.hasNext() )</span><br><span class="line">        &#123;</span><br><span class="line">            Record record &#x3D; result.next();</span><br><span class="line">            System.out.println( record.get( &quot;title&quot; ).asString() + &quot; &quot; + record.get( &quot;name&quot; ).asString() );</span><br><span class="line">        &#125;</span><br><span class="line">        session.close();</span><br><span class="line">        driver.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌入式模式："><a href="#嵌入式模式：" class="headerlink" title="嵌入式模式："></a>嵌入式模式：</h3><p>嵌入式Neo4j数据库是性能的最佳选择。 它运行在相同的客户端应用程序的进程托管它并将数据存储在给定的路径中。 从而，必须以编程方式创建嵌入式数据库。<br>嵌入式模式并不是指硬盘上<br>的实际物理数据库嵌入到你的应用程序中，而是嵌入到Neo4j引擎（类和相<br>关的过程）直接运行和管理Neo4j数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        GraphDatabaseService graphDb &#x3D; new GraphDatabaseFactory().newEmbeddedDatabase(new File(&quot;Data&#x2F;Test&quot;));</span><br><span class="line">        System.out.println(&quot;Database Load!&quot;);</span><br><span class="line">        &#x2F;&#x2F;开启事务</span><br><span class="line">        try (Transaction tx &#x3D; graphDb.beginTx()) &#123;</span><br><span class="line">            &#x2F;&#x2F; Perform DB operations</span><br><span class="line">            Node steve &#x3D; graphDb.createNode(Labels.USER);</span><br><span class="line">            steve.setProperty(&quot;name&quot;, &quot;Steve&quot;);</span><br><span class="line">            Node linda &#x3D; graphDb.createNode(Labels.USER);</span><br><span class="line">            linda.setProperty(&quot;name&quot;, &quot;Linda&quot;);</span><br><span class="line">            steve.createRelationshipTo( linda, RelationshipTypes.IS_FRIEND_OF );</span><br><span class="line">            System.out.println(&quot;created node name is&quot; + steve.getProperty(&quot;name&quot;));</span><br><span class="line">            tx.success();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;查询数据库</span><br><span class="line">        String query &#x3D;&quot;match (n:USER) return n.name as name&quot;;</span><br><span class="line">        Map&lt;String, Object &gt;parameters &#x3D; new HashMap&lt;String, Object&gt;();</span><br><span class="line">         try ( Result result &#x3D; graphDb.execute( query, parameters ) )</span><br><span class="line">         &#123;</span><br><span class="line">             while ( result.hasNext() )</span><br><span class="line">             &#123;</span><br><span class="line">                 Map&lt;String, Object&gt; row &#x3D; result.next();</span><br><span class="line">                 for ( String key : result.columns() )</span><br><span class="line">                 &#123;</span><br><span class="line">                     System.out.printf( &quot;%s &#x3D; %s%n&quot;, key, row.get( key ) );</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         registerShutdownHook(graphDb);</span><br><span class="line">         System.out.println(&quot;Database Shutdown!&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;设置标签，但是必须继承于接口label</span><br><span class="line">    public enum Labels implements Label &#123;</span><br><span class="line">        USER,</span><br><span class="line">        MOVIE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public enum RelationshipTypes implements RelationshipType &#123;</span><br><span class="line">        IS_FRIEND_OF,</span><br><span class="line">        HAS_SEEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static void registerShutdownHook(final GraphDatabaseService graphDb)&#123;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                graphDb.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Neo4j的嵌入式模式与服务器模式依赖引入</summary>
    
    
    
    <category term="Neo4j" scheme="http://example.com/categories/Neo4j/"/>
    
    
    <category term="neo4j的java开发" scheme="http://example.com/tags/neo4j%E7%9A%84java%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>日志系统</title>
    <link href="http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/9%E3%80%81%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/9%E3%80%81%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-09-19T09:11:31.000Z</published>
    <updated>2020-09-19T10:03:59.648Z</updated>
    
    <content type="html"><![CDATA[<p>slf4j是java的一个日志门面（抽象层），实现了日志框架一些通用的api，而log4j和logback或者java.util.logging则是slf4j背后具体的日志框架。具体输出方式规则会去对应的日志框架配置文件（logback.xml或者log4j.xml）</p><p>各个日志框架单独的使用时可以的（不推荐），也可以绑定slf4j一起使用。因为各具体的日志系统会实现slf4j相关接口，log4j、和logback可以随时替换，而不用修改项目的日志输出相关代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;slf4j</span><br><span class="line">　　private static final Logger logger &#x3D; LoggerFactory.getLogger(Tester.class);  &#x2F;&#x2F;通过LoggerFactory获取Logger实例</span><br><span class="line"></span><br><span class="line">　　public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;接口里的统一的调用方法，各具体的日志系统都有实现这些方法</span><br><span class="line">　　logger.info(&quot;testlog: &#123;&#125;&quot;, &quot;test&quot;); </span><br><span class="line"></span><br><span class="line">       logger.debug(&quot;testlog: &#123;&#125;&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">       logger.error(&quot;testlog: &#123;&#125;&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">       logger.trace(&quot;testlog: &#123;&#125;&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">       logger.warn(&quot;testlog: &#123;&#125;&quot;, &quot;test&quot;);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为 ogback 自身实现了 问的<br>接口，无须额外引人适配器，另外 log back lo g4j 的升级版，具备比 log句更多的优点，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4]&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;slf4j-apverson&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;ch.qos.logback&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;logback-classic&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;&#123;logback-classc.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;ch.qos.logback&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;logback-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;logback-core.version)&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>log4j依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--若直接使用了 log 日志库,人曰志库适配器--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j-over-slf4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>slf4j-api(接口层) </li><li>各日志实现包的连接层( slf4j-jdk14, slf4j-log4j) </li><li>结合各日志实现包使用时提供的jar包情况为：</li></ul><p>SLF4J和logback结合使用时需要提供的jar:slf4j-api.jar,logback-classic.jar,logback-core.jar</p><p>SLF4J和log4j结合使用时需要提供的jar:slf4j-api.jar,slf4j-log412.jar,log4j.jar</p><p>SLF4J和JDK中java.util.logging结合使用时需要提供的jar:slf4j-api.jar,slf4j-jdk14.jar</p><p>SLF4J和simple(SLF4J本身提供的一个接口的简单实现)结合使用时需要提供的jar:slf4j-api.jar,slf4j-simple.jar</p><p>==注意==：以上slf4j和各日志实现包结合使用时最好只使用一种结合，不然的话会提示重复绑定日志，并且会导致日志无法输出。</p><p>slf4j-api.jar:对外提供统一的日志调用接口</p><h3 id="lobback-xml配置示例"><a href="#lobback-xml配置示例" class="headerlink" title="lobback.xml配置示例"></a>lobback.xml配置示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration debug&#x3D;&quot;false&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;LOG_HOME&quot; value&#x3D;&quot;&#x2F;home&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--控制台日志， 控制台输出 --&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;STDOUT&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;encoder class&#x3D;&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;</span><br><span class="line">            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度,%msg：日志消息，%n是换行符--&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;&#x2F;pattern&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--文件日志， 按照每天生成日志文件 --&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;FILE&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;!--日志文件输出的文件名--&gt;</span><br><span class="line">            &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;&#x2F;TestWeb.log.%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;FileNamePattern&gt;</span><br><span class="line">            &lt;!--日志文件保留天数--&gt;</span><br><span class="line">            &lt;MaxHistory&gt;30&lt;&#x2F;MaxHistory&gt;</span><br><span class="line">        &lt;&#x2F;rollingPolicy&gt;</span><br><span class="line">        &lt;encoder class&#x3D;&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;</span><br><span class="line">            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;&#x2F;pattern&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">        &lt;!--日志文件最大的大小--&gt;</span><br><span class="line">        &lt;triggeringPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;</span><br><span class="line">            &lt;MaxFileSize&gt;10MB&lt;&#x2F;MaxFileSize&gt;</span><br><span class="line">        &lt;&#x2F;triggeringPolicy&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- show parameters for hibernate sql 专为 Hibernate 定制 --&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;org.hibernate.type.descriptor.sql.BasicBinder&quot; level&#x3D;&quot;TRACE&quot; &#x2F;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;org.hibernate.type.descriptor.sql.BasicExtractor&quot; level&#x3D;&quot;DEBUG&quot; &#x2F;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;org.hibernate.SQL&quot; level&#x3D;&quot;DEBUG&quot; &#x2F;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;org.hibernate.engine.QueryParameters&quot; level&#x3D;&quot;DEBUG&quot; &#x2F;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;org.hibernate.engine.query.HQLQueryPlan&quot; level&#x3D;&quot;DEBUG&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--myibatis log configure--&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;com.apache.ibatis&quot; level&#x3D;&quot;TRACE&quot;&#x2F;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;java.sql.Connection&quot; level&#x3D;&quot;DEBUG&quot;&#x2F;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;java.sql.Statement&quot; level&#x3D;&quot;DEBUG&quot;&#x2F;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;java.sql.PreparedStatement&quot; level&#x3D;&quot;DEBUG&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 日志输出级别 --&gt;</span><br><span class="line">    &lt;root level&#x3D;&quot;DEBUG&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;STDOUT&quot; &#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;FILE&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;root&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="log4j-xml配置示例"><a href="#log4j-xml配置示例" class="headerlink" title="log4j.xml配置示例"></a>log4j.xml配置示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;log4j:configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 将日志信息输出到控制台 --&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;ConsoleAppender&quot; class&#x3D;&quot;org.apache.log4j.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;!-- 设置日志输出的样式 --&gt;</span><br><span class="line">        &lt;layout class&#x3D;&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">            &lt;!-- 设置日志输出的格式 --&gt;</span><br><span class="line">            &lt;param name&#x3D;&quot;ConversionPattern&quot; value&#x3D;&quot;[%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;] [%-5p] [method:%l]%n%m%n%n&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;layout&gt;</span><br><span class="line">        &lt;!--过滤器设置输出的级别--&gt;</span><br><span class="line">        &lt;filter class&#x3D;&quot;org.apache.log4j.varia.LevelRangeFilter&quot;&gt;</span><br><span class="line">            &lt;!-- 设置日志输出的最小级别 --&gt;</span><br><span class="line">            &lt;param name&#x3D;&quot;levelMin&quot; value&#x3D;&quot;WARN&quot; &#x2F;&gt;</span><br><span class="line">            &lt;!-- 设置日志输出的最大级别 --&gt;</span><br><span class="line">            &lt;param name&#x3D;&quot;levelMax&quot; value&#x3D;&quot;ERROR&quot; &#x2F;&gt;</span><br><span class="line">            &lt;!-- 设置日志输出的xxx，默认是false --&gt;</span><br><span class="line">            &lt;param name&#x3D;&quot;AcceptOnMatch&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;filter&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 将日志信息输出到文件，但是当文件的大小达到某个阈值的时候，日志文件会自动回滚 --&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;RollingFileAppender&quot; class&#x3D;&quot;org.apache.log4j.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;!-- 设置日志信息输出文件全路径名 --&gt;</span><br><span class="line">        &lt;param name&#x3D;&quot;File&quot; value&#x3D;&quot;D:&#x2F;log4j&#x2F;RollingFileAppender.log&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- 设置是否在重新启动服务时，在原有日志的基础添加新日志 --&gt;</span><br><span class="line">        &lt;param name&#x3D;&quot;Append&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- 设置保存备份回滚日志的最大个数 --&gt;</span><br><span class="line">        &lt;param name&#x3D;&quot;MaxBackupIndex&quot; value&#x3D;&quot;10&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- 设置当日志文件达到此阈值的时候自动回滚，单位可以是KB，MB，GB，默认单位是KB --&gt;</span><br><span class="line">        &lt;param name&#x3D;&quot;MaxFileSize&quot; value&#x3D;&quot;10KB&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- 设置日志输出的样式 --&gt;</span><br><span class="line">        &lt;layout class&#x3D;&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">            &lt;!-- 设置日志输出的格式 --&gt;</span><br><span class="line">            &lt;param name&#x3D;&quot;ConversionPattern&quot; value&#x3D;&quot;[%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;] [%-5p] [method:%l]%n%m%n%n&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;layout&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 将日志信息输出到文件，可以配置多久产生一个新的日志信息文件 --&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;DailyRollingFileAppender&quot; class&#x3D;&quot;org.apache.log4j.DailyRollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;!-- 设置日志信息输出文件全路径名 --&gt;</span><br><span class="line">        &lt;param name&#x3D;&quot;File&quot; value&#x3D;&quot;D:&#x2F;log4j&#x2F;DailyRollingFileAppender.log&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- 设置日志每分钟回滚一次，即产生一个新的日志文件 --&gt;</span><br><span class="line">        &lt;param name&#x3D;&quot;DatePattern&quot; value&#x3D;&quot;&#39;.&#39;yyyy-MM-dd-HH-mm&#39;.log&#39;&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- 设置日志输出的样式 --&gt;</span><br><span class="line">        &lt;layout class&#x3D;&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">            &lt;!-- 设置日志输出的格式 --&gt;</span><br><span class="line">            &lt;param name&#x3D;&quot;ConversionPattern&quot; value&#x3D;&quot;[%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;] [%-5p] [method:%l]%n%m%n%n&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;layout&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">     注意：</span><br><span class="line">     1：当additivity&#x3D;&quot;false&quot;时，root中的配置就失灵了，不遵循缺省的继承机制</span><br><span class="line">     2：logger中的name非常重要，它代表记录器的包的形式，有一定的包含关系，试验表明</span><br><span class="line">        2-1：当定义的logger的name同名时，只有最后的那一个才能正确的打印日志</span><br><span class="line">        2-2：当对应的logger含有包含关系时，比如：name&#x3D;test.log4j.test8 和 name&#x3D;test.log4j.test8.UseLog4j，则2-1的情况是一样的</span><br><span class="line">        2-3：logger的name表示所有的包含在此名的所有记录器都遵循同样的配置，name的值中的包含关系是指记录器的名称哟！注意啦！</span><br><span class="line">     3：logger中定义的level和appender中的filter定义的level的区间取交集</span><br><span class="line">     4：如果appender中的filter定义的 levelMin &gt; levelMax ，则打印不出日志信息</span><br><span class="line">     --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 指定logger的设置，additivity指示是否遵循缺省的继承机制--&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;test.log4j.test8.UseLog4j&quot; additivity&#x3D;&quot;false&quot;&gt;</span><br><span class="line">        &lt;level value &#x3D;&quot;WARN&quot;&#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;DailyRollingFileAppender&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;logger&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--指定logger的设置，additivity指示是否遵循缺省的继承机制 --&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;test.log4j.test8.UseLog4j_&quot; additivity&#x3D;&quot;false&quot;&gt;</span><br><span class="line">        &lt;level value &#x3D;&quot;ERROR&quot;&#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;RollingFileAppender&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;logger&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 根logger的设置--&gt;</span><br><span class="line">    &lt;root&gt;</span><br><span class="line">        &lt;level value &#x3D;&quot;INFO&quot;&#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;ConsoleAppender&quot;&#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;DailyRollingFileAppender&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;root&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;log4j:configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h3><p>日志级别    描述</p><ul><li>OFF    关闭：最高级别，不打印日志。</li><li>FATAL    致命：指明非常严重的可能会导致应用终止执行错误事件。</li><li>ERROR    错误：指明错误事件，但应用可能还能继续运行。</li><li>WARN    警告：指明可能潜在的危险状况。</li><li>INFO    信息：指明描述信息，从粗粒度上描述了应用运行过程。</li><li>DEBUG    调试：指明细致的事件信息，对调试应用最有用。</li><li>TRACE    跟踪：指明程序运行轨迹，比DEBUG级别的粒度更细。</li><li>ALL    所有：所有日志级别，包括定制级别。</li></ul><p>ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF</p>]]></content>
    
    
    <summary type="html">slf4j是java的一个日志门面（抽象层），实现了日志框架一些通用的api，而log4j和logback或者java.util.logging则是slf4j背后具体的日志框架。具体输出方式规则会去对应的日志框架配置文件（logback.xml或者log4j.xml）各个日志框架单独的使用时可以的（不推荐），也可以绑定slf4j一起使用。因为各具体的日志系统会实现slf4j相关接口，log4j、和logback可以随时替换，而不用修改项目的日志输出相关代码</summary>
    
    
    
    <category term="日志系统" scheme="http://example.com/categories/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="日志系统" scheme="http://example.com/tags/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>lasticsearch安装</title>
    <link href="http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/5%E3%80%81%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/3%E3%80%81elasticsearch/2%E3%80%81lasticsearch%E5%AE%89%E8%A3%85/"/>
    <id>http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/5%E3%80%81%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/3%E3%80%81elasticsearch/2%E3%80%81lasticsearch%E5%AE%89%E8%A3%85/</id>
    <published>2020-09-19T09:08:41.000Z</published>
    <updated>2020-09-19T10:03:59.374Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Elasticsearch使用案例"><a href="#Elasticsearch使用案例" class="headerlink" title="Elasticsearch使用案例"></a>Elasticsearch使用案例</h3><ul><li><p>（1）2013年初，GitHub抛弃了Solr，采取ElasticSearch 来做PB级的搜索。 “GitHub使用ElasticSearch搜索20TB的数据，包括13亿文件和1300亿行代码”</p></li><li><p>（2）维基百科：启动以elasticsearch为基础的核心搜索架构SoundCloud：“SoundCloud使用ElasticSearch为1.8亿用户提供即时而精准的音乐搜索服务”</p></li><li><p>（3）百度：百度目前广泛使用ElasticSearch作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部20多个业务线（包括casio、云分析、网盟、预测、文库、直达号、钱包、风控等），单集群最大100台机器，200个ES节点，每天导入30TB+数据</p></li><li><p>（4）新浪使用ES 分析处理32亿条实时日志</p></li><li><p>（5）阿里使用ES 构建挖财自己的日志采集和分析体系</p></li></ul><h3 id="Solr、ES区别"><a href="#Solr、ES区别" class="headerlink" title="Solr、ES区别"></a>Solr、ES区别</h3><p>solr和es都基于lucene</p><ol><li><p>Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能;</p></li><li><p>Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式；</p></li><li><p>Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；</p></li><li><p>Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch—–附近的人</p></li></ol><p>ELK官网：<a href="https://www.elastic.co/">https://www.elastic.co/</a></p><p>ELK官网文档：<a href="https://www.elastic.co/guide/index.html">https://www.elastic.co/guide/index.html</a></p><p>ELK中文手册：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html">https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html</a></p><p>ELK中文社区：<a href="https://elasticsearch.cn/">https://elasticsearch.cn/</a></p><p>ELK API :<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/travelansport-client.html">https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/travelansport-client.html</a></p><p>1、下载并解压：</p><p>下载地址：<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p><p>2、安装Marvel插件（Marvel是Elasticsearch的管理和监控工具）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#安装监控：Marvel插件</span><br><span class="line">.&#x2F;bin&#x2F;plugin -i elasticsearch&#x2F;marvel&#x2F;latest</span><br><span class="line"></span><br><span class="line">#禁止监控：</span><br><span class="line">echo &#39;marvel.agent.enabled: false&#39; &gt;&gt; .&#x2F;config&#x2F;elasticsearch.yml</span><br></pre></td></tr></table></figure><p>3、修改配置文件：elasticsearch.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#允许所有ip访问</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;elasticsearch</span><br><span class="line"></span><br><span class="line">#后台启动</span><br><span class="line">.&#x2F;bin&#x2F;elasticsearch -d</span><br></pre></td></tr></table></figure><p>5、测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl &#39;http:&#x2F;&#x2F;localhost:9200&#x2F;?pretty&#39;</span><br></pre></td></tr></table></figure><p>返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;status&quot;: 200,</span><br><span class="line">   &quot;name&quot;: &quot;Shrunken Bones&quot;,</span><br><span class="line">   &quot;version&quot;: &#123;</span><br><span class="line">      &quot;number&quot;: &quot;1.4.0&quot;,</span><br><span class="line">      &quot;lucene_version&quot;: &quot;4.10&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;tagline&quot;: &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看Marvel和Sense</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:9200&#x2F;_plugin&#x2F;marvel&#x2F;</span><br></pre></td></tr></table></figure><h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建:"></a>集群搭建:</h3><p>修改elasticserach.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cluster.name: aubin-cluster#必须相同</span><br><span class="line"># 集群名称（不能重复）</span><br><span class="line">node.name: els1（必须不同）</span><br><span class="line"># 节点名称，仅仅是描述名称，用于在日志中区分（自定义）</span><br><span class="line">#指定了该节点可能成为 master 节点，还可以是数据节点</span><br><span class="line">node.master: true</span><br><span class="line">node.data: true</span><br><span class="line">path.data: &#x2F;var&#x2F;lib&#x2F;elasticsearch</span><br><span class="line"># 数据的默认存放路径（自定义）</span><br><span class="line">path.logs: &#x2F;var&#x2F;log&#x2F;elasticsearch </span><br><span class="line"># 日志的默认存放路径</span><br><span class="line">network.host: 192.168.0.1 </span><br><span class="line"># 当前节点的 IP 地址</span><br><span class="line">http.port: 9200 </span><br><span class="line"># 对外提供服务的端口</span><br><span class="line">transport.tcp.port: 9300</span><br><span class="line">#9300 为集群服务的端口</span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;172.18.68.11&quot;, &quot;172.18.68.12&quot;,&quot;172.18.68.13&quot;] </span><br><span class="line"># 集群个节点 IP 地址，也可以使用域名，需要各节点能够解析</span><br><span class="line">discovery.zen.minimum_master_nodes: 2 </span><br><span class="line"># 为了避免脑裂，集群节点数最少为 半数+1</span><br></pre></td></tr></table></figure><p>备注：配置文件详解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 集群的名字，以此作为是否同一集群的判断条件</span><br><span class="line">cluster.name: elasticsearch</span><br><span class="line"># 节点名字，以此作为集群中不同节点的区分条件</span><br><span class="line">node.name: node-1</span><br><span class="line">#设置当前节点既可以为主节点也可以为数据节点</span><br><span class="line">node.master: true</span><br><span class="line">node.data: true</span><br><span class="line"># 索引分片个数，默认为 5 片</span><br><span class="line">#index.number_of_shards: 5</span><br><span class="line"># 索引副本个数，默认为 1 个副本</span><br><span class="line">#index.number_of_replicas: 1</span><br><span class="line"># 数据存储目录（多个路径用逗号分隔）</span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;192.168.14.14&quot;,&quot;192.168.14.15&quot;]</span><br><span class="line">discovery.zen.minimum_master_nodes: 2</span><br><span class="line">#数据目录</span><br><span class="line">path.data: &#x2F;home&#x2F;elk1&#x2F;elasticserach&#x2F;data</span><br><span class="line"># 日志目录</span><br><span class="line">path.logs: &#x2F;home&#x2F;elk1&#x2F;elasticserach&#x2F;logs</span><br><span class="line"># 修改一下 ES 的监听地址，这样别的机器才可以访问</span><br><span class="line">network.host: 192.168.14.13</span><br><span class="line"># 设置节点间交互的 tcp 端口（集群）,默认是 9300</span><br><span class="line">transport.tcp.port: 9300</span><br><span class="line"># 监听端口（默认的就好）</span><br><span class="line">http.port: 9200</span><br><span class="line"># 增加新的参数，这样 head 插件才可以访问 es</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Elasticsearch使用案例（1）2013年初，GitHub抛弃了Solr，采取ElasticSearch来做PB级的搜索。“GitHub使用ElasticSearch搜索20TB的数据，包括13亿文件和1300亿行代码”</summary>
    
    
    
    <category term="elasticsearch" scheme="http://example.com/categories/elasticsearch/"/>
    
    
    <category term="lasticsearch安装" scheme="http://example.com/tags/lasticsearch%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ+zookeeper集群配置</title>
    <link href="http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/1%E3%80%81ActiveMQ/4%E3%80%81ActiveMQ+zookeeper%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/1%E3%80%81ActiveMQ/4%E3%80%81ActiveMQ+zookeeper%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/</id>
    <published>2020-09-19T09:06:38.000Z</published>
    <updated>2020-09-19T10:03:58.440Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、首先，选三台服务器。"><a href="#1、首先，选三台服务器。" class="headerlink" title="1、首先，选三台服务器。"></a>1、首先，选三台服务器。</h3><p>之所以选三台，是因为zookeeper推荐最低三台配置，这样可以保持最大的可用服务器数，ip地址分别为：192.168.120.241,192.168.120.242,192.168.120.171</p><h3 id="2、下载zookeeper"><a href="#2、下载zookeeper" class="headerlink" title="2、下载zookeeper"></a>2、下载zookeeper</h3><p>wget <a href="http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.3.6/zookeeper-3.3.6.tar.gz">http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.3.6/zookeeper-3.3.6.tar.gz</a></p><p>解压tar -xvf  zookeeper-3.3.6.tar.gz</p><p>修改配置，mv zoo_sample.cfg zoo.cfg 实现zookeeper的集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> 1 # The number of milliseconds of each tick</span><br><span class="line"> 2 tickTime&#x3D;2000</span><br><span class="line"> 3 # The number of ticks that the initial </span><br><span class="line"> 4 # synchronization phase can take</span><br><span class="line"> 5 initLimit&#x3D;10</span><br><span class="line"> 6 # The number of ticks that can pass between </span><br><span class="line"> 7 # sending a request and getting an acknowledgement</span><br><span class="line"> 8 syncLimit&#x3D;5</span><br><span class="line"> 9 # the directory where the snapshot is stored.</span><br><span class="line">10 # do not use &#x2F;tmp for storage, &#x2F;tmp here is just </span><br><span class="line">11 # example sakes.</span><br><span class="line">12 </span><br><span class="line">13 dataDir&#x3D;&#x2F;home&#x2F;amqbroker&#x2F;zkdir&#x2F;data</span><br><span class="line">14 dataLogDir&#x3D;&#x2F;home&#x2F;amqbroker&#x2F;zkdir&#x2F;log</span><br><span class="line">15 # the port at which the clients will connect</span><br><span class="line">16 clientPort&#x3D;2181</span><br><span class="line">17 # the maximum number of client connections.</span><br><span class="line">18 # increase this if you need to handle more clients</span><br><span class="line">19 #maxClientCnxns&#x3D;60</span><br><span class="line">20 #</span><br><span class="line">21 # Be sure to read the maintenance section of the </span><br><span class="line">22 # administrator guide before turning on autopurge.</span><br><span class="line">23 #</span><br><span class="line">24 # http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance</span><br><span class="line">25 #</span><br><span class="line">26 # The number of snapshots to retain in dataDir</span><br><span class="line">27 #autopurge.snapRetainCount&#x3D;3</span><br><span class="line">28 # Purge task interval in hours</span><br><span class="line">29 # Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">30 #autopurge.purgeInterval&#x3D;1</span><br><span class="line">31 </span><br><span class="line">32 </span><br><span class="line">33 ##three servers of this cluster</span><br><span class="line">34 server.1&#x3D;192.168.120.241:2888:3888</span><br><span class="line">35 server.2&#x3D;192.168.120.242:2888:3888</span><br><span class="line">36 server.3&#x3D;192.168.120.171:2888:3888</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、配置activemq"><a href="#3、配置activemq" class="headerlink" title="3、配置activemq"></a>3、配置activemq</h3><p>下载activemq-5.10<br>wget  <a href="http://archive.apache.org/dist/activemq/5.10.1/apache-activemq-5.10.1-bin.tar.gz">http://archive.apache.org/dist/activemq/5.10.1/apache-activemq-5.10.1-bin.tar.gz</a></p><p>解压：tar -xvf apache-activemq-5.10.1-bin.tar.gz</p><p>修改配置文件：vi apache-activemq-5.10.1/conf/activemq.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre name&#x3D;&quot;code&quot; class&#x3D;&quot;java&quot;&gt;  1 &lt;!--</span><br><span class="line">  2     Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class="line">  3     contributor license agreements.  See the NOTICE file distributed with</span><br><span class="line">  4     this work for additional information regarding copyright ownership.</span><br><span class="line">  5     The ASF licenses this file to You under the Apache License, Version 2.0</span><br><span class="line">  6     (the &quot;License&quot;); you may not use this file except in compliance with</span><br><span class="line">  7     the License.  You may obtain a copy of the License at</span><br><span class="line">  8 </span><br><span class="line">  9     http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0</span><br><span class="line"> 10 </span><br><span class="line"> 11     Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> 12     distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"> 13     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> 14     See the License for the specific language governing permissions and</span><br><span class="line"> 15     limitations under the License.</span><br><span class="line"> 16 --&gt;</span><br><span class="line"> 17 &lt;!-- START SNIPPET: example --&gt;</span><br><span class="line"> 18 &lt;beans</span><br><span class="line"> 19   xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line"> 20   xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line"> 21   xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line"> 22   http:&#x2F;&#x2F;activemq.apache.org&#x2F;schema&#x2F;core http:&#x2F;&#x2F;activemq.apache.org&#x2F;schema&#x2F;core&#x2F;activemq-core.xsd&quot;&gt;</span><br><span class="line"> 23 </span><br><span class="line"> 24     &lt;!-- Allows us to use system properties as variables in this configuration file --&gt;</span><br><span class="line"> 25     &lt;bean class&#x3D;&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;</span><br><span class="line"> 26         &lt;property name&#x3D;&quot;locations&quot;&gt;</span><br><span class="line"> 27             &lt;value&gt;file:$&#123;activemq.conf&#125;&#x2F;credentials.properties&lt;&#x2F;value&gt;</span><br><span class="line"> 28         &lt;&#x2F;property&gt;</span><br><span class="line"> 29     &lt;&#x2F;bean&gt;</span><br><span class="line"> 30 </span><br><span class="line"> 31    &lt;!-- Allows accessing the server log --&gt;</span><br><span class="line"> 32     &lt;!--</span><br><span class="line"> 33     &lt;bean id&#x3D;&quot;logQuery&quot; class&#x3D;&quot;org.fusesource.insight.log.log4j.Log4jLogQuery&quot;</span><br><span class="line"> 34           lazy-init&#x3D;&quot;false&quot; scope&#x3D;&quot;singleton&quot;</span><br><span class="line"> 35           init-method&#x3D;&quot;start&quot; destroy-method&#x3D;&quot;stop&quot;&gt;</span><br><span class="line"> 36     &lt;&#x2F;bean&gt;</span><br><span class="line"> 37     --&gt;</span><br><span class="line"> 38     &lt;!--</span><br><span class="line"> 39         The &lt;broker&gt; element is used to configure the ActiveMQ broker.</span><br><span class="line"> 40     --&gt;</span><br><span class="line"> 41     &lt;broker xmlns&#x3D;&quot;http:&#x2F;&#x2F;activemq.apache.org&#x2F;schema&#x2F;core&quot; brokerName&#x3D;&quot;job-broker&quot; dataDirectory&#x3D;&quot;$&#123;activemq.data&#125;&quot;&gt;</span><br><span class="line"> 42 </span><br><span class="line"> 43         &lt;destinationPolicy&gt;</span><br><span class="line"> 44             &lt;policyMap&gt;</span><br><span class="line"> 45               &lt;policyEntries&gt;</span><br><span class="line"> 46              &lt;!-- Set the following policy on all queues using the &#39;&gt;&#39; wildcard --&gt;</span><br><span class="line"> 47                 &lt;policyEntry queue&#x3D;&quot;QUEUE.SH.LTE.IMPORT&quot;&gt;</span><br><span class="line"> 48                     &lt;deadLetterStrategy&gt;</span><br><span class="line"> 49                             &lt;!--Use the prefix &#39;DLQ.&#39; for the destination name, and make the DLQ a queue rather than a topic --&gt;</span><br><span class="line"> 50                         &lt;individualDeadLetterStrategy queuePrefix&#x3D;&quot;SH.LTE.DLQ.&quot; useQueueForQueueMessages&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line"> 51                     &lt;&#x2F;deadLetterStrategy&gt;</span><br><span class="line"> 52                 &lt;&#x2F;policyEntry&gt;</span><br><span class="line"> 53                 &lt;policyEntry queue&#x3D;&quot;QUEUE.STTTTT&quot;&gt;</span><br><span class="line"> 54                     &lt;deadLetterStrategy&gt;</span><br><span class="line"> 55                          &lt;!--Use the prefix &#39;DLQ.&#39; for the destination name, and make the DLQ a queue rather than a topic --&gt;</span><br><span class="line"> 56                           &lt;individualDeadLetterStrategy queuePrefix&#x3D;&quot;TTT.LTE.SH.DLQ.&quot; useQueueForQueueMessages&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line"> 57                       &lt;&#x2F;deadLetterStrategy&gt;</span><br><span class="line"> 58                   &lt;&#x2F;policyEntry&gt;</span><br><span class="line"> 59                 &lt;policyEntry topic&#x3D;&quot;&gt;&quot; &gt;</span><br><span class="line"> 60                     &lt;!-- The constantPendingMessageLimitStrategy is used to prevent</span><br><span class="line"> 61                          slow topic consumers to block producers and affect other consumers</span><br><span class="line"> 62                          by limiting the number of messages that are retained</span><br><span class="line"> 63                          For more information, see:</span><br><span class="line"> 64 </span><br><span class="line"> 65                          http:&#x2F;&#x2F;activemq.apache.org&#x2F;slow-consumer-handling.html</span><br><span class="line"> 66 </span><br><span class="line"> 67                     --&gt;</span><br><span class="line"> 68                   &lt;pendingMessageLimitStrategy&gt;</span><br><span class="line"> 69                     &lt;constantPendingMessageLimitStrategy limit&#x3D;&quot;1000&quot;&#x2F;&gt;</span><br><span class="line"> 70                   &lt;&#x2F;pendingMessageLimitStrategy&gt;</span><br><span class="line"> 71                 &lt;&#x2F;policyEntry&gt;</span><br><span class="line"> 72               &lt;&#x2F;policyEntries&gt;</span><br><span class="line"> 73             &lt;&#x2F;policyMap&gt;</span><br><span class="line"> 74         &lt;&#x2F;destinationPolicy&gt;</span><br><span class="line"> 75 </span><br><span class="line"> 76 </span><br><span class="line"> 77         &lt;!--</span><br><span class="line"> 78             The managementContext is used to configure how ActiveMQ is exposed in</span><br><span class="line"> 79             JMX. By default, ActiveMQ uses the MBean server that is started by</span><br><span class="line"> 80             the JVM. For more information, see:</span><br><span class="line"> 81 </span><br><span class="line"> 82             http:&#x2F;&#x2F;activemq.apache.org&#x2F;jmx.html</span><br><span class="line"> 83         --&gt;</span><br><span class="line"> 84         &lt;managementContext&gt;</span><br><span class="line"> 85             &lt;managementContext createConnector&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line"> 86         &lt;&#x2F;managementContext&gt;</span><br><span class="line"> 87 </span><br><span class="line"> 88         &lt;!--</span><br><span class="line"> 89             Configure message persistence for the broker. The default persistence</span><br><span class="line"> 89             Configure message persistence for the broker. The default persistence</span><br><span class="line"> 90             mechanism is the KahaDB store (identified by the kahaDB tag).</span><br><span class="line"> 91             For more information, see:</span><br><span class="line"> 92 </span><br><span class="line"> 93             http:&#x2F;&#x2F;activemq.apache.org&#x2F;persistence.html</span><br><span class="line"> 94         --&gt;</span><br><span class="line"> 95 </span><br><span class="line"> 96      &lt;!-- 数据存储为kahadb</span><br><span class="line"> 97      &lt;persistenceAdapter&gt;</span><br><span class="line"> 98          &lt;kahaDB directory&#x3D;&quot;$&#123;activemq.data&#125;&#x2F;kahadb&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!-- 配置注册中心为zookeeper--&gt;</span><br><span class="line"> 99          &lt;&#x2F;persistenceAdapter&gt;</span><br><span class="line">100      --&gt;</span><br><span class="line">101      &lt;persistenceAdapter&gt;</span><br><span class="line">102         &lt;replicatedLevelDB </span><br><span class="line">103              directory&#x3D;&quot;$&#123;activemq.data&#125;&#x2F;leveldb&quot;</span><br><span class="line">104              replicas&#x3D;&quot;3&quot;</span><br><span class="line">105              bind&#x3D;&quot;tcp:&#x2F;&#x2F;0.0.0.0:0&quot;</span><br><span class="line">106              zkAddress&#x3D;&quot;192.168.120.171:2181,192.168.120.241:2181,192.168.120.242:2181&quot;</span><br><span class="line">107              zkPassword&#x3D;&quot;&quot;</span><br><span class="line">108              hostname&#x3D;&quot;192.168.120.241&quot;</span><br><span class="line">109              sync&#x3D;&quot;local_disk&quot;</span><br><span class="line">110              zkPath&#x3D;&quot;&#x2F;activemq&#x2F;leveldb-stores&quot;&#x2F;&gt;</span><br><span class="line">111      &lt;&#x2F;persistenceAdapter&gt;</span><br><span class="line">112 </span><br><span class="line">113           &lt;!--</span><br><span class="line">114             The systemUsage controls the maximum amount of space the broker will</span><br><span class="line">115             use before disabling caching and&#x2F;or slowing down producers. For more information, see:</span><br><span class="line">116             http:&#x2F;&#x2F;activemq.apache.org&#x2F;producer-flow-control.html</span><br><span class="line">117           --&gt;</span><br><span class="line">118           &lt;systemUsage&gt;</span><br><span class="line">119             &lt;systemUsage&gt;</span><br><span class="line">120                 &lt;memoryUsage&gt;</span><br><span class="line">121                     &lt;memoryUsage percentOfJvmHeap&#x3D;&quot;70&quot; &#x2F;&gt;</span><br><span class="line">122                 &lt;&#x2F;memoryUsage&gt;</span><br><span class="line">123                 &lt;storeUsage&gt;</span><br><span class="line">124                     &lt;storeUsage limit&#x3D;&quot;100 gb&quot;&#x2F;&gt;</span><br><span class="line">125                 &lt;&#x2F;storeUsage&gt;</span><br><span class="line">126                 &lt;tempUsage&gt;</span><br><span class="line">127                     &lt;tempUsage limit&#x3D;&quot;50 gb&quot;&#x2F;&gt;</span><br><span class="line">128                 &lt;&#x2F;tempUsage&gt;</span><br><span class="line">129             &lt;&#x2F;systemUsage&gt;</span><br><span class="line">130         &lt;&#x2F;systemUsage&gt;</span><br><span class="line">131 </span><br><span class="line">132         &lt;!--</span><br><span class="line">133             The transport connectors expose ActiveMQ over a given protocol to</span><br><span class="line">134             clients and other brokers. For more information, see:</span><br><span class="line">135 </span><br><span class="line">136             http:&#x2F;&#x2F;activemq.apache.org&#x2F;configuring-transports.html</span><br><span class="line">137         --&gt;</span><br><span class="line">138         &lt;transportConnectors&gt;</span><br><span class="line">139             &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt;</span><br><span class="line">140             &lt;transportConnector name&#x3D;&quot;openwire&quot; uri&#x3D;&quot;tcp:&#x2F;&#x2F;0.0.0.0:61616?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;104    857600&quot;&#x2F;&gt;</span><br><span class="line">141             &lt;transportConnector name&#x3D;&quot;amqp&quot; uri&#x3D;&quot;amqp:&#x2F;&#x2F;0.0.0.0:5672?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;1048576    00&quot;&#x2F;&gt;</span><br><span class="line">142             &lt;transportConnector name&#x3D;&quot;stomp&quot; uri&#x3D;&quot;stomp:&#x2F;&#x2F;0.0.0.0:61613?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;1048    57600&quot;&#x2F;&gt;</span><br><span class="line">143             &lt;transportConnector name&#x3D;&quot;mqtt&quot; uri&#x3D;&quot;mqtt:&#x2F;&#x2F;0.0.0.0:1883?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;1048576    00&quot;&#x2F;&gt;</span><br><span class="line">144             &lt;transportConnector name&#x3D;&quot;ws&quot; uri&#x3D;&quot;ws:&#x2F;&#x2F;0.0.0.0:61614?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;104857600&quot;    &#x2F;&gt;</span><br><span class="line">145         &lt;&#x2F;transportConnectors&gt;</span><br><span class="line">146 </span><br><span class="line">147         &lt;!-- destroy the spring context on shutdown to stop jetty --&gt;</span><br><span class="line">148         &lt;shutdownHooks&gt;</span><br><span class="line">149             &lt;bean xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; class&#x3D;&quot;org.apache.activemq.hooks.SpringContextHook&quot; &#x2F;&gt;</span><br><span class="line">150         &lt;&#x2F;shutdownHooks&gt;</span><br><span class="line">151 </span><br><span class="line">152     &lt;&#x2F;broker&gt;</span><br><span class="line">153 </span><br><span class="line">154     &lt;!--</span><br><span class="line">155         Enable web consoles, REST and Ajax APIs and demos</span><br><span class="line">156         The web consoles requires by default login, you can disable this in the jetty.xml file</span><br><span class="line">157 </span><br><span class="line">158         Take a look at $&#123;ACTIVEMQ_HOME&#125;&#x2F;conf&#x2F;jetty.xml for more details</span><br><span class="line">159     --&gt;</span><br><span class="line">160     &lt;import resource&#x3D;&quot;jetty.xml&quot;&#x2F;&gt;</span><br><span class="line">161 </span><br><span class="line">162 &lt;&#x2F;beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="另外两台服务器的配置与该文档相似，唯一不同就是-hostname-”192-168-120-241”这里，需要写入各自的ip地址"><a href="#另外两台服务器的配置与该文档相似，唯一不同就是-hostname-”192-168-120-241”这里，需要写入各自的ip地址" class="headerlink" title="另外两台服务器的配置与该文档相似，唯一不同就是    hostname=”192.168.120.241”这里，需要写入各自的ip地址"></a>另外两台服务器的配置与该文档相似，唯一不同就是    hostname=”192.168.120.241”这里，需要写入各自的ip地址</h3><p>1、web管理界面：<a href="http://localhost:8161/admin">http://localhost:8161/admin</a>  默认用户名密码都是admin  可以在conf/jeety-realm.properties文件中添加账户<br>2、在activemq.xml中添加安全配置<br>添加认证插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    &lt;plugins&gt;</span><br><span class="line">&lt;simpleAuthenticationPlugin&gt;</span><br><span class="line">    &lt;users&gt;</span><br><span class="line">    &lt;!-- 就是在获取连接是的用户名和密码 --&gt;</span><br><span class="line">&lt;authenticationUser username&#x3D;&quot;bhz&quot; password&#x3D;&quot;bhz&quot; groups&#x3D;&quot;users,admins&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;users&gt;</span><br><span class="line">&lt;&#x2F;simpleAuthenticationPlugin&gt;</span><br><span class="line">&lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;broker&gt;</span><br></pre></td></tr></table></figure><p>ActiveMQ消息存储方式<br>在activemq.xml文件的persistenceAdapter节点 配置切换数据源 1、默认kahadb(默认),leveldb,mysql,oracle</p>]]></content>
    
    
    <summary type="html">1、首先，选三台服务器。之所以选三台，是因为zookeeper推荐最低三台配置，这样可以保持最大的可用服务器数，ip地址分别为192.168.120.241,192.168.120.242,192.168.120.171</summary>
    
    
    
    <category term="ActiveMQ" scheme="http://example.com/categories/ActiveMQ/"/>
    
    
    <category term="ActiveMQ+zookeeper集群配置" scheme="http://example.com/tags/ActiveMQ-zookeeper%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>事务的配置解析</title>
    <link href="http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/%E6%BA%90%E7%A0%81/5%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/%E6%BA%90%E7%A0%81/5%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/</id>
    <published>2020-09-19T09:05:00.000Z</published>
    <updated>2020-09-19T10:03:58.410Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String resource &#x3D; &quot;mybatis&#x2F;config.xml&quot;;</span><br><span class="line">InputStream is &#x3D; Main.class.getClassLoader().getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sessionFactory &#x3D; new SqlSessionFactoryBuilder().build(is);</span><br><span class="line">SqlSession session &#x3D; sessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">User user &#x3D; new User();</span><br><span class="line">user.setName(&quot;liuliu&quot;);</span><br><span class="line">user.setPassword(&quot;123123&quot;);</span><br><span class="line">user.setScore(&quot;88&quot;);</span><br><span class="line">String statement &#x3D; &quot;mybatis.mapping.UserMapper.insertUser&quot;;</span><br><span class="line">session.insert(statement,user);</span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure><h2 id="mybatis必须手动commit"><a href="#mybatis必须手动commit" class="headerlink" title="==mybatis必须手动commit=="></a>==mybatis必须手动commit==</h2><ul><li>如果不执行sqlSession.commit()操作，直接执行sqlSession.close()，则会在close()中进行事务回滚；</li><li>如果不执行sqlSession.commit()操作也不手动关闭sqlSession，在程序结束时关闭数据库连接时会进行事务回滚；</li></ul><h3 id="事务管理入口"><a href="#事务管理入口" class="headerlink" title="事务管理入口"></a>事务管理入口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;environments default&#x3D;&quot;development&quot;&gt;</span><br><span class="line">    &lt;environment id&#x3D;&quot;development&quot;&gt;</span><br><span class="line">        &lt;transactionManager type&#x3D;&quot;JDBC&quot; &#x2F;&gt;    &#x2F;&#x2F;相当于&lt;transactionManager type&#x3D;&quot;JdbcTransactionFactory.class&quot; &#x2F;&gt;</span><br><span class="line">        &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot; &#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot; &#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;BIUBIU&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;dataSource&gt;</span><br><span class="line">    &lt;&#x2F;environment&gt;</span><br><span class="line">&lt;&#x2F;environments&gt;</span><br></pre></td></tr></table></figure><ul><li>如果type=”JDBC”则使用JdbcTransactionFactory事务工厂则==MyBatis独立管理事务，直接使用JDK提供的JDBC来管理事务的各个环节：提交、回滚、关闭等操作；==</li><li>如果type=”MANAGED”则使用ManagedTransactionFactory事务工厂则MyBatis==不在ORM层管理事务而是将事务管理托付给其他框架，如Spring==<br>；因为ManagedTransactionFactory类中的commit()方法和rollback()方法都为空，事务相关操作不发挥作用；</li></ul><p>从SessionFactory中获取sqlSession时候，同时会获取事务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123;</span><br><span class="line">    Transaction tx &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      final Environment environment &#x3D; configuration.getEnvironment();</span><br><span class="line">      final TransactionFactory transactionFactory &#x3D; getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      tx &#x3D; transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      final Executor executor &#x3D; configuration.newExecutor(tx, execType);</span><br><span class="line">      return new DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); &#x2F;&#x2F; may have fetched a connection so lets call close()</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在sqlSession中执行了UPDATE操作，需要执行sqlSession.commit()方法提交事务，不然在连接关闭时候会自动回滚；</p><p>exector.commit()事务提交方法归根到底是调用了transaction.commit()事务的提交方法；这里的transaction就是根据配置对应的JdbcTransaction或者ManagedTransaction；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void commit() &#123;</span><br><span class="line">  commit(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void commit(boolean force) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    executor.commit(isCommitOrRollbackRequired(force));</span><br><span class="line">    &#x2F;&#x2F;在事务提交时会将dirty赋值为false;</span><br><span class="line">    dirty &#x3D; false;</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    throw ExceptionFactory.wrapException(&quot;Error committing transaction.  Cause: &quot; + e, e);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是JdbcTransaction的commit()方法，通过调用connection.commit()方法通过数据库连接实现事务提交；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void commit() throws SQLException &#123;</span><br><span class="line">  if (connection !&#x3D; null &amp;&amp; !connection.getAutoCommit()) &#123;</span><br><span class="line">    if (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(&quot;Committing JDBC Connection [&quot; + connection + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    connection.commit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是ManagedTransaction的commit()方法，则为空方法不进行任何操作；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void commit() throws SQLException &#123;</span><br><span class="line">  &#x2F;&#x2F; Does nothing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void rollback() throws SQLException &#123;</span><br><span class="line">  &#x2F;&#x2F; Does nothing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在关闭会话时会判断dirty是否为true，如果为true则需要进行事务回滚操作，否则直接关闭会话</p><p>结论：==如果close()操作之前未进行commit()事务提交则会进行事务回滚然后再关闭会话；如果update后执行了commit则直接关闭会话；==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void close() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    executor.close(isCommitOrRollbackRequired(false));</span><br><span class="line">    closeCursors();</span><br><span class="line">    dirty &#x3D; false;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断dirty标志是否为true</span><br><span class="line">private boolean isCommitOrRollbackRequired(boolean force) &#123;</span><br><span class="line">  return (!autoCommit &amp;&amp; dirty) || force;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果dirty为true则判定forceRollback为true，执行回滚操作；</span><br><span class="line">@Override</span><br><span class="line">public void close(boolean forceRollback) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      rollback(forceRollback);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (transaction !&#x3D; null) &#123;</span><br><span class="line">        transaction.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (SQLException e) &#123;</span><br><span class="line">    &#x2F;&#x2F; Ignore.  There&#39;s nothing that can be done at this point.</span><br><span class="line">    log.warn(&quot;Unexpected exception on closing transaction.  Cause: &quot; + e);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    transaction &#x3D; null;</span><br><span class="line">    deferredLoads &#x3D; null;</span><br><span class="line">    localCache &#x3D; null;</span><br><span class="line">    localOutputParameterCache &#x3D; null;</span><br><span class="line">    closed &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Stringresource&quot;mybatis/config.xml&quot;;</summary>
    
    
    
    <category term="源码" scheme="http://example.com/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="事务的配置解析" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>MyBatisSpring</title>
    <link href="http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/MyBatis-Spring/MyBatis-Spring/"/>
    <id>http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/MyBatis-Spring/MyBatis-Spring/</id>
    <published>2020-09-19T09:04:42.000Z</published>
    <updated>2020-09-19T10:03:58.386Z</updated>
    
    <content type="html"><![CDATA[<p>MyBatis-Spring所做的是就是将一下mybatis的手写代码和事务交由spring,将 Mybatis 的异常转换为 Spring 的 DataAccessException</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    String resource &#x3D; &quot;mybatis-config.xml&quot;;</span><br><span class="line">    InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory &#x3D;</span><br><span class="line">      new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    try (SqlSession session &#x3D; sqlSessionFactory.openSession()) &#123;</span><br><span class="line">     &#x2F;&#x2F;方式一：</span><br><span class="line">      UserMapper mapper &#x3D; session.getMapper(UserMapper.class);</span><br><span class="line">      User user1 &#x3D; mapper.selectBlog(&quot;1&quot;);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;方式二：</span><br><span class="line">      User user2 &#x3D; session.selectOne(</span><br><span class="line">        &quot;test.UserMapper.selectBlog&quot;, 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>再mybatis中使用SqlSessionFactoryBuilder 来创建 SqlSessionFactory</p><p> 在 MyBatis-Spring 中使用SqlSessionFactoryBean来创建 SqlSessionFactory</p><p> SqlSessionFactoryBean 实现了 Spring 的 FactoryBean 接口，意味着由 工厂类（SqlSessionFactoryBean）的 getObject() 方法创建。这种情况下，Spring 将会在应用启动时为你创建 SqlSessionFactory，并使用 sqlSessionFactory 这个名字存储起来。</p><p> SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），所以mybatis的配置的任何环境配置（<environments>），数据源（<DataSource>）和 MyBatis 的事务管理器（<transactionManager>）都会被忽略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">  &lt;!--唯一的必要属性dataSource--&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li>dataSource：数据源</li><li>configLocation：：加载mybatis的核心配置文件。MyBatis 的 XML 配置文件中的 <mappers> 部分中指定 XML 文件的类路径</li></ul><p>==如果 MyBatis 在映射器类对应的路径下找不到与之相对应的映射器 XML 文件==</p><ul><li>1、手动在 MyBatis 的 XML 配置文件中的 <mappers> 部分中指定 XML 文件的类路径；(通过mappers，指定的映射器接口实现全部注册为映射器)</li><li>2、工厂 bean 的 mapperLocations 属性。<br>mapperLocations： 属性接受多个资源位置。这个属性可以用来指定 MyBatis 的映射器 XML 配置文件的位置。属性的值是一个 Ant 风格的字符串，可以指定加载一个目录中的所有文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;mapperLocations&quot; value&#x3D;&quot;classpath*:sample&#x2F;config&#x2F;mappers&#x2F;**&#x2F;*.xml&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><ul><li>数据映射器类(接口)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line">  @Select(&quot;SELECT * FROM users WHERE id &#x3D; #&#123;userId&#125;&quot;)</span><br><span class="line">  User getUser(@Param(&quot;userId&quot;) String userId);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>那么可以通过 MapperFactoryBean 将接口加入到 Spring 中:</li></ul><p>MapperFactoryBean 将会负责 SqlSession 的创建和关闭。如果使用了 Spring 的事务功能，那么当事务完成时，session 将会被提交或回滚。最终任何异常都会被转换成 Spring 的 DataAccessException 异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userMapper&quot; class&#x3D;&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;mapperInterface&quot; value&#x3D;&quot;org.mybatis.spring.sample.mapper.UserMapper&quot; &#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;sqlSessionFactory&quot; ref&#x3D;&quot;sqlSessionFactory&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><h2 id="2、SqlSession"><a href="#2、SqlSession" class="headerlink" title="2、SqlSession"></a>2、SqlSession</h2><p>MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession  使用它来执行映射了的语句，提交或回滚连接，关闭 session。</p><p> MyBatis-Spring不在直接使用SqlSessionFactory,bean 可以被注入一个线程安全的 SqlSession(SqlSessionTemplate实现了SqlSession )，它能基于 Spring 的事务配置来自动提交、回滚、关闭 session。  </p><p> SqlSessionTemplate 是线程安全的，可以被多个 DAO 或映射器所共享使用。保证使用的 SqlSession 与当前 Spring 的事务相关。此外，它管理 session 的生命周期，包含必要的关闭、提交或回滚操作,负责将 MyBatis 的异常翻译成 Spring 中的 DataAccessExceptions</p><p> 使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SqlSessionTemplate sqlSession() throws Exception &#123;</span><br><span class="line">  return new SqlSessionTemplate(sqlSessionFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line"></span><br><span class="line">  private SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line">  public void setSqlSession(SqlSession sqlSession) &#123;</span><br><span class="line">    this.sqlSession &#x3D; sqlSession;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public User getUser(String userId) &#123;</span><br><span class="line">    return sqlSession.selectOne(&quot;org.mybatis.spring.sample.mapper.UserMapper.getUser&quot;, userId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册映射器"><a href="#注册映射器" class="headerlink" title="注册映射器"></a>注册映射器</h2><p>与其在数据访问对象（DAO）中手工编写使用 SqlSessionDaoSupport 或 SqlSessionTemplate 的代码，还不如让 Mybatis-Spring 为你创建一个线程安全的映射器，这样你就可以直接注入到其它的 bean 中了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;fooService&quot; class&#x3D;&quot;org.mybatis.spring.sample.service.FooServiceImpl&quot;&gt;</span><br><span class="line">  &lt;constructor-arg ref&#x3D;&quot;userMapper&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class FooServiceImpl implements FooService &#123;</span><br><span class="line"></span><br><span class="line">  @Autowired</span><br><span class="line">  private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">  public User doSomeBusinessStuff(String userId) &#123;</span><br><span class="line">    return this.userMapper.getUser(userId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发现映射器"><a href="#发现映射器" class="headerlink" title="发现映射器"></a>发现映射器</h2><p>XML 中加入 MapperFactoryBean 以便将映射器注册到 Spring 中   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userMapper&quot; class&#x3D;&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;mapperInterface&quot; value&#x3D;&quot;org.mybatis.spring.sample.mapper.UserMapper&quot; &#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;sqlSessionFactory&quot; ref&#x3D;&quot;sqlSessionFactory&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>MyBatis-Spring 借助了 Spring 中的 DataSourceTransactionManager 来实现事务管理。事务处理期间一个单独的 SqlSession 对象将会被创建和使用。当事务完成时，这个 session 会以合适的方式提交或回滚。</p><p>要开启 Spring 的事务处理功能，在 Spring 的配置文件中创建一个 DataSourceTransactionManager 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public DataSourceTransactionManager transactionManager() &#123;</span><br><span class="line">  return new DataSourceTransactionManager(dataSource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==为事务管理器指定的 DataSource 必须和用来创建 SqlSessionFactoryBean 的是同一个数据源，否则事务管理器就无法工作了。==</p><p>不能在 Spring 管理的 SqlSession 上调用 SqlSession.commit()，SqlSession.rollback() 或 SqlSession.close() 方法。如果这样做了，就会抛出 UnsupportedOperationException 异常</p>]]></content>
    
    
    <summary type="html">MyBatisSpring所做的是就是将一下mybatis的手写代码和事务交由spring,将Mybatis的异常转换为Spring的DataAccessException</summary>
    
    
    
    <category term="MyBatisSpring" scheme="http://example.com/categories/MyBatisSpring/"/>
    
    
    <category term="MyBatisSpring" scheme="http://example.com/tags/MyBatisSpring/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloudConfig</title>
    <link href="http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/6%E3%80%81spring-config%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/2%E3%80%81Spring%20Cloud%20Config/"/>
    <id>http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/6%E3%80%81spring-config%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/2%E3%80%81Spring%20Cloud%20Config/</id>
    <published>2020-09-19T09:02:42.000Z</published>
    <updated>2020-09-19T10:03:58.209Z</updated>
    
    <content type="html"><![CDATA[<p>1、思路：</p><p>第一：所有配置文件存放在github或其他git仓库上，由spring-cloud-config server与其通信。</p><p>所以：微服务首先要告诉spring-cloud-config自己需要那个配置文件，spring-cloud-config再从github上将配置文件读取过来。微服务在解析成自己的配置</p><p>config server端搭建步骤：</p><h3 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h3><p>新建一个配置中心的配置文件：application.yml 上传至github上</p><p>1、从前文得知，spring-cloud-config分为服务端和客户端（各个微服务），服务端也是一个独立的微服务，所以新建一个微服务作为配置中心引入spring-cloud-config的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--配置中心添加安全认证--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、在配置文件中指明github地址，与其通信<br>#注意是git的ssh地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8901</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-server</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git: #配置存储配置信息的Git仓库</span><br><span class="line">          uri: https:&#x2F;&#x2F;gitee.com&#x2F;macrozheng&#x2F;springcloud-config.git</span><br><span class="line">          username: macro</span><br><span class="line">          password: 123456</span><br><span class="line">          clone-on-start: true #开启启动时直接从git获取配置</span><br><span class="line">  security: #配置用户名和密码</span><br><span class="line">    user:</span><br><span class="line">      name: macro</span><br><span class="line">      password: 123456</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8001&#x2F;eureka&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、在启动类中添加注解<br>@EnableConfigServer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@EnableConfigServer</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时该配置中心可以与github通信了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 获取配置信息</span><br><span class="line">&#x2F;&#123;label&#125;&#x2F;&#123;application&#125;-&#123;profile&#125;</span><br><span class="line"># 获取配置文件信息</span><br><span class="line">&#x2F;&#123;label&#125;&#x2F;&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>application：代表应用名称，默认为配置文件中的spring.application.name，如果配置了spring.cloud.config.name，则为该名称；</li><li>label：代表分支名称，对应配置文件中的spring.cloud.config.label；</li><li>profile：代表环境名称，对应配置文件中的spring.cloud.config.profile。</li></ul><h4 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h4><p>搞定配置中心。剩下就是微服务与配置中心通信。告诉配置中心自己所需要的配置文件，让他从github上读取到该文件给微服务。</p><p>准备工作：新建一个微服务提供者的配置文件，并上传至github上。</p><p>1、新建一个微服务提供者，引入依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、为微服务提供者的resource目录下新建一个系统级的bootstrap.yml文件，这是一个优先级高于用户级的配置文件application.yml</p><p>内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9001</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-client</span><br><span class="line">  cloud:</span><br><span class="line">    #告诉springcloud-config配置中心需要从github上读取的资源名称  注意末尾没有yml</span><br><span class="line">    config: #Config客户端配置</span><br><span class="line">      profile: dev #启用配置后缀名称</span><br><span class="line">      label: dev #分支名称</span><br><span class="line">      uri: http:&#x2F;&#x2F;localhost:8901 #config server配置中心的地址，让过配置中心微服务获取github上的文件</span><br><span class="line">      name: config #配置文件名称</span><br><span class="line">      #配置中心添加了安全认证</span><br><span class="line">      username: macro</span><br><span class="line">      password: 123456</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8001&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p>微服务客户端获取配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class ConfigClientController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;config.info&#125;&quot;)</span><br><span class="line">    private String configInfo;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;configInfo&quot;)</span><br><span class="line">    public String getConfigInfo() &#123;</span><br><span class="line">        return configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="刷新配置"><a href="#刷新配置" class="headerlink" title="刷新配置"></a>刷新配置</h4><p>当Git仓库中的配置信息更改后，我们可以通过SpringBoot Actuator的refresh端点来刷新客户端配置信息，以下更改都需要在config-client中进行。</p><p>在pom.xml中添加Actuator的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开启refresh端点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#39;refresh&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加@RefreshScope注解用于刷新配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RefreshScope</span><br><span class="line">public class ConfigClientController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;config.info&#125;&quot;)</span><br><span class="line">    private String configInfo;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;configInfo&quot;)</span><br><span class="line">    public String getConfigInfo() &#123;</span><br><span class="line">        return configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="config-sever集群搭建"><a href="#config-sever集群搭建" class="headerlink" title="config-sever集群搭建"></a>config-sever集群搭建</h4><p>在微服务架构中，所有服务都从配置中心获取配置，配置中心一旦宕机，会发生很严重的问题，下面我们搭建一个双节点的配置中心集群来解决该问题。</p><p>启动两个config-server分别运行在8902和8903端口上；</p><p>添加config-client的配置文件bootstrap-cluster.yml，==主要是添加了从注册中心获取配置中心地址的配置并去除了配置中心uri的配置==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      profile: dev #启用环境名称</span><br><span class="line">      label: dev #分支名称</span><br><span class="line">      name: config #配置文件名称</span><br><span class="line">      discovery:</span><br><span class="line">        enabled: true</span><br><span class="line">        service-id: config-server</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8001&#x2F;eureka&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">1、思路第一所有配置文件存放在github或其他git仓库上，由springcloudconfigserver与其通信。</summary>
    
    
    
    <category term="springconfig配置中心" scheme="http://example.com/categories/springconfig%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    
    
    <category term="SpringCloudConfig" scheme="http://example.com/tags/SpringCloudConfig/"/>
    
  </entry>
  
  <entry>
    <title>hystrix介绍</title>
    <link href="http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/4%E3%80%81hystrix%20%E6%96%AD%E8%B7%AF%E5%99%A8/1%E3%80%81hystrix%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/4%E3%80%81hystrix%20%E6%96%AD%E8%B7%AF%E5%99%A8/1%E3%80%81hystrix%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-09-19T09:01:58.000Z</published>
    <updated>2020-09-19T10:03:58.142Z</updated>
    
    <content type="html"><![CDATA[<ul><li>服务降级：系统整体资源不够，忍痛将一些服务关闭，待资源释放后，再开启回来</li><li>服务熔断金额服务降级的概念区分：</li><li>熔断：是单个服务故障或异常引起。当服务的发生异常，直接熔断整个服务，而不是一直等待此服务超时。</li><li>降级：是从整体负荷考虑，当某个服务熔断后，该服务器将不在调用。返回一个本地的fallback回调，返回一个缺省值<br>hystrix断路器：</li></ul><p><a href="https://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_clients">https://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_clients</a></p><p>就是一句话，保证单个服务调用出错，不会导致系统宕机。</p><p>在系统中 微服务A调用微服务B  微服务B调用微服务C 微服务C调用微服务D 。。。就是所谓的扇出<br>若微服务C连接超时或不可用时怎么办？</p><p>hystrix 是一个用于处理分布式系统的延迟和容错的开源库。Hystrix断路器 本身是一种开关装置（保险丝）。当一个微服务发生故障时，通过Hystrix的故障监控，会向调用方返回一个可预期，可处理的备选响应（fallBack）。而不是长时间的的等待或者抛出异常。保证服务调用方的线程不会长时间占用，从而避免故障在系统中的蔓延，乃至宕机。</p><h4 id="1、在服务提供者中添加hystrix的依赖"><a href="#1、在服务提供者中添加hystrix的依赖" class="headerlink" title="1、在服务提供者中添加hystrix的依赖"></a>1、在服务提供者中添加hystrix的依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.cloud&#x2F;spring-cloud-starter-hystrix --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4.5.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="2、再微服务中添加注解："><a href="#2、再微服务中添加注解：" class="headerlink" title="2、再微服务中添加注解："></a>2、再微服务中添加注解：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(fallbackMethod&#x3D;&quot;exceptionHandler&quot;)</span><br></pre></td></tr></table></figure><p>一旦微服务发生异常，就会调用fallbackMethod指定的方法</p><ul><li>fallbackMethod：指定服务降级处理方法；</li><li>ignoreExceptions：忽略某些异常，不发生服务降级；</li><li>commandKey：命令名称，用于区分不同的命令；</li><li>groupKey：分组名称，Hystrix会根据不同的分组来统计命令的告警及仪表盘信息；</li><li>threadPoolKey：线程池名称，用于划分线程池。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(fallbackMethod &#x3D; &quot;exceptionHandler&quot;)</span><br><span class="line">public CommonResult getUser(Long id) &#123;</span><br><span class="line">    return restTemplate.getForObject(userServiceUrl + &quot;&#x2F;user&#x2F;&#123;1&#125;&quot;, CommonResult.class, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public CommonResult exceptionHandler(@PathVariable Long id) &#123;</span><br><span class="line">    User defaultUser &#x3D; new User(-1L, &quot;defaultUser&quot;, &quot;123456&quot;);</span><br><span class="line">    return new CommonResult&lt;&gt;(defaultUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="3、在启动类中开启hystrix熔断器"><a href="#3、在启动类中开启hystrix熔断器" class="headerlink" title="3、在启动类中开启hystrix熔断器"></a>3、在启动类中开启hystrix熔断器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@EnableCircuitBreaker &#x2F;&#x2F;开启hysrtix熔断器</span><br><span class="line">@EnableDiscoveryClient &#x2F;&#x2F;服务发现</span><br></pre></td></tr></table></figure><h3 id="4、说明：上述方式的缺点："><a href="#4、说明：上述方式的缺点：" class="headerlink" title="4、说明：上述方式的缺点："></a>4、说明：上述方式的缺点：</h3><p>每个方法都添加上@HystrixCommand(fallbackMethod=”exceptionHandler”)造成代码的耦合性太高，和代码的冗余<br>可以将针对方法的注解，提取到针对类。原理就是AOP面向切面编程的异常通知。</p><p>4.1 在api moudle中针对service添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class DeptClientFallFactory implements FallbackFactory&lt;DeptService&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public DeptService create(Throwable throwable) &#123;</span><br><span class="line">        return new DeptService()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Dept getData() &#123;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;发送服务熔断时候的处理</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.2 再service中指定该DeptClientFallFactory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value &#x3D;&quot;CLOUD-SERVICE-PROVIDER-01&#x2F;cloud-service-provider-01&quot;)</span><br><span class="line">public interface DeptService &#123;</span><br><span class="line">    Dept getData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hystrix的请求缓存"><a href="#Hystrix的请求缓存" class="headerlink" title="Hystrix的请求缓存"></a>Hystrix的请求缓存</h3><p>当系统并发量越来越大时，我们需要使用缓存来优化系统，达到减轻并发请求线程数，提供响应速度的效果。</p><p>相关注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@CacheResult：开启缓存，默认所有参数作为缓存的key，cacheKeyMethod可以通过返回String类型的方法指定key；</span><br><span class="line">@CacheKey：指定缓存的key，可以指定参数或指定参数中的属性值为缓存key，cacheKeyMethod还可以通过返回String类型的方法指定；</span><br><span class="line">@CacheRemove：移除缓存，需要指定commandKey。</span><br></pre></td></tr></table></figure><p>注意：需要在每次使用缓存的请求前后对HystrixRequestContext进行初始化和关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: Request caching is not available. Maybe you need to initialize the HystrixRequestContext?</span><br></pre></td></tr></table></figure><p>使用过滤器，在每个请求前后初始化和关闭HystrixRequestContext来解决该问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by macro on 2019&#x2F;9&#x2F;4.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">@WebFilter(urlPatterns &#x3D; &quot;&#x2F;*&quot;,asyncSupported &#x3D; true)</span><br><span class="line">public class HystrixRequestContextFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        HystrixRequestContext context &#x3D; HystrixRequestContext.initializeContext();</span><br><span class="line">        try &#123;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            context.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Hystrix的常用配置"><a href="#Hystrix的常用配置" class="headerlink" title="Hystrix的常用配置"></a>Hystrix的常用配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">hystrix:</span><br><span class="line">  command: #用于控制HystrixCommand的行为</span><br><span class="line">    default:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          strategy: THREAD #控制HystrixCommand的隔离策略，THREAD-&gt;线程池隔离策略(默认)，SEMAPHORE-&gt;信号量隔离策略</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: 1000 #配置HystrixCommand执行的超时时间，执行超过该时间会进行服务降级处理</span><br><span class="line">            interruptOnTimeout: true #配置HystrixCommand执行超时的时候是否要中断</span><br><span class="line">            interruptOnCancel: true #配置HystrixCommand执行被取消的时候是否要中断</span><br><span class="line">          timeout:</span><br><span class="line">            enabled: true #配置HystrixCommand的执行是否启用超时时间</span><br><span class="line">          semaphore:</span><br><span class="line">            maxConcurrentRequests: 10 #当使用信号量隔离策略时，用来控制并发量的大小，超过该并发量的请求会被拒绝</span><br><span class="line">      fallback:</span><br><span class="line">        enabled: true #用于控制是否启用服务降级</span><br><span class="line">      circuitBreaker: #用于控制HystrixCircuitBreaker的行为</span><br><span class="line">        enabled: true #用于控制断路器是否跟踪健康状况以及熔断请求</span><br><span class="line">        requestVolumeThreshold: 20 #超过该请求数的请求会被拒绝</span><br><span class="line">        forceOpen: false #强制打开断路器，拒绝所有请求</span><br><span class="line">        forceClosed: false #强制关闭断路器，接收所有请求</span><br><span class="line">      requestCache:</span><br><span class="line">        enabled: true #用于控制是否开启请求缓存</span><br><span class="line">  collapser: #用于控制HystrixCollapser的执行行为</span><br><span class="line">    default:</span><br><span class="line">      maxRequestsInBatch: 100 #控制一次合并请求合并的最大请求数</span><br><span class="line">      timerDelayinMilliseconds: 10 #控制多少毫秒内的请求会被合并成一个</span><br><span class="line">      requestCache:</span><br><span class="line">        enabled: true #控制合并请求是否开启缓存</span><br><span class="line">  threadpool: #用于控制HystrixCommand执行所在线程池的行为</span><br><span class="line">    default:</span><br><span class="line">      coreSize: 10 #线程池的核心线程数</span><br><span class="line">      maximumSize: 10 #线程池的最大线程数，超过该线程数的请求会被拒绝</span><br><span class="line">      maxQueueSize: -1 #用于设置线程池的最大队列大小，-1采用SynchronousQueue，其他正数采用LinkedBlockingQueue</span><br><span class="line">      queueSizeRejectionThreshold: 5 #用于设置线程池队列的拒绝阀值，由于LinkedBlockingQueue不能动态改版大小，使用时需要用该参数来控制线程数</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">服务降级系统整体资源不够，忍痛将一些服务关闭，待资源释放后，再开启回来服务熔断金额服务降级的概念区分</summary>
    
    
    
    <category term="hystrix断路器" scheme="http://example.com/categories/hystrix%E6%96%AD%E8%B7%AF%E5%99%A8/"/>
    
    
    <category term="hystrix介绍" scheme="http://example.com/tags/hystrix%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
  <entry>
    <title>指定bean的初始化销毁方法（一）</title>
    <link href="http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/spring%E6%B3%A8%E8%A7%A3/7%E3%80%81%E6%8C%87%E5%AE%9Abean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/spring%E6%B3%A8%E8%A7%A3/7%E3%80%81%E6%8C%87%E5%AE%9Abean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-09-19T08:59:56.000Z</published>
    <updated>2020-09-19T10:03:57.974Z</updated>
    
    <content type="html"><![CDATA[<p>ioc容器管理bean,负责创建bean  并初始化 销毁。<br>在xml配置文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--可以指定一个无参，可抛异常的初始化方法和销毁方法--&gt;</span><br><span class="line"> &lt;bean id&#x3D;&quot;person&quot; class&#x3D;&quot;com.cloud.spring.anntation.test.Person&quot; init-method&#x3D;&quot;init&quot; destroy-method&#x3D;&quot;destory&quot;&gt;</span><br><span class="line"> &lt;&#x2F;bean&gt;</span><br><span class="line">注解方式：</span><br><span class="line">1、使用@Bean指定初始化和销毁方法（多实例容器不会销毁）</span><br><span class="line">@Configuration</span><br><span class="line">public class MyBeanLifeCycleConfig &#123;</span><br><span class="line">    @Bean(initMethod &#x3D; &quot;init&quot;,destroyMethod &#x3D; &quot;destory&quot;)</span><br><span class="line">    public Car car()&#123;</span><br><span class="line">        return new Car();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>car类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Car &#123;</span><br><span class="line"></span><br><span class="line">    public Car()&#123;</span><br><span class="line">        System.err.println(&quot;car con&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void init()&#123;</span><br><span class="line">        System.err.println(&quot;init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destory()&#123;</span><br><span class="line">        System.err.println(&quot;destory&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、实现InitializingBean  DisposableBean 接口指定初始化和销毁方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements InitializingBean,DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    public Car()&#123;</span><br><span class="line">        System.err.println(&quot;car con&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;bean销毁的时候调用</span><br><span class="line">    public void destroy() throws Exception &#123;</span><br><span class="line">        System.err.println(&quot;DisposableBean--destroy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建完对象，且属性已经赋值后，调用该方法</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.err.println(&quot;InitializingBean-afterPropertiesSet&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;    public void init()&#123;</span><br><span class="line">&#x2F;&#x2F;        System.err.println(&quot;init&quot;);</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    public void destory()&#123;</span><br><span class="line">&#x2F;&#x2F;        System.err.println(&quot;destory&quot;);</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用JSR250规范：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Dog &#123;</span><br><span class="line">    public Dog() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;PostConstruct注解：对象创建并赋值之后调用</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        System.err.println(&quot;init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;PreDestroy注解：容器移除前调用</span><br><span class="line">    @PreDestroy</span><br><span class="line">    public void destory() &#123;</span><br><span class="line">        System.err.println(&quot;destory&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加到容器中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyBeanLifeCycleConfig &#123;</span><br><span class="line">    @Bean(initMethod &#x3D; &quot;init&quot;,destroyMethod &#x3D; &quot;destory&quot;)</span><br><span class="line">    public Car car()&#123;</span><br><span class="line">        return new Car();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、后置处理器：<br>使用：实现BeanPostProcessor 接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Cat implements BeanPostProcessor &#123;</span><br><span class="line">    public Cat() &#123;</span><br><span class="line">        System.err.println(&quot;car初始化&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;ioc容器的每个对象初始化之前调用</span><br><span class="line">    public Object postProcessBeforeInitialization(Object o, String s) throws BeansException &#123;</span><br><span class="line">        System.err.println(&quot;Cat-----postProcessBeforeInitialization----bean的实例：&quot;+o+&quot;bean的名称：&quot;+s);</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;oc容器的每个对象初始化之后调用</span><br><span class="line">    public Object postProcessAfterInitialization(Object o, String s) throws BeansException &#123;</span><br><span class="line">        System.err.println(&quot;Cat-----postProcessAfterInitialization----bean的实例：&quot;+o+&quot;bean的名称：&quot;+s);</span><br><span class="line"></span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ioc容器管理bean,负责创建bean并初始化销毁。在xml配置文件中</summary>
    
    
    
    <category term="spring注解" scheme="http://example.com/categories/spring%E6%B3%A8%E8%A7%A3/"/>
    
    
    <category term="指定bean的初始化销毁方法（一）" scheme="http://example.com/tags/%E6%8C%87%E5%AE%9Abean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>bean的注册</title>
    <link href="http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/IOC/1%E3%80%81bean%E7%9A%84%E6%B3%A8%E5%86%8C/"/>
    <id>http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/IOC/1%E3%80%81bean%E7%9A%84%E6%B3%A8%E5%86%8C/</id>
    <published>2020-09-19T08:59:13.000Z</published>
    <updated>2020-09-19T10:03:57.864Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>控制反转实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</p></li><li><p>依赖注入依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用</p></li></ul><p><a href="https://blog.csdn.net/songxinjianqwe/article/details/78824851">https://blog.csdn.net/songxinjianqwe/article/details/78824851</a></p><p>==IOC本质上是Spring管理一个容器，容器是BeanFactory的实现，容器中管理了所有用户指定的bean（xml或注解），最底层就是一个Map==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;bean的注册</span><br><span class="line">        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;bean的加载</span><br><span class="line">        UserService userService &#x3D; (UserService) applicationContext.getBean(&quot;userService&quot;);</span><br><span class="line">        userService.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bean注册"><a href="#bean注册" class="headerlink" title="bean注册"></a>bean注册</h3><p>==然后解析xml、注解中定义的bean。将bean信息解析存储到BeanDefinition相应的属性中，并将所有的benaName和对应的BeanDefinition存放到BeanFactory中成员变量的Map中。==</p><ul><li>BeanDefinition的保存的是Bean的类名、scope、属性、构造函数参数列表、依赖的bean、是否是单例类、是否是懒加载等，==后面对Bean的操作就直接对BeanDefinition进行==，例如拿到这个BeanDefinition后，可以根据里面的类名、构造函数、构造函数参数，使用反射进行对象创建。</li></ul><p><img src="https://img-blog.csdn.net/20171217162549343?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc29uZ3hpbmppYW5xd2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><p>在解析bean的过程中创建了BeanFactory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected DefaultListableBeanFactory createBeanFactory() &#123;</span><br><span class="line">    return new DefaultListableBeanFactory(this.getInternalParentBeanFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>且BeanFactory有成员变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap &#x3D; new ConcurrentHashMap(256);</span><br></pre></td></tr></table></figure><p>两个重要的方法：</p><ul><li>obtainFreshBeanFactory，读取到所有的beanDefinition（bean的定义，比如xml配置文件中的中定义的，或者@Component、@Service等标记的bean），并保存到beanFactroy中；</li><li>finishBeanFactoryInitialization，加载所有非延迟加载的、单例的bean <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">   synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">      &#x2F;&#x2F; 准备 刷新的上下文环境</span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 初始化BeanFactory，并进行XML文件的读取</span><br><span class="line">      ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 对BeanFactory进行各种功能填充</span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         &#x2F;&#x2F; 子类覆盖方法做额外的处理</span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 激活各种BeanFactory处理器</span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 注册拦截Bean创建的Bean处理器，这里只是注册，真正的调用是在getBean的时候</span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 为上下文初始化Message源，即不同语言的消息体，国际化处理</span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 初始化应用消息广播器，并放入applicationEventMulticaster bean中</span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 留给子类来初始化其他bean</span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 在所有注册的bean中查找Listener bean，注册到消息广播器中</span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 初始化剩下的单例实例（除了lazy-init）</span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 完成刷新过程，通知生命周期处理器lifecycleProcessor刷新过程，同时发出ContextRefreshEvent通知别人</span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      catch (BeansException ex) &#123;</span><br><span class="line">         if (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">                  &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; Destroy already created singletons to avoid dangling resources.</span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; Reset &#39;active&#39; flag.</span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; Propagate exception to caller.</span><br><span class="line">         throw ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      finally &#123;</span><br><span class="line">         &#x2F;&#x2F; Reset common introspection caches in Spring&#39;s core, since we</span><br><span class="line">         &#x2F;&#x2F; might not ever need metadata for singleton beans anymore...</span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>可跟踪代码，最后将解析到的beanName放入beanDefinitionMap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanDefinitionMap.put(beanName, beanDefinition);</span><br></pre></td></tr></table></figure><p>解析标签的时候，涉及到解析AOP标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;处理自定义标签</span><br><span class="line">public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) &#123;</span><br><span class="line">   String namespaceUri &#x3D; getNamespaceURI(ele);</span><br><span class="line">&#x2F;&#x2F; AopNamespaceHandler</span><br><span class="line">   NamespaceHandler handler &#x3D; this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">   if (handler &#x3D;&#x3D; null) &#123;</span><br><span class="line">      error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, ele);</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">   return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里返回的parser即为AspectJAutoProxyBeanDefinitionParser。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">   AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">   extendBeanDefinition(element, parserContext);</span><br><span class="line">   return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册这个creator</span><br><span class="line">public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">      ParserContext parserContext, Element sourceElement) &#123;</span><br><span class="line">   &#x2F;&#x2F; 注册或升级AutoProxyCreator定义beanName为internalAutoProxyCreator的BeanDefinition</span><br><span class="line">   BeanDefinition beanDefinition &#x3D; AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">         parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对于proxy-target-class以及expose-proxy属性的增强</span><br><span class="line">   useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">&#x2F;&#x2F; 注册组件并通知，便于监听器做进一步处理</span><br><span class="line">&#x2F;&#x2F; 其中beanDefinition的className为AnnotationAwareAspectJAutoProxyCreator</span><br><span class="line">   registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">控制反转实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。依赖注入依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过new的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用</summary>
    
    
    
    <category term="IOC" scheme="http://example.com/categories/IOC/"/>
    
    
    <category term="bean的注册" scheme="http://example.com/tags/bean%E7%9A%84%E6%B3%A8%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>bean的初始化</title>
    <link href="http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/IOC/5%E3%80%81bean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/IOC/5%E3%80%81bean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2020-09-19T08:58:13.000Z</published>
    <updated>2020-09-19T10:03:57.898Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">    if (System.getSecurityManager() !&#x3D; null) &#123;</span><br><span class="line">        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object run() &#123;</span><br><span class="line">                invokeAwareMethods(beanName, bean);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; 若 bean 实现了 BeanNameAware、BeanFactoryAware、BeanClassLoaderAware 等接口，则向 bean 中注入相关对象</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object wrappedBean &#x3D; bean;</span><br><span class="line">    if (mbd &#x3D;&#x3D; null || !mbd.isSynthetic()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行 bean 初始化前置操作</span><br><span class="line">        wrappedBean &#x3D; applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 调用初始化方法：</span><br><span class="line">         * 1. 若 bean 实现了 InitializingBean 接口，则调用 afterPropertiesSet 方法</span><br><span class="line">         * 2. 若用户配置了 bean 的 init-method 属性，则调用用户在配置中指定的方法</span><br><span class="line">         *&#x2F;</span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable ex) &#123;</span><br><span class="line">        throw new BeanCreationException(</span><br><span class="line">                (mbd !&#x3D; null ? mbd.getResourceDescription() : null),</span><br><span class="line">                beanName, &quot;Invocation of init method failed&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    if (mbd &#x3D;&#x3D; null || !mbd.isSynthetic()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行 bean 初始化后置操作，AOP 会在此处向目标对象中织入切面逻辑</span><br><span class="line">        wrappedBean &#x3D; applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    return wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>检测 bean 是否实现了 *Aware 类型接口，若实现，则向 bean 中注入相应的对象</li><li>执行 bean 初始化前置操作</li><li>执行初始化操作</li><li>执行 bean 初始化后置操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">private void invokeAwareMethods(final String beanName, final Object bean) &#123;</span><br><span class="line">    if (bean instanceof Aware) &#123;</span><br><span class="line">        if (bean instanceof BeanNameAware) &#123;</span><br><span class="line">            &#x2F;&#x2F; 注入 beanName 字符串</span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        if (bean instanceof BeanClassLoaderAware) &#123;</span><br><span class="line">            &#x2F;&#x2F; 注入 ClassLoader 对象</span><br><span class="line">            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        if (bean instanceof BeanFactoryAware) &#123;</span><br><span class="line">            &#x2F;&#x2F; 注入 BeanFactory 对象</span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)</span><br><span class="line">        throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 检测 bean 是否是 InitializingBean 类型的</span><br><span class="line">    boolean isInitializingBean &#x3D; (bean instanceof InitializingBean);</span><br><span class="line">    if (isInitializingBean &amp;&amp; (mbd &#x3D;&#x3D; null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) &#123;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;Invoking afterPropertiesSet() on bean with name &#39;&quot; + beanName + &quot;&#39;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (System.getSecurityManager() !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object run() throws Exception &#123;</span><br><span class="line">                        ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                throw pae.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果 bean 实现了 InitializingBean，则调用 afterPropertiesSet 方法执行初始化逻辑</span><br><span class="line">            ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mbd !&#x3D; null) &#123;</span><br><span class="line">        String initMethodName &#x3D; mbd.getInitMethodName();</span><br><span class="line">        if (initMethodName !&#x3D; null &amp;&amp; !(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;</span><br><span class="line">                !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 调用用户自定义的初始化方法</span><br><span class="line">            invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">protectedObjectinitializeBean(finalStringbeanName,finalObjectbean,RootBeanDefinitionmbd){</summary>
    
    
    
    <category term="IOC" scheme="http://example.com/categories/IOC/"/>
    
    
    <category term="bean的初始化" scheme="http://example.com/tags/bean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>创建原始bean</title>
    <link href="http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/IOC/3%E3%80%81%E5%88%9B%E5%BB%BA%E5%8E%9F%E5%A7%8Bbean/"/>
    <id>http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/IOC/3%E3%80%81%E5%88%9B%E5%BB%BA%E5%8E%9F%E5%A7%8Bbean/</id>
    <published>2020-09-19T08:58:05.000Z</published>
    <updated>2020-09-19T10:03:57.885Z</updated>
    
    <content type="html"><![CDATA[<p>5.3.1 创建原始bean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) &#123;</span><br><span class="line">    Class&lt;?&gt; beanClass &#x3D; resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 检测类的访问权限。默认情况下，对于非 public 的类，是允许访问的。</span><br><span class="line">     * 若禁止访问，这里会抛出异常</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (beanClass !&#x3D; null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">        throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                &quot;Bean class isn&#39;t public, and non-public access not allowed: &quot; + beanClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 如果工厂方法不为空，则通过工厂方法构建 bean 对象。这种构建 bean 的方式</span><br><span class="line">     * 就不深入分析了，有兴趣的朋友可以自己去看一下。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (mbd.getFactoryMethodName() !&#x3D; null)  &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过“工厂方法”的方式构建 bean 对象</span><br><span class="line">        return instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 当多次构建同一个 bean 时，可以使用此处的快捷路径，即无需再次推断应该使用哪种方式构造实例，</span><br><span class="line">     * 以提高效率。比如在多次构建同一个 prototype 类型的 bean 时，就可以走此处的捷径。</span><br><span class="line">     * 这里的 resolved 和 mbd.constructorArgumentsResolved 将会在 bean 第一次实例</span><br><span class="line">     * 化的过程中被设置，在后面的源码中会分析到，先继续往下看。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean resolved &#x3D; false;</span><br><span class="line">    boolean autowireNecessary &#x3D; false;</span><br><span class="line">    if (args &#x3D;&#x3D; null) &#123;</span><br><span class="line">        synchronized (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            if (mbd.resolvedConstructorOrFactoryMethod !&#x3D; null) &#123;</span><br><span class="line">                resolved &#x3D; true;</span><br><span class="line">                autowireNecessary &#x3D; mbd.constructorArgumentsResolved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (resolved) &#123;</span><br><span class="line">        if (autowireNecessary) &#123;</span><br><span class="line">            &#x2F;&#x2F; 通过“构造方法自动注入”的方式构造 bean 对象</span><br><span class="line">            return autowireConstructor(beanName, mbd, null, null);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 通过“默认构造方法”的方式构造 bean 对象</span><br><span class="line">            return instantiateBean(beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 由后置处理器决定返回哪些构造方法，这里不深入分析了</span><br><span class="line">    Constructor&lt;?&gt;[] ctors &#x3D; determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 下面的条件分支条件用于判断使用什么方式构造 bean 实例，有两种方式可选 - 构造方法自动</span><br><span class="line">     * 注入和默认构造方法。判断的条件由4部分综合而成，如下：</span><br><span class="line">     * </span><br><span class="line">     *    条件1：ctors !&#x3D; null -&gt; 后置处理器返回构造方法数组是否为空</span><br><span class="line">     *    </span><br><span class="line">     *    条件2：mbd.getResolvedAutowireMode() &#x3D;&#x3D; RootBeanDefinition.AUTOWIRE_CONSTRUCTOR </span><br><span class="line">     *              -&gt; bean 配置中的 autowire 属性是否为 constructor    </span><br><span class="line">     *    条件3：mbd.hasConstructorArgumentValues() </span><br><span class="line">     *              -&gt; constructorArgumentValues 是否存在元素，即 bean 配置文件中</span><br><span class="line">     *                 是否配置了 &lt;construct-arg&#x2F;&gt;</span><br><span class="line">     *    条件4：!ObjectUtils.isEmpty(args) </span><br><span class="line">     *              -&gt; args 数组是否存在元素，args 是由用户调用 </span><br><span class="line">     *                 getBean(String name, Object... args) 传入的</span><br><span class="line">     * </span><br><span class="line">     * 上面4个条件，只要有一个为 true，就会通过构造方法自动注入的方式构造 bean 实例</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (ctors !&#x3D; null ||</span><br><span class="line">            mbd.getResolvedAutowireMode() &#x3D;&#x3D; RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过“构造方法自动注入”的方式构造 bean 对象</span><br><span class="line">        return autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 通过“默认构造方法”的方式构造 bean 对象</span><br><span class="line">    return instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>检测类的访问权限，若禁止访问，则抛出异常</li><li>若工厂方法不为空，则通过工厂方法构建 bean 对象，并返回结果</li><li>若构造方式已解析过，则走快捷路径构建 bean 对象，并返回结果</li><li>如第三步不满足，则通过组合条件决定使用哪种方式构建 bean 对象</li></ol><p>这里有三种构造 bean 对象的方式，如下：</p><ul><li>通过“工厂方法”的方式构造 bean 对象</li><li>通过“构造方法自动注入”的方式构造 bean 对象</li><li>通过“默认构造方法”的方式构造 bean 对象</li></ul><p>通过构造方法自动注入的方式创建 bean 实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br></pre></td><td class="code"><pre><span class="line">protected BeanWrapper autowireConstructor(</span><br><span class="line">        String beanName, RootBeanDefinition mbd, Constructor&lt;?&gt;[] ctors, Object[] explicitArgs) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建 ConstructorResolver 对象，并调用其 autowireConstructor 方法</span><br><span class="line">    return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public BeanWrapper autowireConstructor(final String beanName, final RootBeanDefinition mbd,</span><br><span class="line">        Constructor&lt;?&gt;[] chosenCtors, final Object[] explicitArgs) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建 BeanWrapperImpl 对象</span><br><span class="line">    BeanWrapperImpl bw &#x3D; new BeanWrapperImpl();</span><br><span class="line">    this.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line">    Constructor&lt;?&gt; constructorToUse &#x3D; null;</span><br><span class="line">    ArgumentsHolder argsHolderToUse &#x3D; null;</span><br><span class="line">    Object[] argsToUse &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 确定参数值列表（argsToUse）</span><br><span class="line">    if (explicitArgs !&#x3D; null) &#123;</span><br><span class="line">        argsToUse &#x3D; explicitArgs;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        Object[] argsToResolve &#x3D; null;</span><br><span class="line">        synchronized (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取已解析的构造方法</span><br><span class="line">            constructorToUse &#x3D; (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">            if (constructorToUse !&#x3D; null &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line">                &#x2F;&#x2F; 获取已解析的构造方法参数列表</span><br><span class="line">                argsToUse &#x3D; mbd.resolvedConstructorArguments;</span><br><span class="line">                if (argsToUse &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 若 argsToUse 为空，则获取未解析的构造方法参数列表</span><br><span class="line">                    argsToResolve &#x3D; mbd.preparedConstructorArguments;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (argsToResolve !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 解析参数列表</span><br><span class="line">            argsToUse &#x3D; resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (constructorToUse &#x3D;&#x3D; null) &#123;</span><br><span class="line">        boolean autowiring &#x3D; (chosenCtors !&#x3D; null ||</span><br><span class="line">                mbd.getResolvedAutowireMode() &#x3D;&#x3D; RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">        ConstructorArgumentValues resolvedValues &#x3D; null;</span><br><span class="line"></span><br><span class="line">        int minNrOfArgs;</span><br><span class="line">        if (explicitArgs !&#x3D; null) &#123;</span><br><span class="line">            minNrOfArgs &#x3D; explicitArgs.length;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            ConstructorArgumentValues cargs &#x3D; mbd.getConstructorArgumentValues();</span><br><span class="line">            resolvedValues &#x3D; new ConstructorArgumentValues();</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * 确定构造方法参数数量，比如下面的配置：</span><br><span class="line">             *     &lt;bean id&#x3D;&quot;persion&quot; class&#x3D;&quot;xyz.coolblog.autowire.Person&quot;&gt;</span><br><span class="line">             *         &lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;xiaoming&quot;&#x2F;&gt;</span><br><span class="line">             *         &lt;constructor-arg index&#x3D;&quot;1&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;</span><br><span class="line">             *         &lt;constructor-arg index&#x3D;&quot;2&quot; value&#x3D;&quot;man&quot;&#x2F;&gt;</span><br><span class="line">             *     &lt;&#x2F;bean&gt;</span><br><span class="line">             *</span><br><span class="line">             * 此时 minNrOfArgs &#x3D; maxIndex + 1 &#x3D; 2 + 1 &#x3D; 3，除了计算 minNrOfArgs，</span><br><span class="line">             * 下面的方法还会将 cargs 中的参数数据转存到 resolvedValues 中</span><br><span class="line">             *&#x2F;</span><br><span class="line">            minNrOfArgs &#x3D; resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取构造方法列表</span><br><span class="line">        Constructor&lt;?&gt;[] candidates &#x3D; chosenCtors;</span><br><span class="line">        if (candidates &#x3D;&#x3D; null) &#123;</span><br><span class="line">            Class&lt;?&gt; beanClass &#x3D; mbd.getBeanClass();</span><br><span class="line">            try &#123;</span><br><span class="line">                candidates &#x3D; (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">                        beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable ex) &#123;</span><br><span class="line">                throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        &quot;Resolution of declared constructors on bean Class [&quot; + beanClass.getName() +</span><br><span class="line">                        &quot;] from ClassLoader [&quot; + beanClass.getClassLoader() + &quot;] failed&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 按照构造方法的访问权限级别和参数数量进行排序</span><br><span class="line">        AutowireUtils.sortConstructors(candidates);</span><br><span class="line"></span><br><span class="line">        int minTypeDiffWeight &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors &#x3D; null;</span><br><span class="line">        LinkedList&lt;UnsatisfiedDependencyException&gt; causes &#x3D; null;</span><br><span class="line"></span><br><span class="line">        for (Constructor&lt;?&gt; candidate : candidates) &#123;</span><br><span class="line">            Class&lt;?&gt;[] paramTypes &#x3D; candidate.getParameterTypes();</span><br><span class="line"></span><br><span class="line">            &#x2F;*</span><br><span class="line">             * 下面的 if 分支的用途是：若匹配到到合适的构造方法了，提前结束 for 循环</span><br><span class="line">             * constructorToUse !&#x3D; null 这个条件比较好理解，下面分析一下条件 argsToUse.length &gt; paramTypes.length：</span><br><span class="line">             * 前面说到 AutowireUtils.sortConstructors(candidates) 用于对构造方法进行</span><br><span class="line">             * 排序，排序规则如下：</span><br><span class="line">             *   1. 具有 public 访问权限的构造方法排在非 public 构造方法前</span><br><span class="line">             *   2. 参数数量多的构造方法排在前面</span><br><span class="line">             *</span><br><span class="line">             * 假设现在有一组构造方法按照上面的排序规则进行排序，排序结果如下（省略参数名称）：</span><br><span class="line">             *</span><br><span class="line">             *   1. public Hello(Object, Object, Object)</span><br><span class="line">             *   2. public Hello(Object, Object)</span><br><span class="line">             *   3. public Hello(Object)</span><br><span class="line">             *   4. protected Hello(Integer, Object, Object, Object)</span><br><span class="line">             *   5. protected Hello(Integer, Object, Object)</span><br><span class="line">             *   6. protected Hello(Integer, Object)</span><br><span class="line">             *</span><br><span class="line">             * argsToUse &#x3D; [num1, obj2]，可以匹配上的构造方法2和构造方法6。由于构造方法2有</span><br><span class="line">             * 更高的访问权限，所以没理由不选他（尽管后者在参数类型上更加匹配）。由于构造方法3</span><br><span class="line">             * 参数数量 &lt; argsToUse.length，参数数量上不匹配，也不应该选。所以 </span><br><span class="line">             * argsToUse.length &gt; paramTypes.length 这个条件用途是：在条件 </span><br><span class="line">             * constructorToUse !&#x3D; null 成立的情况下，通过判断参数数量与参数值数量</span><br><span class="line">             * （argsToUse.length）是否一致，来决定是否提前终止构造方法匹配逻辑。</span><br><span class="line">             *&#x2F;</span><br><span class="line">            if (constructorToUse !&#x3D; null &amp;&amp; argsToUse.length &gt; paramTypes.length) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;*</span><br><span class="line">             * 构造方法参数数量低于配置的参数数量，则忽略当前构造方法，并重试。比如 </span><br><span class="line">             * argsToUse &#x3D; [obj1, obj2, obj3, obj4]，上面的构造方法列表中，</span><br><span class="line">             * 构造方法1、2和3显然不是合适选择，忽略之。</span><br><span class="line">             *&#x2F;</span><br><span class="line">            if (paramTypes.length &lt; minNrOfArgs) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ArgumentsHolder argsHolder;</span><br><span class="line">            if (resolvedValues !&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;*</span><br><span class="line">                     * 判断否则方法是否有 ConstructorProperties 注解，若有，则取注解中的</span><br><span class="line">                     * 值。比如下面的代码：</span><br><span class="line">                     * </span><br><span class="line">                     *  public class Persion &#123;</span><br><span class="line">                     *      private String name;</span><br><span class="line">                     *      private Integer age;</span><br><span class="line">                     *</span><br><span class="line">                     *      @ConstructorProperties(value &#x3D; &#123;&quot;coolblog&quot;, &quot;20&quot;&#125;)</span><br><span class="line">                     *      public Persion(String name, Integer age) &#123;</span><br><span class="line">                     *          this.name &#x3D; name;</span><br><span class="line">                     *          this.age &#x3D; age;</span><br><span class="line">                     *      &#125;</span><br><span class="line">                     * &#125;</span><br><span class="line">                     *&#x2F;</span><br><span class="line">                    String[] paramNames &#x3D; ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);</span><br><span class="line">                    if (paramNames &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        ParameterNameDiscoverer pnd &#x3D; this.beanFactory.getParameterNameDiscoverer();</span><br><span class="line">                        if (pnd !&#x3D; null) &#123;</span><br><span class="line">                            &#x2F;*</span><br><span class="line">                             * 获取构造方法参数名称列表，比如有这样一个构造方法:</span><br><span class="line">                             *   public Person(String name, int age, String sex)</span><br><span class="line">                             *   </span><br><span class="line">                             * 调用 getParameterNames 方法返回 paramNames &#x3D; [name, age, sex]</span><br><span class="line">                             *&#x2F;</span><br><span class="line">                            paramNames &#x3D; pnd.getParameterNames(candidate);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    &#x2F;* </span><br><span class="line">                     * 创建参数值列表，返回 argsHolder 会包含进行类型转换后的参数值，比如下</span><br><span class="line">                     * 面的配置:</span><br><span class="line">                     *</span><br><span class="line">                     *     &lt;bean id&#x3D;&quot;persion&quot; class&#x3D;&quot;xyz.coolblog.autowire.Person&quot;&gt;</span><br><span class="line">                     *         &lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;xiaoming&quot;&#x2F;&gt;</span><br><span class="line">                     *         &lt;constructor-arg name&#x3D;&quot;age&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;</span><br><span class="line">                     *         &lt;constructor-arg name&#x3D;&quot;sex&quot; value&#x3D;&quot;man&quot;&#x2F;&gt;</span><br><span class="line">                     *     &lt;&#x2F;bean&gt;</span><br><span class="line">                     *</span><br><span class="line">                     * Person 的成员变量 age 是 Integer 类型的，但由于在 Spring 配置中</span><br><span class="line">                     * 只能配成 String 类型，所以这里要进行类型转换。</span><br><span class="line">                     *&#x2F;</span><br><span class="line">                    argsHolder &#x3D; createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,</span><br><span class="line">                            getUserDeclaredConstructor(candidate), autowiring);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (UnsatisfiedDependencyException ex) &#123;</span><br><span class="line">                    if (this.beanFactory.logger.isTraceEnabled()) &#123;</span><br><span class="line">                        this.beanFactory.logger.trace(</span><br><span class="line">                                &quot;Ignoring constructor [&quot; + candidate + &quot;] of bean &#39;&quot; + beanName + &quot;&#39;: &quot; + ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (causes &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        causes &#x3D; new LinkedList&lt;UnsatisfiedDependencyException&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    causes.add(ex);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (paramTypes.length !&#x3D; explicitArgs.length) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                argsHolder &#x3D; new ArgumentsHolder(explicitArgs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;*</span><br><span class="line">             * 计算参数值（argsHolder.arguments）每个参数类型与构造方法参数列表</span><br><span class="line">             * （paramTypes）中参数的类型差异量，差异量越大表明参数类型差异越大。参数类型差异</span><br><span class="line">             * 越大，表明当前构造方法并不是一个最合适的候选项。引入差异量（typeDiffWeight）</span><br><span class="line">             * 变量目的：是将候选构造方法的参数列表类型与参数值列表类型的差异进行量化，通过量化</span><br><span class="line">             * 后的数值筛选出最合适的构造方法。</span><br><span class="line">             * </span><br><span class="line">             * 讲完差异量，再来说说 mbd.isLenientConstructorResolution() 条件。</span><br><span class="line">             * 官方的解释是：返回构造方法的解析模式，有宽松模式（lenient mode）和严格模式</span><br><span class="line">             * （strict mode）两种类型可选。具体的细节没去研究，就不多说了。</span><br><span class="line">             *&#x2F;</span><br><span class="line">            int typeDiffWeight &#x3D; (mbd.isLenientConstructorResolution() ?</span><br><span class="line">                    argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line">            if (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">                constructorToUse &#x3D; candidate;</span><br><span class="line">                argsHolderToUse &#x3D; argsHolder;</span><br><span class="line">                argsToUse &#x3D; argsHolder.arguments;</span><br><span class="line">                minTypeDiffWeight &#x3D; typeDiffWeight;</span><br><span class="line">                ambiguousConstructors &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;* </span><br><span class="line">             * 如果两个构造方法与参数值类型列表之间的差异量一致，那么这两个方法都可以作为</span><br><span class="line">             * 候选项，这个时候就出现歧义了，这里先把有歧义的构造方法放入 </span><br><span class="line">             * ambiguousConstructors 集合中</span><br><span class="line">             *&#x2F;</span><br><span class="line">            else if (constructorToUse !&#x3D; null &amp;&amp; typeDiffWeight &#x3D;&#x3D; minTypeDiffWeight) &#123;</span><br><span class="line">                if (ambiguousConstructors &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    ambiguousConstructors &#x3D; new LinkedHashSet&lt;Constructor&lt;?&gt;&gt;();</span><br><span class="line">                    ambiguousConstructors.add(constructorToUse);</span><br><span class="line">                &#125;</span><br><span class="line">                ambiguousConstructors.add(candidate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 若上面未能筛选出合适的构造方法，这里将抛出 BeanCreationException 异常</span><br><span class="line">        if (constructorToUse &#x3D;&#x3D; null) &#123;</span><br><span class="line">            if (causes !&#x3D; null) &#123;</span><br><span class="line">                UnsatisfiedDependencyException ex &#x3D; causes.removeLast();</span><br><span class="line">                for (Exception cause : causes) &#123;</span><br><span class="line">                    this.beanFactory.onSuppressedException(cause);</span><br><span class="line">                &#125;</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line">            throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    &quot;Could not resolve matching constructor &quot; +</span><br><span class="line">                    &quot;(hint: specify index&#x2F;type&#x2F;name arguments for simple parameters to avoid type ambiguities)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 如果 constructorToUse !&#x3D; null，且 ambiguousConstructors 也不为空，表明解析</span><br><span class="line">         * 出了多个的合适的构造方法，此时就出现歧义了。Spring 不会擅自决定使用哪个构造方法，</span><br><span class="line">         * 所以抛出异常。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        else if (ambiguousConstructors !&#x3D; null &amp;&amp; !mbd.isLenientConstructorResolution()) &#123;</span><br><span class="line">            throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    &quot;Ambiguous constructor matches found in bean &#39;&quot; + beanName + &quot;&#39; &quot; +</span><br><span class="line">                    &quot;(hint: specify index&#x2F;type&#x2F;name arguments for simple parameters to avoid type ambiguities): &quot; +</span><br><span class="line">                    ambiguousConstructors);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (explicitArgs &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * 缓存相关信息，比如：</span><br><span class="line">             *   1. 已解析出的构造方法对象 resolvedConstructorOrFactoryMethod</span><br><span class="line">             *   2. 构造方法参数列表是否已解析标志 constructorArgumentsResolved</span><br><span class="line">             *   3. 参数值列表 resolvedConstructorArguments 或 preparedConstructorArguments</span><br><span class="line">             *</span><br><span class="line">             * 这些信息可用在其他地方，用于进行快捷判断</span><br><span class="line">             *&#x2F;</span><br><span class="line">            argsHolderToUse.storeCache(mbd, constructorToUse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Object beanInstance;</span><br><span class="line"></span><br><span class="line">        if (System.getSecurityManager() !&#x3D; null) &#123;</span><br><span class="line">            final Constructor&lt;?&gt; ctorToUse &#x3D; constructorToUse;</span><br><span class="line">            final Object[] argumentsToUse &#x3D; argsToUse;</span><br><span class="line">            beanInstance &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Object run() &#123;</span><br><span class="line">                    return beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">                            mbd, beanName, beanFactory, ctorToUse, argumentsToUse);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, beanFactory.getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * 调用实例化策略创建实例，默认情况下使用反射创建实例。如果 bean 的配置信息中</span><br><span class="line">             * 包含 lookup-method 和 replace-method，则通过 CGLIB 增强 bean 实例</span><br><span class="line">             *&#x2F;</span><br><span class="line">            beanInstance &#x3D; this.beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">                    mbd, beanName, this.beanFactory, constructorToUse, argsToUse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置 beanInstance 到 BeanWrapperImpl 对象中</span><br><span class="line">        bw.setBeanInstance(beanInstance);</span><br><span class="line">        return bw;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable ex) &#123;</span><br><span class="line">        throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                &quot;Bean instantiation via constructor failed&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Object beanInstance;</span><br><span class="line">        final BeanFactory parent &#x3D; this;</span><br><span class="line">        &#x2F;&#x2F; if 条件分支里的一大坨是 Java 安全相关的代码，可以忽略，直接看 else 分支</span><br><span class="line">        if (System.getSecurityManager() !&#x3D; null) &#123;</span><br><span class="line">            beanInstance &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Object run() &#123;</span><br><span class="line">                    return getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * 调用实例化策略创建实例，默认情况下使用反射创建对象。如果 bean 的配置信息中</span><br><span class="line">             * 包含 lookup-method 和 replace-method，则通过 CGLIB 创建 bean 对象</span><br><span class="line">             *&#x2F;</span><br><span class="line">            beanInstance &#x3D; getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 创建 BeanWrapperImpl 对象</span><br><span class="line">        BeanWrapper bw &#x3D; new BeanWrapperImpl(beanInstance);</span><br><span class="line">        initBeanWrapper(bw);</span><br><span class="line">        return bw;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable ex) &#123;</span><br><span class="line">        throw new BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, &quot;Instantiation of bean failed&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) &#123;</span><br><span class="line">    &#x2F;&#x2F; 检测 bean 配置中是否配置了 lookup-method 或 replace-method，若配置了，则需使用 CGLIB 构建 bean 对象</span><br><span class="line">    if (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">        Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">        synchronized (bd.constructorArgumentLock) &#123;</span><br><span class="line">            constructorToUse &#x3D; (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">            if (constructorToUse &#x3D;&#x3D; null) &#123;</span><br><span class="line">                final Class&lt;?&gt; clazz &#x3D; bd.getBeanClass();</span><br><span class="line">                if (clazz.isInterface()) &#123;</span><br><span class="line">                    throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (System.getSecurityManager() !&#x3D; null) &#123;</span><br><span class="line">                        constructorToUse &#x3D; AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public Constructor&lt;?&gt; run() throws Exception &#123;</span><br><span class="line">                                return clazz.getDeclaredConstructor((Class[]) null);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        &#x2F;&#x2F; 获取默认构造方法</span><br><span class="line">                        constructorToUse &#x3D; clazz.getDeclaredConstructor((Class[]) null);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 设置 resolvedConstructorOrFactoryMethod</span><br><span class="line">                    bd.resolvedConstructorOrFactoryMethod &#x3D; constructorToUse;</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Throwable ex) &#123;</span><br><span class="line">                    throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 通过无参构造方法创建 bean 对象</span><br><span class="line">        return BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用 GCLIG 创建 bean 对象</span><br><span class="line">        return instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">5.3.1创建原始bean</summary>
    
    
    
    <category term="IOC" scheme="http://example.com/categories/IOC/"/>
    
    
    <category term="创建原始bean" scheme="http://example.com/tags/%E5%88%9B%E5%BB%BA%E5%8E%9F%E5%A7%8Bbean/"/>
    
  </entry>
  
  <entry>
    <title>springmvc和struts2的区别</title>
    <link href="http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/5%E3%80%81springmvc%E5%92%8Cstruts2%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/5%E3%80%81springmvc%E5%92%8Cstruts2%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-09-19T08:57:43.000Z</published>
    <updated>2020-09-19T10:03:58.265Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、框架机制"><a href="#一、框架机制" class="headerlink" title="一、框架机制"></a>一、框架机制</h3><p>1、Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。<br>2、Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。</p><h3 id="二、拦截机制"><a href="#二、拦截机制" class="headerlink" title="二、拦截机制"></a>二、拦截机制</h3><p>1、Struts2</p><p>a、Struts2框架是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype（否则会出现线程并发问题），然后通过setter，getter吧request数据注入到属性。<br>b、Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。<br>c、Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了</p><p>2、SpringMVC<br>a、SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。<br>b、在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。</p><h3 id="三、性能方面"><a href="#三、性能方面" class="headerlink" title="三、性能方面"></a>三、性能方面</h3><p>SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。而Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，所以，SpringMVC开发效率和性能高于Struts2。</p><h3 id="四、拦截机制"><a href="#四、拦截机制" class="headerlink" title="四、拦截机制"></a>四、拦截机制</h3><p>Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。</p><h3 id="五、配置方面"><a href="#五、配置方面" class="headerlink" title="五、配置方面"></a>五、配置方面</h3><p>spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高（当然Struts2也可以通过不同的目录结构和相关配置做到SpringMVC一样的效果，但是需要xml配置的地方不少）。<br>SpringMVC可以认为已经100%零配置。</p><h3 id="六、设计思想"><a href="#六、设计思想" class="headerlink" title="六、设计思想"></a>六、设计思想</h3><p>Struts2更加符合OOP的编程思想， SpringMVC就比较谨慎，在servlet上扩展。</p><h3 id="七、集成方面"><a href="#七、集成方面" class="headerlink" title="七、集成方面"></a>七、集成方面</h3><p>SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。</p>]]></content>
    
    
    <summary type="html">一、框架机制1、Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。</summary>
    
    
    
    <category term="SpringMVC" scheme="http://example.com/categories/SpringMVC/"/>
    
    
    <category term="springmvc和struts2的区别" scheme="http://example.com/tags/springmvc%E5%92%8Cstruts2%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>搭建SSM框架</title>
    <link href="http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/spring-mvc/%E6%90%AD%E5%BB%BASSM%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/spring-mvc/%E6%90%AD%E5%BB%BASSM%E6%A1%86%E6%9E%B6/</id>
    <published>2020-09-19T08:57:20.000Z</published>
    <updated>2020-09-19T10:03:58.290Z</updated>
    
    <content type="html"><![CDATA[<p>获取request的方式：</p><h2 id="方法1：Controller中加参数"><a href="#方法1：Controller中加参数" class="headerlink" title="方法1：Controller中加参数"></a>方法1：Controller中加参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController &#123;</span><br><span class="line">   @RequestMapping(&quot;&#x2F;test&quot;)</span><br><span class="line">   public void test(HttpServletRequest request) throws InterruptedException &#123;</span><br><span class="line">       &#x2F;&#x2F; 模拟程序执行了一段时间</span><br><span class="line">       Thread.sleep(1000);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法实现的原理是，在Controller方法开始处理请求时，Spring会将request对象赋值到方法参数中。除了request对象，可以通过这种方法获取的参数还有很多，具体可以参见：<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods</a><br>Controller中获取request对象后，如果要在其他方法中（如service方法、工具类方法等）使用request对象，需要在调用这些方法时将request对象作为参数传入。<br>此时request对象是方法参数，相当于局部变量，毫无疑问是线程安全的。<br>优缺点<br>这种方法的主要缺点是request对象写起来冗余太多，主要体现在两点：</p><ol><li>如果多个controller方法中都需要request对象，那么在每个方法中都需要添加一遍request参数</li><li>request对象的获取只能从controller开始，如果使用request对象的地方在函数调用层级比较深的地方，那么整个调用链上的所有方法都需要添加request参数</li></ol><p>实际上，在整个请求处理的过程中，request对象是贯穿始终的；也就是说，除了定时器等特殊情况，request对象相当于线程内部的一个全局变量。而该方法，相当于将这个全局变量，传来传去。</p><h2 id="方法2：自动注入-推荐使用"><a href="#方法2：自动注入-推荐使用" class="headerlink" title="方法2：自动注入(推荐使用)"></a>方法2：自动注入(推荐使用)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController&#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   private HttpServletRequest request; &#x2F;&#x2F;自动注入request</span><br><span class="line">   @RequestMapping(&quot;&#x2F;test&quot;)</span><br><span class="line">   public void test() throws InterruptedException&#123;</span><br><span class="line">       &#x2F;&#x2F;模拟程序执行了一段时间</span><br><span class="line">       Thread.sleep(1000);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：在Spring中，Controller的scope是singleton(单例)，也就是说在整个web系统中，只有一个TestController；但是其中注入的request却是线程安全的，原因在于：<br>使用这种方式，当Bean（本例的TestController）初始化时，Spring并没有注入一个request对象，而是注入了一个代理（proxy）；当Bean中需要使用request对象时，通过该代理获取request对象<br>该方法的主要优点：</p><ol><li>注入不局限于Controller中：在方法1中，只能在Controller中加入request参数。而对于方法2，不仅可以在Controller中注入，还可以在任何Bean中注入，包括Service、Repository及普通的Bean。</li><li>注入的对象不限于request：除了注入request对象，该方法还可以注入其他scope为request或session的对象，如response对象、session对象等；并保证线程安全。</li><li>减少代码冗余：只需要在需要request对象的Bean中注入request对象，便可以在该Bean的各个方法中使用，与方法1相比大大减少了代码冗余。<br>缺点:<br>方法也会存在代码冗余。考虑这样的场景：web系统中有很多controller，每个controller中都会使用request对象（这种场景实际上非常频繁），这时就需要写很多次注入request的代码；如果还需要注入response，代码就更繁琐了。下面说明自动注入方法的改进方法，并分析其线程安全性及优缺点。<h2 id="方法3：基类中自动注入-推荐使用-："><a href="#方法3：基类中自动注入-推荐使用-：" class="headerlink" title="方法3：基类中自动注入(推荐使用)："></a>方法3：基类中自动注入(推荐使用)：</h2></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class BaseController &#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   protected HttpServletRequest request;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：在理解了方法2的线程安全性的基础上，很容易理解方法3是线程安全的：当创建不同的派生类对象时，基类中的域（这里是注入的request）在不同的派生类对象中会占据不同的内存空间，也就是说将注入request的代码放在基类中对线程安全性没有任何影响；测试结果也证明了这一点。线程安全<br>优缺点<br>与方法2相比，避免了在不同的Controller中重复注入request；但是考虑到java只允许继承一个基类，所以如果Controller需要继承其他类时，该方法便不再好用。<br>无论是方法2和方法3，都只能在Bean中注入request；如果其他方法（如工具类中static方法）需要使用request对象，则需要在调用这些方法时将request参数传递进去。下面介绍的方法4，则可以直接在诸如工具类中的static方法中使用request对象（当然在各种Bean中也可以使用）。</p><h2 id="方法4：手动调用"><a href="#方法4：手动调用" class="headerlink" title="方法4：手动调用"></a>方法4：手动调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TestUtil &#123;</span><br><span class="line">   public void test() throws InterruptedException &#123; HttpServletRequest request &#x3D;((ServletRequestAttributes)(RequestContextHolder.currentRequestAttributes())).getRequest();</span><br><span class="line">       &#x2F;&#x2F; 模拟程序执行了一段时间</span><br><span class="line">       Thread.sleep(1000);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：线程安全<br>分析：该方法与方法2（自动注入）类似，只不过方法2中通过自动注入实现，本方法通过手动方法调用实现。因此本方法也是线程安全的<br>优缺点<br>优点：可以在非Bean中直接获取。缺点：如果使用的地方较多，代码非常繁琐；因此可以与其他方法配合使用。</p><h2 id="方法5：-ModelAttribute方法"><a href="#方法5：-ModelAttribute方法" class="headerlink" title="方法5：@ModelAttribute方法"></a>方法5：@ModelAttribute方法</h2>]]></content>
    
    
    <summary type="html">获取request的方式方法1Controller中加参数</summary>
    
    
    
    <category term="springmvc" scheme="http://example.com/categories/springmvc/"/>
    
    
    <category term="搭建SSM框架" scheme="http://example.com/tags/%E6%90%AD%E5%BB%BASSM%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-09-19T08:54:59.000Z</published>
    <updated>2020-09-19T10:03:55.183Z</updated>
    
    <content type="html"><![CDATA[<p>世界上最难的事有两件：一是让人心甘情愿地把钱掏出来给你，二是把自己的思想灌输 到别人的脑子里。设计模式就属于第二种。</p><p>它不是一种具体的技术，不像Struts、Spring、 Hibernate等框架。一个工具用久了可以熟能生巧。所有框架和工具只是一个合格的程序员应该具备的基本能力。</p><p>设计模式就是一把刀，极致的境界就是心中无设计模式，代码亦无 设计模式——设计模式随处可见，俯拾皆是，已经融入软件设计的灵魂中，这才是高手中的 高手，简称高高手</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1、单例模式 </span><br><span class="line">2、工厂方法模式 </span><br><span class="line">3、抽象工厂模式 </span><br><span class="line">4、模板方法模式 </span><br><span class="line">5、建造者模式 </span><br><span class="line">6、代理模式 </span><br><span class="line">7、原型模式 </span><br><span class="line">8、中介者模式 </span><br><span class="line">9、命令模式 </span><br><span class="line">10、责任链模式 </span><br><span class="line">11、装饰模式 </span><br><span class="line">12、策略模式 </span><br><span class="line">13、适配器模式 </span><br><span class="line">14、迭代器模式 </span><br><span class="line">15、组合模式 </span><br><span class="line">16、观察者模式 </span><br><span class="line">17、门面模式 </span><br><span class="line">18、备忘录模式 </span><br><span class="line">19、访问者模式 </span><br><span class="line">20、状态模式 </span><br><span class="line">21、解释器模式</span><br><span class="line">22、享元模式 </span><br><span class="line">23、桥梁模式</span><br></pre></td></tr></table></figure><h4 id="1、原型设计"><a href="#1、原型设计" class="headerlink" title="1、原型设计"></a>1、原型设计</h4><ol><li>请使用UML类图画出原型模式核心角色</li><li>原型设计模式的深拷贝和浅拷贝是什么，并写出深拷贝的两种方式的源码(重写<br>clone方法实现深拷贝、使用序列化来实现深拷贝)</li><li>在Spring框架中哪里使用到原型模式，并对源码进行分析<br>beans.xml<bean id="id01" class="com.atguigu.spring.bean.Monster" scope="prototype"/></li></ol><h4 id="2、解释器设计模式"><a href="#2、解释器设计模式" class="headerlink" title="2、解释器设计模式"></a>2、解释器设计模式</h4><ol><li>介绍解释器设计模式是什么?</li><li>画出解释器设计模式的UML类图,<br>分析设计模式中的各个角色是什<br>么?</li><li>请说明Spring的框架中，哪里<br>使用到了解释器设计模式，并<br>做源码级别的分析</li></ol><h4 id="3、单例设计模式"><a href="#3、单例设计模式" class="headerlink" title="3、单例设计模式"></a>3、单例设计模式</h4><p>单例设计模式一共有几种实现方式？请分别用代码实现，并说明各个实现方式的<br>优点和缺点?</p><h4 id="4、综合："><a href="#4、综合：" class="headerlink" title="4、综合："></a>4、综合：</h4><p>一线IT公司(大厂)，都会问你在实际项目中使用过什么<br>设计模式，怎样使用的，解决了什么问题。</p><p>注意：设计模式是站在项目稳定性，拓展性的至高点，去解决问题。不是为实现某一个功能而做的。所以不要觉得实现某功能用个设计模式反而很麻烦。</p><p>设计模式分为三种类型，共23种</p><ol><li>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。</li><li>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享<br>元模式、代理模式。</li><li>行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者<br>模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模<br>式、策略模式、职责链模式(责任链模式)</li></ol>]]></content>
    
    
    <summary type="html">世界上最难的事有两件一是让人心甘情愿地把钱掏出来给你，二是把自己的思想灌输到别人的脑子里。设计模式就属于第二种。它不是一种具体的技术，不像Struts、Spring、Hibernate等框架。一个工具用久了可以熟能生巧。所有框架和工具只是一个合格的程序员应该具备的基本能力。</summary>
    
    
    
    <category term="设计模式原则" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>监听器</title>
    <link href="http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/12%E3%80%81javaWeb/servlet/7%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/12%E3%80%81javaWeb/servlet/7%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8/</id>
    <published>2020-09-19T08:53:40.000Z</published>
    <updated>2020-09-19T10:03:55.133Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、在web-xml文件中配置监听器"><a href="#1、在web-xml文件中配置监听器" class="headerlink" title="1、在web.xml文件中配置监听器"></a>1、在web.xml文件中配置监听器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置应用监听器  --&gt;     </span><br><span class="line">&lt;listener&gt;     </span><br><span class="line">    &lt;listener-class&gt;com.ycq.ListenerTest&lt;&#x2F;listener-class&gt;     </span><br><span class="line">&lt;&#x2F;listener&gt;</span><br></pre></td></tr></table></figure><ul><li>现在来说说Servlet的监听器Listener，它是实现了javax.servlet.ServletContextListener 接口的 </li><li>服务器端程序，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。主要作用是：做一些初始化 </li><li>的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等。 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ListenerTest implements ServletContextListener&#123;       </span><br><span class="line">   &#x2F;&#x2F; 应用监听器的销毁方法     </span><br><span class="line">   public void contextDestroyed(ServletContextEvent servletContextEvent) &#123;     </span><br><span class="line">        ServletContext servletContext &#x3D; servletContextEvent.getServletContext();  </span><br><span class="line">        &#x2F;&#x2F; 在整个web应用销毁之前调用，将所有应用空间所设置的内容清空  </span><br><span class="line">        System.out.println(&quot;销毁工作完成...&quot;);    </span><br><span class="line">   &#125;     </span><br><span class="line">    &#x2F;&#x2F; 应用监听器的初始化方法     </span><br><span class="line">    public void contextInitialized(ServletContextEvent servletContextEvent) &#123;     </span><br><span class="line">        &#x2F;&#x2F; 通过这个事件可以获取整个应用的空间     </span><br><span class="line">        &#x2F;&#x2F; 在整个web应用下面启动的时候做一些初始化的内容添加工作     </span><br><span class="line">        ServletContext servletContext &#x3D; servletContextEvent.getServletContext();    </span><br><span class="line">        &#x2F;&#x2F; 设置一些基本的内容；比如一些参数或者是一些固定的对象     </span><br><span class="line">        System.out.println(&quot;应用监听器初始化工作完成...&quot;);     </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="过滤器和拦截器的区别"><a href="#过滤器和拦截器的区别" class="headerlink" title="过滤器和拦截器的区别"></a>过滤器和拦截器的区别</h4><p>是 JavaEE 的标准，依赖于 Servlet 容器，使用的时候是配置在 web.xml 文件中的，<br>可以配置多个，执行的顺序是根据配置顺序从上到下。常用来配置请求编码以及过滤一些非法参数，垃圾信息或者是网站登录验证<br>码。</p><p>拦截器 Interceptor 不依赖 Servlet 容器，依赖 Spring 等 Web 框架，在 SpringMVC 框架中是配置在SpringMVC 的配置文件中，在<br>SpringBoot 项目中也可以采用注解的形式实现。拦截器是 AOP 的一种应用，底层采用 Java 的反射机制来实现的。与过滤器一个很<br>大的区别是在拦截器中可以注入 Spring 的 Bean，能够获取到各种需要的 Service 来处理业务逻辑，而过滤器则不行。</p>]]></content>
    
    
    <summary type="html">1、在web.xml文件中配置监听器</summary>
    
    
    
    <category term="servlet" scheme="http://example.com/categories/servlet/"/>
    
    
    <category term="监听器" scheme="http://example.com/tags/%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>工具构建线程池</title>
    <link href="http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E5%B7%A5%E5%85%B7%E6%9E%84%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E5%B7%A5%E5%85%B7%E6%9E%84%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-09-19T08:52:00.000Z</published>
    <updated>2020-09-19T10:03:57.394Z</updated>
    
    <content type="html"><![CDATA[<p>通过Executor框架的工具类Executors，可以创建3种类型的ThreadPoolExecutor</p><ul><li>FixedThreadPool</li><li>SingleThreadExecutor</li><li>CachedThreadPool</li></ul><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>FixedThreadPool被称为可重用固定线程数的线程池。下面是FixedThreadPool的源代码实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads。</p><p>当线程池中的线程数大于corePoolSize时，keepAliveTime设置为0L，意味着多余<br>的空闲线程会被立即终止。</p><ul><li>1）如果当前运行的线程数少于corePoolSize，则创建新线程来执行任务。</li><li>2）在线程池完成预热之后（当前运行的线程数等于corePoolSize），将任务加入LinkedBlockingQueue。</li><li>3）线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行。<br>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。使用无界队列作为工作队列会对线程池带来如下影响。</li></ul><ol><li>当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。</li><li>由于1，使用无界队列时maximumPoolSize将是一个无效参数。</li><li>由于1和2，使用无界队列时keepAliveTime将是一个无效参数。</li><li>由于使用无界队列，运行中的FixedThreadPool（未执行方法shutdown()或<br>shutdownNow()）不会拒绝任务（不会调用RejectedExecutionHandler.rejectedExecution方法）。</li></ol><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>SingleThreadExecutor等价于new FixedThreadPool(1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>CachedThreadPool是一个会根据需要创建新线程的线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运<br>行任务，或者定期执行任务。ScheduledThreadPoolExecutor的功能与Timer类似，Timer对应的是单个后台线程，而<br>ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。</p><h3 id="为什么阿里开发手册建议自定义线程池；"><a href="#为什么阿里开发手册建议自定义线程池；" class="headerlink" title="为什么阿里开发手册建议自定义线程池；"></a>为什么阿里开发手册建议自定义线程池；</h3><p>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这<br>样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>说明：Executors 返回的线程池对象的弊端如下： </p><ul><li>1） FixedThreadPool 和 SingleThreadPool：<br>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 </li><li>2） CachedThreadPool：<br>允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</li></ul><h3 id="线程池监控"><a href="#线程池监控" class="headerlink" title="线程池监控"></a>线程池监控</h3><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根<br>据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池的<br>时候可以使用以下属性。</p><ul><li>·taskCount：线程池需要执行的任务数量。</li><li>·completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</li><li>·largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是</li><li>否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</li><li>·getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销</li><li>毁，所以这个大小只增不减。</li><li>·getActiveCount：获取活动的线程数。</li><li>通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的</li><li>beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执<br>行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。<br>这几个方法在线程池里是空方法。</li></ul>]]></content>
    
    
    <summary type="html">通过Executor框架的工具类Executors，可以创建3种类型的ThreadPoolExecutorFixedThreadPool</summary>
    
    
    
    <category term="线程池" scheme="http://example.com/categories/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
    <category term="工具构建线程池" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7%E6%9E%84%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>CocurrentHashMap1.8</title>
    <link href="http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/5%E3%80%81CocurrentHashMap1.8/"/>
    <id>http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/5%E3%80%81CocurrentHashMap1.8/</id>
    <published>2020-09-19T08:50:22.000Z</published>
    <updated>2020-09-19T10:03:55.626Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>　HashMap ：HashMap是线程不安全的，在并发环境下，可能会形成环状链表（扩容时可能造成），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的。</p></li><li><p>HashTable ： HashTable和HashMap的实现原理几乎一样，差别无非是</p></li></ul><ol><li>HashTable不允许key和value为null；</li><li>HashTable是线程安全的。但是HashTable线程安全的策略是在get/put所有相关操作都是synchronized的</li></ol><p>HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的”分段锁”思想。</p><h4 id="1-8中放弃了1-7的Segment臃肿的设计，取而代之的是采用Node-CAS-Synchronized来保证并发安全进行实现"><a href="#1-8中放弃了1-7的Segment臃肿的设计，取而代之的是采用Node-CAS-Synchronized来保证并发安全进行实现" class="headerlink" title="==1.8中放弃了1.7的Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现=="></a>==1.8中放弃了1.7的Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现==</h4><h3 id="ConcurrentHashMap源码分析："><a href="#ConcurrentHashMap源码分析：" class="headerlink" title="ConcurrentHashMap源码分析："></a>ConcurrentHashMap源码分析：</h3><ol><li>Node类</li></ol><p>　　Node类主要用于存储具体键值对，其子类有ForwardingNode、ReservationNode、TreeNode和TreeBin四个子类</p><ol start="2"><li>Traverser类</li></ol><p>　　Traverser类主要用于遍历操作，其子类有BaseIterator、KeySpliterator、ValueSpliterator、EntrySpliterator四个类，BaseIterator用于遍历操作。KeySplitertor、ValueSpliterator、EntrySpliterator则用于键、值、键值对的划分。</p><ol start="3"><li>CollectionView类</li></ol><p>　　CollectionView抽象类主要定义了视图操作，其子类KeySetView、ValueSetView、EntrySetView分别表示键视图、值视图、键值对视图。对视图均可以进行操作。</p><ol start="4"><li>Segment类</li></ol><p>　　Segment类在JDK1.8中与之前的版本的JDK作用存在很大的差别，JDK1.8下，其在普通的ConcurrentHashMap操作中已经没有失效，其在序列化与反序列化的时候会发挥作用。</p><ol start="5"><li>CounterCell</li></ol><p>CounterCell类主要用于对baseCount的计数。</p><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements ConcurrentMap&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 7249069246763182397L;</span><br><span class="line">    &#x2F;&#x2F; 表的最大容量</span><br><span class="line">    private static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line">    &#x2F;&#x2F; 默认表的大小</span><br><span class="line">    private static final int DEFAULT_CAPACITY &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 最大数组大小</span><br><span class="line">    static final int MAX_ARRAY_SIZE &#x3D; Integer.MAX_VALUE - 8;</span><br><span class="line">    &#x2F;&#x2F; 默认并发数</span><br><span class="line">    private static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 装载因子</span><br><span class="line">    private static final float LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">    &#x2F;&#x2F; 转化为红黑树的阈值</span><br><span class="line">    static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line">    &#x2F;&#x2F; 由红黑树转化为链表的阈值</span><br><span class="line">    static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line">    &#x2F;&#x2F; 转化为红黑树的表的最小容量</span><br><span class="line">    static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br><span class="line">    &#x2F;&#x2F; 每次进行转移的最小值</span><br><span class="line">    private static final int MIN_TRANSFER_STRIDE &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 生成sizeCtl所使用的bit位数</span><br><span class="line">    private static int RESIZE_STAMP_BITS &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 进行扩容所允许的最大线程数</span><br><span class="line">    private static final int MAX_RESIZERS &#x3D; (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;</span><br><span class="line">    &#x2F;&#x2F; 记录sizeCtl中的大小所需要进行的偏移位数</span><br><span class="line">    private static final int RESIZE_STAMP_SHIFT &#x3D; 32 - RESIZE_STAMP_BITS;    </span><br><span class="line">    &#x2F;&#x2F; 一系列的标识</span><br><span class="line">    static final int MOVED     &#x3D; -1; &#x2F;&#x2F; hash for forwarding nodes</span><br><span class="line">    static final int TREEBIN   &#x3D; -2; &#x2F;&#x2F; hash for roots of trees</span><br><span class="line">    static final int RESERVED  &#x3D; -3; &#x2F;&#x2F; hash for transient reservations</span><br><span class="line">    static final int HASH_BITS &#x3D; 0x7fffffff; &#x2F;&#x2F; usable bits of normal node hash</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    &#x2F;** Number of CPUS, to place bounds on some sizings *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 获取可用的CPU个数</span><br><span class="line">    static final int NCPU &#x3D; Runtime.getRuntime().availableProcessors();</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    &#x2F;** For serialization compatibility. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 进行序列化的属性</span><br><span class="line">    private static final ObjectStreamField[] serialPersistentFields &#x3D; &#123;</span><br><span class="line">        new ObjectStreamField(&quot;segments&quot;, Segment[].class),</span><br><span class="line">        new ObjectStreamField(&quot;segmentMask&quot;, Integer.TYPE),</span><br><span class="line">        new ObjectStreamField(&quot;segmentShift&quot;, Integer.TYPE)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 表</span><br><span class="line">    transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line">    &#x2F;&#x2F; 下一个表</span><br><span class="line">    private transient volatile Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Base counter value, used mainly when there is no contention,</span><br><span class="line">     * but also as a fallback during table initialization</span><br><span class="line">     * races. Updated via CAS.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 基本计数</span><br><span class="line">    private transient volatile long baseCount;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Table initialization and resizing control.  When negative, the</span><br><span class="line">     * table is being initialized or resized: -1 for initialization,</span><br><span class="line">     * else -(1 + the number of active resizing threads).  Otherwise,</span><br><span class="line">     * when table is null, holds the initial table size to use upon</span><br><span class="line">     * creation, or 0 for default. After initialization, holds the</span><br><span class="line">     * next element count value upon which to resize the table.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 对表初始化和扩容控制</span><br><span class="line">    private transient volatile int sizeCtl;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The next table index (plus one) to split while resizing.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 扩容下另一个表的索引</span><br><span class="line">    private transient volatile int transferIndex;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Spinlock (locked via CAS) used when resizing and&#x2F;or creating CounterCells.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 旋转锁</span><br><span class="line">    private transient volatile int cellsBusy;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Table of counter cells. When non-null, size is a power of 2.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; counterCell表</span><br><span class="line">    private transient volatile CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; views</span><br><span class="line">    &#x2F;&#x2F; 视图</span><br><span class="line">    private transient KeySetView&lt;K,V&gt; keySet;</span><br><span class="line">    private transient ValuesView&lt;K,V&gt; values;</span><br><span class="line">    private transient EntrySetView&lt;K,V&gt; entrySet;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Unsafe mechanics</span><br><span class="line">    private static final sun.misc.Unsafe U;</span><br><span class="line">    private static final long SIZECTL;</span><br><span class="line">    private static final long TRANSFERINDEX;</span><br><span class="line">    private static final long BASECOUNT;</span><br><span class="line">    private static final long CELLSBUSY;</span><br><span class="line">    private static final long CELLVALUE;</span><br><span class="line">    private static final long ABASE;</span><br><span class="line">    private static final int ASHIFT;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            U &#x3D; sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k &#x3D; ConcurrentHashMap.class;</span><br><span class="line">            SIZECTL &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;sizeCtl&quot;));</span><br><span class="line">            TRANSFERINDEX &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;transferIndex&quot;));</span><br><span class="line">            BASECOUNT &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;baseCount&quot;));</span><br><span class="line">            CELLSBUSY &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;cellsBusy&quot;));</span><br><span class="line">            Class&lt;?&gt; ck &#x3D; CounterCell.class;</span><br><span class="line">            CELLVALUE &#x3D; U.objectFieldOffset</span><br><span class="line">                (ck.getDeclaredField(&quot;value&quot;));</span><br><span class="line">            Class&lt;?&gt; ak &#x3D; Node[].class;</span><br><span class="line">            ABASE &#x3D; U.arrayBaseOffset(ak);</span><br><span class="line">            int scale &#x3D; U.arrayIndexScale(ak);</span><br><span class="line">            if ((scale &amp; (scale - 1)) !&#x3D; 0)</span><br><span class="line">                throw new Error(&quot;data type scale not a power of two&quot;);</span><br><span class="line">            ASHIFT &#x3D; 31 - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用于创建一个带有默认初始容量 (16)、加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。</span><br><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;创建一个带有指定初始容量、默认加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。</span><br><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity &lt; 0) &#x2F;&#x2F; 初始容量小于0，抛出异常</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        int cap &#x3D; ((initialCapacity &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); &#x2F;&#x2F; 找到最接近该容量的2的幂次方数</span><br><span class="line">        &#x2F;&#x2F; 初始化</span><br><span class="line">        this.sizeCtl &#x3D; cap;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;构造一个与给定映射具有相同映射关系的新映射。</span><br><span class="line">    public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this.sizeCtl &#x3D; DEFAULT_CAPACITY;</span><br><span class="line">        &#x2F;&#x2F; 将集合m的元素全部放入</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个带有指定初始容量、加载因子和默认 concurrencyLevel (1) 的新的空映射。</span><br><span class="line">     public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        this(initialCapacity, loadFactor, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个带有指定初始容量、加载因子和并发级别的新的空映射。</span><br><span class="line">    public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                             float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">        if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0) &#x2F;&#x2F; 合法性判断</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (initialCapacity &lt; concurrencyLevel)   &#x2F;&#x2F; Use at least as many bins</span><br><span class="line">            initialCapacity &#x3D; concurrencyLevel;   &#x2F;&#x2F; as estimated threads</span><br><span class="line">        long size &#x3D; (long)(1.0 + (long)initialCapacity &#x2F; loadFactor);</span><br><span class="line">        int cap &#x3D; (size &gt;&#x3D; (long)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((int)size);</span><br><span class="line">        this.sizeCtl &#x3D; cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="putVal函数"><a href="#putVal函数" class="headerlink" title="putVal函数"></a>putVal函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">        if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException(); &#x2F;&#x2F; 键或值为空，抛出异常</span><br><span class="line">        &#x2F;&#x2F; 键的hash值经过计算获得hash值</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        int binCount &#x3D; 0;</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) &#x2F;&#x2F; 表为空或者表的长度为0</span><br><span class="line">                &#x2F;&#x2F; 初始化表</span><br><span class="line">                tab &#x3D; initTable();</span><br><span class="line">            else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 表不为空并且表的长度大于0，并且该桶不为空</span><br><span class="line">                if (casTabAt(tab, i, null,</span><br><span class="line">                             new Node&lt;K,V&gt;(hash, key, value, null))) &#x2F;&#x2F; 比较并且交换值，如tab的第i项为空则用新生成的node替换</span><br><span class="line">                    break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED) &#x2F;&#x2F; 该结点的hash值为MOVED</span><br><span class="line">                &#x2F;&#x2F; 进行结点的转移（在扩容的过程中）</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                synchronized (f) &#123; &#x2F;&#x2F; 加锁同步</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123; &#x2F;&#x2F; 找到table表下标为i的节点</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 该table表中该结点的hash值大于0</span><br><span class="line">                            &#x2F;&#x2F; binCount赋值为1</span><br><span class="line">                            binCount &#x3D; 1;</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123; &#x2F;&#x2F; 结点的hash值相等并且key也相等</span><br><span class="line">                                    &#x2F;&#x2F; 保存该结点的val值</span><br><span class="line">                                    oldVal &#x3D; e.val;</span><br><span class="line">                                    if (!onlyIfAbsent) &#x2F;&#x2F; 进行判断</span><br><span class="line">                                        &#x2F;&#x2F; 将指定的value保存至结点，即进行了结点值的更新</span><br><span class="line">                                        e.val &#x3D; value;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                &#x2F;&#x2F; 保存当前结点</span><br><span class="line">                                Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 当前结点的下一个结点为空，即为最后一个结点</span><br><span class="line">                                    &#x2F;&#x2F; 新生一个结点并且赋值给next域</span><br><span class="line">                                    pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, null);</span><br><span class="line">                                    &#x2F;&#x2F; 退出循环</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 结点为红黑树结点类型</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            &#x2F;&#x2F; binCount赋值为2</span><br><span class="line">                            binCount &#x3D; 2;</span><br><span class="line">                            if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) !&#x3D; null) &#123; &#x2F;&#x2F; 将hash、key、value放入红黑树</span><br><span class="line">                                &#x2F;&#x2F; 保存结点的val</span><br><span class="line">                                oldVal &#x3D; p.val;</span><br><span class="line">                                if (!onlyIfAbsent) &#x2F;&#x2F; 判断</span><br><span class="line">                                    &#x2F;&#x2F; 赋值结点value值</span><br><span class="line">                                    p.val &#x3D; value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (binCount !&#x3D; 0) &#123; &#x2F;&#x2F; binCount不为0</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD) &#x2F;&#x2F; 如果binCount大于等于转化为红黑树的阈值</span><br><span class="line">                        &#x2F;&#x2F; 进行转化</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    if (oldVal !&#x3D; null) &#x2F;&#x2F; 旧值不为空</span><br><span class="line">                        &#x2F;&#x2F; 返回旧值</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 增加binCount的数量</span><br><span class="line">        addCount(1L, binCount);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：put函数底层调用了putVal进行数据的插入，对于putVal函数的流程大体如下。</p><p>　　① 判断存储的key、value是否为空，若为空，则抛出异常，否则，进入步骤②</p><p>　　② 计算key的hash值，随后进入无限循环，该无限循环可以确保成功插入数据，若table表为空或者长度为0，则初始化table表，否则，进入步骤③</p><p>　　③ 根据key的hash值取出table表中的结点元素，若取出的结点为空（该桶为空），则使用CAS将key、value、hash值生成的结点放入桶中。否则，进入步骤④</p><p>　　④ 若该结点的的hash值为MOVED，则对该桶中的结点进行转移，否则，进入步骤⑤</p><p>　　⑤ 对桶中的第一个结点（即table表中的结点）进行加锁，对该桶进行遍历，桶中的结点的hash值与key值与给定的hash值和key值相等，则根据标识选择是否进行更新操作（用给定的value值替换该结点的value值），若遍历完桶仍没有找到hash值与key值和指定的hash值与key值相等的结点，则直接新生一个结点并赋值为之前最后一个结点的下一个结点。进入步骤⑥</p><p>　　⑥ 若binCount值达到红黑树转化的阈值，则将桶中的结构转化为红黑树存储，最后，增加binCount的值。</p><p>　　在putVal函数中会涉及到如下几个函数：initTable、tabAt、casTabAt、helpTransfer、putTreeVal、treeifyBin、addCount函数。下面对其中涉及到的函数进行分析。</p><h3 id="initTable"><a href="#initTable" class="headerlink" title="　　initTable"></a>　　initTable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">        while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            if ((sc &#x3D; sizeCtl) &lt; 0) &#x2F;&#x2F; sizeCtl小于0，则进行线程让步等待</span><br><span class="line">                Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin</span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; &#x2F;&#x2F; 比较sizeCtl的值与sc是否相等，相等则用-1替换</span><br><span class="line">                try &#123;</span><br><span class="line">                    if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; table表为空或者大小为0</span><br><span class="line">                        &#x2F;&#x2F; sc的值是否大于0，若是，则n为sc，否则，n为默认初始容量</span><br><span class="line">                        int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                        &#x2F;&#x2F; 新生结点数组</span><br><span class="line">                        Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                        &#x2F;&#x2F; 赋值给table</span><br><span class="line">                        table &#x3D; tab &#x3D; nt;</span><br><span class="line">                        &#x2F;&#x2F; sc为n * 3&#x2F;4</span><br><span class="line">                        sc &#x3D; n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    &#x2F;&#x2F; 设置sizeCtl的值</span><br><span class="line">                    sizeCtl &#x3D; sc;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 返回table表</span><br><span class="line">        return tab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于table的大小，会根据sizeCtl的值进行设置，如果没有设置szieCtl的值，那么默认生成的table大小为16，否则，会根据sizeCtl的大小设置table大小。</p><h3 id="tabAt函数"><a href="#tabAt函数" class="headerlink" title="tabAt函数"></a>tabAt函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</span><br><span class="line">        return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数返回table数组中下标为i的结点，可以看到是通过Unsafe对象通过反射获取的，getObjectVolatile的第二项参数为下标为i的偏移地址。</p><h3 id="casTabAt函数"><a href="#casTabAt函数" class="headerlink" title="casTabAt函数"></a>casTabAt函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,</span><br><span class="line">                                      Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</span><br><span class="line">      return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此函数用于比较table数组下标为i的结点是否为c，若为c，则用v交换操作。否则，不进行交换操作。</p><h3 id="helpTransfer函数"><a href="#helpTransfer函数" class="headerlink" title="helpTransfer函数"></a>helpTransfer函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">        if (tab !&#x3D; null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">            (nextTab &#x3D; ((ForwardingNode&lt;K,V&gt;)f).nextTable) !&#x3D; null) &#123; &#x2F;&#x2F; table表不为空并且结点类型使ForwardingNode类型，并且结点的nextTable不为空</span><br><span class="line">            int rs &#x3D; resizeStamp(tab.length);</span><br><span class="line">            while (nextTab &#x3D;&#x3D; nextTable &amp;&amp; table &#x3D;&#x3D; tab &amp;&amp;</span><br><span class="line">                   (sc &#x3D; sizeCtl) &lt; 0) &#123; &#x2F;&#x2F; 条件判断</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                    sc &#x3D;&#x3D; rs + MAX_RESIZERS || transferIndex &lt;&#x3D; 0) &#x2F;&#x2F; </span><br><span class="line">                    break;</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; &#x2F;&#x2F; 比较并交换</span><br><span class="line">                    &#x2F;&#x2F; 将table的结点转移到nextTab中</span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        return table;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此函数用于在扩容时将table表中的结点转移到nextTable中。</p><h3 id="putTreeVal函数"><a href="#putTreeVal函数" class="headerlink" title="putTreeVal函数"></a>putTreeVal函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">final TreeNode&lt;K,V&gt; putTreeVal(int h, K k, V v) &#123;</span><br><span class="line">            Class&lt;?&gt; kc &#x3D; null;</span><br><span class="line">            boolean searched &#x3D; false;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; p &#x3D; root;;) &#123;</span><br><span class="line">                int dir, ph; K pk;</span><br><span class="line">                if (p &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    first &#x3D; root &#x3D; new TreeNode&lt;K,V&gt;(h, k, v, null, null);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else if ((ph &#x3D; p.hash) &gt; h)</span><br><span class="line">                    dir &#x3D; -1;</span><br><span class="line">                else if (ph &lt; h)</span><br><span class="line">                    dir &#x3D; 1;</span><br><span class="line">                else if ((pk &#x3D; p.key) &#x3D;&#x3D; k || (pk !&#x3D; null &amp;&amp; k.equals(pk)))</span><br><span class="line">                    return p;</span><br><span class="line">                else if ((kc &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">                          (kc &#x3D; comparableClassFor(k)) &#x3D;&#x3D; null) ||</span><br><span class="line">                         (dir &#x3D; compareComparables(kc, k, pk)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    if (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched &#x3D; true;</span><br><span class="line">                        if (((ch &#x3D; p.left) !&#x3D; null &amp;&amp;</span><br><span class="line">                             (q &#x3D; ch.findTreeNode(h, k, kc)) !&#x3D; null) ||</span><br><span class="line">                            ((ch &#x3D; p.right) !&#x3D; null &amp;&amp;</span><br><span class="line">                             (q &#x3D; ch.findTreeNode(h, k, kc)) !&#x3D; null))</span><br><span class="line">                            return q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir &#x3D; tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp &#x3D; p;</span><br><span class="line">                if ((p &#x3D; (dir &lt;&#x3D; 0) ? p.left : p.right) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x, f &#x3D; first;</span><br><span class="line">                    first &#x3D; x &#x3D; new TreeNode&lt;K,V&gt;(h, k, v, f, xp);</span><br><span class="line">                    if (f !&#x3D; null)</span><br><span class="line">                        f.prev &#x3D; x;</span><br><span class="line">                    if (dir &lt;&#x3D; 0)</span><br><span class="line">                        xp.left &#x3D; x;</span><br><span class="line">                    else</span><br><span class="line">                        xp.right &#x3D; x;</span><br><span class="line">                    if (!xp.red)</span><br><span class="line">                        x.red &#x3D; true;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        lockRoot();</span><br><span class="line">                        try &#123;</span><br><span class="line">                            root &#x3D; balanceInsertion(root, x);</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            unlockRoot();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            assert checkInvariants(root);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>　说明：此函数用于将指定的hash、key、value值添加到红黑树中，若已经添加了，则返回null，否则返回该结点。</p><h3 id="treeifyBin函数"><a href="#treeifyBin函数" class="headerlink" title="　treeifyBin函数"></a>　treeifyBin函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</span><br><span class="line">        Node&lt;K,V&gt; b; int n, sc;</span><br><span class="line">        if (tab !&#x3D; null) &#123; &#x2F;&#x2F; 表不为空</span><br><span class="line">            if ((n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY) &#x2F;&#x2F; table表的长度小于最小的长度</span><br><span class="line">                &#x2F;&#x2F; 进行扩容，调整某个桶中结点数量过多的问题（由于某个桶中结点数量超出了阈值，则触发treeifyBin）</span><br><span class="line">                tryPresize(n &lt;&lt; 1);</span><br><span class="line">            else if ((b &#x3D; tabAt(tab, index)) !&#x3D; null &amp;&amp; b.hash &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 桶中存在结点并且结点的hash值大于等于0</span><br><span class="line">                synchronized (b) &#123; &#x2F;&#x2F; 对桶中第一个结点进行加锁</span><br><span class="line">                    if (tabAt(tab, index) &#x3D;&#x3D; b) &#123; &#x2F;&#x2F; 第一个结点没有变化</span><br><span class="line">                        TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;</span><br><span class="line">                        for (Node&lt;K,V&gt; e &#x3D; b; e !&#x3D; null; e &#x3D; e.next) &#123; &#x2F;&#x2F; 遍历桶中所有结点</span><br><span class="line">                            &#x2F;&#x2F; 新生一个TreeNode结点</span><br><span class="line">                            TreeNode&lt;K,V&gt; p &#x3D;</span><br><span class="line">                                new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                  null, null);</span><br><span class="line">                            if ((p.prev &#x3D; tl) &#x3D;&#x3D; null) &#x2F;&#x2F; 该结点前驱为空</span><br><span class="line">                                &#x2F;&#x2F; 设置p为头结点</span><br><span class="line">                                hd &#x3D; p;</span><br><span class="line">                            else</span><br><span class="line">                                &#x2F;&#x2F; 尾节点的next域赋值为p</span><br><span class="line">                                tl.next &#x3D; p;</span><br><span class="line">                            &#x2F;&#x2F; 尾节点赋值为p</span><br><span class="line">                            tl &#x3D; p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; 设置table表中下标为index的值为hd</span><br><span class="line">                        setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此函数用于将桶中的数据结构转化为红黑树，其中，值得注意的是，当table的长度未达到阈值时，会进行一次扩容操作，该操作会使得触发treeifyBin操作的某个桶中的所有元素进行一次重新分配，这样可以避免某个桶中的结点数量太大。</p><h3 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private final void addCount(long x, int check) &#123;</span><br><span class="line">        CounterCell[] as; long b, s;</span><br><span class="line">        if ((as &#x3D; counterCells) !&#x3D; null ||</span><br><span class="line">            !U.compareAndSwapLong(this, BASECOUNT, b &#x3D; baseCount, s &#x3D; b + x)) &#123; &#x2F;&#x2F; counterCells不为空或者比较交换失败</span><br><span class="line">            CounterCell a; long v; int m;</span><br><span class="line">            &#x2F;&#x2F; 无竞争标识</span><br><span class="line">            boolean uncontended &#x3D; true;</span><br><span class="line">            if (as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0 ||</span><br><span class="line">                (a &#x3D; as[ThreadLocalRandom.getProbe() &amp; m]) &#x3D;&#x3D; null ||</span><br><span class="line">                !(uncontended &#x3D;</span><br><span class="line">                  U.compareAndSwapLong(a, CELLVALUE, v &#x3D; a.value, v + x))) &#123; &#x2F;&#x2F; </span><br><span class="line">                fullAddCount(x, uncontended);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (check &lt;&#x3D; 1)</span><br><span class="line">                return;</span><br><span class="line">            s &#x3D; sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">        if (check &gt;&#x3D; 0) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; int n, sc;</span><br><span class="line">            while (s &gt;&#x3D; (long)(sc &#x3D; sizeCtl) &amp;&amp; (tab &#x3D; table) !&#x3D; null &amp;&amp;</span><br><span class="line">                   (n &#x3D; tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                int rs &#x3D; resizeStamp(n);</span><br><span class="line">                if (sc &lt; 0) &#123;</span><br><span class="line">                    if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                        sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||</span><br><span class="line">                        transferIndex &lt;&#x3D; 0)</span><br><span class="line">                        break;</span><br><span class="line">                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                    transfer(tab, null);</span><br><span class="line">                s &#x3D; sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数主要完成binCount的值加1的操作。</p><h3 id="get函数"><a href="#get函数" class="headerlink" title="get函数"></a>get函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">        &#x2F;&#x2F; 计算key的hash值</span><br><span class="line">        int h &#x3D; spread(key.hashCode()); </span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123; &#x2F;&#x2F; 表不为空并且表的长度大于0并且key所在的桶不为空</span><br><span class="line">            if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123; &#x2F;&#x2F; 表中的元素的hash值与key的hash值相等</span><br><span class="line">                if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))) &#x2F;&#x2F; 键相等</span><br><span class="line">                    &#x2F;&#x2F; 返回值</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (eh &lt; 0) &#x2F;&#x2F; 结点hash值小于0</span><br><span class="line">                &#x2F;&#x2F; 在桶（链表&#x2F;红黑树）中查找</span><br><span class="line">                return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;</span><br><span class="line">            while ((e &#x3D; e.next) !&#x3D; null) &#123; &#x2F;&#x2F; 对于结点hash值大于0的情况</span><br><span class="line">                if (e.hash &#x3D;&#x3D; h &amp;&amp;</span><br><span class="line">                    ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>get函数根据key的hash值来计算在哪个桶中，再遍历桶，查找元素，若找到则返回该结点，否则，返回null。</p><h3 id="replaceNode函数"><a href="#replaceNode函数" class="headerlink" title="replaceNode函数"></a>replaceNode函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">final V replaceNode(Object key, V value, Object cv) &#123;</span><br><span class="line">        &#x2F;&#x2F; 计算key的hash值</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0 ||</span><br><span class="line">                (f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#x2F;&#x2F; table表为空或者表长度为0或者key所对应的桶为空</span><br><span class="line">                &#x2F;&#x2F; 跳出循环</span><br><span class="line">                break;</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED) &#x2F;&#x2F; 桶中第一个结点的hash值为MOVED</span><br><span class="line">                &#x2F;&#x2F; 转移</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                boolean validated &#x3D; false;</span><br><span class="line">                synchronized (f) &#123; &#x2F;&#x2F; 加锁同步</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123; &#x2F;&#x2F; 桶中的第一个结点没有发生变化</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 结点hash值大于0</span><br><span class="line">                            validated &#x3D; true;</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f, pred &#x3D; null;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123; &#x2F;&#x2F; 结点的hash值与指定的hash值相等，并且key也相等</span><br><span class="line">                                    V ev &#x3D; e.val;</span><br><span class="line">                                    if (cv &#x3D;&#x3D; null || cv &#x3D;&#x3D; ev ||</span><br><span class="line">                                        (ev !&#x3D; null &amp;&amp; cv.equals(ev))) &#123; &#x2F;&#x2F; cv为空或者与结点value相等或者不为空并且相等</span><br><span class="line">                                        &#x2F;&#x2F; 保存该结点的val值</span><br><span class="line">                                        oldVal &#x3D; ev;</span><br><span class="line">                                        if (value !&#x3D; null) &#x2F;&#x2F; value为null</span><br><span class="line">                                            &#x2F;&#x2F; 设置结点value值</span><br><span class="line">                                            e.val &#x3D; value;</span><br><span class="line">                                        else if (pred !&#x3D; null) &#x2F;&#x2F; 前驱不为空</span><br><span class="line">                                            &#x2F;&#x2F; 前驱的后继为e的后继，即删除了e结点</span><br><span class="line">                                            pred.next &#x3D; e.next;</span><br><span class="line">                                        else</span><br><span class="line">                                            &#x2F;&#x2F; 设置table表中下标为index的值为e.next</span><br><span class="line">                                            setTabAt(tab, i, e.next);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                pred &#x3D; e;</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null)</span><br><span class="line">                                    break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 为红黑树结点类型</span><br><span class="line">                            validated &#x3D; true;</span><br><span class="line">                            &#x2F;&#x2F; 类型转化</span><br><span class="line">                            TreeBin&lt;K,V&gt; t &#x3D; (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                            if ((r &#x3D; t.root) !&#x3D; null &amp;&amp;</span><br><span class="line">                                (p &#x3D; r.findTreeNode(hash, key, null)) !&#x3D; null) &#123; &#x2F;&#x2F; 根节点不为空并且存在与指定hash和key相等的结点</span><br><span class="line">                                &#x2F;&#x2F; 保存p结点的value</span><br><span class="line">                                V pv &#x3D; p.val;</span><br><span class="line">                                if (cv &#x3D;&#x3D; null || cv &#x3D;&#x3D; pv ||</span><br><span class="line">                                    (pv !&#x3D; null &amp;&amp; cv.equals(pv))) &#123; &#x2F;&#x2F; cv为空或者与结点value相等或者不为空并且相等</span><br><span class="line">                                    oldVal &#x3D; pv;</span><br><span class="line">                                    if (value !&#x3D; null) </span><br><span class="line">                                        p.val &#x3D; value;</span><br><span class="line">                                    else if (t.removeTreeNode(p)) &#x2F;&#x2F; 移除p结点</span><br><span class="line">                                        setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (validated) &#123;</span><br><span class="line">                    if (oldVal !&#x3D; null) &#123;</span><br><span class="line">                        if (value &#x3D;&#x3D; null)</span><br><span class="line">                            &#x2F;&#x2F; baseCount值减一</span><br><span class="line">                            addCount(-1L, -1);</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数对remove函数提供支持，remove函数底层是调用的replaceNode函数实现结点的删除。　</p><p>ConcurrentHashMap的性能相比HashMap的线程安全同步集合和Hashtable而言，性能都要高出不少。原因是经过Collections封装的线程安全的HashMap和Hashtable都是对整个结构加锁，而ConcurrentHashMap是对每一个桶单独进行锁操作，不同的桶之间的操作不会相互影响，可以并发执行。因此，其速度会快很多。</p>]]></content>
    
    
    <summary type="html">　HashMapHashMap是线程不安全的，在并发环境下，可能会形成环状链表（扩容时可能造成），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的。HashTableHashTable和HashMap的实现原理几乎一样，差别无非是</summary>
    
    
    
    <category term="JUC" scheme="http://example.com/categories/JUC/"/>
    
    
    <category term="CocurrentHashMap1.8" scheme="http://example.com/tags/CocurrentHashMap1-8/"/>
    
  </entry>
  
  <entry>
    <title>CocurrentHashMap1.7</title>
    <link href="http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/5%E3%80%81CocurrentHashMap1.7/"/>
    <id>http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/5%E3%80%81CocurrentHashMap1.7/</id>
    <published>2020-09-19T08:49:57.000Z</published>
    <updated>2020-09-19T10:03:55.621Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>　HashMap ：HashMap是线程不安全的，在并发环境下，可能会形成环状链表（扩容时可能造成），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的。</p></li><li><p>HashTable ： HashTable和HashMap的实现原理几乎一样，差别无非是</p></li></ul><ol><li>HashTable不允许key和value为null；</li><li>HashTable是线程安全的。但是HashTable线程安全的策略是在get/put所有相关操作都是synchronized的</li></ol><p>HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的”分段锁”思想。</p><h4 id="1-8中放弃了1-7的Segment臃肿的设计，取而代之的是采用Node-CAS-Synchronized来保证并发安全进行实现"><a href="#1-8中放弃了1-7的Segment臃肿的设计，取而代之的是采用Node-CAS-Synchronized来保证并发安全进行实现" class="headerlink" title="==1.8中放弃了1.7的Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现=="></a>==1.8中放弃了1.7的Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现==</h4><h3 id="ConcurrentHashMap源码分析："><a href="#ConcurrentHashMap源码分析：" class="headerlink" title="ConcurrentHashMap源码分析："></a>ConcurrentHashMap源码分析：</h3><ol><li>Node类</li></ol><p>　　Node类主要用于存储具体键值对，其子类有ForwardingNode、ReservationNode、TreeNode和TreeBin四个子类</p><ol start="2"><li>Traverser类</li></ol><p>　　Traverser类主要用于遍历操作，其子类有BaseIterator、KeySpliterator、ValueSpliterator、EntrySpliterator四个类，BaseIterator用于遍历操作。KeySplitertor、ValueSpliterator、EntrySpliterator则用于键、值、键值对的划分。</p><ol start="3"><li>CollectionView类</li></ol><p>　　CollectionView抽象类主要定义了视图操作，其子类KeySetView、ValueSetView、EntrySetView分别表示键视图、值视图、键值对视图。对视图均可以进行操作。</p><ol start="4"><li>Segment类</li></ol><p>　　Segment类在JDK1.8中与之前的版本的JDK作用存在很大的差别，JDK1.8下，其在普通的ConcurrentHashMap操作中已经没有失效，其在序列化与反序列化的时候会发挥作用。</p><ol start="5"><li>CounterCell</li></ol><p>CounterCell类主要用于对baseCount的计数。</p><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements ConcurrentMap&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 7249069246763182397L;</span><br><span class="line">    &#x2F;&#x2F; 表的最大容量</span><br><span class="line">    private static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line">    &#x2F;&#x2F; 默认表的大小</span><br><span class="line">    private static final int DEFAULT_CAPACITY &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 最大数组大小</span><br><span class="line">    static final int MAX_ARRAY_SIZE &#x3D; Integer.MAX_VALUE - 8;</span><br><span class="line">    &#x2F;&#x2F; 默认并发数</span><br><span class="line">    private static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 装载因子</span><br><span class="line">    private static final float LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">    &#x2F;&#x2F; 转化为红黑树的阈值</span><br><span class="line">    static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line">    &#x2F;&#x2F; 由红黑树转化为链表的阈值</span><br><span class="line">    static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line">    &#x2F;&#x2F; 转化为红黑树的表的最小容量</span><br><span class="line">    static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br><span class="line">    &#x2F;&#x2F; 每次进行转移的最小值</span><br><span class="line">    private static final int MIN_TRANSFER_STRIDE &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 生成sizeCtl所使用的bit位数</span><br><span class="line">    private static int RESIZE_STAMP_BITS &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 进行扩容所允许的最大线程数</span><br><span class="line">    private static final int MAX_RESIZERS &#x3D; (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;</span><br><span class="line">    &#x2F;&#x2F; 记录sizeCtl中的大小所需要进行的偏移位数</span><br><span class="line">    private static final int RESIZE_STAMP_SHIFT &#x3D; 32 - RESIZE_STAMP_BITS;    </span><br><span class="line">    &#x2F;&#x2F; 一系列的标识</span><br><span class="line">    static final int MOVED     &#x3D; -1; &#x2F;&#x2F; hash for forwarding nodes</span><br><span class="line">    static final int TREEBIN   &#x3D; -2; &#x2F;&#x2F; hash for roots of trees</span><br><span class="line">    static final int RESERVED  &#x3D; -3; &#x2F;&#x2F; hash for transient reservations</span><br><span class="line">    static final int HASH_BITS &#x3D; 0x7fffffff; &#x2F;&#x2F; usable bits of normal node hash</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    &#x2F;** Number of CPUS, to place bounds on some sizings *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 获取可用的CPU个数</span><br><span class="line">    static final int NCPU &#x3D; Runtime.getRuntime().availableProcessors();</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    &#x2F;** For serialization compatibility. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 进行序列化的属性</span><br><span class="line">    private static final ObjectStreamField[] serialPersistentFields &#x3D; &#123;</span><br><span class="line">        new ObjectStreamField(&quot;segments&quot;, Segment[].class),</span><br><span class="line">        new ObjectStreamField(&quot;segmentMask&quot;, Integer.TYPE),</span><br><span class="line">        new ObjectStreamField(&quot;segmentShift&quot;, Integer.TYPE)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 表</span><br><span class="line">    transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line">    &#x2F;&#x2F; 下一个表</span><br><span class="line">    private transient volatile Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Base counter value, used mainly when there is no contention,</span><br><span class="line">     * but also as a fallback during table initialization</span><br><span class="line">     * races. Updated via CAS.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 基本计数</span><br><span class="line">    private transient volatile long baseCount;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Table initialization and resizing control.  When negative, the</span><br><span class="line">     * table is being initialized or resized: -1 for initialization,</span><br><span class="line">     * else -(1 + the number of active resizing threads).  Otherwise,</span><br><span class="line">     * when table is null, holds the initial table size to use upon</span><br><span class="line">     * creation, or 0 for default. After initialization, holds the</span><br><span class="line">     * next element count value upon which to resize the table.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 对表初始化和扩容控制</span><br><span class="line">    private transient volatile int sizeCtl;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The next table index (plus one) to split while resizing.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 扩容下另一个表的索引</span><br><span class="line">    private transient volatile int transferIndex;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Spinlock (locked via CAS) used when resizing and&#x2F;or creating CounterCells.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 旋转锁</span><br><span class="line">    private transient volatile int cellsBusy;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Table of counter cells. When non-null, size is a power of 2.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; counterCell表</span><br><span class="line">    private transient volatile CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; views</span><br><span class="line">    &#x2F;&#x2F; 视图</span><br><span class="line">    private transient KeySetView&lt;K,V&gt; keySet;</span><br><span class="line">    private transient ValuesView&lt;K,V&gt; values;</span><br><span class="line">    private transient EntrySetView&lt;K,V&gt; entrySet;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Unsafe mechanics</span><br><span class="line">    private static final sun.misc.Unsafe U;</span><br><span class="line">    private static final long SIZECTL;</span><br><span class="line">    private static final long TRANSFERINDEX;</span><br><span class="line">    private static final long BASECOUNT;</span><br><span class="line">    private static final long CELLSBUSY;</span><br><span class="line">    private static final long CELLVALUE;</span><br><span class="line">    private static final long ABASE;</span><br><span class="line">    private static final int ASHIFT;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            U &#x3D; sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k &#x3D; ConcurrentHashMap.class;</span><br><span class="line">            SIZECTL &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;sizeCtl&quot;));</span><br><span class="line">            TRANSFERINDEX &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;transferIndex&quot;));</span><br><span class="line">            BASECOUNT &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;baseCount&quot;));</span><br><span class="line">            CELLSBUSY &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;cellsBusy&quot;));</span><br><span class="line">            Class&lt;?&gt; ck &#x3D; CounterCell.class;</span><br><span class="line">            CELLVALUE &#x3D; U.objectFieldOffset</span><br><span class="line">                (ck.getDeclaredField(&quot;value&quot;));</span><br><span class="line">            Class&lt;?&gt; ak &#x3D; Node[].class;</span><br><span class="line">            ABASE &#x3D; U.arrayBaseOffset(ak);</span><br><span class="line">            int scale &#x3D; U.arrayIndexScale(ak);</span><br><span class="line">            if ((scale &amp; (scale - 1)) !&#x3D; 0)</span><br><span class="line">                throw new Error(&quot;data type scale not a power of two&quot;);</span><br><span class="line">            ASHIFT &#x3D; 31 - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用于创建一个带有默认初始容量 (16)、加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。</span><br><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;创建一个带有指定初始容量、默认加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。</span><br><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity &lt; 0) &#x2F;&#x2F; 初始容量小于0，抛出异常</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        int cap &#x3D; ((initialCapacity &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); &#x2F;&#x2F; 找到最接近该容量的2的幂次方数</span><br><span class="line">        &#x2F;&#x2F; 初始化</span><br><span class="line">        this.sizeCtl &#x3D; cap;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;构造一个与给定映射具有相同映射关系的新映射。</span><br><span class="line">    public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this.sizeCtl &#x3D; DEFAULT_CAPACITY;</span><br><span class="line">        &#x2F;&#x2F; 将集合m的元素全部放入</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个带有指定初始容量、加载因子和默认 concurrencyLevel (1) 的新的空映射。</span><br><span class="line">     public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        this(initialCapacity, loadFactor, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个带有指定初始容量、加载因子和并发级别的新的空映射。</span><br><span class="line">    public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                             float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">        if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0) &#x2F;&#x2F; 合法性判断</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (initialCapacity &lt; concurrencyLevel)   &#x2F;&#x2F; Use at least as many bins</span><br><span class="line">            initialCapacity &#x3D; concurrencyLevel;   &#x2F;&#x2F; as estimated threads</span><br><span class="line">        long size &#x3D; (long)(1.0 + (long)initialCapacity &#x2F; loadFactor);</span><br><span class="line">        int cap &#x3D; (size &gt;&#x3D; (long)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((int)size);</span><br><span class="line">        this.sizeCtl &#x3D; cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="putVal函数"><a href="#putVal函数" class="headerlink" title="putVal函数"></a>putVal函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">        if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException(); &#x2F;&#x2F; 键或值为空，抛出异常</span><br><span class="line">        &#x2F;&#x2F; 键的hash值经过计算获得hash值</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        int binCount &#x3D; 0;</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) &#x2F;&#x2F; 表为空或者表的长度为0</span><br><span class="line">                &#x2F;&#x2F; 初始化表</span><br><span class="line">                tab &#x3D; initTable();</span><br><span class="line">            else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 表不为空并且表的长度大于0，并且该桶不为空</span><br><span class="line">                if (casTabAt(tab, i, null,</span><br><span class="line">                             new Node&lt;K,V&gt;(hash, key, value, null))) &#x2F;&#x2F; 比较并且交换值，如tab的第i项为空则用新生成的node替换</span><br><span class="line">                    break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED) &#x2F;&#x2F; 该结点的hash值为MOVED</span><br><span class="line">                &#x2F;&#x2F; 进行结点的转移（在扩容的过程中）</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                synchronized (f) &#123; &#x2F;&#x2F; 加锁同步</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123; &#x2F;&#x2F; 找到table表下标为i的节点</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 该table表中该结点的hash值大于0</span><br><span class="line">                            &#x2F;&#x2F; binCount赋值为1</span><br><span class="line">                            binCount &#x3D; 1;</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123; &#x2F;&#x2F; 结点的hash值相等并且key也相等</span><br><span class="line">                                    &#x2F;&#x2F; 保存该结点的val值</span><br><span class="line">                                    oldVal &#x3D; e.val;</span><br><span class="line">                                    if (!onlyIfAbsent) &#x2F;&#x2F; 进行判断</span><br><span class="line">                                        &#x2F;&#x2F; 将指定的value保存至结点，即进行了结点值的更新</span><br><span class="line">                                        e.val &#x3D; value;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                &#x2F;&#x2F; 保存当前结点</span><br><span class="line">                                Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 当前结点的下一个结点为空，即为最后一个结点</span><br><span class="line">                                    &#x2F;&#x2F; 新生一个结点并且赋值给next域</span><br><span class="line">                                    pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, null);</span><br><span class="line">                                    &#x2F;&#x2F; 退出循环</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 结点为红黑树结点类型</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            &#x2F;&#x2F; binCount赋值为2</span><br><span class="line">                            binCount &#x3D; 2;</span><br><span class="line">                            if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) !&#x3D; null) &#123; &#x2F;&#x2F; 将hash、key、value放入红黑树</span><br><span class="line">                                &#x2F;&#x2F; 保存结点的val</span><br><span class="line">                                oldVal &#x3D; p.val;</span><br><span class="line">                                if (!onlyIfAbsent) &#x2F;&#x2F; 判断</span><br><span class="line">                                    &#x2F;&#x2F; 赋值结点value值</span><br><span class="line">                                    p.val &#x3D; value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (binCount !&#x3D; 0) &#123; &#x2F;&#x2F; binCount不为0</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD) &#x2F;&#x2F; 如果binCount大于等于转化为红黑树的阈值</span><br><span class="line">                        &#x2F;&#x2F; 进行转化</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    if (oldVal !&#x3D; null) &#x2F;&#x2F; 旧值不为空</span><br><span class="line">                        &#x2F;&#x2F; 返回旧值</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 增加binCount的数量</span><br><span class="line">        addCount(1L, binCount);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：put函数底层调用了putVal进行数据的插入，对于putVal函数的流程大体如下。</p><p>　　① 判断存储的key、value是否为空，若为空，则抛出异常，否则，进入步骤②</p><p>　　② 计算key的hash值，随后进入无限循环，该无限循环可以确保成功插入数据，若table表为空或者长度为0，则初始化table表，否则，进入步骤③</p><p>　　③ 根据key的hash值取出table表中的结点元素，若取出的结点为空（该桶为空），则使用CAS将key、value、hash值生成的结点放入桶中。否则，进入步骤④</p><p>　　④ 若该结点的的hash值为MOVED，则对该桶中的结点进行转移，否则，进入步骤⑤</p><p>　　⑤ 对桶中的第一个结点（即table表中的结点）进行加锁，对该桶进行遍历，桶中的结点的hash值与key值与给定的hash值和key值相等，则根据标识选择是否进行更新操作（用给定的value值替换该结点的value值），若遍历完桶仍没有找到hash值与key值和指定的hash值与key值相等的结点，则直接新生一个结点并赋值为之前最后一个结点的下一个结点。进入步骤⑥</p><p>　　⑥ 若binCount值达到红黑树转化的阈值，则将桶中的结构转化为红黑树存储，最后，增加binCount的值。</p><p>　　在putVal函数中会涉及到如下几个函数：initTable、tabAt、casTabAt、helpTransfer、putTreeVal、treeifyBin、addCount函数。下面对其中涉及到的函数进行分析。</p><h3 id="initTable"><a href="#initTable" class="headerlink" title="　　initTable"></a>　　initTable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">        while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            if ((sc &#x3D; sizeCtl) &lt; 0) &#x2F;&#x2F; sizeCtl小于0，则进行线程让步等待</span><br><span class="line">                Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin</span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; &#x2F;&#x2F; 比较sizeCtl的值与sc是否相等，相等则用-1替换</span><br><span class="line">                try &#123;</span><br><span class="line">                    if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; table表为空或者大小为0</span><br><span class="line">                        &#x2F;&#x2F; sc的值是否大于0，若是，则n为sc，否则，n为默认初始容量</span><br><span class="line">                        int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                        &#x2F;&#x2F; 新生结点数组</span><br><span class="line">                        Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                        &#x2F;&#x2F; 赋值给table</span><br><span class="line">                        table &#x3D; tab &#x3D; nt;</span><br><span class="line">                        &#x2F;&#x2F; sc为n * 3&#x2F;4</span><br><span class="line">                        sc &#x3D; n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    &#x2F;&#x2F; 设置sizeCtl的值</span><br><span class="line">                    sizeCtl &#x3D; sc;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 返回table表</span><br><span class="line">        return tab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于table的大小，会根据sizeCtl的值进行设置，如果没有设置szieCtl的值，那么默认生成的table大小为16，否则，会根据sizeCtl的大小设置table大小。</p><h3 id="tabAt函数"><a href="#tabAt函数" class="headerlink" title="tabAt函数"></a>tabAt函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</span><br><span class="line">        return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数返回table数组中下标为i的结点，可以看到是通过Unsafe对象通过反射获取的，getObjectVolatile的第二项参数为下标为i的偏移地址。</p><h3 id="casTabAt函数"><a href="#casTabAt函数" class="headerlink" title="casTabAt函数"></a>casTabAt函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,</span><br><span class="line">                                      Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</span><br><span class="line">      return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此函数用于比较table数组下标为i的结点是否为c，若为c，则用v交换操作。否则，不进行交换操作。</p><h3 id="helpTransfer函数"><a href="#helpTransfer函数" class="headerlink" title="helpTransfer函数"></a>helpTransfer函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">        if (tab !&#x3D; null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">            (nextTab &#x3D; ((ForwardingNode&lt;K,V&gt;)f).nextTable) !&#x3D; null) &#123; &#x2F;&#x2F; table表不为空并且结点类型使ForwardingNode类型，并且结点的nextTable不为空</span><br><span class="line">            int rs &#x3D; resizeStamp(tab.length);</span><br><span class="line">            while (nextTab &#x3D;&#x3D; nextTable &amp;&amp; table &#x3D;&#x3D; tab &amp;&amp;</span><br><span class="line">                   (sc &#x3D; sizeCtl) &lt; 0) &#123; &#x2F;&#x2F; 条件判断</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                    sc &#x3D;&#x3D; rs + MAX_RESIZERS || transferIndex &lt;&#x3D; 0) &#x2F;&#x2F; </span><br><span class="line">                    break;</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; &#x2F;&#x2F; 比较并交换</span><br><span class="line">                    &#x2F;&#x2F; 将table的结点转移到nextTab中</span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        return table;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此函数用于在扩容时将table表中的结点转移到nextTable中。</p><h3 id="putTreeVal函数"><a href="#putTreeVal函数" class="headerlink" title="putTreeVal函数"></a>putTreeVal函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">final TreeNode&lt;K,V&gt; putTreeVal(int h, K k, V v) &#123;</span><br><span class="line">            Class&lt;?&gt; kc &#x3D; null;</span><br><span class="line">            boolean searched &#x3D; false;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; p &#x3D; root;;) &#123;</span><br><span class="line">                int dir, ph; K pk;</span><br><span class="line">                if (p &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    first &#x3D; root &#x3D; new TreeNode&lt;K,V&gt;(h, k, v, null, null);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else if ((ph &#x3D; p.hash) &gt; h)</span><br><span class="line">                    dir &#x3D; -1;</span><br><span class="line">                else if (ph &lt; h)</span><br><span class="line">                    dir &#x3D; 1;</span><br><span class="line">                else if ((pk &#x3D; p.key) &#x3D;&#x3D; k || (pk !&#x3D; null &amp;&amp; k.equals(pk)))</span><br><span class="line">                    return p;</span><br><span class="line">                else if ((kc &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">                          (kc &#x3D; comparableClassFor(k)) &#x3D;&#x3D; null) ||</span><br><span class="line">                         (dir &#x3D; compareComparables(kc, k, pk)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    if (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched &#x3D; true;</span><br><span class="line">                        if (((ch &#x3D; p.left) !&#x3D; null &amp;&amp;</span><br><span class="line">                             (q &#x3D; ch.findTreeNode(h, k, kc)) !&#x3D; null) ||</span><br><span class="line">                            ((ch &#x3D; p.right) !&#x3D; null &amp;&amp;</span><br><span class="line">                             (q &#x3D; ch.findTreeNode(h, k, kc)) !&#x3D; null))</span><br><span class="line">                            return q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir &#x3D; tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp &#x3D; p;</span><br><span class="line">                if ((p &#x3D; (dir &lt;&#x3D; 0) ? p.left : p.right) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x, f &#x3D; first;</span><br><span class="line">                    first &#x3D; x &#x3D; new TreeNode&lt;K,V&gt;(h, k, v, f, xp);</span><br><span class="line">                    if (f !&#x3D; null)</span><br><span class="line">                        f.prev &#x3D; x;</span><br><span class="line">                    if (dir &lt;&#x3D; 0)</span><br><span class="line">                        xp.left &#x3D; x;</span><br><span class="line">                    else</span><br><span class="line">                        xp.right &#x3D; x;</span><br><span class="line">                    if (!xp.red)</span><br><span class="line">                        x.red &#x3D; true;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        lockRoot();</span><br><span class="line">                        try &#123;</span><br><span class="line">                            root &#x3D; balanceInsertion(root, x);</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            unlockRoot();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            assert checkInvariants(root);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>　说明：此函数用于将指定的hash、key、value值添加到红黑树中，若已经添加了，则返回null，否则返回该结点。</p><h3 id="treeifyBin函数"><a href="#treeifyBin函数" class="headerlink" title="　treeifyBin函数"></a>　treeifyBin函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</span><br><span class="line">        Node&lt;K,V&gt; b; int n, sc;</span><br><span class="line">        if (tab !&#x3D; null) &#123; &#x2F;&#x2F; 表不为空</span><br><span class="line">            if ((n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY) &#x2F;&#x2F; table表的长度小于最小的长度</span><br><span class="line">                &#x2F;&#x2F; 进行扩容，调整某个桶中结点数量过多的问题（由于某个桶中结点数量超出了阈值，则触发treeifyBin）</span><br><span class="line">                tryPresize(n &lt;&lt; 1);</span><br><span class="line">            else if ((b &#x3D; tabAt(tab, index)) !&#x3D; null &amp;&amp; b.hash &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 桶中存在结点并且结点的hash值大于等于0</span><br><span class="line">                synchronized (b) &#123; &#x2F;&#x2F; 对桶中第一个结点进行加锁</span><br><span class="line">                    if (tabAt(tab, index) &#x3D;&#x3D; b) &#123; &#x2F;&#x2F; 第一个结点没有变化</span><br><span class="line">                        TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;</span><br><span class="line">                        for (Node&lt;K,V&gt; e &#x3D; b; e !&#x3D; null; e &#x3D; e.next) &#123; &#x2F;&#x2F; 遍历桶中所有结点</span><br><span class="line">                            &#x2F;&#x2F; 新生一个TreeNode结点</span><br><span class="line">                            TreeNode&lt;K,V&gt; p &#x3D;</span><br><span class="line">                                new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                  null, null);</span><br><span class="line">                            if ((p.prev &#x3D; tl) &#x3D;&#x3D; null) &#x2F;&#x2F; 该结点前驱为空</span><br><span class="line">                                &#x2F;&#x2F; 设置p为头结点</span><br><span class="line">                                hd &#x3D; p;</span><br><span class="line">                            else</span><br><span class="line">                                &#x2F;&#x2F; 尾节点的next域赋值为p</span><br><span class="line">                                tl.next &#x3D; p;</span><br><span class="line">                            &#x2F;&#x2F; 尾节点赋值为p</span><br><span class="line">                            tl &#x3D; p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; 设置table表中下标为index的值为hd</span><br><span class="line">                        setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此函数用于将桶中的数据结构转化为红黑树，其中，值得注意的是，当table的长度未达到阈值时，会进行一次扩容操作，该操作会使得触发treeifyBin操作的某个桶中的所有元素进行一次重新分配，这样可以避免某个桶中的结点数量太大。</p><h3 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private final void addCount(long x, int check) &#123;</span><br><span class="line">        CounterCell[] as; long b, s;</span><br><span class="line">        if ((as &#x3D; counterCells) !&#x3D; null ||</span><br><span class="line">            !U.compareAndSwapLong(this, BASECOUNT, b &#x3D; baseCount, s &#x3D; b + x)) &#123; &#x2F;&#x2F; counterCells不为空或者比较交换失败</span><br><span class="line">            CounterCell a; long v; int m;</span><br><span class="line">            &#x2F;&#x2F; 无竞争标识</span><br><span class="line">            boolean uncontended &#x3D; true;</span><br><span class="line">            if (as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0 ||</span><br><span class="line">                (a &#x3D; as[ThreadLocalRandom.getProbe() &amp; m]) &#x3D;&#x3D; null ||</span><br><span class="line">                !(uncontended &#x3D;</span><br><span class="line">                  U.compareAndSwapLong(a, CELLVALUE, v &#x3D; a.value, v + x))) &#123; &#x2F;&#x2F; </span><br><span class="line">                fullAddCount(x, uncontended);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (check &lt;&#x3D; 1)</span><br><span class="line">                return;</span><br><span class="line">            s &#x3D; sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">        if (check &gt;&#x3D; 0) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; int n, sc;</span><br><span class="line">            while (s &gt;&#x3D; (long)(sc &#x3D; sizeCtl) &amp;&amp; (tab &#x3D; table) !&#x3D; null &amp;&amp;</span><br><span class="line">                   (n &#x3D; tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                int rs &#x3D; resizeStamp(n);</span><br><span class="line">                if (sc &lt; 0) &#123;</span><br><span class="line">                    if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                        sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||</span><br><span class="line">                        transferIndex &lt;&#x3D; 0)</span><br><span class="line">                        break;</span><br><span class="line">                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                    transfer(tab, null);</span><br><span class="line">                s &#x3D; sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数主要完成binCount的值加1的操作。</p><h3 id="get函数"><a href="#get函数" class="headerlink" title="get函数"></a>get函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">        &#x2F;&#x2F; 计算key的hash值</span><br><span class="line">        int h &#x3D; spread(key.hashCode()); </span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123; &#x2F;&#x2F; 表不为空并且表的长度大于0并且key所在的桶不为空</span><br><span class="line">            if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123; &#x2F;&#x2F; 表中的元素的hash值与key的hash值相等</span><br><span class="line">                if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))) &#x2F;&#x2F; 键相等</span><br><span class="line">                    &#x2F;&#x2F; 返回值</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (eh &lt; 0) &#x2F;&#x2F; 结点hash值小于0</span><br><span class="line">                &#x2F;&#x2F; 在桶（链表&#x2F;红黑树）中查找</span><br><span class="line">                return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;</span><br><span class="line">            while ((e &#x3D; e.next) !&#x3D; null) &#123; &#x2F;&#x2F; 对于结点hash值大于0的情况</span><br><span class="line">                if (e.hash &#x3D;&#x3D; h &amp;&amp;</span><br><span class="line">                    ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>get函数根据key的hash值来计算在哪个桶中，再遍历桶，查找元素，若找到则返回该结点，否则，返回null。</p><h3 id="replaceNode函数"><a href="#replaceNode函数" class="headerlink" title="replaceNode函数"></a>replaceNode函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">final V replaceNode(Object key, V value, Object cv) &#123;</span><br><span class="line">        &#x2F;&#x2F; 计算key的hash值</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0 ||</span><br><span class="line">                (f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#x2F;&#x2F; table表为空或者表长度为0或者key所对应的桶为空</span><br><span class="line">                &#x2F;&#x2F; 跳出循环</span><br><span class="line">                break;</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED) &#x2F;&#x2F; 桶中第一个结点的hash值为MOVED</span><br><span class="line">                &#x2F;&#x2F; 转移</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                boolean validated &#x3D; false;</span><br><span class="line">                synchronized (f) &#123; &#x2F;&#x2F; 加锁同步</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123; &#x2F;&#x2F; 桶中的第一个结点没有发生变化</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 结点hash值大于0</span><br><span class="line">                            validated &#x3D; true;</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f, pred &#x3D; null;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123; &#x2F;&#x2F; 结点的hash值与指定的hash值相等，并且key也相等</span><br><span class="line">                                    V ev &#x3D; e.val;</span><br><span class="line">                                    if (cv &#x3D;&#x3D; null || cv &#x3D;&#x3D; ev ||</span><br><span class="line">                                        (ev !&#x3D; null &amp;&amp; cv.equals(ev))) &#123; &#x2F;&#x2F; cv为空或者与结点value相等或者不为空并且相等</span><br><span class="line">                                        &#x2F;&#x2F; 保存该结点的val值</span><br><span class="line">                                        oldVal &#x3D; ev;</span><br><span class="line">                                        if (value !&#x3D; null) &#x2F;&#x2F; value为null</span><br><span class="line">                                            &#x2F;&#x2F; 设置结点value值</span><br><span class="line">                                            e.val &#x3D; value;</span><br><span class="line">                                        else if (pred !&#x3D; null) &#x2F;&#x2F; 前驱不为空</span><br><span class="line">                                            &#x2F;&#x2F; 前驱的后继为e的后继，即删除了e结点</span><br><span class="line">                                            pred.next &#x3D; e.next;</span><br><span class="line">                                        else</span><br><span class="line">                                            &#x2F;&#x2F; 设置table表中下标为index的值为e.next</span><br><span class="line">                                            setTabAt(tab, i, e.next);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                pred &#x3D; e;</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null)</span><br><span class="line">                                    break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 为红黑树结点类型</span><br><span class="line">                            validated &#x3D; true;</span><br><span class="line">                            &#x2F;&#x2F; 类型转化</span><br><span class="line">                            TreeBin&lt;K,V&gt; t &#x3D; (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                            if ((r &#x3D; t.root) !&#x3D; null &amp;&amp;</span><br><span class="line">                                (p &#x3D; r.findTreeNode(hash, key, null)) !&#x3D; null) &#123; &#x2F;&#x2F; 根节点不为空并且存在与指定hash和key相等的结点</span><br><span class="line">                                &#x2F;&#x2F; 保存p结点的value</span><br><span class="line">                                V pv &#x3D; p.val;</span><br><span class="line">                                if (cv &#x3D;&#x3D; null || cv &#x3D;&#x3D; pv ||</span><br><span class="line">                                    (pv !&#x3D; null &amp;&amp; cv.equals(pv))) &#123; &#x2F;&#x2F; cv为空或者与结点value相等或者不为空并且相等</span><br><span class="line">                                    oldVal &#x3D; pv;</span><br><span class="line">                                    if (value !&#x3D; null) </span><br><span class="line">                                        p.val &#x3D; value;</span><br><span class="line">                                    else if (t.removeTreeNode(p)) &#x2F;&#x2F; 移除p结点</span><br><span class="line">                                        setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (validated) &#123;</span><br><span class="line">                    if (oldVal !&#x3D; null) &#123;</span><br><span class="line">                        if (value &#x3D;&#x3D; null)</span><br><span class="line">                            &#x2F;&#x2F; baseCount值减一</span><br><span class="line">                            addCount(-1L, -1);</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数对remove函数提供支持，remove函数底层是调用的replaceNode函数实现结点的删除。　</p><p>ConcurrentHashMap的性能相比HashMap的线程安全同步集合和Hashtable而言，性能都要高出不少。原因是经过Collections封装的线程安全的HashMap和Hashtable都是对整个结构加锁，而ConcurrentHashMap是对每一个桶单独进行锁操作，不同的桶之间的操作不会相互影响，可以并发执行。因此，其速度会快很多。</p>]]></content>
    
    
    <summary type="html">　HashMapHashMap是线程不安全的，在并发环境下，可能会形成环状链表（扩容时可能造成），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的。HashTableHashTable和HashMap的实现原理几乎一样，差别无非是</summary>
    
    
    
    <category term="JUC" scheme="http://example.com/categories/JUC/"/>
    
    
    <category term="CocurrentHashMap1.7" scheme="http://example.com/tags/CocurrentHashMap1-7/"/>
    
  </entry>
  
  <entry>
    <title>juc框架</title>
    <link href="http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/1%E3%80%81juc%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/1%E3%80%81juc%E6%A1%86%E6%9E%B6/</id>
    <published>2020-09-19T08:49:37.000Z</published>
    <updated>2020-09-19T10:03:55.604Z</updated>
    
    <content type="html"><![CDATA[<p>CopyOnWriteArrayList是一个线程安全的ArrayList,对其进行修改操作和元素迭代操作都是在底层创建一个拷贝数组（快照）上进行的，也就是写时拷贝策略。</p><p>==每个CopyOnWriteArrayList对象里面有一个array数组对象用来存放具体元素，ReentrantLock独占锁对象用来保证同时只有一个线程对array进行修改。==</p><p>JDK8</p><h3 id="类属性："><a href="#类属性：" class="headerlink" title="类属性："></a>类属性：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class CopyOnWriteArrayList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    &#x2F;&#x2F; 版本序列号</span><br><span class="line">    private static final long serialVersionUID &#x3D; 8673264195747942595L;</span><br><span class="line">    &#x2F;&#x2F; 可重入锁</span><br><span class="line">    final transient ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">    &#x2F;&#x2F; 对象数组，用于存放元素</span><br><span class="line">    private transient volatile Object[] array;</span><br><span class="line">    &#x2F;&#x2F; 反射机制</span><br><span class="line">    private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">    &#x2F;&#x2F; lock域的内存偏移量</span><br><span class="line">    private static final long lockOffset;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            UNSAFE &#x3D; sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k &#x3D; CopyOnWriteArrayList.class;</span><br><span class="line">            lockOffset &#x3D; UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;lock&quot;));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public CopyOnWriteArrayList() &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置数组</span><br><span class="line">    setArray(new Object[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    if (c.getClass() &#x3D;&#x3D; CopyOnWriteArrayList.class) &#x2F;&#x2F; 类型相同</span><br><span class="line">        &#x2F;&#x2F; 获取c集合的数组</span><br><span class="line">        elements &#x3D; ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    else &#123; &#x2F;&#x2F; 类型不相同</span><br><span class="line">        &#x2F;&#x2F; 将c集合转化为数组并赋值给elements</span><br><span class="line">        elements &#x3D; c.toArray();</span><br><span class="line">        &#x2F;&#x2F; c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">        if (elements.getClass() !&#x3D; Object[].class) &#x2F;&#x2F; elements类型不为Object[]类型</span><br><span class="line">            &#x2F;&#x2F; 将elements数组转化为Object[]类型的数组</span><br><span class="line">            elements &#x3D; Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 设置数组</span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br><span class="line">  public CopyOnWriteArrayList(E[] toCopyIn) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将toCopyIn转化为Object[]类型数组，然后设置当前数组</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① 判断传入的集合c的类型是否为CopyOnWriteArrayList类型，若是，则获取该集合类型的底层数组（Object[]），并且设置当前CopyOnWriteArrayList的数组（Object[]数组），进入步骤③；否则，进入步骤②</p><p>　　② 将传入的集合转化为数组elements，判断elements的类型是否为Object[]类型（toArray方法可能不会返回Object类型的数组），若不是，则将elements转化为Object类型的数组。进入步骤③</p><p>　　③ 设置当前CopyOnWriteArrayList的Object[]为elements。</p><h3 id="copyOf函数"><a href="#copyOf函数" class="headerlink" title="copyOf函数　　"></a>copyOf函数　　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        &#x2F;&#x2F; 确定copy的类型（将newType转化为Object类型，将Object[].class转化为Object类型，判断两者是否相等，若相等，则生成指定长度的Object数组</span><br><span class="line">        &#x2F;&#x2F; 否则,生成指定长度的新类型的数组）</span><br><span class="line">        T[] copy &#x3D; ((Object)newType &#x3D;&#x3D; (Object)Object[].class)</span><br><span class="line">            ? (T[]) new Object[newLength]</span><br><span class="line">            : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">        &#x2F;&#x2F; 将original数组从下标0开始，复制长度为(original.length和newLength的较小者),复制到copy数组中（也从下标0开始）</span><br><span class="line">        System.arraycopy(original, 0, copy, 0,</span><br><span class="line">                         Math.min(original.length, newLength));</span><br><span class="line">        return copy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        &#x2F;&#x2F; 可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 元素数组</span><br><span class="line">            Object[] elements &#x3D; getArray();</span><br><span class="line">            &#x2F;&#x2F; 数组长度</span><br><span class="line">            int len &#x3D; elements.length;</span><br><span class="line">            &#x2F;&#x2F; 复制数组</span><br><span class="line">            Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);</span><br><span class="line">            &#x2F;&#x2F; 存放元素e</span><br><span class="line">            newElements[len] &#x3D; e;</span><br><span class="line">            &#x2F;&#x2F; 设置数组</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数用于将指定元素添加到此列表的尾部，处理流程如下</p><p>　　① 获取锁（保证多线程的安全访问），获取当前的Object数组，获取Object数组的长度为length，进入步骤②。</p><p>　　② 根据Object数组复制一个长度为length+1的Object数组为newElements（此时，newElements[length]为null），进入步骤③。</p><p>　　③ 将下标为length的数组元素newElements[length]设置为元素e，再设置当前Object[]为newElements，释放锁，返回。这样就完成了元素的添加。　　</p><h3 id="addIfAbsent"><a href="#addIfAbsent" class="headerlink" title="　　addIfAbsent"></a>　　addIfAbsent</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private boolean addIfAbsent(E e, Object[] snapshot) &#123;</span><br><span class="line">        &#x2F;&#x2F; 重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取数组</span><br><span class="line">            Object[] current &#x3D; getArray();</span><br><span class="line">            &#x2F;&#x2F; 数组长度</span><br><span class="line">            int len &#x3D; current.length;</span><br><span class="line">            if (snapshot !&#x3D; current) &#123; &#x2F;&#x2F; 快照不等于当前数组，对数组进行了修改</span><br><span class="line">                &#x2F;&#x2F; Optimize for lost race to another addXXX operation</span><br><span class="line">                &#x2F;&#x2F; 取较小者</span><br><span class="line">                int common &#x3D; Math.min(snapshot.length, len);</span><br><span class="line">                for (int i &#x3D; 0; i &lt; common; i++) &#x2F;&#x2F; 遍历</span><br><span class="line">                    if (current[i] !&#x3D; snapshot[i] &amp;&amp; eq(e, current[i])) &#x2F;&#x2F; 当前数组的元素与快照的元素不相等并且e与当前元素相等</span><br><span class="line">                        &#x2F;&#x2F; 表示在snapshot与current之间修改了数组，并且设置了数组某一元素为e，已经存在</span><br><span class="line">                        &#x2F;&#x2F; 返回</span><br><span class="line">                        return false;</span><br><span class="line">                if (indexOf(e, current, common, len) &gt;&#x3D; 0) &#x2F;&#x2F; 在当前数组中找到e元素</span><br><span class="line">                        &#x2F;&#x2F; 返回</span><br><span class="line">                        return false;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 复制数组</span><br><span class="line">            Object[] newElements &#x3D; Arrays.copyOf(current, len + 1);</span><br><span class="line">            &#x2F;&#x2F; 对数组len索引的元素赋值为e</span><br><span class="line">            newElements[len] &#x3D; e;</span><br><span class="line">            &#x2F;&#x2F; 设置数组</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：该函数用于添加元素（如果数组中不存在，则添加；否则，不添加，直接返回）。可以保证多线程环境下不会重复添加元素，该函数的流程如下</p><p>　　① 获取锁，获取当前数组为current，current长度为len，判断数组之前的快照snapshot是否等于当前数组current，若不相等，则进入步骤②；否则，进入步骤④</p><p>　　② 不相等，表示在snapshot与current之间，对数组进行了修改（如进行了add、set、remove等操作），获取长度（snapshot与current之间的较小者），对current进行遍历操作，若遍历过程发现snapshot与current的元素不相等并且current的元素与指定元素相等（可能进行了set操作），进入步骤⑤，否则，进入步骤③</p><p>　　③ 在当前数组中索引指定元素，若能够找到，进入步骤⑤，否则，进入步骤④</p><p>　　④ 复制当前数组current为newElements，长度为len+1，此时newElements[len]为null。再设置newElements[len]为指定元素e，再设置数组，进入步骤⑤</p><p>　　⑤ 释放锁，返回。　　</p><h3 id="set函数"><a href="#set函数" class="headerlink" title="　　set函数　"></a>　　set函数　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">        &#x2F;&#x2F; 可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取数组</span><br><span class="line">            Object[] elements &#x3D; getArray();</span><br><span class="line">            &#x2F;&#x2F; 获取index索引的元素</span><br><span class="line">            E oldValue &#x3D; get(elements, index);</span><br><span class="line"></span><br><span class="line">            if (oldValue !&#x3D; element) &#123; &#x2F;&#x2F; 旧值等于element</span><br><span class="line">                &#x2F;&#x2F; 数组长度</span><br><span class="line">                int len &#x3D; elements.length;</span><br><span class="line">                &#x2F;&#x2F; 复制数组</span><br><span class="line">                Object[] newElements &#x3D; Arrays.copyOf(elements, len);</span><br><span class="line">                &#x2F;&#x2F; 重新赋值index索引的值</span><br><span class="line">                newElements[index] &#x3D; element;</span><br><span class="line">                &#x2F;&#x2F; 设置数组</span><br><span class="line">                setArray(newElements);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; Not quite a no-op; ensures volatile write semantics</span><br><span class="line">                &#x2F;&#x2F; 设置数组</span><br><span class="line">                setArray(elements);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 返回旧值</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">        &#x2F;&#x2F; 可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取数组</span><br><span class="line">            Object[] elements &#x3D; getArray();</span><br><span class="line">            &#x2F;&#x2F; 数组长度</span><br><span class="line">            int len &#x3D; elements.length;</span><br><span class="line">            &#x2F;&#x2F; 获取旧值</span><br><span class="line">            E oldValue &#x3D; get(elements, index);</span><br><span class="line">            &#x2F;&#x2F; 需要移动的元素个数</span><br><span class="line">            int numMoved &#x3D; len - index - 1;</span><br><span class="line">            if (numMoved &#x3D;&#x3D; 0) &#x2F;&#x2F; 移动个数为0</span><br><span class="line">                &#x2F;&#x2F; 复制后设置数组</span><br><span class="line">                setArray(Arrays.copyOf(elements, len - 1));</span><br><span class="line">            else &#123; &#x2F;&#x2F; 移动个数不为0</span><br><span class="line">                &#x2F;&#x2F; 新生数组</span><br><span class="line">                Object[] newElements &#x3D; new Object[len - 1];</span><br><span class="line">                &#x2F;&#x2F; 复制index索引之前的元素</span><br><span class="line">                System.arraycopy(elements, 0, newElements, 0, index);</span><br><span class="line">                &#x2F;&#x2F; 复制index索引之后的元素</span><br><span class="line">                System.arraycopy(elements, index + 1, newElements, index,</span><br><span class="line">                                 numMoved);</span><br><span class="line">                &#x2F;&#x2F; 设置索引</span><br><span class="line">                setArray(newElements);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 返回旧值</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数用于移除此列表指定位置上的元素。处理流程如下</p><p>　　① 获取锁，获取数组elements，数组长度为length，获取索引的值elements[index]，计算需要移动的元素个数（length - index - 1）,若个数为0，则表示移除的是数组的最后一个元素，复制elements数组，复制长度为length-1，然后设置数组，进入步骤③；否则，进入步骤②</p><p>　　② 先复制index索引前的元素，再复制index索引后的元素，然后设置数组。</p><p>　　③ 释放锁，返回旧值。    </p><h3 id="COWIterator迭代器"><a href="#COWIterator迭代器" class="headerlink" title="COWIterator迭代器"></a>COWIterator迭代器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">        &#x2F;** Snapshot of the array *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 快照</span><br><span class="line">        private final Object[] snapshot;</span><br><span class="line">        &#x2F;** Index of element to be returned by subsequent call to next.  *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 游标</span><br><span class="line">        private int cursor;</span><br><span class="line">        &#x2F;&#x2F; 构造函数</span><br><span class="line">        private COWIterator(Object[] elements, int initialCursor) &#123;</span><br><span class="line">            cursor &#x3D; initialCursor;</span><br><span class="line">            snapshot &#x3D; elements;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 是否还有下一项</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return cursor &lt; snapshot.length;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 是否有上一项</span><br><span class="line">        public boolean hasPrevious() &#123;</span><br><span class="line">            return cursor &gt; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; next项</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public E next() &#123;</span><br><span class="line">            if (! hasNext()) &#x2F;&#x2F; 不存在下一项，抛出异常</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            &#x2F;&#x2F; 返回下一项</span><br><span class="line">            return (E) snapshot[cursor++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public E previous() &#123;</span><br><span class="line">            if (! hasPrevious())</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            return (E) snapshot[--cursor];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 下一项索引</span><br><span class="line">        public int nextIndex() &#123;</span><br><span class="line">            return cursor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 上一项索引</span><br><span class="line">        public int previousIndex() &#123;</span><br><span class="line">            return cursor-1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Not supported. Always throws UnsupportedOperationException.</span><br><span class="line">         * @throws UnsupportedOperationException always; &#123;@code remove&#125;</span><br><span class="line">         *         is not supported by this iterator.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 不支持remove操作</span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            throw new UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Not supported. Always throws UnsupportedOperationException.</span><br><span class="line">         * @throws UnsupportedOperationException always; &#123;@code set&#125;</span><br><span class="line">         *         is not supported by this iterator.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 不支持set操作</span><br><span class="line">        public void set(E e) &#123;</span><br><span class="line">            throw new UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Not supported. Always throws UnsupportedOperationException.</span><br><span class="line">         * @throws UnsupportedOperationException always; &#123;@code add&#125;</span><br><span class="line">         *         is not supported by this iterator.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 不支持add操作</span><br><span class="line">        public void add(E e) &#123;</span><br><span class="line">            throw new UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;</span><br><span class="line">            Objects.requireNonNull(action);</span><br><span class="line">            Object[] elements &#x3D; snapshot;</span><br><span class="line">            final int size &#x3D; elements.length;</span><br><span class="line">            for (int i &#x3D; cursor; i &lt; size; i++) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;) E e &#x3D; (E) elements[i];</span><br><span class="line">                action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">            cursor &#x3D; size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>COWIterator表示迭代器，其也有一个Object类型的数组作为CopyOnWriteArrayList数组的快照，这种快照风格的迭代器方法在创建迭代器时使用了对当时数组状态的引用。此数组在迭代器的生存期内不会更改，因此不可能发生冲突，并且迭代器保证不会抛出 ConcurrentModificationException。创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。在迭代器上进行的元素更改操作（remove、set 和 add）不受支持。这些方法将抛出 UnsupportedOperationException。</p><p>CopyOnWriteArrayList的源码很简单，其主要用到的快照的思路，使得在迭代的过程中，只是Object数组之前的某个快照，而不是最新的Object，这样可以保证在迭代的过程中不会抛出ConcurrentModificationException异常。谢谢各位园友的观看~</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>内存占用问题，有可能造成频繁的垃圾回收。</li><li>数据一致性问题，CopyOnWriteArrayList只能保证数据的最终一致性，不能保证数据的实时一致性。</li></ul>]]></content>
    
    
    <summary type="html">CopyOnWriteArrayList是一个线程安全的ArrayList,对其进行修改操作和元素迭代操作都是在底层创建一个拷贝数组（快照）上进行的，也就是写时拷贝策略。每个CopyOnWriteArrayList对象里面有一个array数组对象用来存放具体元素，ReentrantLock独占锁对象用来保证同时只有一个线程对array进行修改。</summary>
    
    
    
    <category term="JUC" scheme="http://example.com/categories/JUC/"/>
    
    
    <category term="juc框架" scheme="http://example.com/tags/juc%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
