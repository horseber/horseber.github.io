<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>horseber</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-09-19T09:26:48.644Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>horseber</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>lasticsearch安装</title>
    <link href="http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/5%E3%80%81%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/3%E3%80%81elasticsearch/2%E3%80%81lasticsearch%E5%AE%89%E8%A3%85/"/>
    <id>http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/5%E3%80%81%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/3%E3%80%81elasticsearch/2%E3%80%81lasticsearch%E5%AE%89%E8%A3%85/</id>
    <published>2020-09-19T09:08:41.000Z</published>
    <updated>2020-09-19T09:26:48.644Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Elasticsearch使用案例"><a href="#Elasticsearch使用案例" class="headerlink" title="Elasticsearch使用案例"></a>Elasticsearch使用案例</h3><ul><li><p>（1）2013年初，GitHub抛弃了Solr，采取ElasticSearch 来做PB级的搜索。 “GitHub使用ElasticSearch搜索20TB的数据，包括13亿文件和1300亿行代码”</p></li><li><p>（2）维基百科：启动以elasticsearch为基础的核心搜索架构SoundCloud：“SoundCloud使用ElasticSearch为1.8亿用户提供即时而精准的音乐搜索服务”</p></li><li><p>（3）百度：百度目前广泛使用ElasticSearch作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部20多个业务线（包括casio、云分析、网盟、预测、文库、直达号、钱包、风控等），单集群最大100台机器，200个ES节点，每天导入30TB+数据</p></li><li><p>（4）新浪使用ES 分析处理32亿条实时日志</p></li><li><p>（5）阿里使用ES 构建挖财自己的日志采集和分析体系</p></li></ul><h3 id="Solr、ES区别"><a href="#Solr、ES区别" class="headerlink" title="Solr、ES区别"></a>Solr、ES区别</h3><p>solr和es都基于lucene</p><ol><li><p>Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能;</p></li><li><p>Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式；</p></li><li><p>Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；</p></li><li><p>Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch—–附近的人</p></li></ol><p>ELK官网：<a href="https://www.elastic.co/">https://www.elastic.co/</a></p><p>ELK官网文档：<a href="https://www.elastic.co/guide/index.html">https://www.elastic.co/guide/index.html</a></p><p>ELK中文手册：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html">https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html</a></p><p>ELK中文社区：<a href="https://elasticsearch.cn/">https://elasticsearch.cn/</a></p><p>ELK API :<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/travelansport-client.html">https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/travelansport-client.html</a></p><p>1、下载并解压：</p><p>下载地址：<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p><p>2、安装Marvel插件（Marvel是Elasticsearch的管理和监控工具）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#安装监控：Marvel插件</span><br><span class="line">.&#x2F;bin&#x2F;plugin -i elasticsearch&#x2F;marvel&#x2F;latest</span><br><span class="line"></span><br><span class="line">#禁止监控：</span><br><span class="line">echo &#39;marvel.agent.enabled: false&#39; &gt;&gt; .&#x2F;config&#x2F;elasticsearch.yml</span><br></pre></td></tr></table></figure><p>3、修改配置文件：elasticsearch.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#允许所有ip访问</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;elasticsearch</span><br><span class="line"></span><br><span class="line">#后台启动</span><br><span class="line">.&#x2F;bin&#x2F;elasticsearch -d</span><br></pre></td></tr></table></figure><p>5、测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl &#39;http:&#x2F;&#x2F;localhost:9200&#x2F;?pretty&#39;</span><br></pre></td></tr></table></figure><p>返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;status&quot;: 200,</span><br><span class="line">   &quot;name&quot;: &quot;Shrunken Bones&quot;,</span><br><span class="line">   &quot;version&quot;: &#123;</span><br><span class="line">      &quot;number&quot;: &quot;1.4.0&quot;,</span><br><span class="line">      &quot;lucene_version&quot;: &quot;4.10&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;tagline&quot;: &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看Marvel和Sense</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:9200&#x2F;_plugin&#x2F;marvel&#x2F;</span><br></pre></td></tr></table></figure><h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建:"></a>集群搭建:</h3><p>修改elasticserach.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cluster.name: aubin-cluster#必须相同</span><br><span class="line"># 集群名称（不能重复）</span><br><span class="line">node.name: els1（必须不同）</span><br><span class="line"># 节点名称，仅仅是描述名称，用于在日志中区分（自定义）</span><br><span class="line">#指定了该节点可能成为 master 节点，还可以是数据节点</span><br><span class="line">node.master: true</span><br><span class="line">node.data: true</span><br><span class="line">path.data: &#x2F;var&#x2F;lib&#x2F;elasticsearch</span><br><span class="line"># 数据的默认存放路径（自定义）</span><br><span class="line">path.logs: &#x2F;var&#x2F;log&#x2F;elasticsearch </span><br><span class="line"># 日志的默认存放路径</span><br><span class="line">network.host: 192.168.0.1 </span><br><span class="line"># 当前节点的 IP 地址</span><br><span class="line">http.port: 9200 </span><br><span class="line"># 对外提供服务的端口</span><br><span class="line">transport.tcp.port: 9300</span><br><span class="line">#9300 为集群服务的端口</span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;172.18.68.11&quot;, &quot;172.18.68.12&quot;,&quot;172.18.68.13&quot;] </span><br><span class="line"># 集群个节点 IP 地址，也可以使用域名，需要各节点能够解析</span><br><span class="line">discovery.zen.minimum_master_nodes: 2 </span><br><span class="line"># 为了避免脑裂，集群节点数最少为 半数+1</span><br></pre></td></tr></table></figure><p>备注：配置文件详解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 集群的名字，以此作为是否同一集群的判断条件</span><br><span class="line">cluster.name: elasticsearch</span><br><span class="line"># 节点名字，以此作为集群中不同节点的区分条件</span><br><span class="line">node.name: node-1</span><br><span class="line">#设置当前节点既可以为主节点也可以为数据节点</span><br><span class="line">node.master: true</span><br><span class="line">node.data: true</span><br><span class="line"># 索引分片个数，默认为 5 片</span><br><span class="line">#index.number_of_shards: 5</span><br><span class="line"># 索引副本个数，默认为 1 个副本</span><br><span class="line">#index.number_of_replicas: 1</span><br><span class="line"># 数据存储目录（多个路径用逗号分隔）</span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;192.168.14.14&quot;,&quot;192.168.14.15&quot;]</span><br><span class="line">discovery.zen.minimum_master_nodes: 2</span><br><span class="line">#数据目录</span><br><span class="line">path.data: &#x2F;home&#x2F;elk1&#x2F;elasticserach&#x2F;data</span><br><span class="line"># 日志目录</span><br><span class="line">path.logs: &#x2F;home&#x2F;elk1&#x2F;elasticserach&#x2F;logs</span><br><span class="line"># 修改一下 ES 的监听地址，这样别的机器才可以访问</span><br><span class="line">network.host: 192.168.14.13</span><br><span class="line"># 设置节点间交互的 tcp 端口（集群）,默认是 9300</span><br><span class="line">transport.tcp.port: 9300</span><br><span class="line"># 监听端口（默认的就好）</span><br><span class="line">http.port: 9200</span><br><span class="line"># 增加新的参数，这样 head 插件才可以访问 es</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Elasticsearch使用案例 （1）2013年初，GitHub抛弃了Solr，采取ElasticSearch 来做PB级的搜索。 “GitHub使用ElasticSearch搜索20TB的数据，包括13亿文件和1300亿行代码”</summary>
    
    
    
    <category term="elasticsearch" scheme="http://example.com/categories/elasticsearch/"/>
    
    
    <category term="lasticsearch安装" scheme="http://example.com/tags/lasticsearch%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>hystrix介绍</title>
    <link href="http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/4%E3%80%81hystrix%20%E6%96%AD%E8%B7%AF%E5%99%A8/1%E3%80%81hystrix%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/4%E3%80%81hystrix%20%E6%96%AD%E8%B7%AF%E5%99%A8/1%E3%80%81hystrix%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-09-19T09:01:58.000Z</published>
    <updated>2020-09-19T09:26:48.193Z</updated>
    
    <content type="html"><![CDATA[<ul><li>服务降级：系统整体资源不够，忍痛将一些服务关闭，待资源释放后，再开启回来</li><li>服务熔断金额服务降级的概念区分：</li><li>熔断：是单个服务故障或异常引起。当服务的发生异常，直接熔断整个服务，而不是一直等待此服务超时。</li><li>降级：是从整体负荷考虑，当某个服务熔断后，该服务器将不在调用。返回一个本地的fallback回调，返回一个缺省值<br>hystrix断路器：</li></ul><p><a href="https://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_clients">https://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_clients</a></p><p>就是一句话，保证单个服务调用出错，不会导致系统宕机。</p><p>在系统中 微服务A调用微服务B  微服务B调用微服务C 微服务C调用微服务D 。。。就是所谓的扇出<br>若微服务C连接超时或不可用时怎么办？</p><p>hystrix 是一个用于处理分布式系统的延迟和容错的开源库。Hystrix断路器 本身是一种开关装置（保险丝）。当一个微服务发生故障时，通过Hystrix的故障监控，会向调用方返回一个可预期，可处理的备选响应（fallBack）。而不是长时间的的等待或者抛出异常。保证服务调用方的线程不会长时间占用，从而避免故障在系统中的蔓延，乃至宕机。</p><h4 id="1、在服务提供者中添加hystrix的依赖"><a href="#1、在服务提供者中添加hystrix的依赖" class="headerlink" title="1、在服务提供者中添加hystrix的依赖"></a>1、在服务提供者中添加hystrix的依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.cloud&#x2F;spring-cloud-starter-hystrix --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4.5.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="2、再微服务中添加注解："><a href="#2、再微服务中添加注解：" class="headerlink" title="2、再微服务中添加注解："></a>2、再微服务中添加注解：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(fallbackMethod&#x3D;&quot;exceptionHandler&quot;)</span><br></pre></td></tr></table></figure><p>一旦微服务发生异常，就会调用fallbackMethod指定的方法</p><ul><li>fallbackMethod：指定服务降级处理方法；</li><li>ignoreExceptions：忽略某些异常，不发生服务降级；</li><li>commandKey：命令名称，用于区分不同的命令；</li><li>groupKey：分组名称，Hystrix会根据不同的分组来统计命令的告警及仪表盘信息；</li><li>threadPoolKey：线程池名称，用于划分线程池。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(fallbackMethod &#x3D; &quot;exceptionHandler&quot;)</span><br><span class="line">public CommonResult getUser(Long id) &#123;</span><br><span class="line">    return restTemplate.getForObject(userServiceUrl + &quot;&#x2F;user&#x2F;&#123;1&#125;&quot;, CommonResult.class, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public CommonResult exceptionHandler(@PathVariable Long id) &#123;</span><br><span class="line">    User defaultUser &#x3D; new User(-1L, &quot;defaultUser&quot;, &quot;123456&quot;);</span><br><span class="line">    return new CommonResult&lt;&gt;(defaultUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="3、在启动类中开启hystrix熔断器"><a href="#3、在启动类中开启hystrix熔断器" class="headerlink" title="3、在启动类中开启hystrix熔断器"></a>3、在启动类中开启hystrix熔断器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@EnableCircuitBreaker &#x2F;&#x2F;开启hysrtix熔断器</span><br><span class="line">@EnableDiscoveryClient &#x2F;&#x2F;服务发现</span><br></pre></td></tr></table></figure><h3 id="4、说明：上述方式的缺点："><a href="#4、说明：上述方式的缺点：" class="headerlink" title="4、说明：上述方式的缺点："></a>4、说明：上述方式的缺点：</h3><p>每个方法都添加上@HystrixCommand(fallbackMethod=”exceptionHandler”)造成代码的耦合性太高，和代码的冗余<br>可以将针对方法的注解，提取到针对类。原理就是AOP面向切面编程的异常通知。</p><p>4.1 在api moudle中针对service添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class DeptClientFallFactory implements FallbackFactory&lt;DeptService&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public DeptService create(Throwable throwable) &#123;</span><br><span class="line">        return new DeptService()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Dept getData() &#123;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;发送服务熔断时候的处理</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.2 再service中指定该DeptClientFallFactory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value &#x3D;&quot;CLOUD-SERVICE-PROVIDER-01&#x2F;cloud-service-provider-01&quot;)</span><br><span class="line">public interface DeptService &#123;</span><br><span class="line">    Dept getData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hystrix的请求缓存"><a href="#Hystrix的请求缓存" class="headerlink" title="Hystrix的请求缓存"></a>Hystrix的请求缓存</h3><p>当系统并发量越来越大时，我们需要使用缓存来优化系统，达到减轻并发请求线程数，提供响应速度的效果。</p><p>相关注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@CacheResult：开启缓存，默认所有参数作为缓存的key，cacheKeyMethod可以通过返回String类型的方法指定key；</span><br><span class="line">@CacheKey：指定缓存的key，可以指定参数或指定参数中的属性值为缓存key，cacheKeyMethod还可以通过返回String类型的方法指定；</span><br><span class="line">@CacheRemove：移除缓存，需要指定commandKey。</span><br></pre></td></tr></table></figure><p>注意：需要在每次使用缓存的请求前后对HystrixRequestContext进行初始化和关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: Request caching is not available. Maybe you need to initialize the HystrixRequestContext?</span><br></pre></td></tr></table></figure><p>使用过滤器，在每个请求前后初始化和关闭HystrixRequestContext来解决该问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by macro on 2019&#x2F;9&#x2F;4.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">@WebFilter(urlPatterns &#x3D; &quot;&#x2F;*&quot;,asyncSupported &#x3D; true)</span><br><span class="line">public class HystrixRequestContextFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        HystrixRequestContext context &#x3D; HystrixRequestContext.initializeContext();</span><br><span class="line">        try &#123;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            context.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Hystrix的常用配置"><a href="#Hystrix的常用配置" class="headerlink" title="Hystrix的常用配置"></a>Hystrix的常用配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">hystrix:</span><br><span class="line">  command: #用于控制HystrixCommand的行为</span><br><span class="line">    default:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          strategy: THREAD #控制HystrixCommand的隔离策略，THREAD-&gt;线程池隔离策略(默认)，SEMAPHORE-&gt;信号量隔离策略</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: 1000 #配置HystrixCommand执行的超时时间，执行超过该时间会进行服务降级处理</span><br><span class="line">            interruptOnTimeout: true #配置HystrixCommand执行超时的时候是否要中断</span><br><span class="line">            interruptOnCancel: true #配置HystrixCommand执行被取消的时候是否要中断</span><br><span class="line">          timeout:</span><br><span class="line">            enabled: true #配置HystrixCommand的执行是否启用超时时间</span><br><span class="line">          semaphore:</span><br><span class="line">            maxConcurrentRequests: 10 #当使用信号量隔离策略时，用来控制并发量的大小，超过该并发量的请求会被拒绝</span><br><span class="line">      fallback:</span><br><span class="line">        enabled: true #用于控制是否启用服务降级</span><br><span class="line">      circuitBreaker: #用于控制HystrixCircuitBreaker的行为</span><br><span class="line">        enabled: true #用于控制断路器是否跟踪健康状况以及熔断请求</span><br><span class="line">        requestVolumeThreshold: 20 #超过该请求数的请求会被拒绝</span><br><span class="line">        forceOpen: false #强制打开断路器，拒绝所有请求</span><br><span class="line">        forceClosed: false #强制关闭断路器，接收所有请求</span><br><span class="line">      requestCache:</span><br><span class="line">        enabled: true #用于控制是否开启请求缓存</span><br><span class="line">  collapser: #用于控制HystrixCollapser的执行行为</span><br><span class="line">    default:</span><br><span class="line">      maxRequestsInBatch: 100 #控制一次合并请求合并的最大请求数</span><br><span class="line">      timerDelayinMilliseconds: 10 #控制多少毫秒内的请求会被合并成一个</span><br><span class="line">      requestCache:</span><br><span class="line">        enabled: true #控制合并请求是否开启缓存</span><br><span class="line">  threadpool: #用于控制HystrixCommand执行所在线程池的行为</span><br><span class="line">    default:</span><br><span class="line">      coreSize: 10 #线程池的核心线程数</span><br><span class="line">      maximumSize: 10 #线程池的最大线程数，超过该线程数的请求会被拒绝</span><br><span class="line">      maxQueueSize: -1 #用于设置线程池的最大队列大小，-1采用SynchronousQueue，其他正数采用LinkedBlockingQueue</span><br><span class="line">      queueSizeRejectionThreshold: 5 #用于设置线程池队列的拒绝阀值，由于LinkedBlockingQueue不能动态改版大小，使用时需要用该参数来控制线程数</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">服务降级：系统整体资源不够，忍痛将一些服务关闭，待资源释放后，再开启回来 服务熔断金额服务降级的概念区分：</summary>
    
    
    
    <category term="hystrix 断路器" scheme="http://example.com/categories/hystrix-%E6%96%AD%E8%B7%AF%E5%99%A8/"/>
    
    
    <category term="hystrix介绍" scheme="http://example.com/tags/hystrix%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
  <entry>
    <title>bean的注册</title>
    <link href="http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/IOC/1%E3%80%81bean%E7%9A%84%E6%B3%A8%E5%86%8C/"/>
    <id>http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/IOC/1%E3%80%81bean%E7%9A%84%E6%B3%A8%E5%86%8C/</id>
    <published>2020-09-19T08:59:13.000Z</published>
    <updated>2020-09-19T09:26:48.014Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>控制反转实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</p></li><li><p>依赖注入依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用</p></li></ul><p><a href="https://blog.csdn.net/songxinjianqwe/article/details/78824851">https://blog.csdn.net/songxinjianqwe/article/details/78824851</a></p><p>==IOC本质上是Spring管理一个容器，容器是BeanFactory的实现，容器中管理了所有用户指定的bean（xml或注解），最底层就是一个Map==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;bean的注册</span><br><span class="line">        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;bean的加载</span><br><span class="line">        UserService userService &#x3D; (UserService) applicationContext.getBean(&quot;userService&quot;);</span><br><span class="line">        userService.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bean注册"><a href="#bean注册" class="headerlink" title="bean注册"></a>bean注册</h3><p>==然后解析xml、注解中定义的bean。将bean信息解析存储到BeanDefinition相应的属性中，并将所有的benaName和对应的BeanDefinition存放到BeanFactory中成员变量的Map中。==</p><ul><li>BeanDefinition的保存的是Bean的类名、scope、属性、构造函数参数列表、依赖的bean、是否是单例类、是否是懒加载等，==后面对Bean的操作就直接对BeanDefinition进行==，例如拿到这个BeanDefinition后，可以根据里面的类名、构造函数、构造函数参数，使用反射进行对象创建。</li></ul><p><img src="https://img-blog.csdn.net/20171217162549343?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc29uZ3hpbmppYW5xd2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><p>在解析bean的过程中创建了BeanFactory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected DefaultListableBeanFactory createBeanFactory() &#123;</span><br><span class="line">    return new DefaultListableBeanFactory(this.getInternalParentBeanFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>且BeanFactory有成员变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap &#x3D; new ConcurrentHashMap(256);</span><br></pre></td></tr></table></figure><p>两个重要的方法：</p><ul><li>obtainFreshBeanFactory，读取到所有的beanDefinition（bean的定义，比如xml配置文件中的中定义的，或者@Component、@Service等标记的bean），并保存到beanFactroy中；</li><li>finishBeanFactoryInitialization，加载所有非延迟加载的、单例的bean <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">   synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">      &#x2F;&#x2F; 准备 刷新的上下文环境</span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 初始化BeanFactory，并进行XML文件的读取</span><br><span class="line">      ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 对BeanFactory进行各种功能填充</span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         &#x2F;&#x2F; 子类覆盖方法做额外的处理</span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 激活各种BeanFactory处理器</span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 注册拦截Bean创建的Bean处理器，这里只是注册，真正的调用是在getBean的时候</span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 为上下文初始化Message源，即不同语言的消息体，国际化处理</span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 初始化应用消息广播器，并放入applicationEventMulticaster bean中</span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 留给子类来初始化其他bean</span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 在所有注册的bean中查找Listener bean，注册到消息广播器中</span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 初始化剩下的单例实例（除了lazy-init）</span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 完成刷新过程，通知生命周期处理器lifecycleProcessor刷新过程，同时发出ContextRefreshEvent通知别人</span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      catch (BeansException ex) &#123;</span><br><span class="line">         if (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">                  &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; Destroy already created singletons to avoid dangling resources.</span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; Reset &#39;active&#39; flag.</span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; Propagate exception to caller.</span><br><span class="line">         throw ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      finally &#123;</span><br><span class="line">         &#x2F;&#x2F; Reset common introspection caches in Spring&#39;s core, since we</span><br><span class="line">         &#x2F;&#x2F; might not ever need metadata for singleton beans anymore...</span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>可跟踪代码，最后将解析到的beanName放入beanDefinitionMap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanDefinitionMap.put(beanName, beanDefinition);</span><br></pre></td></tr></table></figure><p>解析标签的时候，涉及到解析AOP标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;处理自定义标签</span><br><span class="line">public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) &#123;</span><br><span class="line">   String namespaceUri &#x3D; getNamespaceURI(ele);</span><br><span class="line">&#x2F;&#x2F; AopNamespaceHandler</span><br><span class="line">   NamespaceHandler handler &#x3D; this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">   if (handler &#x3D;&#x3D; null) &#123;</span><br><span class="line">      error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, ele);</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">   return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里返回的parser即为AspectJAutoProxyBeanDefinitionParser。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">   AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">   extendBeanDefinition(element, parserContext);</span><br><span class="line">   return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册这个creator</span><br><span class="line">public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">      ParserContext parserContext, Element sourceElement) &#123;</span><br><span class="line">   &#x2F;&#x2F; 注册或升级AutoProxyCreator定义beanName为internalAutoProxyCreator的BeanDefinition</span><br><span class="line">   BeanDefinition beanDefinition &#x3D; AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">         parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对于proxy-target-class以及expose-proxy属性的增强</span><br><span class="line">   useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">&#x2F;&#x2F; 注册组件并通知，便于监听器做进一步处理</span><br><span class="line">&#x2F;&#x2F; 其中beanDefinition的className为AnnotationAwareAspectJAutoProxyCreator</span><br><span class="line">   registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">控制反转实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。 依赖注入依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用</summary>
    
    
    
    <category term="IOC" scheme="http://example.com/categories/IOC/"/>
    
    
    <category term="bean的注册" scheme="http://example.com/tags/bean%E7%9A%84%E6%B3%A8%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>搭建SSM框架</title>
    <link href="http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/spring-mvc/%E6%90%AD%E5%BB%BASSM%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/spring-mvc/%E6%90%AD%E5%BB%BASSM%E6%A1%86%E6%9E%B6/</id>
    <published>2020-09-19T08:57:20.000Z</published>
    <updated>2020-09-19T09:26:48.270Z</updated>
    
    <content type="html"><![CDATA[<p>获取request的方式：</p><h2 id="方法1：Controller中加参数"><a href="#方法1：Controller中加参数" class="headerlink" title="方法1：Controller中加参数"></a>方法1：Controller中加参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController &#123;</span><br><span class="line">   @RequestMapping(&quot;&#x2F;test&quot;)</span><br><span class="line">   public void test(HttpServletRequest request) throws InterruptedException &#123;</span><br><span class="line">       &#x2F;&#x2F; 模拟程序执行了一段时间</span><br><span class="line">       Thread.sleep(1000);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法实现的原理是，在Controller方法开始处理请求时，Spring会将request对象赋值到方法参数中。除了request对象，可以通过这种方法获取的参数还有很多，具体可以参见：<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods</a><br>Controller中获取request对象后，如果要在其他方法中（如service方法、工具类方法等）使用request对象，需要在调用这些方法时将request对象作为参数传入。<br>此时request对象是方法参数，相当于局部变量，毫无疑问是线程安全的。<br>优缺点<br>这种方法的主要缺点是request对象写起来冗余太多，主要体现在两点：</p><ol><li>如果多个controller方法中都需要request对象，那么在每个方法中都需要添加一遍request参数</li><li>request对象的获取只能从controller开始，如果使用request对象的地方在函数调用层级比较深的地方，那么整个调用链上的所有方法都需要添加request参数</li></ol><p>实际上，在整个请求处理的过程中，request对象是贯穿始终的；也就是说，除了定时器等特殊情况，request对象相当于线程内部的一个全局变量。而该方法，相当于将这个全局变量，传来传去。</p><h2 id="方法2：自动注入-推荐使用"><a href="#方法2：自动注入-推荐使用" class="headerlink" title="方法2：自动注入(推荐使用)"></a>方法2：自动注入(推荐使用)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController&#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   private HttpServletRequest request; &#x2F;&#x2F;自动注入request</span><br><span class="line">   @RequestMapping(&quot;&#x2F;test&quot;)</span><br><span class="line">   public void test() throws InterruptedException&#123;</span><br><span class="line">       &#x2F;&#x2F;模拟程序执行了一段时间</span><br><span class="line">       Thread.sleep(1000);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：在Spring中，Controller的scope是singleton(单例)，也就是说在整个web系统中，只有一个TestController；但是其中注入的request却是线程安全的，原因在于：<br>使用这种方式，当Bean（本例的TestController）初始化时，Spring并没有注入一个request对象，而是注入了一个代理（proxy）；当Bean中需要使用request对象时，通过该代理获取request对象<br>该方法的主要优点：</p><ol><li>注入不局限于Controller中：在方法1中，只能在Controller中加入request参数。而对于方法2，不仅可以在Controller中注入，还可以在任何Bean中注入，包括Service、Repository及普通的Bean。</li><li>注入的对象不限于request：除了注入request对象，该方法还可以注入其他scope为request或session的对象，如response对象、session对象等；并保证线程安全。</li><li>减少代码冗余：只需要在需要request对象的Bean中注入request对象，便可以在该Bean的各个方法中使用，与方法1相比大大减少了代码冗余。<br>缺点:<br>方法也会存在代码冗余。考虑这样的场景：web系统中有很多controller，每个controller中都会使用request对象（这种场景实际上非常频繁），这时就需要写很多次注入request的代码；如果还需要注入response，代码就更繁琐了。下面说明自动注入方法的改进方法，并分析其线程安全性及优缺点。<h2 id="方法3：基类中自动注入-推荐使用-："><a href="#方法3：基类中自动注入-推荐使用-：" class="headerlink" title="方法3：基类中自动注入(推荐使用)："></a>方法3：基类中自动注入(推荐使用)：</h2></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class BaseController &#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   protected HttpServletRequest request;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：在理解了方法2的线程安全性的基础上，很容易理解方法3是线程安全的：当创建不同的派生类对象时，基类中的域（这里是注入的request）在不同的派生类对象中会占据不同的内存空间，也就是说将注入request的代码放在基类中对线程安全性没有任何影响；测试结果也证明了这一点。线程安全<br>优缺点<br>与方法2相比，避免了在不同的Controller中重复注入request；但是考虑到java只允许继承一个基类，所以如果Controller需要继承其他类时，该方法便不再好用。<br>无论是方法2和方法3，都只能在Bean中注入request；如果其他方法（如工具类中static方法）需要使用request对象，则需要在调用这些方法时将request参数传递进去。下面介绍的方法4，则可以直接在诸如工具类中的static方法中使用request对象（当然在各种Bean中也可以使用）。</p><h2 id="方法4：手动调用"><a href="#方法4：手动调用" class="headerlink" title="方法4：手动调用"></a>方法4：手动调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TestUtil &#123;</span><br><span class="line">   public void test() throws InterruptedException &#123; HttpServletRequest request &#x3D;((ServletRequestAttributes)(RequestContextHolder.currentRequestAttributes())).getRequest();</span><br><span class="line">       &#x2F;&#x2F; 模拟程序执行了一段时间</span><br><span class="line">       Thread.sleep(1000);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：线程安全<br>分析：该方法与方法2（自动注入）类似，只不过方法2中通过自动注入实现，本方法通过手动方法调用实现。因此本方法也是线程安全的<br>优缺点<br>优点：可以在非Bean中直接获取。缺点：如果使用的地方较多，代码非常繁琐；因此可以与其他方法配合使用。</p><h2 id="方法5：-ModelAttribute方法"><a href="#方法5：-ModelAttribute方法" class="headerlink" title="方法5：@ModelAttribute方法"></a>方法5：@ModelAttribute方法</h2>]]></content>
    
    
    <summary type="html">获取request的方式： 方法1：Controller中加参数</summary>
    
    
    
    <category term="spring-mvc" scheme="http://example.com/categories/spring-mvc/"/>
    
    
    <category term="搭建SSM框架" scheme="http://example.com/tags/%E6%90%AD%E5%BB%BASSM%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>工具构建线程池</title>
    <link href="http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E5%B7%A5%E5%85%B7%E6%9E%84%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E5%B7%A5%E5%85%B7%E6%9E%84%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-09-19T08:52:00.000Z</published>
    <updated>2020-09-19T09:26:47.875Z</updated>
    
    <content type="html"><![CDATA[<p>通过Executor框架的工具类Executors，可以创建3种类型的ThreadPoolExecutor</p><ul><li>FixedThreadPool</li><li>SingleThreadExecutor</li><li>CachedThreadPool</li></ul><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>FixedThreadPool被称为可重用固定线程数的线程池。下面是FixedThreadPool的源代码实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads。</p><p>当线程池中的线程数大于corePoolSize时，keepAliveTime设置为0L，意味着多余<br>的空闲线程会被立即终止。</p><ul><li>1）如果当前运行的线程数少于corePoolSize，则创建新线程来执行任务。</li><li>2）在线程池完成预热之后（当前运行的线程数等于corePoolSize），将任务加入LinkedBlockingQueue。</li><li>3）线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行。<br>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。使用无界队列作为工作队列会对线程池带来如下影响。</li></ul><ol><li>当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。</li><li>由于1，使用无界队列时maximumPoolSize将是一个无效参数。</li><li>由于1和2，使用无界队列时keepAliveTime将是一个无效参数。</li><li>由于使用无界队列，运行中的FixedThreadPool（未执行方法shutdown()或<br>shutdownNow()）不会拒绝任务（不会调用RejectedExecutionHandler.rejectedExecution方法）。</li></ol><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>SingleThreadExecutor等价于new FixedThreadPool(1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>CachedThreadPool是一个会根据需要创建新线程的线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运<br>行任务，或者定期执行任务。ScheduledThreadPoolExecutor的功能与Timer类似，Timer对应的是单个后台线程，而<br>ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。</p><h3 id="为什么阿里开发手册建议自定义线程池；"><a href="#为什么阿里开发手册建议自定义线程池；" class="headerlink" title="为什么阿里开发手册建议自定义线程池；"></a>为什么阿里开发手册建议自定义线程池；</h3><p>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这<br>样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>说明：Executors 返回的线程池对象的弊端如下： </p><ul><li>1） FixedThreadPool 和 SingleThreadPool：<br>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 </li><li>2） CachedThreadPool：<br>允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</li></ul><h3 id="线程池监控"><a href="#线程池监控" class="headerlink" title="线程池监控"></a>线程池监控</h3><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根<br>据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池的<br>时候可以使用以下属性。</p><ul><li>·taskCount：线程池需要执行的任务数量。</li><li>·completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</li><li>·largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是</li><li>否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</li><li>·getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销</li><li>毁，所以这个大小只增不减。</li><li>·getActiveCount：获取活动的线程数。</li><li>通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的</li><li>beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执<br>行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。<br>这几个方法在线程池里是空方法。</li></ul>]]></content>
    
    
    <summary type="html">通过Executor框架的工具类Executors，可以创建3种类型的ThreadPoolExecutor FixedThreadPool</summary>
    
    
    
    <category term="线程池" scheme="http://example.com/categories/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
    <category term="工具构建线程池" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7%E6%9E%84%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>CocurrentHashMap1.8</title>
    <link href="http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/5%E3%80%81CocurrentHashMap1.8/"/>
    <id>http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/5%E3%80%81CocurrentHashMap1.8/</id>
    <published>2020-09-19T08:50:22.000Z</published>
    <updated>2020-09-19T09:26:47.600Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>　HashMap ：HashMap是线程不安全的，在并发环境下，可能会形成环状链表（扩容时可能造成），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的。</p></li><li><p>HashTable ： HashTable和HashMap的实现原理几乎一样，差别无非是</p></li></ul><ol><li>HashTable不允许key和value为null；</li><li>HashTable是线程安全的。但是HashTable线程安全的策略是在get/put所有相关操作都是synchronized的</li></ol><p>HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的”分段锁”思想。</p><h4 id="1-8中放弃了1-7的Segment臃肿的设计，取而代之的是采用Node-CAS-Synchronized来保证并发安全进行实现"><a href="#1-8中放弃了1-7的Segment臃肿的设计，取而代之的是采用Node-CAS-Synchronized来保证并发安全进行实现" class="headerlink" title="==1.8中放弃了1.7的Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现=="></a>==1.8中放弃了1.7的Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现==</h4><h3 id="ConcurrentHashMap源码分析："><a href="#ConcurrentHashMap源码分析：" class="headerlink" title="ConcurrentHashMap源码分析："></a>ConcurrentHashMap源码分析：</h3><ol><li>Node类</li></ol><p>　　Node类主要用于存储具体键值对，其子类有ForwardingNode、ReservationNode、TreeNode和TreeBin四个子类</p><ol start="2"><li>Traverser类</li></ol><p>　　Traverser类主要用于遍历操作，其子类有BaseIterator、KeySpliterator、ValueSpliterator、EntrySpliterator四个类，BaseIterator用于遍历操作。KeySplitertor、ValueSpliterator、EntrySpliterator则用于键、值、键值对的划分。</p><ol start="3"><li>CollectionView类</li></ol><p>　　CollectionView抽象类主要定义了视图操作，其子类KeySetView、ValueSetView、EntrySetView分别表示键视图、值视图、键值对视图。对视图均可以进行操作。</p><ol start="4"><li>Segment类</li></ol><p>　　Segment类在JDK1.8中与之前的版本的JDK作用存在很大的差别，JDK1.8下，其在普通的ConcurrentHashMap操作中已经没有失效，其在序列化与反序列化的时候会发挥作用。</p><ol start="5"><li>CounterCell</li></ol><p>CounterCell类主要用于对baseCount的计数。</p><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements ConcurrentMap&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 7249069246763182397L;</span><br><span class="line">    &#x2F;&#x2F; 表的最大容量</span><br><span class="line">    private static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line">    &#x2F;&#x2F; 默认表的大小</span><br><span class="line">    private static final int DEFAULT_CAPACITY &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 最大数组大小</span><br><span class="line">    static final int MAX_ARRAY_SIZE &#x3D; Integer.MAX_VALUE - 8;</span><br><span class="line">    &#x2F;&#x2F; 默认并发数</span><br><span class="line">    private static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 装载因子</span><br><span class="line">    private static final float LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">    &#x2F;&#x2F; 转化为红黑树的阈值</span><br><span class="line">    static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line">    &#x2F;&#x2F; 由红黑树转化为链表的阈值</span><br><span class="line">    static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line">    &#x2F;&#x2F; 转化为红黑树的表的最小容量</span><br><span class="line">    static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br><span class="line">    &#x2F;&#x2F; 每次进行转移的最小值</span><br><span class="line">    private static final int MIN_TRANSFER_STRIDE &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 生成sizeCtl所使用的bit位数</span><br><span class="line">    private static int RESIZE_STAMP_BITS &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 进行扩容所允许的最大线程数</span><br><span class="line">    private static final int MAX_RESIZERS &#x3D; (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;</span><br><span class="line">    &#x2F;&#x2F; 记录sizeCtl中的大小所需要进行的偏移位数</span><br><span class="line">    private static final int RESIZE_STAMP_SHIFT &#x3D; 32 - RESIZE_STAMP_BITS;    </span><br><span class="line">    &#x2F;&#x2F; 一系列的标识</span><br><span class="line">    static final int MOVED     &#x3D; -1; &#x2F;&#x2F; hash for forwarding nodes</span><br><span class="line">    static final int TREEBIN   &#x3D; -2; &#x2F;&#x2F; hash for roots of trees</span><br><span class="line">    static final int RESERVED  &#x3D; -3; &#x2F;&#x2F; hash for transient reservations</span><br><span class="line">    static final int HASH_BITS &#x3D; 0x7fffffff; &#x2F;&#x2F; usable bits of normal node hash</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    &#x2F;** Number of CPUS, to place bounds on some sizings *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 获取可用的CPU个数</span><br><span class="line">    static final int NCPU &#x3D; Runtime.getRuntime().availableProcessors();</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    &#x2F;** For serialization compatibility. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 进行序列化的属性</span><br><span class="line">    private static final ObjectStreamField[] serialPersistentFields &#x3D; &#123;</span><br><span class="line">        new ObjectStreamField(&quot;segments&quot;, Segment[].class),</span><br><span class="line">        new ObjectStreamField(&quot;segmentMask&quot;, Integer.TYPE),</span><br><span class="line">        new ObjectStreamField(&quot;segmentShift&quot;, Integer.TYPE)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 表</span><br><span class="line">    transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line">    &#x2F;&#x2F; 下一个表</span><br><span class="line">    private transient volatile Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Base counter value, used mainly when there is no contention,</span><br><span class="line">     * but also as a fallback during table initialization</span><br><span class="line">     * races. Updated via CAS.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 基本计数</span><br><span class="line">    private transient volatile long baseCount;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Table initialization and resizing control.  When negative, the</span><br><span class="line">     * table is being initialized or resized: -1 for initialization,</span><br><span class="line">     * else -(1 + the number of active resizing threads).  Otherwise,</span><br><span class="line">     * when table is null, holds the initial table size to use upon</span><br><span class="line">     * creation, or 0 for default. After initialization, holds the</span><br><span class="line">     * next element count value upon which to resize the table.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 对表初始化和扩容控制</span><br><span class="line">    private transient volatile int sizeCtl;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The next table index (plus one) to split while resizing.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 扩容下另一个表的索引</span><br><span class="line">    private transient volatile int transferIndex;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Spinlock (locked via CAS) used when resizing and&#x2F;or creating CounterCells.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 旋转锁</span><br><span class="line">    private transient volatile int cellsBusy;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Table of counter cells. When non-null, size is a power of 2.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; counterCell表</span><br><span class="line">    private transient volatile CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; views</span><br><span class="line">    &#x2F;&#x2F; 视图</span><br><span class="line">    private transient KeySetView&lt;K,V&gt; keySet;</span><br><span class="line">    private transient ValuesView&lt;K,V&gt; values;</span><br><span class="line">    private transient EntrySetView&lt;K,V&gt; entrySet;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Unsafe mechanics</span><br><span class="line">    private static final sun.misc.Unsafe U;</span><br><span class="line">    private static final long SIZECTL;</span><br><span class="line">    private static final long TRANSFERINDEX;</span><br><span class="line">    private static final long BASECOUNT;</span><br><span class="line">    private static final long CELLSBUSY;</span><br><span class="line">    private static final long CELLVALUE;</span><br><span class="line">    private static final long ABASE;</span><br><span class="line">    private static final int ASHIFT;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            U &#x3D; sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k &#x3D; ConcurrentHashMap.class;</span><br><span class="line">            SIZECTL &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;sizeCtl&quot;));</span><br><span class="line">            TRANSFERINDEX &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;transferIndex&quot;));</span><br><span class="line">            BASECOUNT &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;baseCount&quot;));</span><br><span class="line">            CELLSBUSY &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;cellsBusy&quot;));</span><br><span class="line">            Class&lt;?&gt; ck &#x3D; CounterCell.class;</span><br><span class="line">            CELLVALUE &#x3D; U.objectFieldOffset</span><br><span class="line">                (ck.getDeclaredField(&quot;value&quot;));</span><br><span class="line">            Class&lt;?&gt; ak &#x3D; Node[].class;</span><br><span class="line">            ABASE &#x3D; U.arrayBaseOffset(ak);</span><br><span class="line">            int scale &#x3D; U.arrayIndexScale(ak);</span><br><span class="line">            if ((scale &amp; (scale - 1)) !&#x3D; 0)</span><br><span class="line">                throw new Error(&quot;data type scale not a power of two&quot;);</span><br><span class="line">            ASHIFT &#x3D; 31 - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用于创建一个带有默认初始容量 (16)、加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。</span><br><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;创建一个带有指定初始容量、默认加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。</span><br><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity &lt; 0) &#x2F;&#x2F; 初始容量小于0，抛出异常</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        int cap &#x3D; ((initialCapacity &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); &#x2F;&#x2F; 找到最接近该容量的2的幂次方数</span><br><span class="line">        &#x2F;&#x2F; 初始化</span><br><span class="line">        this.sizeCtl &#x3D; cap;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;构造一个与给定映射具有相同映射关系的新映射。</span><br><span class="line">    public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this.sizeCtl &#x3D; DEFAULT_CAPACITY;</span><br><span class="line">        &#x2F;&#x2F; 将集合m的元素全部放入</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个带有指定初始容量、加载因子和默认 concurrencyLevel (1) 的新的空映射。</span><br><span class="line">     public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        this(initialCapacity, loadFactor, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个带有指定初始容量、加载因子和并发级别的新的空映射。</span><br><span class="line">    public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                             float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">        if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0) &#x2F;&#x2F; 合法性判断</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (initialCapacity &lt; concurrencyLevel)   &#x2F;&#x2F; Use at least as many bins</span><br><span class="line">            initialCapacity &#x3D; concurrencyLevel;   &#x2F;&#x2F; as estimated threads</span><br><span class="line">        long size &#x3D; (long)(1.0 + (long)initialCapacity &#x2F; loadFactor);</span><br><span class="line">        int cap &#x3D; (size &gt;&#x3D; (long)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((int)size);</span><br><span class="line">        this.sizeCtl &#x3D; cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="putVal函数"><a href="#putVal函数" class="headerlink" title="putVal函数"></a>putVal函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">        if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException(); &#x2F;&#x2F; 键或值为空，抛出异常</span><br><span class="line">        &#x2F;&#x2F; 键的hash值经过计算获得hash值</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        int binCount &#x3D; 0;</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) &#x2F;&#x2F; 表为空或者表的长度为0</span><br><span class="line">                &#x2F;&#x2F; 初始化表</span><br><span class="line">                tab &#x3D; initTable();</span><br><span class="line">            else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 表不为空并且表的长度大于0，并且该桶不为空</span><br><span class="line">                if (casTabAt(tab, i, null,</span><br><span class="line">                             new Node&lt;K,V&gt;(hash, key, value, null))) &#x2F;&#x2F; 比较并且交换值，如tab的第i项为空则用新生成的node替换</span><br><span class="line">                    break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED) &#x2F;&#x2F; 该结点的hash值为MOVED</span><br><span class="line">                &#x2F;&#x2F; 进行结点的转移（在扩容的过程中）</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                synchronized (f) &#123; &#x2F;&#x2F; 加锁同步</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123; &#x2F;&#x2F; 找到table表下标为i的节点</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 该table表中该结点的hash值大于0</span><br><span class="line">                            &#x2F;&#x2F; binCount赋值为1</span><br><span class="line">                            binCount &#x3D; 1;</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123; &#x2F;&#x2F; 结点的hash值相等并且key也相等</span><br><span class="line">                                    &#x2F;&#x2F; 保存该结点的val值</span><br><span class="line">                                    oldVal &#x3D; e.val;</span><br><span class="line">                                    if (!onlyIfAbsent) &#x2F;&#x2F; 进行判断</span><br><span class="line">                                        &#x2F;&#x2F; 将指定的value保存至结点，即进行了结点值的更新</span><br><span class="line">                                        e.val &#x3D; value;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                &#x2F;&#x2F; 保存当前结点</span><br><span class="line">                                Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 当前结点的下一个结点为空，即为最后一个结点</span><br><span class="line">                                    &#x2F;&#x2F; 新生一个结点并且赋值给next域</span><br><span class="line">                                    pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, null);</span><br><span class="line">                                    &#x2F;&#x2F; 退出循环</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 结点为红黑树结点类型</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            &#x2F;&#x2F; binCount赋值为2</span><br><span class="line">                            binCount &#x3D; 2;</span><br><span class="line">                            if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) !&#x3D; null) &#123; &#x2F;&#x2F; 将hash、key、value放入红黑树</span><br><span class="line">                                &#x2F;&#x2F; 保存结点的val</span><br><span class="line">                                oldVal &#x3D; p.val;</span><br><span class="line">                                if (!onlyIfAbsent) &#x2F;&#x2F; 判断</span><br><span class="line">                                    &#x2F;&#x2F; 赋值结点value值</span><br><span class="line">                                    p.val &#x3D; value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (binCount !&#x3D; 0) &#123; &#x2F;&#x2F; binCount不为0</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD) &#x2F;&#x2F; 如果binCount大于等于转化为红黑树的阈值</span><br><span class="line">                        &#x2F;&#x2F; 进行转化</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    if (oldVal !&#x3D; null) &#x2F;&#x2F; 旧值不为空</span><br><span class="line">                        &#x2F;&#x2F; 返回旧值</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 增加binCount的数量</span><br><span class="line">        addCount(1L, binCount);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：put函数底层调用了putVal进行数据的插入，对于putVal函数的流程大体如下。</p><p>　　① 判断存储的key、value是否为空，若为空，则抛出异常，否则，进入步骤②</p><p>　　② 计算key的hash值，随后进入无限循环，该无限循环可以确保成功插入数据，若table表为空或者长度为0，则初始化table表，否则，进入步骤③</p><p>　　③ 根据key的hash值取出table表中的结点元素，若取出的结点为空（该桶为空），则使用CAS将key、value、hash值生成的结点放入桶中。否则，进入步骤④</p><p>　　④ 若该结点的的hash值为MOVED，则对该桶中的结点进行转移，否则，进入步骤⑤</p><p>　　⑤ 对桶中的第一个结点（即table表中的结点）进行加锁，对该桶进行遍历，桶中的结点的hash值与key值与给定的hash值和key值相等，则根据标识选择是否进行更新操作（用给定的value值替换该结点的value值），若遍历完桶仍没有找到hash值与key值和指定的hash值与key值相等的结点，则直接新生一个结点并赋值为之前最后一个结点的下一个结点。进入步骤⑥</p><p>　　⑥ 若binCount值达到红黑树转化的阈值，则将桶中的结构转化为红黑树存储，最后，增加binCount的值。</p><p>　　在putVal函数中会涉及到如下几个函数：initTable、tabAt、casTabAt、helpTransfer、putTreeVal、treeifyBin、addCount函数。下面对其中涉及到的函数进行分析。</p><h3 id="initTable"><a href="#initTable" class="headerlink" title="　　initTable"></a>　　initTable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">        while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            if ((sc &#x3D; sizeCtl) &lt; 0) &#x2F;&#x2F; sizeCtl小于0，则进行线程让步等待</span><br><span class="line">                Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin</span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; &#x2F;&#x2F; 比较sizeCtl的值与sc是否相等，相等则用-1替换</span><br><span class="line">                try &#123;</span><br><span class="line">                    if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; table表为空或者大小为0</span><br><span class="line">                        &#x2F;&#x2F; sc的值是否大于0，若是，则n为sc，否则，n为默认初始容量</span><br><span class="line">                        int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                        &#x2F;&#x2F; 新生结点数组</span><br><span class="line">                        Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                        &#x2F;&#x2F; 赋值给table</span><br><span class="line">                        table &#x3D; tab &#x3D; nt;</span><br><span class="line">                        &#x2F;&#x2F; sc为n * 3&#x2F;4</span><br><span class="line">                        sc &#x3D; n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    &#x2F;&#x2F; 设置sizeCtl的值</span><br><span class="line">                    sizeCtl &#x3D; sc;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 返回table表</span><br><span class="line">        return tab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于table的大小，会根据sizeCtl的值进行设置，如果没有设置szieCtl的值，那么默认生成的table大小为16，否则，会根据sizeCtl的大小设置table大小。</p><h3 id="tabAt函数"><a href="#tabAt函数" class="headerlink" title="tabAt函数"></a>tabAt函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</span><br><span class="line">        return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数返回table数组中下标为i的结点，可以看到是通过Unsafe对象通过反射获取的，getObjectVolatile的第二项参数为下标为i的偏移地址。</p><h3 id="casTabAt函数"><a href="#casTabAt函数" class="headerlink" title="casTabAt函数"></a>casTabAt函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,</span><br><span class="line">                                      Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</span><br><span class="line">      return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此函数用于比较table数组下标为i的结点是否为c，若为c，则用v交换操作。否则，不进行交换操作。</p><h3 id="helpTransfer函数"><a href="#helpTransfer函数" class="headerlink" title="helpTransfer函数"></a>helpTransfer函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">        if (tab !&#x3D; null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">            (nextTab &#x3D; ((ForwardingNode&lt;K,V&gt;)f).nextTable) !&#x3D; null) &#123; &#x2F;&#x2F; table表不为空并且结点类型使ForwardingNode类型，并且结点的nextTable不为空</span><br><span class="line">            int rs &#x3D; resizeStamp(tab.length);</span><br><span class="line">            while (nextTab &#x3D;&#x3D; nextTable &amp;&amp; table &#x3D;&#x3D; tab &amp;&amp;</span><br><span class="line">                   (sc &#x3D; sizeCtl) &lt; 0) &#123; &#x2F;&#x2F; 条件判断</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                    sc &#x3D;&#x3D; rs + MAX_RESIZERS || transferIndex &lt;&#x3D; 0) &#x2F;&#x2F; </span><br><span class="line">                    break;</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; &#x2F;&#x2F; 比较并交换</span><br><span class="line">                    &#x2F;&#x2F; 将table的结点转移到nextTab中</span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        return table;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此函数用于在扩容时将table表中的结点转移到nextTable中。</p><h3 id="putTreeVal函数"><a href="#putTreeVal函数" class="headerlink" title="putTreeVal函数"></a>putTreeVal函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">final TreeNode&lt;K,V&gt; putTreeVal(int h, K k, V v) &#123;</span><br><span class="line">            Class&lt;?&gt; kc &#x3D; null;</span><br><span class="line">            boolean searched &#x3D; false;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; p &#x3D; root;;) &#123;</span><br><span class="line">                int dir, ph; K pk;</span><br><span class="line">                if (p &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    first &#x3D; root &#x3D; new TreeNode&lt;K,V&gt;(h, k, v, null, null);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else if ((ph &#x3D; p.hash) &gt; h)</span><br><span class="line">                    dir &#x3D; -1;</span><br><span class="line">                else if (ph &lt; h)</span><br><span class="line">                    dir &#x3D; 1;</span><br><span class="line">                else if ((pk &#x3D; p.key) &#x3D;&#x3D; k || (pk !&#x3D; null &amp;&amp; k.equals(pk)))</span><br><span class="line">                    return p;</span><br><span class="line">                else if ((kc &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">                          (kc &#x3D; comparableClassFor(k)) &#x3D;&#x3D; null) ||</span><br><span class="line">                         (dir &#x3D; compareComparables(kc, k, pk)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    if (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched &#x3D; true;</span><br><span class="line">                        if (((ch &#x3D; p.left) !&#x3D; null &amp;&amp;</span><br><span class="line">                             (q &#x3D; ch.findTreeNode(h, k, kc)) !&#x3D; null) ||</span><br><span class="line">                            ((ch &#x3D; p.right) !&#x3D; null &amp;&amp;</span><br><span class="line">                             (q &#x3D; ch.findTreeNode(h, k, kc)) !&#x3D; null))</span><br><span class="line">                            return q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir &#x3D; tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp &#x3D; p;</span><br><span class="line">                if ((p &#x3D; (dir &lt;&#x3D; 0) ? p.left : p.right) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x, f &#x3D; first;</span><br><span class="line">                    first &#x3D; x &#x3D; new TreeNode&lt;K,V&gt;(h, k, v, f, xp);</span><br><span class="line">                    if (f !&#x3D; null)</span><br><span class="line">                        f.prev &#x3D; x;</span><br><span class="line">                    if (dir &lt;&#x3D; 0)</span><br><span class="line">                        xp.left &#x3D; x;</span><br><span class="line">                    else</span><br><span class="line">                        xp.right &#x3D; x;</span><br><span class="line">                    if (!xp.red)</span><br><span class="line">                        x.red &#x3D; true;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        lockRoot();</span><br><span class="line">                        try &#123;</span><br><span class="line">                            root &#x3D; balanceInsertion(root, x);</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            unlockRoot();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            assert checkInvariants(root);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>　说明：此函数用于将指定的hash、key、value值添加到红黑树中，若已经添加了，则返回null，否则返回该结点。</p><h3 id="treeifyBin函数"><a href="#treeifyBin函数" class="headerlink" title="　treeifyBin函数"></a>　treeifyBin函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</span><br><span class="line">        Node&lt;K,V&gt; b; int n, sc;</span><br><span class="line">        if (tab !&#x3D; null) &#123; &#x2F;&#x2F; 表不为空</span><br><span class="line">            if ((n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY) &#x2F;&#x2F; table表的长度小于最小的长度</span><br><span class="line">                &#x2F;&#x2F; 进行扩容，调整某个桶中结点数量过多的问题（由于某个桶中结点数量超出了阈值，则触发treeifyBin）</span><br><span class="line">                tryPresize(n &lt;&lt; 1);</span><br><span class="line">            else if ((b &#x3D; tabAt(tab, index)) !&#x3D; null &amp;&amp; b.hash &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 桶中存在结点并且结点的hash值大于等于0</span><br><span class="line">                synchronized (b) &#123; &#x2F;&#x2F; 对桶中第一个结点进行加锁</span><br><span class="line">                    if (tabAt(tab, index) &#x3D;&#x3D; b) &#123; &#x2F;&#x2F; 第一个结点没有变化</span><br><span class="line">                        TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;</span><br><span class="line">                        for (Node&lt;K,V&gt; e &#x3D; b; e !&#x3D; null; e &#x3D; e.next) &#123; &#x2F;&#x2F; 遍历桶中所有结点</span><br><span class="line">                            &#x2F;&#x2F; 新生一个TreeNode结点</span><br><span class="line">                            TreeNode&lt;K,V&gt; p &#x3D;</span><br><span class="line">                                new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                  null, null);</span><br><span class="line">                            if ((p.prev &#x3D; tl) &#x3D;&#x3D; null) &#x2F;&#x2F; 该结点前驱为空</span><br><span class="line">                                &#x2F;&#x2F; 设置p为头结点</span><br><span class="line">                                hd &#x3D; p;</span><br><span class="line">                            else</span><br><span class="line">                                &#x2F;&#x2F; 尾节点的next域赋值为p</span><br><span class="line">                                tl.next &#x3D; p;</span><br><span class="line">                            &#x2F;&#x2F; 尾节点赋值为p</span><br><span class="line">                            tl &#x3D; p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; 设置table表中下标为index的值为hd</span><br><span class="line">                        setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此函数用于将桶中的数据结构转化为红黑树，其中，值得注意的是，当table的长度未达到阈值时，会进行一次扩容操作，该操作会使得触发treeifyBin操作的某个桶中的所有元素进行一次重新分配，这样可以避免某个桶中的结点数量太大。</p><h3 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private final void addCount(long x, int check) &#123;</span><br><span class="line">        CounterCell[] as; long b, s;</span><br><span class="line">        if ((as &#x3D; counterCells) !&#x3D; null ||</span><br><span class="line">            !U.compareAndSwapLong(this, BASECOUNT, b &#x3D; baseCount, s &#x3D; b + x)) &#123; &#x2F;&#x2F; counterCells不为空或者比较交换失败</span><br><span class="line">            CounterCell a; long v; int m;</span><br><span class="line">            &#x2F;&#x2F; 无竞争标识</span><br><span class="line">            boolean uncontended &#x3D; true;</span><br><span class="line">            if (as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0 ||</span><br><span class="line">                (a &#x3D; as[ThreadLocalRandom.getProbe() &amp; m]) &#x3D;&#x3D; null ||</span><br><span class="line">                !(uncontended &#x3D;</span><br><span class="line">                  U.compareAndSwapLong(a, CELLVALUE, v &#x3D; a.value, v + x))) &#123; &#x2F;&#x2F; </span><br><span class="line">                fullAddCount(x, uncontended);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (check &lt;&#x3D; 1)</span><br><span class="line">                return;</span><br><span class="line">            s &#x3D; sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">        if (check &gt;&#x3D; 0) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; int n, sc;</span><br><span class="line">            while (s &gt;&#x3D; (long)(sc &#x3D; sizeCtl) &amp;&amp; (tab &#x3D; table) !&#x3D; null &amp;&amp;</span><br><span class="line">                   (n &#x3D; tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                int rs &#x3D; resizeStamp(n);</span><br><span class="line">                if (sc &lt; 0) &#123;</span><br><span class="line">                    if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                        sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||</span><br><span class="line">                        transferIndex &lt;&#x3D; 0)</span><br><span class="line">                        break;</span><br><span class="line">                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                    transfer(tab, null);</span><br><span class="line">                s &#x3D; sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数主要完成binCount的值加1的操作。</p><h3 id="get函数"><a href="#get函数" class="headerlink" title="get函数"></a>get函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">        &#x2F;&#x2F; 计算key的hash值</span><br><span class="line">        int h &#x3D; spread(key.hashCode()); </span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123; &#x2F;&#x2F; 表不为空并且表的长度大于0并且key所在的桶不为空</span><br><span class="line">            if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123; &#x2F;&#x2F; 表中的元素的hash值与key的hash值相等</span><br><span class="line">                if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))) &#x2F;&#x2F; 键相等</span><br><span class="line">                    &#x2F;&#x2F; 返回值</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (eh &lt; 0) &#x2F;&#x2F; 结点hash值小于0</span><br><span class="line">                &#x2F;&#x2F; 在桶（链表&#x2F;红黑树）中查找</span><br><span class="line">                return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;</span><br><span class="line">            while ((e &#x3D; e.next) !&#x3D; null) &#123; &#x2F;&#x2F; 对于结点hash值大于0的情况</span><br><span class="line">                if (e.hash &#x3D;&#x3D; h &amp;&amp;</span><br><span class="line">                    ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>get函数根据key的hash值来计算在哪个桶中，再遍历桶，查找元素，若找到则返回该结点，否则，返回null。</p><h3 id="replaceNode函数"><a href="#replaceNode函数" class="headerlink" title="replaceNode函数"></a>replaceNode函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">final V replaceNode(Object key, V value, Object cv) &#123;</span><br><span class="line">        &#x2F;&#x2F; 计算key的hash值</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0 ||</span><br><span class="line">                (f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#x2F;&#x2F; table表为空或者表长度为0或者key所对应的桶为空</span><br><span class="line">                &#x2F;&#x2F; 跳出循环</span><br><span class="line">                break;</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED) &#x2F;&#x2F; 桶中第一个结点的hash值为MOVED</span><br><span class="line">                &#x2F;&#x2F; 转移</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                boolean validated &#x3D; false;</span><br><span class="line">                synchronized (f) &#123; &#x2F;&#x2F; 加锁同步</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123; &#x2F;&#x2F; 桶中的第一个结点没有发生变化</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 结点hash值大于0</span><br><span class="line">                            validated &#x3D; true;</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f, pred &#x3D; null;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123; &#x2F;&#x2F; 结点的hash值与指定的hash值相等，并且key也相等</span><br><span class="line">                                    V ev &#x3D; e.val;</span><br><span class="line">                                    if (cv &#x3D;&#x3D; null || cv &#x3D;&#x3D; ev ||</span><br><span class="line">                                        (ev !&#x3D; null &amp;&amp; cv.equals(ev))) &#123; &#x2F;&#x2F; cv为空或者与结点value相等或者不为空并且相等</span><br><span class="line">                                        &#x2F;&#x2F; 保存该结点的val值</span><br><span class="line">                                        oldVal &#x3D; ev;</span><br><span class="line">                                        if (value !&#x3D; null) &#x2F;&#x2F; value为null</span><br><span class="line">                                            &#x2F;&#x2F; 设置结点value值</span><br><span class="line">                                            e.val &#x3D; value;</span><br><span class="line">                                        else if (pred !&#x3D; null) &#x2F;&#x2F; 前驱不为空</span><br><span class="line">                                            &#x2F;&#x2F; 前驱的后继为e的后继，即删除了e结点</span><br><span class="line">                                            pred.next &#x3D; e.next;</span><br><span class="line">                                        else</span><br><span class="line">                                            &#x2F;&#x2F; 设置table表中下标为index的值为e.next</span><br><span class="line">                                            setTabAt(tab, i, e.next);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                pred &#x3D; e;</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null)</span><br><span class="line">                                    break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 为红黑树结点类型</span><br><span class="line">                            validated &#x3D; true;</span><br><span class="line">                            &#x2F;&#x2F; 类型转化</span><br><span class="line">                            TreeBin&lt;K,V&gt; t &#x3D; (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                            if ((r &#x3D; t.root) !&#x3D; null &amp;&amp;</span><br><span class="line">                                (p &#x3D; r.findTreeNode(hash, key, null)) !&#x3D; null) &#123; &#x2F;&#x2F; 根节点不为空并且存在与指定hash和key相等的结点</span><br><span class="line">                                &#x2F;&#x2F; 保存p结点的value</span><br><span class="line">                                V pv &#x3D; p.val;</span><br><span class="line">                                if (cv &#x3D;&#x3D; null || cv &#x3D;&#x3D; pv ||</span><br><span class="line">                                    (pv !&#x3D; null &amp;&amp; cv.equals(pv))) &#123; &#x2F;&#x2F; cv为空或者与结点value相等或者不为空并且相等</span><br><span class="line">                                    oldVal &#x3D; pv;</span><br><span class="line">                                    if (value !&#x3D; null) </span><br><span class="line">                                        p.val &#x3D; value;</span><br><span class="line">                                    else if (t.removeTreeNode(p)) &#x2F;&#x2F; 移除p结点</span><br><span class="line">                                        setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (validated) &#123;</span><br><span class="line">                    if (oldVal !&#x3D; null) &#123;</span><br><span class="line">                        if (value &#x3D;&#x3D; null)</span><br><span class="line">                            &#x2F;&#x2F; baseCount值减一</span><br><span class="line">                            addCount(-1L, -1);</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数对remove函数提供支持，remove函数底层是调用的replaceNode函数实现结点的删除。　</p><p>ConcurrentHashMap的性能相比HashMap的线程安全同步集合和Hashtable而言，性能都要高出不少。原因是经过Collections封装的线程安全的HashMap和Hashtable都是对整个结构加锁，而ConcurrentHashMap是对每一个桶单独进行锁操作，不同的桶之间的操作不会相互影响，可以并发执行。因此，其速度会快很多。</p>]]></content>
    
    
    <summary type="html">　HashMap ：HashMap是线程不安全的，在并发环境下，可能会形成环状链表（扩容时可能造成），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的。 HashTable ： HashTable和HashMap的实现原理几乎一样，差别无非是</summary>
    
    
    
    <category term="JUC" scheme="http://example.com/categories/JUC/"/>
    
    
    <category term="CocurrentHashMap1.8" scheme="http://example.com/tags/CocurrentHashMap1-8/"/>
    
  </entry>
  
  <entry>
    <title>CocurrentHashMap1.7</title>
    <link href="http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/5%E3%80%81CocurrentHashMap1.7/"/>
    <id>http://example.com/2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/5%E3%80%81CocurrentHashMap1.7/</id>
    <published>2020-09-19T08:49:57.000Z</published>
    <updated>2020-09-19T09:26:47.595Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>　HashMap ：HashMap是线程不安全的，在并发环境下，可能会形成环状链表（扩容时可能造成），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的。</p></li><li><p>HashTable ： HashTable和HashMap的实现原理几乎一样，差别无非是</p></li></ul><ol><li>HashTable不允许key和value为null；</li><li>HashTable是线程安全的。但是HashTable线程安全的策略是在get/put所有相关操作都是synchronized的</li></ol><p>HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的”分段锁”思想。</p><h4 id="1-8中放弃了1-7的Segment臃肿的设计，取而代之的是采用Node-CAS-Synchronized来保证并发安全进行实现"><a href="#1-8中放弃了1-7的Segment臃肿的设计，取而代之的是采用Node-CAS-Synchronized来保证并发安全进行实现" class="headerlink" title="==1.8中放弃了1.7的Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现=="></a>==1.8中放弃了1.7的Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现==</h4><h3 id="ConcurrentHashMap源码分析："><a href="#ConcurrentHashMap源码分析：" class="headerlink" title="ConcurrentHashMap源码分析："></a>ConcurrentHashMap源码分析：</h3><ol><li>Node类</li></ol><p>　　Node类主要用于存储具体键值对，其子类有ForwardingNode、ReservationNode、TreeNode和TreeBin四个子类</p><ol start="2"><li>Traverser类</li></ol><p>　　Traverser类主要用于遍历操作，其子类有BaseIterator、KeySpliterator、ValueSpliterator、EntrySpliterator四个类，BaseIterator用于遍历操作。KeySplitertor、ValueSpliterator、EntrySpliterator则用于键、值、键值对的划分。</p><ol start="3"><li>CollectionView类</li></ol><p>　　CollectionView抽象类主要定义了视图操作，其子类KeySetView、ValueSetView、EntrySetView分别表示键视图、值视图、键值对视图。对视图均可以进行操作。</p><ol start="4"><li>Segment类</li></ol><p>　　Segment类在JDK1.8中与之前的版本的JDK作用存在很大的差别，JDK1.8下，其在普通的ConcurrentHashMap操作中已经没有失效，其在序列化与反序列化的时候会发挥作用。</p><ol start="5"><li>CounterCell</li></ol><p>CounterCell类主要用于对baseCount的计数。</p><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements ConcurrentMap&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 7249069246763182397L;</span><br><span class="line">    &#x2F;&#x2F; 表的最大容量</span><br><span class="line">    private static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line">    &#x2F;&#x2F; 默认表的大小</span><br><span class="line">    private static final int DEFAULT_CAPACITY &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 最大数组大小</span><br><span class="line">    static final int MAX_ARRAY_SIZE &#x3D; Integer.MAX_VALUE - 8;</span><br><span class="line">    &#x2F;&#x2F; 默认并发数</span><br><span class="line">    private static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 装载因子</span><br><span class="line">    private static final float LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">    &#x2F;&#x2F; 转化为红黑树的阈值</span><br><span class="line">    static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line">    &#x2F;&#x2F; 由红黑树转化为链表的阈值</span><br><span class="line">    static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line">    &#x2F;&#x2F; 转化为红黑树的表的最小容量</span><br><span class="line">    static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br><span class="line">    &#x2F;&#x2F; 每次进行转移的最小值</span><br><span class="line">    private static final int MIN_TRANSFER_STRIDE &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 生成sizeCtl所使用的bit位数</span><br><span class="line">    private static int RESIZE_STAMP_BITS &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 进行扩容所允许的最大线程数</span><br><span class="line">    private static final int MAX_RESIZERS &#x3D; (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;</span><br><span class="line">    &#x2F;&#x2F; 记录sizeCtl中的大小所需要进行的偏移位数</span><br><span class="line">    private static final int RESIZE_STAMP_SHIFT &#x3D; 32 - RESIZE_STAMP_BITS;    </span><br><span class="line">    &#x2F;&#x2F; 一系列的标识</span><br><span class="line">    static final int MOVED     &#x3D; -1; &#x2F;&#x2F; hash for forwarding nodes</span><br><span class="line">    static final int TREEBIN   &#x3D; -2; &#x2F;&#x2F; hash for roots of trees</span><br><span class="line">    static final int RESERVED  &#x3D; -3; &#x2F;&#x2F; hash for transient reservations</span><br><span class="line">    static final int HASH_BITS &#x3D; 0x7fffffff; &#x2F;&#x2F; usable bits of normal node hash</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    &#x2F;** Number of CPUS, to place bounds on some sizings *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 获取可用的CPU个数</span><br><span class="line">    static final int NCPU &#x3D; Runtime.getRuntime().availableProcessors();</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    &#x2F;** For serialization compatibility. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 进行序列化的属性</span><br><span class="line">    private static final ObjectStreamField[] serialPersistentFields &#x3D; &#123;</span><br><span class="line">        new ObjectStreamField(&quot;segments&quot;, Segment[].class),</span><br><span class="line">        new ObjectStreamField(&quot;segmentMask&quot;, Integer.TYPE),</span><br><span class="line">        new ObjectStreamField(&quot;segmentShift&quot;, Integer.TYPE)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 表</span><br><span class="line">    transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line">    &#x2F;&#x2F; 下一个表</span><br><span class="line">    private transient volatile Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Base counter value, used mainly when there is no contention,</span><br><span class="line">     * but also as a fallback during table initialization</span><br><span class="line">     * races. Updated via CAS.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 基本计数</span><br><span class="line">    private transient volatile long baseCount;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Table initialization and resizing control.  When negative, the</span><br><span class="line">     * table is being initialized or resized: -1 for initialization,</span><br><span class="line">     * else -(1 + the number of active resizing threads).  Otherwise,</span><br><span class="line">     * when table is null, holds the initial table size to use upon</span><br><span class="line">     * creation, or 0 for default. After initialization, holds the</span><br><span class="line">     * next element count value upon which to resize the table.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 对表初始化和扩容控制</span><br><span class="line">    private transient volatile int sizeCtl;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The next table index (plus one) to split while resizing.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 扩容下另一个表的索引</span><br><span class="line">    private transient volatile int transferIndex;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Spinlock (locked via CAS) used when resizing and&#x2F;or creating CounterCells.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 旋转锁</span><br><span class="line">    private transient volatile int cellsBusy;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Table of counter cells. When non-null, size is a power of 2.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; counterCell表</span><br><span class="line">    private transient volatile CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; views</span><br><span class="line">    &#x2F;&#x2F; 视图</span><br><span class="line">    private transient KeySetView&lt;K,V&gt; keySet;</span><br><span class="line">    private transient ValuesView&lt;K,V&gt; values;</span><br><span class="line">    private transient EntrySetView&lt;K,V&gt; entrySet;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Unsafe mechanics</span><br><span class="line">    private static final sun.misc.Unsafe U;</span><br><span class="line">    private static final long SIZECTL;</span><br><span class="line">    private static final long TRANSFERINDEX;</span><br><span class="line">    private static final long BASECOUNT;</span><br><span class="line">    private static final long CELLSBUSY;</span><br><span class="line">    private static final long CELLVALUE;</span><br><span class="line">    private static final long ABASE;</span><br><span class="line">    private static final int ASHIFT;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            U &#x3D; sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k &#x3D; ConcurrentHashMap.class;</span><br><span class="line">            SIZECTL &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;sizeCtl&quot;));</span><br><span class="line">            TRANSFERINDEX &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;transferIndex&quot;));</span><br><span class="line">            BASECOUNT &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;baseCount&quot;));</span><br><span class="line">            CELLSBUSY &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;cellsBusy&quot;));</span><br><span class="line">            Class&lt;?&gt; ck &#x3D; CounterCell.class;</span><br><span class="line">            CELLVALUE &#x3D; U.objectFieldOffset</span><br><span class="line">                (ck.getDeclaredField(&quot;value&quot;));</span><br><span class="line">            Class&lt;?&gt; ak &#x3D; Node[].class;</span><br><span class="line">            ABASE &#x3D; U.arrayBaseOffset(ak);</span><br><span class="line">            int scale &#x3D; U.arrayIndexScale(ak);</span><br><span class="line">            if ((scale &amp; (scale - 1)) !&#x3D; 0)</span><br><span class="line">                throw new Error(&quot;data type scale not a power of two&quot;);</span><br><span class="line">            ASHIFT &#x3D; 31 - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用于创建一个带有默认初始容量 (16)、加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。</span><br><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;创建一个带有指定初始容量、默认加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。</span><br><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity &lt; 0) &#x2F;&#x2F; 初始容量小于0，抛出异常</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        int cap &#x3D; ((initialCapacity &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); &#x2F;&#x2F; 找到最接近该容量的2的幂次方数</span><br><span class="line">        &#x2F;&#x2F; 初始化</span><br><span class="line">        this.sizeCtl &#x3D; cap;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;构造一个与给定映射具有相同映射关系的新映射。</span><br><span class="line">    public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this.sizeCtl &#x3D; DEFAULT_CAPACITY;</span><br><span class="line">        &#x2F;&#x2F; 将集合m的元素全部放入</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个带有指定初始容量、加载因子和默认 concurrencyLevel (1) 的新的空映射。</span><br><span class="line">     public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        this(initialCapacity, loadFactor, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个带有指定初始容量、加载因子和并发级别的新的空映射。</span><br><span class="line">    public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                             float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">        if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0) &#x2F;&#x2F; 合法性判断</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (initialCapacity &lt; concurrencyLevel)   &#x2F;&#x2F; Use at least as many bins</span><br><span class="line">            initialCapacity &#x3D; concurrencyLevel;   &#x2F;&#x2F; as estimated threads</span><br><span class="line">        long size &#x3D; (long)(1.0 + (long)initialCapacity &#x2F; loadFactor);</span><br><span class="line">        int cap &#x3D; (size &gt;&#x3D; (long)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((int)size);</span><br><span class="line">        this.sizeCtl &#x3D; cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="putVal函数"><a href="#putVal函数" class="headerlink" title="putVal函数"></a>putVal函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">        if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException(); &#x2F;&#x2F; 键或值为空，抛出异常</span><br><span class="line">        &#x2F;&#x2F; 键的hash值经过计算获得hash值</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        int binCount &#x3D; 0;</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) &#x2F;&#x2F; 表为空或者表的长度为0</span><br><span class="line">                &#x2F;&#x2F; 初始化表</span><br><span class="line">                tab &#x3D; initTable();</span><br><span class="line">            else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 表不为空并且表的长度大于0，并且该桶不为空</span><br><span class="line">                if (casTabAt(tab, i, null,</span><br><span class="line">                             new Node&lt;K,V&gt;(hash, key, value, null))) &#x2F;&#x2F; 比较并且交换值，如tab的第i项为空则用新生成的node替换</span><br><span class="line">                    break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED) &#x2F;&#x2F; 该结点的hash值为MOVED</span><br><span class="line">                &#x2F;&#x2F; 进行结点的转移（在扩容的过程中）</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                synchronized (f) &#123; &#x2F;&#x2F; 加锁同步</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123; &#x2F;&#x2F; 找到table表下标为i的节点</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 该table表中该结点的hash值大于0</span><br><span class="line">                            &#x2F;&#x2F; binCount赋值为1</span><br><span class="line">                            binCount &#x3D; 1;</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123; &#x2F;&#x2F; 结点的hash值相等并且key也相等</span><br><span class="line">                                    &#x2F;&#x2F; 保存该结点的val值</span><br><span class="line">                                    oldVal &#x3D; e.val;</span><br><span class="line">                                    if (!onlyIfAbsent) &#x2F;&#x2F; 进行判断</span><br><span class="line">                                        &#x2F;&#x2F; 将指定的value保存至结点，即进行了结点值的更新</span><br><span class="line">                                        e.val &#x3D; value;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                &#x2F;&#x2F; 保存当前结点</span><br><span class="line">                                Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 当前结点的下一个结点为空，即为最后一个结点</span><br><span class="line">                                    &#x2F;&#x2F; 新生一个结点并且赋值给next域</span><br><span class="line">                                    pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, null);</span><br><span class="line">                                    &#x2F;&#x2F; 退出循环</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 结点为红黑树结点类型</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            &#x2F;&#x2F; binCount赋值为2</span><br><span class="line">                            binCount &#x3D; 2;</span><br><span class="line">                            if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) !&#x3D; null) &#123; &#x2F;&#x2F; 将hash、key、value放入红黑树</span><br><span class="line">                                &#x2F;&#x2F; 保存结点的val</span><br><span class="line">                                oldVal &#x3D; p.val;</span><br><span class="line">                                if (!onlyIfAbsent) &#x2F;&#x2F; 判断</span><br><span class="line">                                    &#x2F;&#x2F; 赋值结点value值</span><br><span class="line">                                    p.val &#x3D; value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (binCount !&#x3D; 0) &#123; &#x2F;&#x2F; binCount不为0</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD) &#x2F;&#x2F; 如果binCount大于等于转化为红黑树的阈值</span><br><span class="line">                        &#x2F;&#x2F; 进行转化</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    if (oldVal !&#x3D; null) &#x2F;&#x2F; 旧值不为空</span><br><span class="line">                        &#x2F;&#x2F; 返回旧值</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 增加binCount的数量</span><br><span class="line">        addCount(1L, binCount);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：put函数底层调用了putVal进行数据的插入，对于putVal函数的流程大体如下。</p><p>　　① 判断存储的key、value是否为空，若为空，则抛出异常，否则，进入步骤②</p><p>　　② 计算key的hash值，随后进入无限循环，该无限循环可以确保成功插入数据，若table表为空或者长度为0，则初始化table表，否则，进入步骤③</p><p>　　③ 根据key的hash值取出table表中的结点元素，若取出的结点为空（该桶为空），则使用CAS将key、value、hash值生成的结点放入桶中。否则，进入步骤④</p><p>　　④ 若该结点的的hash值为MOVED，则对该桶中的结点进行转移，否则，进入步骤⑤</p><p>　　⑤ 对桶中的第一个结点（即table表中的结点）进行加锁，对该桶进行遍历，桶中的结点的hash值与key值与给定的hash值和key值相等，则根据标识选择是否进行更新操作（用给定的value值替换该结点的value值），若遍历完桶仍没有找到hash值与key值和指定的hash值与key值相等的结点，则直接新生一个结点并赋值为之前最后一个结点的下一个结点。进入步骤⑥</p><p>　　⑥ 若binCount值达到红黑树转化的阈值，则将桶中的结构转化为红黑树存储，最后，增加binCount的值。</p><p>　　在putVal函数中会涉及到如下几个函数：initTable、tabAt、casTabAt、helpTransfer、putTreeVal、treeifyBin、addCount函数。下面对其中涉及到的函数进行分析。</p><h3 id="initTable"><a href="#initTable" class="headerlink" title="　　initTable"></a>　　initTable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">        while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            if ((sc &#x3D; sizeCtl) &lt; 0) &#x2F;&#x2F; sizeCtl小于0，则进行线程让步等待</span><br><span class="line">                Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin</span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; &#x2F;&#x2F; 比较sizeCtl的值与sc是否相等，相等则用-1替换</span><br><span class="line">                try &#123;</span><br><span class="line">                    if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; table表为空或者大小为0</span><br><span class="line">                        &#x2F;&#x2F; sc的值是否大于0，若是，则n为sc，否则，n为默认初始容量</span><br><span class="line">                        int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                        &#x2F;&#x2F; 新生结点数组</span><br><span class="line">                        Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                        &#x2F;&#x2F; 赋值给table</span><br><span class="line">                        table &#x3D; tab &#x3D; nt;</span><br><span class="line">                        &#x2F;&#x2F; sc为n * 3&#x2F;4</span><br><span class="line">                        sc &#x3D; n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    &#x2F;&#x2F; 设置sizeCtl的值</span><br><span class="line">                    sizeCtl &#x3D; sc;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 返回table表</span><br><span class="line">        return tab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于table的大小，会根据sizeCtl的值进行设置，如果没有设置szieCtl的值，那么默认生成的table大小为16，否则，会根据sizeCtl的大小设置table大小。</p><h3 id="tabAt函数"><a href="#tabAt函数" class="headerlink" title="tabAt函数"></a>tabAt函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</span><br><span class="line">        return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数返回table数组中下标为i的结点，可以看到是通过Unsafe对象通过反射获取的，getObjectVolatile的第二项参数为下标为i的偏移地址。</p><h3 id="casTabAt函数"><a href="#casTabAt函数" class="headerlink" title="casTabAt函数"></a>casTabAt函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,</span><br><span class="line">                                      Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</span><br><span class="line">      return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此函数用于比较table数组下标为i的结点是否为c，若为c，则用v交换操作。否则，不进行交换操作。</p><h3 id="helpTransfer函数"><a href="#helpTransfer函数" class="headerlink" title="helpTransfer函数"></a>helpTransfer函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">        if (tab !&#x3D; null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">            (nextTab &#x3D; ((ForwardingNode&lt;K,V&gt;)f).nextTable) !&#x3D; null) &#123; &#x2F;&#x2F; table表不为空并且结点类型使ForwardingNode类型，并且结点的nextTable不为空</span><br><span class="line">            int rs &#x3D; resizeStamp(tab.length);</span><br><span class="line">            while (nextTab &#x3D;&#x3D; nextTable &amp;&amp; table &#x3D;&#x3D; tab &amp;&amp;</span><br><span class="line">                   (sc &#x3D; sizeCtl) &lt; 0) &#123; &#x2F;&#x2F; 条件判断</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                    sc &#x3D;&#x3D; rs + MAX_RESIZERS || transferIndex &lt;&#x3D; 0) &#x2F;&#x2F; </span><br><span class="line">                    break;</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; &#x2F;&#x2F; 比较并交换</span><br><span class="line">                    &#x2F;&#x2F; 将table的结点转移到nextTab中</span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        return table;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此函数用于在扩容时将table表中的结点转移到nextTable中。</p><h3 id="putTreeVal函数"><a href="#putTreeVal函数" class="headerlink" title="putTreeVal函数"></a>putTreeVal函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">final TreeNode&lt;K,V&gt; putTreeVal(int h, K k, V v) &#123;</span><br><span class="line">            Class&lt;?&gt; kc &#x3D; null;</span><br><span class="line">            boolean searched &#x3D; false;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; p &#x3D; root;;) &#123;</span><br><span class="line">                int dir, ph; K pk;</span><br><span class="line">                if (p &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    first &#x3D; root &#x3D; new TreeNode&lt;K,V&gt;(h, k, v, null, null);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else if ((ph &#x3D; p.hash) &gt; h)</span><br><span class="line">                    dir &#x3D; -1;</span><br><span class="line">                else if (ph &lt; h)</span><br><span class="line">                    dir &#x3D; 1;</span><br><span class="line">                else if ((pk &#x3D; p.key) &#x3D;&#x3D; k || (pk !&#x3D; null &amp;&amp; k.equals(pk)))</span><br><span class="line">                    return p;</span><br><span class="line">                else if ((kc &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">                          (kc &#x3D; comparableClassFor(k)) &#x3D;&#x3D; null) ||</span><br><span class="line">                         (dir &#x3D; compareComparables(kc, k, pk)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    if (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched &#x3D; true;</span><br><span class="line">                        if (((ch &#x3D; p.left) !&#x3D; null &amp;&amp;</span><br><span class="line">                             (q &#x3D; ch.findTreeNode(h, k, kc)) !&#x3D; null) ||</span><br><span class="line">                            ((ch &#x3D; p.right) !&#x3D; null &amp;&amp;</span><br><span class="line">                             (q &#x3D; ch.findTreeNode(h, k, kc)) !&#x3D; null))</span><br><span class="line">                            return q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir &#x3D; tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp &#x3D; p;</span><br><span class="line">                if ((p &#x3D; (dir &lt;&#x3D; 0) ? p.left : p.right) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x, f &#x3D; first;</span><br><span class="line">                    first &#x3D; x &#x3D; new TreeNode&lt;K,V&gt;(h, k, v, f, xp);</span><br><span class="line">                    if (f !&#x3D; null)</span><br><span class="line">                        f.prev &#x3D; x;</span><br><span class="line">                    if (dir &lt;&#x3D; 0)</span><br><span class="line">                        xp.left &#x3D; x;</span><br><span class="line">                    else</span><br><span class="line">                        xp.right &#x3D; x;</span><br><span class="line">                    if (!xp.red)</span><br><span class="line">                        x.red &#x3D; true;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        lockRoot();</span><br><span class="line">                        try &#123;</span><br><span class="line">                            root &#x3D; balanceInsertion(root, x);</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            unlockRoot();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            assert checkInvariants(root);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>　说明：此函数用于将指定的hash、key、value值添加到红黑树中，若已经添加了，则返回null，否则返回该结点。</p><h3 id="treeifyBin函数"><a href="#treeifyBin函数" class="headerlink" title="　treeifyBin函数"></a>　treeifyBin函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</span><br><span class="line">        Node&lt;K,V&gt; b; int n, sc;</span><br><span class="line">        if (tab !&#x3D; null) &#123; &#x2F;&#x2F; 表不为空</span><br><span class="line">            if ((n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY) &#x2F;&#x2F; table表的长度小于最小的长度</span><br><span class="line">                &#x2F;&#x2F; 进行扩容，调整某个桶中结点数量过多的问题（由于某个桶中结点数量超出了阈值，则触发treeifyBin）</span><br><span class="line">                tryPresize(n &lt;&lt; 1);</span><br><span class="line">            else if ((b &#x3D; tabAt(tab, index)) !&#x3D; null &amp;&amp; b.hash &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 桶中存在结点并且结点的hash值大于等于0</span><br><span class="line">                synchronized (b) &#123; &#x2F;&#x2F; 对桶中第一个结点进行加锁</span><br><span class="line">                    if (tabAt(tab, index) &#x3D;&#x3D; b) &#123; &#x2F;&#x2F; 第一个结点没有变化</span><br><span class="line">                        TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;</span><br><span class="line">                        for (Node&lt;K,V&gt; e &#x3D; b; e !&#x3D; null; e &#x3D; e.next) &#123; &#x2F;&#x2F; 遍历桶中所有结点</span><br><span class="line">                            &#x2F;&#x2F; 新生一个TreeNode结点</span><br><span class="line">                            TreeNode&lt;K,V&gt; p &#x3D;</span><br><span class="line">                                new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                  null, null);</span><br><span class="line">                            if ((p.prev &#x3D; tl) &#x3D;&#x3D; null) &#x2F;&#x2F; 该结点前驱为空</span><br><span class="line">                                &#x2F;&#x2F; 设置p为头结点</span><br><span class="line">                                hd &#x3D; p;</span><br><span class="line">                            else</span><br><span class="line">                                &#x2F;&#x2F; 尾节点的next域赋值为p</span><br><span class="line">                                tl.next &#x3D; p;</span><br><span class="line">                            &#x2F;&#x2F; 尾节点赋值为p</span><br><span class="line">                            tl &#x3D; p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; 设置table表中下标为index的值为hd</span><br><span class="line">                        setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此函数用于将桶中的数据结构转化为红黑树，其中，值得注意的是，当table的长度未达到阈值时，会进行一次扩容操作，该操作会使得触发treeifyBin操作的某个桶中的所有元素进行一次重新分配，这样可以避免某个桶中的结点数量太大。</p><h3 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private final void addCount(long x, int check) &#123;</span><br><span class="line">        CounterCell[] as; long b, s;</span><br><span class="line">        if ((as &#x3D; counterCells) !&#x3D; null ||</span><br><span class="line">            !U.compareAndSwapLong(this, BASECOUNT, b &#x3D; baseCount, s &#x3D; b + x)) &#123; &#x2F;&#x2F; counterCells不为空或者比较交换失败</span><br><span class="line">            CounterCell a; long v; int m;</span><br><span class="line">            &#x2F;&#x2F; 无竞争标识</span><br><span class="line">            boolean uncontended &#x3D; true;</span><br><span class="line">            if (as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0 ||</span><br><span class="line">                (a &#x3D; as[ThreadLocalRandom.getProbe() &amp; m]) &#x3D;&#x3D; null ||</span><br><span class="line">                !(uncontended &#x3D;</span><br><span class="line">                  U.compareAndSwapLong(a, CELLVALUE, v &#x3D; a.value, v + x))) &#123; &#x2F;&#x2F; </span><br><span class="line">                fullAddCount(x, uncontended);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (check &lt;&#x3D; 1)</span><br><span class="line">                return;</span><br><span class="line">            s &#x3D; sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">        if (check &gt;&#x3D; 0) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; int n, sc;</span><br><span class="line">            while (s &gt;&#x3D; (long)(sc &#x3D; sizeCtl) &amp;&amp; (tab &#x3D; table) !&#x3D; null &amp;&amp;</span><br><span class="line">                   (n &#x3D; tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                int rs &#x3D; resizeStamp(n);</span><br><span class="line">                if (sc &lt; 0) &#123;</span><br><span class="line">                    if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                        sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||</span><br><span class="line">                        transferIndex &lt;&#x3D; 0)</span><br><span class="line">                        break;</span><br><span class="line">                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                    transfer(tab, null);</span><br><span class="line">                s &#x3D; sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数主要完成binCount的值加1的操作。</p><h3 id="get函数"><a href="#get函数" class="headerlink" title="get函数"></a>get函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">        &#x2F;&#x2F; 计算key的hash值</span><br><span class="line">        int h &#x3D; spread(key.hashCode()); </span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123; &#x2F;&#x2F; 表不为空并且表的长度大于0并且key所在的桶不为空</span><br><span class="line">            if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123; &#x2F;&#x2F; 表中的元素的hash值与key的hash值相等</span><br><span class="line">                if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))) &#x2F;&#x2F; 键相等</span><br><span class="line">                    &#x2F;&#x2F; 返回值</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (eh &lt; 0) &#x2F;&#x2F; 结点hash值小于0</span><br><span class="line">                &#x2F;&#x2F; 在桶（链表&#x2F;红黑树）中查找</span><br><span class="line">                return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;</span><br><span class="line">            while ((e &#x3D; e.next) !&#x3D; null) &#123; &#x2F;&#x2F; 对于结点hash值大于0的情况</span><br><span class="line">                if (e.hash &#x3D;&#x3D; h &amp;&amp;</span><br><span class="line">                    ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>get函数根据key的hash值来计算在哪个桶中，再遍历桶，查找元素，若找到则返回该结点，否则，返回null。</p><h3 id="replaceNode函数"><a href="#replaceNode函数" class="headerlink" title="replaceNode函数"></a>replaceNode函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">final V replaceNode(Object key, V value, Object cv) &#123;</span><br><span class="line">        &#x2F;&#x2F; 计算key的hash值</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0 ||</span><br><span class="line">                (f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#x2F;&#x2F; table表为空或者表长度为0或者key所对应的桶为空</span><br><span class="line">                &#x2F;&#x2F; 跳出循环</span><br><span class="line">                break;</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED) &#x2F;&#x2F; 桶中第一个结点的hash值为MOVED</span><br><span class="line">                &#x2F;&#x2F; 转移</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                boolean validated &#x3D; false;</span><br><span class="line">                synchronized (f) &#123; &#x2F;&#x2F; 加锁同步</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123; &#x2F;&#x2F; 桶中的第一个结点没有发生变化</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 结点hash值大于0</span><br><span class="line">                            validated &#x3D; true;</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f, pred &#x3D; null;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123; &#x2F;&#x2F; 结点的hash值与指定的hash值相等，并且key也相等</span><br><span class="line">                                    V ev &#x3D; e.val;</span><br><span class="line">                                    if (cv &#x3D;&#x3D; null || cv &#x3D;&#x3D; ev ||</span><br><span class="line">                                        (ev !&#x3D; null &amp;&amp; cv.equals(ev))) &#123; &#x2F;&#x2F; cv为空或者与结点value相等或者不为空并且相等</span><br><span class="line">                                        &#x2F;&#x2F; 保存该结点的val值</span><br><span class="line">                                        oldVal &#x3D; ev;</span><br><span class="line">                                        if (value !&#x3D; null) &#x2F;&#x2F; value为null</span><br><span class="line">                                            &#x2F;&#x2F; 设置结点value值</span><br><span class="line">                                            e.val &#x3D; value;</span><br><span class="line">                                        else if (pred !&#x3D; null) &#x2F;&#x2F; 前驱不为空</span><br><span class="line">                                            &#x2F;&#x2F; 前驱的后继为e的后继，即删除了e结点</span><br><span class="line">                                            pred.next &#x3D; e.next;</span><br><span class="line">                                        else</span><br><span class="line">                                            &#x2F;&#x2F; 设置table表中下标为index的值为e.next</span><br><span class="line">                                            setTabAt(tab, i, e.next);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                pred &#x3D; e;</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null)</span><br><span class="line">                                    break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 为红黑树结点类型</span><br><span class="line">                            validated &#x3D; true;</span><br><span class="line">                            &#x2F;&#x2F; 类型转化</span><br><span class="line">                            TreeBin&lt;K,V&gt; t &#x3D; (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                            if ((r &#x3D; t.root) !&#x3D; null &amp;&amp;</span><br><span class="line">                                (p &#x3D; r.findTreeNode(hash, key, null)) !&#x3D; null) &#123; &#x2F;&#x2F; 根节点不为空并且存在与指定hash和key相等的结点</span><br><span class="line">                                &#x2F;&#x2F; 保存p结点的value</span><br><span class="line">                                V pv &#x3D; p.val;</span><br><span class="line">                                if (cv &#x3D;&#x3D; null || cv &#x3D;&#x3D; pv ||</span><br><span class="line">                                    (pv !&#x3D; null &amp;&amp; cv.equals(pv))) &#123; &#x2F;&#x2F; cv为空或者与结点value相等或者不为空并且相等</span><br><span class="line">                                    oldVal &#x3D; pv;</span><br><span class="line">                                    if (value !&#x3D; null) </span><br><span class="line">                                        p.val &#x3D; value;</span><br><span class="line">                                    else if (t.removeTreeNode(p)) &#x2F;&#x2F; 移除p结点</span><br><span class="line">                                        setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (validated) &#123;</span><br><span class="line">                    if (oldVal !&#x3D; null) &#123;</span><br><span class="line">                        if (value &#x3D;&#x3D; null)</span><br><span class="line">                            &#x2F;&#x2F; baseCount值减一</span><br><span class="line">                            addCount(-1L, -1);</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数对remove函数提供支持，remove函数底层是调用的replaceNode函数实现结点的删除。　</p><p>ConcurrentHashMap的性能相比HashMap的线程安全同步集合和Hashtable而言，性能都要高出不少。原因是经过Collections封装的线程安全的HashMap和Hashtable都是对整个结构加锁，而ConcurrentHashMap是对每一个桶单独进行锁操作，不同的桶之间的操作不会相互影响，可以并发执行。因此，其速度会快很多。</p>]]></content>
    
    
    <summary type="html">　HashMap ：HashMap是线程不安全的，在并发环境下，可能会形成环状链表（扩容时可能造成），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的。 HashTable ： HashTable和HashMap的实现原理几乎一样，差别无非是</summary>
    
    
    
    <category term="JUC" scheme="http://example.com/categories/JUC/"/>
    
    
    <category term="CocurrentHashMap1.7" scheme="http://example.com/tags/CocurrentHashMap1-7/"/>
    
  </entry>
  
  <entry>
    <title>前中后缀表达式</title>
    <link href="http://example.com/2020/09/19/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E3%80%81%E6%A0%88/3%E3%80%81%E5%89%8D%E4%B8%AD%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://example.com/2020/09/19/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E3%80%81%E6%A0%88/3%E3%80%81%E5%89%8D%E4%B8%AD%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-09-19T08:41:21.000Z</published>
    <updated>2020-09-19T09:26:45.689Z</updated>
    
    <content type="html"><![CDATA[<p>前缀记法、中缀记法和后缀记法。它们之间的区别在于运算符相对与操作数的位置不同</p><ul><li>(3 + 4) × 5 - 6 就是中缀表达式</li><li>一 * + 3 4 5 6 前缀表达式（波兰式）</li><li>3 4 + 5 × 6 - 后缀表达式（逆波兰式）</li></ul><p>虽然人的大脑很容易理解与分析中缀表达式，但对计算机来说中缀表达式却是很复杂的，因此计算表达式的值时，通常需要先将中缀表达式转换为前缀或后缀表达式，然后再进行求值。对计算机来说，计算前缀或后缀表达式的值非常简单。</p><h3 id="前缀表达式求值："><a href="#前缀表达式求值：" class="headerlink" title="前缀表达式求值："></a>前缀表达式求值：</h3><p>从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果。</p><p>例如前缀表达式“- × + 3 4 5 6”：</p><ul><li>(1) 从右至左扫描，将6、5、4、3压入堆栈；</li><li>(2) 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素，注意与后缀表达式做比较），计算出3+4的值，得7，再将7入栈；</li><li>(3) 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈；</li><li>(4) 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。</li></ul><h3 id="后缀表达式求值："><a href="#后缀表达式求值：" class="headerlink" title="后缀表达式求值："></a>后缀表达式求值：</h3><p>与前缀表达式类似，只是顺序是从左至右</p><p>例如后缀表达式“3 4 + 5 × 6 -”：</p><ul><li>(1) 从左至右扫描，将3和4压入堆栈；</li><li>(2) 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素，注意与前缀表达式做比较），计算出3+4的值，得7，再将7入栈；</li><li>(3) 将5入栈；</li><li>(4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</li><li>(5) 将6入栈；</li><li>(6) 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。</li></ul><h3 id="中缀表达式转后缀表达式："><a href="#中缀表达式转后缀表达式：" class="headerlink" title="中缀表达式转后缀表达式："></a>中缀表达式转后缀表达式：</h3><p>中缀表达式1 + (( 2 + 3)* 4 ) –5，请将它转化为后缀表达式。</p><p>首先将中缀表达式转换为表达式树，然后后序遍历表达式树，所得结果就是后缀表达式。</p><p>将中缀表达式转化为表达式树方法：表达式树的树叶是操作数，而其他的节点为操作符，根节点为优先级最低且靠右的操作符（如上述表达式优先级最低的是- 和+，但 + 更靠右，所以根为+），圆括号不包括。如上述中缀表达式转换后的表达式树如下：</p><p><img src="https://img-blog.csdn.net/20140402144303578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2Fsa2Vya2Fscg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><p>经过后序遍历表达式树后得到的后缀表达式为：12 3 + 4 * + 5 –</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line">public class PolandNotation &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;完成将一个中缀表达式转成后缀表达式的功能</span><br><span class="line">&#x2F;&#x2F;说明</span><br><span class="line">&#x2F;&#x2F;1. 1+((2+3)×4)-5 &#x3D;&gt; 转成  1 2 3 + 4 × + 5 –</span><br><span class="line">&#x2F;&#x2F;2. 因为直接对str 进行操作，不方便，因此 先将  &quot;1+((2+3)×4)-5&quot; &#x3D;》 中缀的表达式对应的List</span><br><span class="line">&#x2F;&#x2F;   即 &quot;1+((2+3)×4)-5&quot; &#x3D;&gt; ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span><br><span class="line">&#x2F;&#x2F;3. 将得到的中缀表达式对应的List &#x3D;&gt; 后缀表达式对应的List</span><br><span class="line">&#x2F;&#x2F;   即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  &#x3D;》 ArrayList [1,2,3,+,4,*,+,5,–]</span><br><span class="line"></span><br><span class="line">String expression &#x3D; &quot;1+((2+3)*4)-5&quot;;&#x2F;&#x2F;注意表达式 </span><br><span class="line">List&lt;String&gt; infixExpressionList &#x3D; toInfixExpressionList(expression);</span><br><span class="line">System.out.println(&quot;中缀表达式对应的List&#x3D;&quot; + infixExpressionList); &#x2F;&#x2F; ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span><br><span class="line">List&lt;String&gt; suffixExpreesionList &#x3D; parseSuffixExpreesionList(infixExpressionList);</span><br><span class="line">System.out.println(&quot;后缀表达式对应的List&quot; + suffixExpreesionList); &#x2F;&#x2F;ArrayList [1,2,3,+,4,*,+,5,–] </span><br><span class="line"></span><br><span class="line">System.out.printf(&quot;expression&#x3D;%d&quot;, calculate(suffixExpreesionList)); &#x2F;&#x2F; ?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;先定义给逆波兰表达式</span><br><span class="line">&#x2F;&#x2F;(30+4)×5-6  &#x3D;&gt; 30 4 + 5 × 6 - &#x3D;&gt; 164</span><br><span class="line">&#x2F;&#x2F; 4 * 5 - 8 + 60 + 8 &#x2F; 2 &#x3D;&gt; 4 5 * 8 - 60 + 8 2 &#x2F; + </span><br><span class="line">&#x2F;&#x2F;测试 </span><br><span class="line">&#x2F;&#x2F;说明为了方便，逆波兰表达式 的数字和符号使用空格隔开</span><br><span class="line">&#x2F;&#x2F;String suffixExpression &#x3D; &quot;30 4 + 5 * 6 -&quot;;</span><br><span class="line">String suffixExpression &#x3D; &quot;4 5 * 8 - 60 + 8 2 &#x2F; +&quot;; &#x2F;&#x2F; 76</span><br><span class="line">&#x2F;&#x2F;思路</span><br><span class="line">&#x2F;&#x2F;1. 先将 &quot;3 4 + 5 × 6 - &quot; &#x3D;&gt; 放到ArrayList中</span><br><span class="line">&#x2F;&#x2F;2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list &#x3D; getListString(suffixExpression);</span><br><span class="line">System.out.println(&quot;rpnList&#x3D;&quot; + list);</span><br><span class="line">int res &#x3D; calculate(list);</span><br><span class="line">System.out.println(&quot;计算的结果是&#x3D;&quot; + res);</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  &#x3D;》 ArrayList [1,2,3,+,4,*,+,5,–]</span><br><span class="line">&#x2F;&#x2F;方法：将得到的中缀表达式对应的List &#x3D;&gt; 后缀表达式对应的List</span><br><span class="line">public static List&lt;String&gt; parseSuffixExpreesionList(List&lt;String&gt; ls) &#123;</span><br><span class="line">&#x2F;&#x2F;定义两个栈</span><br><span class="line">Stack&lt;String&gt; s1 &#x3D; new Stack&lt;String&gt;(); &#x2F;&#x2F; 符号栈</span><br><span class="line">&#x2F;&#x2F;说明：因为s2 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出</span><br><span class="line">&#x2F;&#x2F;因此比较麻烦，这里我们就不用 Stack&lt;String&gt; 直接使用 List&lt;String&gt; s2</span><br><span class="line">&#x2F;&#x2F;Stack&lt;String&gt; s2 &#x3D; new Stack&lt;String&gt;(); &#x2F;&#x2F; 储存中间结果的栈s2</span><br><span class="line">List&lt;String&gt; s2 &#x3D; new ArrayList&lt;String&gt;(); &#x2F;&#x2F; 储存中间结果的Lists2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;遍历ls</span><br><span class="line">for(String item: ls) &#123;</span><br><span class="line">&#x2F;&#x2F;如果是一个数，加入s2</span><br><span class="line">if(item.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">s2.add(item);</span><br><span class="line">&#125; else if (item.equals(&quot;(&quot;)) &#123;</span><br><span class="line">s1.push(item);</span><br><span class="line">&#125; else if (item.equals(&quot;)&quot;)) &#123;</span><br><span class="line">&#x2F;&#x2F;如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span><br><span class="line">while(!s1.peek().equals(&quot;(&quot;)) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line">s1.pop();&#x2F;&#x2F;!!! 将 ( 弹出 s1栈， 消除小括号</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;当item的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较</span><br><span class="line">&#x2F;&#x2F;问题：我们缺少一个比较优先级高低的方法</span><br><span class="line">while(s1.size() !&#x3D; 0 &amp;&amp; Operation.getValue(s1.peek()) &gt;&#x3D; Operation.getValue(item) ) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;还需要将item压入栈</span><br><span class="line">s1.push(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将s1中剩余的运算符依次弹出并加入s2</span><br><span class="line">while(s1.size() !&#x3D; 0) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return s2; &#x2F;&#x2F;注意因为是存放到List, 因此按顺序输出就是对应的后缀表达式对应的List</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法：将 中缀表达式转成对应的List</span><br><span class="line">&#x2F;&#x2F;  s&#x3D;&quot;1+((2+3)×4)-5&quot;;</span><br><span class="line">public static List&lt;String&gt; toInfixExpressionList(String s) &#123;</span><br><span class="line">&#x2F;&#x2F;定义一个List,存放中缀表达式 对应的内容</span><br><span class="line">List&lt;String&gt; ls &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">int i &#x3D; 0; &#x2F;&#x2F;这时是一个指针，用于遍历 中缀表达式字符串</span><br><span class="line">String str; &#x2F;&#x2F; 对多位数的拼接</span><br><span class="line">char c; &#x2F;&#x2F; 每遍历到一个字符，就放入到c</span><br><span class="line">do &#123;</span><br><span class="line">&#x2F;&#x2F;如果c是一个非数字，我需要加入到ls</span><br><span class="line">if((c&#x3D;s.charAt(i)) &lt; 48 ||  (c&#x3D;s.charAt(i)) &gt; 57) &#123;</span><br><span class="line">ls.add(&quot;&quot; + c);</span><br><span class="line">i++; &#x2F;&#x2F;i需要后移</span><br><span class="line">&#125; else &#123; &#x2F;&#x2F;如果是一个数，需要考虑多位数</span><br><span class="line">str &#x3D; &quot;&quot;; &#x2F;&#x2F;先将str 置成&quot;&quot; &#39;0&#39;[48]-&gt;&#39;9&#39;[57]</span><br><span class="line">while(i &lt; s.length() &amp;&amp; (c&#x3D;s.charAt(i)) &gt;&#x3D; 48 &amp;&amp; (c&#x3D;s.charAt(i)) &lt;&#x3D; 57) &#123;</span><br><span class="line">str +&#x3D; c;&#x2F;&#x2F;拼接</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">ls.add(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;while(i &lt; s.length());</span><br><span class="line">return ls;&#x2F;&#x2F;返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList中</span><br><span class="line">public static List&lt;String&gt; getListString(String suffixExpression) &#123;</span><br><span class="line">&#x2F;&#x2F;将 suffixExpression 分割</span><br><span class="line">String[] split &#x3D; suffixExpression.split(&quot; &quot;);</span><br><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">for(String ele: split) &#123;</span><br><span class="line">list.add(ele);</span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;完成对逆波兰表达式的运算</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 1)从左至右扫描，将3和4压入堆栈；</span><br><span class="line">2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；</span><br><span class="line">3)将5入栈；</span><br><span class="line">4)接下来是×运算符，因此弹出5和7，计算出7×5&#x3D;35，将35入栈；</span><br><span class="line">5)将6入栈；</span><br><span class="line">6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public static int calculate(List&lt;String&gt; ls) &#123;</span><br><span class="line">&#x2F;&#x2F; 创建给栈, 只需要一个栈即可</span><br><span class="line">Stack&lt;String&gt; stack &#x3D; new Stack&lt;String&gt;();</span><br><span class="line">&#x2F;&#x2F; 遍历 ls</span><br><span class="line">for (String item : ls) &#123;</span><br><span class="line">&#x2F;&#x2F; 这里使用正则表达式来取出数</span><br><span class="line">if (item.matches(&quot;\\d+&quot;)) &#123; &#x2F;&#x2F; 匹配的是多位数</span><br><span class="line">&#x2F;&#x2F; 入栈</span><br><span class="line">stack.push(item);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; pop出两个数，并运算， 再入栈</span><br><span class="line">int num2 &#x3D; Integer.parseInt(stack.pop());</span><br><span class="line">int num1 &#x3D; Integer.parseInt(stack.pop());</span><br><span class="line">int res &#x3D; 0;</span><br><span class="line">if (item.equals(&quot;+&quot;)) &#123;</span><br><span class="line">res &#x3D; num1 + num2;</span><br><span class="line">&#125; else if (item.equals(&quot;-&quot;)) &#123;</span><br><span class="line">res &#x3D; num1 - num2;</span><br><span class="line">&#125; else if (item.equals(&quot;*&quot;)) &#123;</span><br><span class="line">res &#x3D; num1 * num2;</span><br><span class="line">&#125; else if (item.equals(&quot;&#x2F;&quot;)) &#123;</span><br><span class="line">res &#x3D; num1 &#x2F; num2;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">throw new RuntimeException(&quot;运算符有误&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;把res 入栈</span><br><span class="line">stack.push(&quot;&quot; + res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;最后留在stack中的数据是运算结果</span><br><span class="line">return Integer.parseInt(stack.pop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编写一个类 Operation 可以返回一个运算符 对应的优先级</span><br><span class="line">class Operation &#123;</span><br><span class="line">private static int ADD &#x3D; 1;</span><br><span class="line">private static int SUB &#x3D; 1;</span><br><span class="line">private static int MUL &#x3D; 2;</span><br><span class="line">private static int DIV &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;写一个方法，返回对应的优先级数字</span><br><span class="line">public static int getValue(String operation) &#123;</span><br><span class="line">int result &#x3D; 0;</span><br><span class="line">switch (operation) &#123;</span><br><span class="line">case &quot;+&quot;:</span><br><span class="line">result &#x3D; ADD;</span><br><span class="line">break;</span><br><span class="line">case &quot;-&quot;:</span><br><span class="line">result &#x3D; SUB;</span><br><span class="line">break;</span><br><span class="line">case &quot;*&quot;:</span><br><span class="line">result &#x3D; MUL;</span><br><span class="line">break;</span><br><span class="line">case &quot;&#x2F;&quot;:</span><br><span class="line">result &#x3D; DIV;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">System.out.println(&quot;不存在该运算符&quot; + operation);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前缀记法、中缀记法和后缀记法。它们之间的区别在于运算符相对与操作数的位置不同 (3 + 4) × 5  6 就是中缀表达式</summary>
    
    
    
    <category term="栈" scheme="http://example.com/categories/%E6%A0%88/"/>
    
    
    <category term="前中后缀表达式" scheme="http://example.com/tags/%E5%89%8D%E4%B8%AD%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>栈：应用</title>
    <link href="http://example.com/2020/09/19/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E3%80%81%E6%A0%88/%E6%A0%88%EF%BC%9A%E5%BA%94%E7%94%A8/"/>
    <id>http://example.com/2020/09/19/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E3%80%81%E6%A0%88/%E6%A0%88%EF%BC%9A%E5%BA%94%E7%94%A8/</id>
    <published>2020-09-19T01:22:32.000Z</published>
    <updated>2020-09-19T09:26:45.706Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、如何实现浏览器的前进和后退功能"><a href="#1、如何实现浏览器的前进和后退功能" class="headerlink" title="1、如何实现浏览器的前进和后退功能"></a>1、如何实现浏览器的前进和后退功能</h3><h3 id="2、两个栈实现一个队列"><a href="#2、两个栈实现一个队列" class="headerlink" title="2、两个栈实现一个队列"></a>2、两个栈实现一个队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class StackToQueue&lt;T&gt; &#123;</span><br><span class="line">    Stack&lt;T&gt; stackOne &#x3D; new Stack&lt;T&gt;();</span><br><span class="line">    Stack&lt;T&gt; stackTwo &#x3D; new Stack&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    private void push(T data) &#123;</span><br><span class="line">        stackOne.push(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private T pop() &#123;</span><br><span class="line">        while (!stackOne.isEmpty()) &#123;</span><br><span class="line">            stackTwo.push(stackOne.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        T first &#x3D; stackTwo.pop();</span><br><span class="line">        while (!stackTwo.isEmpty()) &#123;</span><br><span class="line">            stackOne.push(stackTwo.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return first;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、两个队列实现一个栈"><a href="#3、两个队列实现一个栈" class="headerlink" title="3、两个队列实现一个栈"></a>3、两个队列实现一个栈</h3><p>入栈操作，我们固定把元素压入queue1<br>出栈操作，如果队列1不为空，就把队列1中q1.size()-1个元素poll出来，添加到队列2中，再把队列中那个最后的元素poll出来<br>这两个队列中始终有一个是空的。另一个非空。push添加元素到非空队列中，pop把非空队列中前面的元素都转移到另一个队列中，只剩最后一个元素，再把最后一个元素pop出来。这样这一个队列是空的，另一个队列又非空了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class QueueToStack&lt;T&gt; &#123;</span><br><span class="line">    private ArrayDeque&lt;T&gt; queueOne &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line">    private ArrayDeque&lt;T&gt; queueTwo &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private void push(T t) &#123;</span><br><span class="line">        queueOne.offer(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private T pop() &#123;</span><br><span class="line">        if (!queueOne.isEmpty() || !queueTwo.isEmpty()) &#123;</span><br><span class="line">            if (!queueOne.isEmpty()) &#123;</span><br><span class="line">                while (queueOne.size() &gt; 1) &#123;</span><br><span class="line">                    queueTwo.offer(queueOne.poll());</span><br><span class="line">                &#125;</span><br><span class="line">                return queueOne.poll();</span><br><span class="line">            &#125; else if (!queueTwo.isEmpty()) &#123;</span><br><span class="line">                while (queueTwo.size() &gt; 1) &#123;</span><br><span class="line">                    queueOne.offer(queueTwo.poll());</span><br><span class="line">                &#125;</span><br><span class="line">                return queueTwo.poll();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private T top() &#123;</span><br><span class="line">        T top &#x3D; null;</span><br><span class="line">        if (!isEmpty()) &#123;</span><br><span class="line">            if (!queueOne.isEmpty()) &#123;</span><br><span class="line">                while (queueOne.size() &gt; 1) &#123;</span><br><span class="line">                    queueTwo.offer(queueOne.poll());</span><br><span class="line">                &#125;</span><br><span class="line">                top &#x3D; queueOne.peek();</span><br><span class="line">                queueTwo.offer(queueOne.poll());</span><br><span class="line">            &#125; else if (!queueTwo.isEmpty()) &#123;</span><br><span class="line">                while (queueTwo.size() &gt; 1) &#123;</span><br><span class="line">                    queueOne.offer(queueTwo.poll());</span><br><span class="line">                &#125;</span><br><span class="line">                top &#x3D; queueTwo.peek();</span><br><span class="line">                queueOne.offer(queueTwo.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            return top;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isEmpty() &#123;</span><br><span class="line">        return queueOne.isEmpty() &amp;&amp; queueTwo.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">1、如何实现浏览器的前进和后退功能 2、两个栈实现一个队列</summary>
    
    
    
    <category term="栈" scheme="http://example.com/categories/%E6%A0%88/"/>
    
    
    <category term="栈：应用" scheme="http://example.com/tags/%E6%A0%88%EF%BC%9A%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>CAP、BASE理论</title>
    <link href="http://example.com/2020/09/16/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2%E3%80%81CAP%E3%80%81BASE%E7%90%86%E8%AE%BA/"/>
    <id>http://example.com/2020/09/16/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2%E3%80%81CAP%E3%80%81BASE%E7%90%86%E8%AE%BA/</id>
    <published>2020-09-15T22:58:06.000Z</published>
    <updated>2020-09-19T09:26:47.899Z</updated>
    
    <content type="html"><![CDATA[<ul><li>1、商品服务请求主数据库写入商品信息（添加商品、修改商品、删除商品）</li><li>2、主数据库向商品服务响应写入成功。</li><li>3、商品服务请求从数据库读取商品信息。</li></ul><h4 id="C-Consistency："><a href="#C-Consistency：" class="headerlink" title="C  Consistency："></a>C  Consistency：</h4><p>一致性是指写操作后的读操作可以读取到最新的数据状态，当数据分布在多个节点上，从任意结点读取到的数据都 是最新的状态。<br>上图中，商品信息的读写要满足一致性就是要实现如下目标：</p><ul><li>1、商品服务写入主数据库成功，则向从数据库查询新数据也成功。</li><li>2、商品服务写入主数据库失败，则向从数据库查询新数据也失败。 如何实现一致性？</li><li>3、写入主数据库后要将数据同步到从数据库。</li><li>4、写入主数据库后，在向从数据库同步期间要将从数据库锁定，待同步完成后再释放锁，以免在新数据写入成功 后，向从数据库查询到旧的数据。</li></ul><p>分布式系统一致性的特点：</p><ul><li>1、由于存在数据同步的过程，写操作的响应会有一定的延迟。 </li><li>2、为了保证数据一致性会对资源暂时锁定，待数据同步完成释放锁定资源。 </li><li>3、如果请求数据同步失败的结点则会返回错误信息，一定不会返回旧数据。 </li></ul><h4 id="A-Availability-："><a href="#A-Availability-：" class="headerlink" title="A - Availability ："></a>A - Availability ：</h4><p>可用性是指任何事务操作都可以得到响应结果，且不会出现响应超时或响应错误。 上图中，商品信息读取满足可用性就是要实现如下目标： </p><ul><li>1、从数据库接收到数据查询的请求则立即能够响应数据查询结果。 </li><li>2、从数据库不允许出现响应超时或响应错误。 如何实现可用性？ </li><li>1、写入主数据库后要将数据同步到从数据库。 </li><li>2、由于要保证从数据库的可用性，不可将从数据库中的资源进行锁定。 </li><li>3、即时数据还没有同步过来，从数据库也要返回要查询的数据，哪怕是旧数据，如果连旧数据也没有则可以按照 约定返回一个默认信息，但不能返回错误或响应超时。 分布式系统可用性的特点： 1、 所有请求都有响应，且不会出现响应超时或响应错误。</li></ul><h5 id="P-Partition-tolerance-："><a href="#P-Partition-tolerance-：" class="headerlink" title="P - Partition tolerance ："></a>P - Partition tolerance ：</h5><p>通常分布式系统的各各结点部署在不同的子网，这就是网络分区，不可避免的会出现由于网络问题而导致结点之间 通信失败，此时仍可对外提供服务，这叫分区容忍性。 上图中，商品信息读写满足分区容忍性就是要实现如下目标： </p><ul><li>1、主数据库向从数据库同步数据失败不影响读写操作。 </li><li>2、其一个结点挂掉不影响另一个结点对外提供服务。 如何实现分区容忍性？ </li><li>1、尽量使用异步取代同步操作，例如使用异步方式将数据从主数据库同步到从数据，这样结点之间能有效的实现 松耦合。 </li><li>2、添加从数据库结点，其中一个从结点挂掉其它从结点提供服务。 分布式分区容忍性的特点： 1、分区容忍性分是布式系统具备的基本能力。</li></ul><p>一般都会做出如下选择：保证P和A，舍弃C强一致，保证最终一致性。</p><p>BASE理论</p><p>1、理解强一致性和最终一致性 CAP理论告诉我们一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍 性（Partition tolerance）这三项中的两项，其中AP在实际应用中较多，AP即舍弃一致性，保证可用性和分区容忍 性，但是在实际生产中很多场景都要实现一致性，比如前边我们举的例子主数据库向从数据库同步数据，即使不要 一致性，但是最终也要将数据同步成功来保证数据一致，这种一致性和CAP中的一致性不同，CAP中的一致性要求 在任何时间查询每个结点数据都必须一致，它强调的是强一致性，但是最终一致性是允许可以在一段时间内每个结 点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。 </p><p>2、Base理论介绍 BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩 写。</p><p>==BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性==，当出现故障允许部分不可用但要保证 核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为“柔 性事务”。</p><ul><li>基本可用:分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如，电商网站交易付款出 现问题了，商品依然可以正常浏览。 </li><li>软状态:由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫软状态），这个状态不影响系统可用 性，如订单的”支付中”、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。 </li><li>最终一致:最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的”支付中”状态，最终会变 为“支付成功”或者”支付失败”，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。</li></ul>]]></content>
    
    
    <summary type="html">1、商品服务请求主数据库写入商品信息（添加商品、修改商品、删除商品） 2、主数据库向商品服务响应写入成功。</summary>
    
    
    
    <category term="分布式事务解决方案" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="CAP、BASE理论" scheme="http://example.com/tags/CAP%E3%80%81BASE%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>如何存储IP地址</title>
    <link href="http://example.com/2020/09/14/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8IP%E5%9C%B0%E5%9D%80/"/>
    <id>http://example.com/2020/09/14/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8IP%E5%9C%B0%E5%9D%80/</id>
    <published>2020-09-14T06:33:42.000Z</published>
    <updated>2020-09-19T09:26:48.761Z</updated>
    
    <content type="html"><![CDATA[<p> IP地址 本来就是一个字符串，存放在数据库作为字符穿类型</p><p> 网络地址：<br>192.168.33.123每一个值最大不会越过255，也就是十六进制的FF，两个Byte刚好表示的最大值是255，<br>这样子，就可以用一个32位的整形来保存这个IP<br>1100 0000 1010 1000 0010 0001 0111 1011<br>把这些二进制合在一起就是32位的数了<br>11000000101010000010000101111011<br>十进制为<br>3232244091</p><p>《高性能MySQL 第3版》第4.1.7节时，作者建议当存储IPv4地址时，应该使用32位的无符号整数（UNSIGNED INT）来存储IP<br>地址<br>优点：</p><ul><li>节省空间，不管是数据存储空间，还是索引存储空间</li><li>便于使用范围查询（BETWEEN…AND），且效率更高</li></ul><p>如果是 IPv4地址 的话 可通过数据库自带的函数 INET_ATON 和 INET_NTOA 进行转化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT INET_ATON(&#39;209.207.224.40&#39;);</span><br><span class="line">-&gt; 3520061480</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT INET_NTOA(3520061480);</span><br><span class="line">-&gt; &#39;209.207.224.40&#39;</span><br></pre></td></tr></table></figure><p>如果是 IPv6地址 的话，MySQL 5.6 版本之后。则使用函数 INET6_ATON 和 INET6_NTOA 进行转化。然后数据库定义为 varbinary 类型，分配 128bits 空间（因为 ipv6采用的是128bits，16个字节）；或者定义为 char 类型，分配<br>32bits 空间</p>]]></content>
    
    
    <summary type="html">IP地址 本来就是一个字符串，存放在数据库作为字符穿类型 网络地址：</summary>
    
    
    
    <category term="mysql" scheme="http://example.com/categories/mysql/"/>
    
    
    <category term="如何存储IP地址" scheme="http://example.com/tags/%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8IP%E5%9C%B0%E5%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>文件上传漏洞</title>
    <link href="http://example.com/2020/09/10/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/3%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2020/09/10/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/3%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-09-10T06:38:17.000Z</published>
    <updated>2020-09-19T09:26:49.635Z</updated>
    
    <content type="html"><![CDATA[<p>文件上传攻击指的是恶意攻击者利用一些站点没有对文件的类型做很好的校验，上传了可执行的文件或者脚本，并且通过脚本获得服务器上相应的权力，或者是通过诱导外部用户访问、下载上传的病毒或木马文件，达到攻击的目的</p><ul><li>1、文件上传的目录设置为不可执行</li><li>2、上传的文件需要使用随机数等进行重命名，使攻击者无法猜测到上传文件的访问路径</li><li>3、对于图片类型的文件，可以在上传后，利用imagemagick等工具对图片进行相应的缩放，破坏恶意用户上传的二进制可执行文件的结构，来避免恶意代码执行</li><li>4、对HTTP包头的content-type也和上传文件的大小也需要进行检查。</li><li>5、不能简单地通过后缀名来判断文件类型，很多类型的文件起始的几个字节内容是固定的，根据这几个字节(魔数)的内容就可以确定文件类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public enum FileType&#123;</span><br><span class="line">    JPEG(&quot;FFD8FF&quot;),</span><br><span class="line">    PNG(&quot;89504E47&quot;),</span><br><span class="line">    GIF(&quot;47494638&quot;),</span><br><span class="line">    TIFF(&quot;49492A00&quot;),</span><br><span class="line">    BMP(&quot;424D&quot;),</span><br><span class="line">    DWG(&quot;41433130&quot;),</span><br><span class="line">    PSD(&quot;38425053&quot;),</span><br><span class="line">    XML(&quot;3C3F786D6C&quot;),</span><br><span class="line">    HTML(&quot;68746D6C3E&quot;),</span><br><span class="line">    PDF(&quot;255044462D312E&quot;),</span><br><span class="line">    ZIP(&quot;504B0304&quot;),</span><br><span class="line">    RAR(&quot;52617221&quot;),</span><br><span class="line">    WAV(&quot;57415645&quot;),</span><br><span class="line">    AVI(&quot;41564920&quot;),</span><br><span class="line"></span><br><span class="line">    private String value &#x3D; &quot;&quot;;</span><br><span class="line">    private FileType(String value)&#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getValue()&#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setValue(String value)&#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *读取文件头</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"> private static String getFileHeader(String filePath) throws IOException &#123;</span><br><span class="line">     &#x2F;&#x2F;这里需要注意的是，每个文件的魔数的长度都不相同，因此需要使用startwith</span><br><span class="line">     byte[] b &#x3D; new byte[28];</span><br><span class="line">     InputStream is &#x3D; null;</span><br><span class="line">     is &#x3D; new FileInputStream(filePath);</span><br><span class="line">     is.read(b, 0, 28);</span><br><span class="line">     is.close();</span><br><span class="line"></span><br><span class="line">     return bytes2hex(b);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">  *判断文件类型</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static FileType getType(String filePath) throws IOException &#123;</span><br><span class="line">      String fileHead &#x3D; getFileHeader(filePath);</span><br><span class="line">      if(fileHead &#x3D;&#x3D; null || fileHead.length() &#x3D;&#x3D; 0)&#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">      fileHead &#x3D; fileHead.toUpperCase();</span><br><span class="line">      FileType[] fileTypes &#x3D; FileType.values();</span><br><span class="line">      for(FileType type : fileTypes)&#123;</span><br><span class="line">          if(fileHead.startsWith(type.getValue()))&#123;</span><br><span class="line">              return type;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">文件上传攻击指的是恶意攻击者利用一些站点没有对文件的类型做很好的校验，上传了可执行的文件或者脚本，并且通过脚本获得服务器上相应的权力，或者是通过诱导外部用户访问、下载上传的病毒或木马文件，达到攻击的目的 1、文件上传的目录设置为不可执行</summary>
    
    
    
    <category term="web攻击" scheme="http://example.com/categories/web%E6%94%BB%E5%87%BB/"/>
    
    
    <category term="文件上传漏洞" scheme="http://example.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>redis延时队列</title>
    <link href="http://example.com/2020/08/24/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/12%E3%80%81redis%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2020/08/24/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/12%E3%80%81redis%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/</id>
    <published>2020-08-24T11:47:35.000Z</published>
    <updated>2020-09-19T09:26:48.871Z</updated>
    
    <content type="html"><![CDATA[<ul><li>超时订单自动取消</li><li>用户未点击确认收货，超时订单自动完成</li></ul><p>定时任务扫表处理的缺点：</p><ul><li>数据量大的情况下延时较高，若在规定时间处理不完，影响业务</li><li>维护多个定时任务，重复扫描业务表</li></ul><h5 id="JDK的DelayQueue延时队列"><a href="#JDK的DelayQueue延时队列" class="headerlink" title="JDK的DelayQueue延时队列"></a>JDK的DelayQueue延时队列</h5><h5 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h5><p>实现原理</p><p>利用 Redis 的 sorted set 结构，使用 timeStamp 作为 score，比如你的任务是要延迟5分钟，那么就在当前时间上加5分钟作为 score ，客户端做轮询处理，且轮询任务每秒只轮询 score 大于当前时间的 key即可</p><p>优点：简单易用</p><p>缺点</p><ul><li>单个 zset 支持不了太大的数据量，百万级的延迟任务需求，则处理不过来</li><li>定时器轮询方案可能会有异常终止的情况需要自己处理，同时消息处理失败的回滚方案，您也要自己处理。</li></ul><h5 id="RabbitMQ-延时队列（常用的落地方式）"><a href="#RabbitMQ-延时队列（常用的落地方式）" class="headerlink" title="RabbitMQ 延时队列（常用的落地方式）"></a>RabbitMQ 延时队列（常用的落地方式）</h5><p>利用RabbitMQ 有两个特性，一个是 Time-To-Live Extensions，另一个是 Dead Letter Exchanges。</p><p>TTL：消息的存活时间，单位为微秒。</p><p>DLX：死信交换机。绑定在死信交换机上的即死信队列。RabbitMQ的Queue（队列）可以配置两个参数x-dead-letter-exchange和x-dead-letter-routing-key（可选），一旦队列内出现了Dead Letter（死信），则按照这两个参数可以将消息重新路由到另一个Exchange（交换机），让消息重新被消费</p><p>我们将订单消息A0001发送到延迟队列order.delay.queue，并设置x-message-tt消息存活时间为30分钟，当到达30分钟后订单消息A0001成为了Dead Letter（死信），延迟队列检测到有死信，通过配置x-dead-letter-exchange，将死信重新转发到能正常消费的关单队列，直接监听关单队列处理关单逻辑即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void send(String delayTimes) &#123;</span><br><span class="line">    amqpTemplate.convertAndSend(&quot;order.pay.exchange&quot;, &quot;order.pay.queue&quot;,&quot;大家好我是延迟数据&quot;, message -&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 设置延迟毫秒值</span><br><span class="line">        message.getMessageProperties().setExpiration(String.valueOf(delayTimes));</span><br><span class="line">        return message;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Bean(name &#x3D; &quot;order.delay.queue&quot;)</span><br><span class="line">public Queue getMessageQueue() &#123;</span><br><span class="line">    return QueueBuilder</span><br><span class="line">            .durable(RabbitConstant.DEAD_LETTER_QUEUE)</span><br><span class="line">            &#x2F;&#x2F; 配置到期后转发的交换</span><br><span class="line">            .withArgument(&quot;x-dead-letter-exchange&quot;, &quot;order.close.exchange&quot;)</span><br><span class="line">            &#x2F;&#x2F; 配置到期后转发的路由键</span><br><span class="line">            .withArgument(&quot;x-dead-letter-routing-key&quot;, &quot;order.close.queue&quot;)</span><br><span class="line">            .build();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>优点：</p><p>如果面临大数据量需求可以很容易的横向扩展，同时消息支持持久化，有问题可回滚。</p><p>缺点：</p><p>配置麻烦，额外增加一个死信交换机和一个死信队列的配置；</p><p>RabbitMQ的定位是消息中间件，TTL 和 DLX 特性去实现一个功能。若需要替换其他MQ，则不满足</p><p>需要考虑不同延迟的消息要放到不同的队列：消息队列具有先进先出的特点，如果第一个进入队列的消息 A 的延迟是10分钟，第二个进入队列的消息B 的延迟是5分钟，期望的是谁先到 TTL谁先出，但是事实是B已经到期了，而还要等到 A 的延迟10分钟结束A先出之后，B 才能出</p><p>当用户发送一个消息请求给服务器后台的时候，服务器会检测这条消息是否需要进行延时处理，如果需要就放入到延时队列中，由延时任务检测器进行检测和处理，对于不需要进行延时处理的任务，服务器会立马对消息进行处理，并把处理后的结果返会给用户。</p><h5 id="Netty-HashedWheelTimer"><a href="#Netty-HashedWheelTimer" class="headerlink" title="Netty#HashedWheelTimer"></a>Netty#HashedWheelTimer</h5><p>HashedWheelTimer 是 Netty 中 的一个基础工具类，主要用来高效处理大量定时任务，且任务对时间精度要求相对不高， 在Netty 中的应用场景就是连接超时或者任务处理超时，一般都是操作比较快速的任务，缺点是内存占用相对较高</p>]]></content>
    
    
    <summary type="html">超时订单自动取消 用户未点击确认收货，超时订单自动完成</summary>
    
    
    
    <category term="redis" scheme="http://example.com/categories/redis/"/>
    
    
    <category term="redis延时队列" scheme="http://example.com/tags/redis%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>HTTP</title>
    <link href="http://example.com/2020/08/15/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/1%E3%80%81HTTP/"/>
    <id>http://example.com/2020/08/15/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/1%E3%80%81HTTP/</id>
    <published>2020-08-15T00:04:46.000Z</published>
    <updated>2020-09-19T09:26:46.017Z</updated>
    
    <content type="html"><![CDATA[<p>连接超时参数 ConnectTimeout，让用户配置建连阶段的最长等待时间。</p><h4 id="ConnectTimeout"><a href="#ConnectTimeout" class="headerlink" title="ConnectTimeout"></a>ConnectTimeout</h4><p>让用户配置建连阶段的最长等待时间</p><p>一般来说，TCP 三次握手建立连接需要的时间非常短，通常在毫秒级最多到秒级，如果几秒连接不上，那么可能永远也连接不上。因此，设置特别长的连接超时意义不大，将其配置得短一些（比如 1~5 秒）即可。如果是纯内网调用的话，这个参数可以设置得更短，在下游服务离线无法连接的时候，可以快速失败。</p><h4 id="ReadTimeout"><a href="#ReadTimeout" class="headerlink" title="ReadTimeout"></a>ReadTimeout</h4><p>是建立连接后从服务器读取到可用资源所用的时间。</p><p>HTTP 请求通过 URL 传递参数时，不能超过 2048 字节。</p><p>HTTP 请求通过 body 传递内容时，nginx 默认限制是 1MB，tomcat 默认限制为 2MB，当确实有业务需要传较大内容时，可以通过调<br>大服务器端的限制</p>]]></content>
    
    
    <summary type="html">连接超时参数 ConnectTimeout，让用户配置建连阶段的最长等待时间。 ConnectTimeout</summary>
    
    
    
    <category term="HTTP" scheme="http://example.com/categories/HTTP/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="http://example.com/2020/08/13/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7%E3%80%81%E5%A0%86/%E5%A0%86/"/>
    <id>http://example.com/2020/08/13/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7%E3%80%81%E5%A0%86/%E5%A0%86/</id>
    <published>2020-08-13T08:06:44.000Z</published>
    <updated>2020-09-19T09:26:45.829Z</updated>
    
    <content type="html"><![CDATA[<ul><li>堆是一个完全二叉树；==完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。==</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</li></ul><p>完全二叉树：如果二叉树的深度为k，则除第k层外其余所有层节点的度都为2，且叶子节点从左到右依次存在。也即是，将满二叉树的最后一层从左到右依次删除若干节点就得到完全二叉树。满二叉树是一棵特殊的完全二叉树，但完全二叉树不一定是满二叉树。<br><img src="https://static001.geekbang.org/resource/image/18/60/18413c6597c2850b75367393b401ad60.jpg" alt="image"></p><p>堆是具有以下性质的完全二叉树：==每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。==<br><img src="https://static001.geekbang.org/resource/image/4c/99/4c452a1ad3b2d152daa2727d06097099.jpg" alt="image"></p><p>第 1 个和第 2 个是大顶堆，第 3 个是小顶堆，第 4 个不是堆</p><h3 id="堆的实现："><a href="#堆的实现：" class="headerlink" title="堆的实现："></a>堆的实现：</h3><p>完全二叉树比较适合用数组来存储，节省空间<br><img src="https://static001.geekbang.org/resource/image/4d/1e/4d349f57947df6590a2dd1364c3b0b1e.jpg" alt="image"></p><p>数组中下标为 i 的节点的左子节点，就是下标为 i∗2 的节点，右子节点就是下标为 i∗2+1 的节点，父节点就是下标为 i/2 的节点。</p>]]></content>
    
    
    <summary type="html">堆是一个完全二叉树；完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</summary>
    
    
    
    <category term="堆" scheme="http://example.com/categories/%E5%A0%86/"/>
    
    
    <category term="堆" scheme="http://example.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>Redis单进程单线程为什么还这么快</title>
    <link href="http://example.com/2020/08/10/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/14%E3%80%81Redis%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%BF%99%E4%B9%88%E5%BF%AB/"/>
    <id>http://example.com/2020/08/10/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/14%E3%80%81Redis%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%BF%99%E4%B9%88%E5%BF%AB/</id>
    <published>2020-08-10T08:05:54.000Z</published>
    <updated>2020-09-19T09:26:48.883Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</p><h2 id="1、redis单线程为什么这么快？"><a href="#1、redis单线程为什么这么快？" class="headerlink" title="1、redis单线程为什么这么快？"></a>1、redis单线程为什么这么快？</h2><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。（如何测试redis的速度？10w+/s）数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p><p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p><p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；因为Redis是基于内存的操作，CPU不是Redis的瓶颈，==Redis的瓶颈最有可能是机器内存的大小或者网络带宽==</p><p>4、使用多路I/O复用模型，非阻塞IO；</p><p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p><h2 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h2><p>1、单进程多线程模型：MySQL、Memcached、Oracle（Windows版本）；</p><p>2、多进程模型：Oracle（Linux版本）；</p><p>3、Nginx有两类进程，一类称为Master进程(相当于管理进程)，另一类称为Worker进程（实际工作进程）。启动方式有两种：</p><p>（1）单进程启动：此时系统中仅有一个进程，该进程既充当Master进程的角色，也充当Worker进程的角色。</p><p>（2）多进程启动：此时系统有且仅有一个Master进程，至少有一个Worker进程工作。</p><p>（3）Master进程主要进行一些全局性的初始化工作和管理Worker的工作；事件处理是在Worker中进行的。</p><h2 id="2、redis阻塞和性能监控"><a href="#2、redis阻塞和性能监控" class="headerlink" title="2、redis阻塞和性能监控"></a>2、redis阻塞和性能监控</h2><p>Redis的事件循环在一个线程中处理，作为一个单线程程序，重要的是要保证事件处理的时延短，这样，事件循环中的后续任务才不会阻塞；<br>当redis的数据量达到一定级别后（比如20G），阻塞操作对性能的影响尤为严重； </p><ul><li><p>keys、sort等命令<br>keys命令用于查找所有符合给定模式 pattern 的 key，时间复杂度为O(N)， N 为数据库中 key 的数量。当数据库中的个数达到千万时，这个命令会造成读写线程阻塞数秒；<br>类似的命令有sunion sort等操作； </p></li><li><p>smembers命令</p></li></ul><p>smembers命令用于获取集合全集，时间复杂度为O(N),N为集合中的数量；<br>如果一个集合中保存了千万量级的数据，一次取回也会造成事件处理线程的长时间阻塞；</p><ul><li>save命令</li></ul><p>save命令使用事件处理线程进行数据的持久化；当数据量大的时候，会造成线程长时间阻塞（我们的生产上，reids内存中1个G保存需要12s左右），整个redis被block；<br>save阻塞了事件处理的线程，我们甚至无法使用redis-cli查看当前的系统状态，造成“何时保存结束，目前保存了多少”这样的信息都无从得知；</p>]]></content>
    
    
    <summary type="html">Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。 1、redis单线程为什么这么快？</summary>
    
    
    
    <category term="redis" scheme="http://example.com/categories/redis/"/>
    
    
    <category term="Redis单进程单线程为什么还这么快" scheme="http://example.com/tags/Redis%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%BF%99%E4%B9%88%E5%BF%AB/"/>
    
  </entry>
  
  <entry>
    <title>ArrayBlockingQueue</title>
    <link href="http://example.com/2020/08/08/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/8%E3%80%81ArrayBlockingQueue/"/>
    <id>http://example.com/2020/08/08/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/8%E3%80%81ArrayBlockingQueue/</id>
    <published>2020-08-08T08:50:42.000Z</published>
    <updated>2020-09-19T09:26:47.624Z</updated>
    
    <content type="html"><![CDATA[<p>ArrayBlockingQueue的底层数据结构是数组,对数组的访问添加了锁的机制，使其能够支持多线程并发。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性　　"></a>属性　　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span><br><span class="line">        implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">    &#x2F;&#x2F; 版本序列号</span><br><span class="line">    private static final long serialVersionUID &#x3D; -817911632652898426L;</span><br><span class="line">    &#x2F;&#x2F; 存放实际元素的数组</span><br><span class="line">    final Object[] items;</span><br><span class="line">    &#x2F;&#x2F; 取元素索引</span><br><span class="line">    int takeIndex;</span><br><span class="line">    &#x2F;&#x2F; 获取元素索引</span><br><span class="line">    int putIndex;</span><br><span class="line">    &#x2F;&#x2F; 队列中的项</span><br><span class="line">    int count;</span><br><span class="line">    &#x2F;&#x2F; 可重入锁</span><br><span class="line">    final ReentrantLock lock;</span><br><span class="line">    &#x2F;&#x2F; 等待获取条件</span><br><span class="line">    private final Condition notEmpty;</span><br><span class="line">    &#x2F;&#x2F; 等待存放条件</span><br><span class="line">    private final Condition notFull;</span><br><span class="line">    &#x2F;&#x2F; 迭代器</span><br><span class="line">    transient Itrs itrs &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　说明：从类的属性中可以清楚的看到其底层的结构是Object类型的数组，取元素和存元素有不同的索引，有一个可重入锁ReentrantLock，两个条件Condition　</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="　构造函数"></a>　构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建一个带有给定的（固定）容量和默认访问策略的 ArrayBlockingQueue。    </span><br><span class="line"> public ArrayBlockingQueue(int capacity) &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用两个参数的构造函数</span><br><span class="line">        this(capacity, false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue。</span><br><span class="line">    public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始容量必须大于0</span><br><span class="line">        if (capacity &lt;&#x3D; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        &#x2F;&#x2F; 初始化数组</span><br><span class="line">        this.items &#x3D; new Object[capacity];</span><br><span class="line">        &#x2F;&#x2F; 初始化可重入锁</span><br><span class="line">        lock &#x3D; new ReentrantLock(fair);</span><br><span class="line">        &#x2F;&#x2F; 初始化等待条件</span><br><span class="line">        notEmpty &#x3D; lock.newCondition();</span><br><span class="line">        notFull &#x3D;  lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue，它最初包含给定 collection 的元素，并以 collection 迭代器的遍历顺序添加元素。</span><br><span class="line">    public ArrayBlockingQueue(int capacity, boolean fair,</span><br><span class="line">                              Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用两个参数的构造函数</span><br><span class="line">        this(capacity, fair);</span><br><span class="line">        &#x2F;&#x2F; 可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 上锁</span><br><span class="line">        lock.lock(); &#x2F;&#x2F; Lock only for visibility, not mutual exclusion</span><br><span class="line">        try &#123;</span><br><span class="line">            int i &#x3D; 0;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (E e : c) &#123; &#x2F;&#x2F; 遍历集合</span><br><span class="line">                    &#x2F;&#x2F; 检查元素是否为空</span><br><span class="line">                    checkNotNull(e);</span><br><span class="line">                    &#x2F;&#x2F; 存入ArrayBlockingQueue中</span><br><span class="line">                    items[i++] &#x3D; e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ArrayIndexOutOfBoundsException ex) &#123; &#x2F;&#x2F; 当初始化容量小于传入集合的大小时，会抛出异常</span><br><span class="line">                throw new IllegalArgumentException();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 元素数量</span><br><span class="line">            count &#x3D; i;</span><br><span class="line">            &#x2F;&#x2F; 初始化存元素的索引</span><br><span class="line">            putIndex &#x3D; (i &#x3D;&#x3D; capacity) ? 0 : i;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="put函数"><a href="#put函数" class="headerlink" title="put函数　　"></a>put函数　　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        &#x2F;&#x2F; 获取可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 如果当前线程未被中断，则获取锁</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count &#x3D;&#x3D; items.length) &#x2F;&#x2F; 判断元素是否已满</span><br><span class="line">                &#x2F;&#x2F; 若满，则等待</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#x2F;&#x2F; 入队列</span><br><span class="line">            enqueue(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　说明：put函数用于存放元素，在当前线程被中断时会抛出异常，并且当队列已经满时，会阻塞一直等待。其中，put会调用enqueue函数，enqueue函数源码如下　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">        &#x2F;&#x2F; assert lock.getHoldCount() &#x3D;&#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F; assert items[putIndex] &#x3D;&#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 获取数组</span><br><span class="line">        final Object[] items &#x3D; this.items;</span><br><span class="line">        &#x2F;&#x2F; 将元素放入</span><br><span class="line">        items[putIndex] &#x3D; x;</span><br><span class="line">        if (++putIndex &#x3D;&#x3D; items.length) &#x2F;&#x2F; 放入后存元素的索引等于数组长度（表示已满）</span><br><span class="line">            &#x2F;&#x2F; 重置存索引为0</span><br><span class="line">            putIndex &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 元素数量加1</span><br><span class="line">        count++;</span><br><span class="line">        &#x2F;&#x2F; 唤醒在notEmpty条件上等待的线程</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：enqueue函数用于将元素存入底层Object数组中，并且会唤醒等待notEmpty条件的线程。</p><h3 id="offer函数"><a href="#offer函数" class="headerlink" title="offer函数　　"></a>offer函数　　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">        &#x2F;&#x2F; 检查元素不能为空</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        &#x2F;&#x2F; 可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (count &#x3D;&#x3D; items.length) &#x2F;&#x2F; 元素个数等于数组长度，则返回</span><br><span class="line">                return false; </span><br><span class="line">            else &#123; &#x2F;&#x2F; 添加进数组</span><br><span class="line">                enqueue(e);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放数组</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：offer函数也用于存放元素，在调用ArrayBlockingQueue的add方法时，会间接的调用到offer函数，offer函数添加元素不会抛出异常，当底层Object数组已满时，则返回false，否则，会调用enqueue函数，将元素存入底层Object数组。并唤醒等待notEmpty条件的线程。</p><h3 id="take函数"><a href="#take函数" class="headerlink" title="take函数　"></a>take函数　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F; 可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 如果当前线程未被中断，则获取锁，中断会抛出异常</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count &#x3D;&#x3D; 0) &#x2F;&#x2F; 元素数量为0，即Object数组为空</span><br><span class="line">                &#x2F;&#x2F; 则等待notEmpty条件</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#x2F;&#x2F; 出队列</span><br><span class="line">            return dequeue();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：take函数用于从ArrayBlockingQueue中获取一个元素，其与put函数相对应，在当前线程被中断时会抛出异常，并且==当队列为空时，会阻塞一直等待==。其中，take会调用dequeue函数，dequeue函数源码如下　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private E dequeue() &#123;</span><br><span class="line">        &#x2F;&#x2F; assert lock.getHoldCount() &#x3D;&#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F; assert items[takeIndex] !&#x3D; null;</span><br><span class="line">        final Object[] items &#x3D; this.items;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        &#x2F;&#x2F; 取元素</span><br><span class="line">        E x &#x3D; (E) items[takeIndex];</span><br><span class="line">        &#x2F;&#x2F; 该索引的值赋值为null</span><br><span class="line">        items[takeIndex] &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 取值索引等于数组长度</span><br><span class="line">        if (++takeIndex &#x3D;&#x3D; items.length)</span><br><span class="line">            &#x2F;&#x2F; 重新赋值取值索引</span><br><span class="line">            takeIndex &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 元素个数减1</span><br><span class="line">        count--;</span><br><span class="line">        if (itrs !&#x3D; null) </span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">        &#x2F;&#x2F; 唤醒在notFull条件上等待的线程</span><br><span class="line">        notFull.signal();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：dequeue函数用于将取元素，并且会唤醒等待notFull条件的线程。</p><h3 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数　　"></a>poll函数　　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">        &#x2F;&#x2F; 重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 若元素个数为0则返回null，否则，调用dequeue，出队列</span><br><span class="line">            return (count &#x3D;&#x3D; 0) ? null : dequeue();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　说明：poll函数用于获取元素，其与offer函数相对应，不会抛出异常，当元素个数为0是，返回null，否则，调用dequeue函数，并唤醒等待notFull条件的线程。并返回。</p><h3 id="clear函数"><a href="#clear函数" class="headerlink" title="　 clear函数　　"></a>　 clear函数　　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">        &#x2F;&#x2F; 数组</span><br><span class="line">        final Object[] items &#x3D; this.items;</span><br><span class="line">        &#x2F;&#x2F; 可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 保存元素个数</span><br><span class="line">            int k &#x3D; count;</span><br><span class="line">            if (k &gt; 0) &#123; &#x2F;&#x2F; 元素个数大于0</span><br><span class="line">                &#x2F;&#x2F; 存数元素索引</span><br><span class="line">                final int putIndex &#x3D; this.putIndex;</span><br><span class="line">                &#x2F;&#x2F; 取元素索引</span><br><span class="line">                int i &#x3D; takeIndex;</span><br><span class="line">                do &#123;</span><br><span class="line">                    &#x2F;&#x2F; 赋值为null</span><br><span class="line">                    items[i] &#x3D; null;</span><br><span class="line">                    if (++i &#x3D;&#x3D; items.length) &#x2F;&#x2F; 重新赋值i</span><br><span class="line">                        i &#x3D; 0;</span><br><span class="line">                &#125; while (i !&#x3D; putIndex);</span><br><span class="line">                &#x2F;&#x2F; 重新赋值取元素索引</span><br><span class="line">                takeIndex &#x3D; putIndex;</span><br><span class="line">                &#x2F;&#x2F; 元素个数为0</span><br><span class="line">                count &#x3D; 0;</span><br><span class="line">                if (itrs !&#x3D; null)</span><br><span class="line">                    itrs.queueIsEmpty();</span><br><span class="line">                for (; k &gt; 0 &amp;&amp; lock.hasWaiters(notFull); k--) &#x2F;&#x2F; 若有等待notFull条件的线程，则逐一唤醒</span><br><span class="line">                    notFull.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure><p>clear函数用于清空ArrayBlockingQueue，并且会释放所有等待notFull条件的线程（存放元素的线程）。</p><p>ArrayBlockingQueue是通过ReentrantLock和Condition条件来保证多线程的正确访问的</p>]]></content>
    
    
    <summary type="html">ArrayBlockingQueue的底层数据结构是数组,对数组的访问添加了锁的机制，使其能够支持多线程并发。 属性　　</summary>
    
    
    
    <category term="JUC" scheme="http://example.com/categories/JUC/"/>
    
    
    <category term="ArrayBlockingQueue" scheme="http://example.com/tags/ArrayBlockingQueue/"/>
    
  </entry>
  
  <entry>
    <title>BlockingQueue</title>
    <link href="http://example.com/2020/08/08/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/7%E3%80%81BlockingQueue/"/>
    <id>http://example.com/2020/08/08/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/7%E3%80%81BlockingQueue/</id>
    <published>2020-08-08T08:50:34.000Z</published>
    <updated>2020-09-19T09:26:47.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><ul><li>在队列为空时，获取元素的线程会等待队列变为非空</li><li>当队列满时，存储元素的线程会等待队列可用</li></ul><p>应用：阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>阻塞队列提供了四种处理方法:<br>方法\处理方式 | 抛出异常| 返回特殊值| 一直阻塞| 超时退出<br>—|—|—|—|—<br>插入方法 | add(e)| offer(e)| put(e)| offer(e,time,unit)<br>移除方法 | remove()|poll()|take()|     poll(time,unit)<br>检查方法| element()| peek()| | </p><p>插入方法    add(e)    offer(e)    put(e)    offer(e,time,unit)<br>移除方法    remove()    poll()    take()    poll(time,unit)<br>检查方法    element()    peek()    不可用    不可用</p><ul><li>抛出异常：是指当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</li><li>返回特殊值：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元素，如果没有则返回null</li><li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻塞消费者线程，直到队列可用。</li><li>超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。</li></ul><p>JDK7提供了7个阻塞队列。分别是</p><ul><li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</li><li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。默认情况下元素采取自然顺序排列，也可以通过比较器comparator来指定元素的排序规则。元素按照升序排列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul><p>阻塞队列简单实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class BlockingQueue &#123;</span><br><span class="line"></span><br><span class="line">    private List queue &#x3D; new LinkedList();</span><br><span class="line">    </span><br><span class="line">    private int  limit &#x3D; 10;</span><br><span class="line">    </span><br><span class="line">    public BlockingQueue(int limit)&#123;</span><br><span class="line">    </span><br><span class="line">    this.limit &#x3D; limit;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public synchronized void enqueue(Object item)</span><br><span class="line">    </span><br><span class="line">    throws InterruptedException  &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;当队列满时，存储元素的线程会等待队列可用</span><br><span class="line">    </span><br><span class="line">    while(this.queue.size() &#x3D;&#x3D; this.limit) &#123;</span><br><span class="line">    </span><br><span class="line">    wait();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(this.queue.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    </span><br><span class="line">    notifyAll();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    this.queue.add(item);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public synchronized Object dequeue()</span><br><span class="line">    </span><br><span class="line">    throws InterruptedException&#123;</span><br><span class="line">    &#x2F;&#x2F;在队列为空时，获取元素的线程会等待队列变为非空</span><br><span class="line">    </span><br><span class="line">    while(this.queue.size() &#x3D;&#x3D; 0)&#123;</span><br><span class="line">    </span><br><span class="line">    wait();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(this.queue.size() &#x3D;&#x3D; this.limit)&#123;</span><br><span class="line">    </span><br><span class="line">    notifyAll();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return this.queue.remove(0);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">阻塞队列 在队列为空时，获取元素的线程会等待队列变为非空</summary>
    
    
    
    <category term="JUC" scheme="http://example.com/categories/JUC/"/>
    
    
    <category term="BlockingQueue" scheme="http://example.com/tags/BlockingQueue/"/>
    
  </entry>
  
  <entry>
    <title>synchronized优化</title>
    <link href="http://example.com/2020/08/02/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/6%E3%80%81synchronized%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2020/08/02/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/6%E3%80%81synchronized%E4%BC%98%E5%8C%96/</id>
    <published>2020-08-02T09:54:56.000Z</published>
    <updated>2020-09-19T09:26:47.816Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Synchronized的实现："><a href="#Synchronized的实现：" class="headerlink" title="Synchronized的实现："></a>Synchronized的实现：</h4><ul><li>Synchronized同步代码块基于monitorenter进入和monitorexit退出（JVM保证其成对出现） Monitor监视器对象实现</li><li>Synchronized同步方法基于ACC_SYNCHRONIZED 标志来隐式实现的</li><li></li></ul><p>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。==任何对象都有 一个monitor与之关联==，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter 指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象在内存中的布局分为三块区域：对象头、实例变量和填充数据</p><p><img src="https://images2017.cnblogs.com/blog/918656/201708/918656-20170824180707777-1312147323.png" alt="image"></p><ul><li><p>实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</p></li><li><p>填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点了解即可。</p></li><li><p>对象头：Hotspot虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、KlassPointer（类型指针）虚拟机通过这个指针来确定这个对象是哪个类的实例</p></li></ul><p>（1）Mark Word它是实现轻量级锁和偏向锁的关键。用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>jdk1.6以后对synchronized的锁进行了优化：==无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁==(单向)</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让其获得锁的代价更低而引入了偏向锁。</p><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。</p><p>如果测试成功，表示线程已经获得了锁。</p><p>如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成01（表示当前是偏向锁）。</p><p>如果没有设置，则使用轻量级锁使用CAS竞争。</p><p>如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p><p><img src="http://s4.sinaimg.cn/mw690/003wfAbNzy6MSO08bIvf3&690" alt="image"></p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>通过CAS竞争锁，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p><p><img src="http://s1.sinaimg.cn/mw690/003wfAbNzy6MSOsRjkAa0&690" alt="image"></p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。<br><img src="https://img2018.cnblogs.com/blog/1323383/201903/1323383-20190306134123353-740044884.png" alt="image"></p><h2 id="jvm其他对锁的其他优化方式："><a href="#jvm其他对锁的其他优化方式：" class="headerlink" title="jvm其他对锁的其他优化方式："></a>jvm其他对锁的其他优化方式：</h2><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void synchronized()&#123;</span><br><span class="line">    &#x2F;&#x2F;业务处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程获取锁，并执行过程中，切换到线程B，线程不能获取锁，便放弃CPU执行时间。挂起线程和恢复线程的操作比较耗费性能。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行。让线程执行一个忙循环（自旋），不放弃CPU执行时间，等待一下线程A释放锁。这项技术就是所谓的自旋锁。</p><p>JDK6之前使用-XX：+UseSpinning参数来开启。jdk6之后默认开启。自旋次数的默认值是10次，用户可以使用参数-XX：PreBlockSpin来更改。超过自旋次数，线程便挂起。</p><p>如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源。</p><p>在JDK 1.6中引入了自适应的自旋锁。==由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定自旋次数==。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。 另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。 </p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>==虚拟机对检测到不可能存在共享数据竞争的锁进行消除==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String concatString（String s1，String s2，String s3）&#123;</span><br><span class="line">    return s1+s2+s3；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK5之后编辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String concatString（String s1，String s2，String s3）&#123;</span><br><span class="line">    StringBuffer sb&#x3D;new StringBuffer（）；</span><br><span class="line">    sb.append（s1）；</span><br><span class="line">    sb.append（s2）；</span><br><span class="line">    sb.append（s3）；</span><br><span class="line">    return sb.toString（）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个StringBuffer.append（）方法中都有一个同步块，锁就是sb对象。 虚拟机观察变量sb，很快就会发现它的动态作用域被限制在concatString（）方法内部。 也就是说，sb的所有引用永远不会“逃逸”到concatString（）方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>==将连续的加锁操作， 精简到只加一次锁==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String concatString（String s1，String s2，String s3）&#123;</span><br><span class="line">    StringBuffer sb&#x3D;new StringBuffer（）；</span><br><span class="line">    sb.append（s1）；</span><br><span class="line">    sb.append（s2）；</span><br><span class="line">    sb.append（s3）；</span><br><span class="line">    return sb.toString（）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，示例代码就是扩展到第一个append（）操作之前直至最后一个append（）操作之后，这样只需要加锁一次就可以了。</p>]]></content>
    
    
    <summary type="html">Synchronized的实现： Synchronized同步代码块基于monitorenter进入和monitorexit退出（JVM保证其成对出现） Monitor监视器对象实现</summary>
    
    
    
    <category term="多线程" scheme="http://example.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="synchronized优化" scheme="http://example.com/tags/synchronized%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>多线程的优点与缺点</title>
    <link href="http://example.com/2020/08/02/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9/"/>
    <id>http://example.com/2020/08/02/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9/</id>
    <published>2020-08-02T09:38:11.000Z</published>
    <updated>2020-09-19T09:26:47.800Z</updated>
    
    <content type="html"><![CDATA[<p>减少上下文切换的方案：</p><ul><li>无锁并发编程：多线程竞争时，会引起上下文切换（因为只有一个线程能进入临界区，获取锁失败的线程会被阻塞在临界区之外，线程此时挂起），所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的 ID 按照 Hash 取模分段，不同的线程处理不同段的数据。</li><li>CAS 算法：Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁。（这种方式思想同无锁并发编程一样，只不过这是一种具体的且常见的实现手段）</li><li>使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。（使用少量线程不止可以减少上下文切换，同时也减少了系统的开销）</li><li>使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li></ul><ul><li>缓存导致的可见性问题</li><li>线程切换带来的原子性问题，</li><li>指令重排带来的有序性问题。</li></ul><h2 id="多线程优点："><a href="#多线程优点：" class="headerlink" title="多线程优点："></a>多线程优点：</h2><h4 id="1-资源利用率更好，发挥多处理器的能力"><a href="#1-资源利用率更好，发挥多处理器的能力" class="headerlink" title="1.  资源利用率更好，发挥多处理器的能力"></a>1.  资源利用率更好，发挥多处理器的能力</h4><p>从磁盘读取一个文件需要5秒，处理一个文件需要2秒。处理两个文件则需要：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5秒读取文件A</span><br><span class="line">2秒处理文件A</span><br><span class="line">5秒读取文件B</span><br><span class="line">2秒处理文件B</span><br><span class="line">---------------------</span><br><span class="line">6总共需要14秒</span><br></pre></td></tr></table></figure><p>大部分的CPU时间用于等待磁盘去读取数据。在这段时间里，CPU非常的空闲。它可以做一些别的事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5秒读取文件A</span><br><span class="line">5秒读取文件B + 2秒处理文件A</span><br><span class="line">2秒处理文件B</span><br><span class="line">---------------------</span><br><span class="line">总共需要12秒</span><br></pre></td></tr></table></figure><p>总结：CPU能够在等待磁盘/网络IO的时候做一些其他的事情。</p><h4 id="2、公平性"><a href="#2、公平性" class="headerlink" title="2、公平性"></a>2、公平性</h4><p>通过粗粒度的时间分片，使用户和程序都能共享计算机资源，而不是等一个进程执行完了，在执行下一个进程。</p><h4 id="3-程序设计在某些情况下更简单"><a href="#3-程序设计在某些情况下更简单" class="headerlink" title="3.  程序设计在某些情况下更简单"></a>3.  程序设计在某些情况下更简单</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多线程处理一个程序比多进程处理同一个程序设计更容易实现</span><br></pre></td></tr></table></figure><h4 id="3-程序响应更快"><a href="#3-程序响应更快" class="headerlink" title="3. 程序响应更快"></a>3. 程序响应更快</h4><h2 id="多线程缺点："><a href="#多线程缺点：" class="headerlink" title="多线程缺点："></a>多线程缺点：</h2><h4 id="1-并发线程安全问题"><a href="#1-并发线程安全问题" class="headerlink" title="1. 并发线程安全问题"></a>1. 并发线程安全问题</h4><h4 id="2、活跃性问题"><a href="#2、活跃性问题" class="headerlink" title="2、活跃性问题"></a>2、活跃性问题</h4><p>在单线程中活跃性问题表现之一就是无限循环，使得循环后面的代码无法得到执行。多线程活跃性时常见形式是死锁，线程A在等待线程B释放锁，而线程B永远不释放</p><h4 id="3-性能问题"><a href="#3-性能问题" class="headerlink" title="3.性能问题"></a>3.性能问题</h4><ul><li>如上下文切换的开销等性能问题，当CPU从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。上下文切换并不廉价。</li></ul><p>lmbench3可检测上下文切换的时间</p><ul><li>增加资源消耗：线程在运行的时候需要从计算机里面得到一些资源。除了CPU，线程还需要一些内存来维持它本地的堆栈。它也需要占用操作系统中一些资源来管理线程。</li></ul>]]></content>
    
    
    <summary type="html">减少上下文切换的方案： 无锁并发编程：多线程竞争时，会引起上下文切换（因为只有一个线程能进入临界区，获取锁失败的线程会被阻塞在临界区之外，线程此时挂起），所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的 ID 按照 Hash 取模分段，不同的线程处理不同段的数据。</summary>
    
    
    
    <category term="多线程" scheme="http://example.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程的优点与缺点" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9/"/>
    
  </entry>
  
</feed>
