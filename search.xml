<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态代理与反射</title>
      <link href="2020/09/19/Study%20notes/3%E3%80%81java/10%E3%80%81%E5%8F%8D%E5%B0%84/2%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
      <url>2020/09/19/Study%20notes/3%E3%80%81java/10%E3%80%81%E5%8F%8D%E5%B0%84/2%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>利用Java反射机制你可以在运行期动态的创建接口的实现。java.lang.reflect.Proxy类就可以实现这一功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler handler &#x3D; new MyInvocationHandler();</span><br><span class="line">MyInterface proxy &#x3D; (MyInterface) Proxy.newProxyInstance(</span><br><span class="line">                            MyInterface.class.getClassLoader(),</span><br><span class="line">                            new Class[] &#123; MyInterface.class &#125;,</span><br><span class="line">                            handler);</span><br></pre></td></tr></table></figure><ul><li>1、类加载器（ClassLoader）用来加载动态代理类。</li><li>2、一个要实现的接口的数组。</li><li>3、一个InvocationHandler把所有方法的调用都转到代理上。</li></ul><p>所有对proxy的调用都委托到实现了InvocationHandler接口的handler上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyInvocationHandler implements InvocationHandler&#123;</span><br><span class="line"></span><br><span class="line">  public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">  throws Throwable &#123;</span><br><span class="line">    &#x2F;&#x2F;do something &quot;dynamic&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>proxy参数是实现要代理接口的动态代理对象。通常你是不需要他的。</li><li>Method对象参数代表了被动态代理的接口中要调用的方法，从这个method对象中你可以获取到这个方法名字，方法的参数，参数类型等等信息</li></ul><p>动态代理常被应用到以下几种情况中</p><ul><li>数据库连接以及事物管理</li><li>单元测试中的动态Mock对象</li><li>自定义工厂与依赖注入（DI）容器之间的适配器</li><li>类似AOP的方法拦截器</li></ul>]]></content>
      
      
      <categories>
          
          <category> 反射 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态代理与反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo常见错误</title>
      <link href="2020/09/18/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/hexo/Hexo%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
      <url>2020/09/18/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/hexo/Hexo%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<p>更换next主题时候，启动的时候报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WARN  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">WARN  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ATTENTION! &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">WARN  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">WARN   NexT repository is moving here: https:&#x2F;&#x2F;github.com&#x2F;theme-next</span><br><span class="line">WARN  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">WARN   It&#39;s rebase to v6.0.0 and future maintenance will resume there</span><br><span class="line">WARN  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">INFO  Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop.</span><br><span class="line">INFO  See you again</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问首页出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &#39;_layout.swig&#39; %&#125; &#123;% import &#39;_macro&#x2F;post.swig&#39; as post_template %&#125; &#123;% import &#39;_macro&#x2F;sidebar.swig&#39; as sidebar_template %&#125; &#123;% block title %&#125;&#123;&#123; config.title &#125;&#125;&#123;% if theme.index_with_subtitle and config.subtitle %&#125; - &#123;&#123;config.subtitle &#125;&#125;&#123;% endif %&#125;&#123;% endblock %&#125; &#123;% block page_class %&#125; &#123;% if is_home() %&#125;page-home&#123;% endif -%&#125; &#123;% endblock %&#125; &#123;% block content %&#125;</span><br><span class="line">&#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125;</span><br><span class="line">&#123;% include &#39;_partials&#x2F;pagination.swig&#39; %&#125; &#123;% endblock %&#125; &#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125; &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>next官网的指南和相当多的博客上的下载网址都是旧的，会出现以上错误。根据提示说明使用命令行下载的时候，next主题下载网址不对，应该改成命令提示中的网站</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next.git</span><br></pre></td></tr></table></figure><p>其他常见错误：<a href="http://theme-next.iissnan.com/faqs.html">http://theme-next.iissnan.com/faqs.html</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo常见错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github</title>
      <link href="2020/09/18/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/hexo/Hexo+Github/"/>
      <url>2020/09/18/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/hexo/Hexo+Github/</url>
      
        <content type="html"><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>安装 Hexo 相当简单,但若Node安装有问题，环境变量配置等出问题，后面安装hexo很恶心。</p><p>Node.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v10.13.0&#x2F;node-v10.13.0-x64.msi(Winx64)</span><br></pre></td></tr></table></figure><p>Git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;git-for-windows&#x2F;git&#x2F;releases&#x2F;download&#x2F;v2.19.1.windows.1&#x2F;Git-2.19.1-64-bit.exe（Win x64）</span><br></pre></td></tr></table></figure><p>检查Node.js 和 Git </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure><p>主要nodejs和npm版本需要对应上,</p><p>参考nodejs和npm版本对应关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;nodejs.org&#x2F;zh-cn&#x2F;download&#x2F;releases&#x2F;</span><br></pre></td></tr></table></figure><p>安装hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>查看版本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>安装Hexo 插件：自动生成sitemap,Rss，部署到git等，建议安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked@0.2 --save</span><br><span class="line">npm install hexo-renderer-stylus@0.2 --save</span><br><span class="line">npm install hexo-generator-feed@1 --save</span><br><span class="line">npm install hexo-generator-sitemap@1 --save</span><br><span class="line">npm install --save hexo-deployer-git</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Hexo常用的几个命令</p><p>新建博客目录，进入，初始化工作空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>1、创建新博文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &quot;postName&quot; #新建文章</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#清除缓存</span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">#生成静态站点文件</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">#运行服务器</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">#发布到github</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>部署到Github前需要配置_config.yml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: git@github.com:EZLippi&#x2F;EZLippi.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>next主题配置主页说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;theme-next.iissnan.com&#x2F;theme-settings.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo+Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无标题Markdown</title>
      <link href="2020/09/17/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/3%E3%80%81%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Gradle/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/"/>
      <url>2020/09/17/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/3%E3%80%81%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Gradle/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/</url>
      
        <content type="html"><![CDATA[<p><a href="https://gradle.org/releases/">https://gradle.org/releases/</a> 这个是发布版，当然你还可以去 <a href="https://services.gradle.org/">https://services.gradle.org/</a> 下载更新的版本。本人下载5.2.1的发布版 <a href="https://gradle.org/next-steps/?version=5.2.1&amp;format=all">https://gradle.org/next-steps/?version=5.2.1&amp;format=all</a> </p><p>二、配置环境变量：GRADLE_HOME 变量值为Gradle文件解压的实际路径，本文为例：E:\Gradle\gradle-5.2.1-all\gradle-5.2.1</p><p>　　在系统变量 path中加入：%GRADLE_HOME%\bin;<br>　　<br>　　<br>　　在cmd输入gradle -v验证是否安装成功</p>]]></content>
      
      
      <categories>
          
          <category> Gradle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标题Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP、BASE理论</title>
      <link href="2020/09/16/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2%E3%80%81CAP%E3%80%81BASE%E7%90%86%E8%AE%BA/"/>
      <url>2020/09/16/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2%E3%80%81CAP%E3%80%81BASE%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<ul><li>1、商品服务请求主数据库写入商品信息（添加商品、修改商品、删除商品）</li><li>2、主数据库向商品服务响应写入成功。</li><li>3、商品服务请求从数据库读取商品信息。</li></ul><h4 id="C-Consistency："><a href="#C-Consistency：" class="headerlink" title="C  Consistency："></a>C  Consistency：</h4><p>一致性是指写操作后的读操作可以读取到最新的数据状态，当数据分布在多个节点上，从任意结点读取到的数据都 是最新的状态。<br>上图中，商品信息的读写要满足一致性就是要实现如下目标：</p><ul><li>1、商品服务写入主数据库成功，则向从数据库查询新数据也成功。</li><li>2、商品服务写入主数据库失败，则向从数据库查询新数据也失败。 如何实现一致性？</li><li>3、写入主数据库后要将数据同步到从数据库。</li><li>4、写入主数据库后，在向从数据库同步期间要将从数据库锁定，待同步完成后再释放锁，以免在新数据写入成功 后，向从数据库查询到旧的数据。</li></ul><p>分布式系统一致性的特点：</p><ul><li>1、由于存在数据同步的过程，写操作的响应会有一定的延迟。 </li><li>2、为了保证数据一致性会对资源暂时锁定，待数据同步完成释放锁定资源。 </li><li>3、如果请求数据同步失败的结点则会返回错误信息，一定不会返回旧数据。 </li></ul><h4 id="A-Availability-："><a href="#A-Availability-：" class="headerlink" title="A - Availability ："></a>A - Availability ：</h4><p>可用性是指任何事务操作都可以得到响应结果，且不会出现响应超时或响应错误。 上图中，商品信息读取满足可用性就是要实现如下目标： </p><ul><li>1、从数据库接收到数据查询的请求则立即能够响应数据查询结果。 </li><li>2、从数据库不允许出现响应超时或响应错误。 如何实现可用性？ </li><li>1、写入主数据库后要将数据同步到从数据库。 </li><li>2、由于要保证从数据库的可用性，不可将从数据库中的资源进行锁定。 </li><li>3、即时数据还没有同步过来，从数据库也要返回要查询的数据，哪怕是旧数据，如果连旧数据也没有则可以按照 约定返回一个默认信息，但不能返回错误或响应超时。 分布式系统可用性的特点： 1、 所有请求都有响应，且不会出现响应超时或响应错误。</li></ul><h5 id="P-Partition-tolerance-："><a href="#P-Partition-tolerance-：" class="headerlink" title="P - Partition tolerance ："></a>P - Partition tolerance ：</h5><p>通常分布式系统的各各结点部署在不同的子网，这就是网络分区，不可避免的会出现由于网络问题而导致结点之间 通信失败，此时仍可对外提供服务，这叫分区容忍性。 上图中，商品信息读写满足分区容忍性就是要实现如下目标： </p><ul><li>1、主数据库向从数据库同步数据失败不影响读写操作。 </li><li>2、其一个结点挂掉不影响另一个结点对外提供服务。 如何实现分区容忍性？ </li><li>1、尽量使用异步取代同步操作，例如使用异步方式将数据从主数据库同步到从数据，这样结点之间能有效的实现 松耦合。 </li><li>2、添加从数据库结点，其中一个从结点挂掉其它从结点提供服务。 分布式分区容忍性的特点： 1、分区容忍性分是布式系统具备的基本能力。</li></ul><p>一般都会做出如下选择：保证P和A，舍弃C强一致，保证最终一致性。</p><p>BASE理论</p><p>1、理解强一致性和最终一致性 CAP理论告诉我们一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍 性（Partition tolerance）这三项中的两项，其中AP在实际应用中较多，AP即舍弃一致性，保证可用性和分区容忍 性，但是在实际生产中很多场景都要实现一致性，比如前边我们举的例子主数据库向从数据库同步数据，即使不要 一致性，但是最终也要将数据同步成功来保证数据一致，这种一致性和CAP中的一致性不同，CAP中的一致性要求 在任何时间查询每个结点数据都必须一致，它强调的是强一致性，但是最终一致性是允许可以在一段时间内每个结 点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。 </p><p>2、Base理论介绍 BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩 写。</p><p>==BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性==，当出现故障允许部分不可用但要保证 核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为“柔 性事务”。</p><ul><li>基本可用:分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如，电商网站交易付款出 现问题了，商品依然可以正常浏览。 </li><li>软状态:由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫软状态），这个状态不影响系统可用 性，如订单的”支付中”、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。 </li><li>最终一致:最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的”支付中”状态，最终会变 为“支付成功”或者”支付失败”，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式事务解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP、BASE理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务-TCC补偿机制</title>
      <link href="2020/09/16/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/5%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-TCC%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6/"/>
      <url>2020/09/16/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/5%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-TCC%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>TCC事务是Try、Commit、Cancel三种指令的缩写，其逻辑模式类似于数据库层的XA两阶段提交，==但是实现方式是在代码层面来人为实现==。</p><p>TCC开源框架ByteTCC，tcc-transaction，himly,EasyTransaction</p><p>1、先来Try一下，不要把业务逻辑完成，先试试看，看各个服务能不能基本正常运转，能不能先冻结我需要的资源。如果Try都ok，也就是说，底层的数据库、redis、elasticsearch、MQ都是可以写入数据的，并且你保留好了需要使用的一些资源（比如冻结了一部分库存）。</p><p>2、再执行各个服务的Confirm逻辑，基本上Confirm就可以很大概率保证一个分布式事务的完成了。</p><p>3、如果try或Confirm 失败了则执行cancel回滚逻辑（如果cancel回滚阶段异常，可多次调用等补偿机制），所有服务都不要执行任何设计的业务逻辑。保证大家要么一起成功，要么一起失败。</p><h4 id="示例：下单减库存的方案-伪代码"><a href="#示例：下单减库存的方案-伪代码" class="headerlink" title="示例：下单减库存的方案[伪代码]"></a>示例：下单减库存的方案[伪代码]</h4><p>单机服务各个系统都在同一台服务器上，可以直接执行以下伪代码，本地事务保证数据一致性，任何一步异常则回滚整个事务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">订单系统：下单</span><br><span class="line">支付系统：支付[成功]</span><br><span class="line">优惠券系统：扣减优惠券</span><br><span class="line">库存系统：减库存</span><br><span class="line">用户系统：增加用户积分</span><br></pre></td></tr></table></figure><p>分布式系统中，各个服务都在不同机器上，无法利用本地事务。则可以使用TCC补偿机制</p><p>try阶段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">订单系统：下单</span><br><span class="line">优惠券系统：先冻结优惠券</span><br><span class="line">库存系统：先预占库存</span><br><span class="line">用户系统：先预增加用户积分</span><br></pre></td></tr></table></figure><p>Confirm阶段：主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。(Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">支付系统：支付[成功]</span><br><span class="line">优惠券系统：解冻优惠券-真正扣减优惠券</span><br><span class="line">库存系统：释放预占库存-真正减库存</span><br><span class="line">用户系统：回滚预增加的用户积分-真正增加用户积分</span><br></pre></td></tr></table></figure><p>cancel阶段：业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">支付系统：支付[失败]</span><br><span class="line">优惠券系统：解冻优惠券</span><br><span class="line">库存系统：释放预占库存</span><br><span class="line">用户系统：回滚预增加的用户积分</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/eluanshi12/article/details/84528393">https://blog.csdn.net/eluanshi12/article/details/84528393</a></p><p>TCC可以让应用自己定义数据操作的粒度，使 得降低锁冲突、提高吞吐量成为可能<br>不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。此 外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式事务解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务-TCC补偿机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务-异步消息确保</title>
      <link href="2020/09/16/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/6%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E7%A1%AE%E4%BF%9D/"/>
      <url>2020/09/16/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/6%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E7%A1%AE%E4%BF%9D/</url>
      
        <content type="html"><![CDATA[<p>==当事务发起方执行完成本地事务后并发出一条消息，事务参与方(消息消费者)一定能 够接收消息并处理事务成功==</p><p>此可靠消息最终一致性方案要解决以下几个问题：</p><p>1.本地事务与消息发送的原子性问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">begin transaction； </span><br><span class="line">&#x2F;&#x2F;1.发送MQ </span><br><span class="line">&#x2F;&#x2F;2.本地数据库操作 </span><br><span class="line">commit transation;</span><br><span class="line"></span><br><span class="line">begin transaction； </span><br><span class="line">&#x2F;&#x2F;1.本地数据库操作 </span><br><span class="line">&#x2F;&#x2F;2.发送MQ </span><br><span class="line">commit transation;</span><br></pre></td></tr></table></figure><p>虽然是原子性，两种方式都有可能是数据库操作异常，但MQ最终是发送出去，导致数据不一致</p><p>2、事务参与方接收消息的可靠性<br>事务参与方必须能够从消息队列接收到消息，如果接收消息失败可以重复接收消息。</p><p>3、消息重复消费的问题：下游做消息消费的幂等处理</p><p>RocketMQ实现可靠消息最终一致性事务。针对以上问题的解决方案：</p><p>RocketMQ主要解决了两个功能： </p><ul><li>1、本地事务与消息发送的原子性问题。 </li><li>2、事务参与方接收消息的可靠性。<br>具体参考笔记：RocketMQ事务消息<br><a href="http://note.youdao.com/noteshare?id=420d588c673e85de9add4c9089db8062&amp;sub=C4D87D9DD04441C7845C5131269D9D1F">http://note.youdao.com/noteshare?id=420d588c673e85de9add4c9089db8062&amp;sub=C4D87D9DD04441C7845C5131269D9D1F</a></li></ul><p>可靠消息最终一致性就是保证消息从生产方经过消息中间件传递到消费方的一致性，本案例使用了RocketMQ作为 消息中间件 可靠消息最终一致性事务适合执行周期长且实时性要求不高的场景。引入消息机制后，同步的事务操作变为基于消 息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式事务解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务-异步消息确保 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eureka原理</title>
      <link href="2020/09/14/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/1%E3%80%81Eureka/4%E3%80%81eureka%E5%8E%9F%E7%90%86/"/>
      <url>2020/09/14/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/1%E3%80%81Eureka/4%E3%80%81eureka%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/suifeng629/article/details/102812715">https://blog.csdn.net/suifeng629/article/details/102812715</a></p><p>1、Eureka Client会每隔30秒去找Eureka Server拉取最近注册表的变化</p><p>2、Eureka Client每隔30秒会发送一次心跳到Eureka Server</p><p>如此高频率的请求，Eureka是如何抗住的。</p><h3 id="1、Eureka基于内存-存储的注册表"><a href="#1、Eureka基于内存-存储的注册表" class="headerlink" title="1、Eureka基于内存 存储的注册表"></a>1、Eureka基于内存 存储的注册表</h3><p>Eureka Server的注册表直接基于纯内存，即在内存里维护了一个数据结构。各个服务的注册、服务下线、服务故障，全部会在内存里维护和更新这个注册表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><ul><li>外层key是实例名称：appName，</li><li>value则代表了一个服务的多个服务实例。内层的key是instanceId(服务实例的id)</li></ul><p>value是一个叫做Lease的类，它的泛型是一个叫做InstanceInfo</p><ul><li>Lease：里面则会维护每个服务最近一次发送心跳的时间</li><li>InstanceInfo：服务实例的具体信息，比如机器的ip地址、hostname以及端口号<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;appName, Map&lt;instanceId, Lease&lt;InstanceInfo&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、多级缓存机制"><a href="#2、多级缓存机制" class="headerlink" title="2、多级缓存机制"></a>2、多级缓存机制</h3><p>在拉取注册表的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一步从ReadOnlyCacheMap里查缓存的注册表。</span><br><span class="line">    有--&gt;直接返回</span><br><span class="line">    没有--&gt;就从ReadWriteCacheMap里查缓存的注册表。</span><br><span class="line">        有--&gt;直接返回</span><br><span class="line">        没有--&gt;从内存中获取实际的注册表数据</span><br><span class="line">            有--&gt;直接返回</span><br><span class="line">            没有--&gt; 内存中获取实际的注册表数据</span><br></pre></td></tr></table></figure><p>在注册表发生变更的时候：</p><ul><li>会在内存中更新变更的注册表数据，同时过期掉ReadWriteCacheMap。</li><li>此过程不会影响ReadOnlyCacheMap提供人家查询注册表。</li><li>一段时间内（默认30秒），各服务拉取注册表会直接读ReadOnlyCacheMap</li><li>30秒过后，Eureka Server的后台线程发现ReadWriteCacheMap已经清空了，也会清空ReadOnlyCacheMap中的缓存</li><li>下次有服务拉取注册表，又会从内存中获取最新的数据了，同时填充各个缓存。</li></ul><p>多级缓存机制的优点是什么？</p><ul><li>尽可能保证了内存注册表数据不会出现频繁的读写冲突问题。</li><li>并且进一步保证对Eureka Server的大量请求，都是快速从纯内存走，性能极高。</li></ul><p>在接受客户端注册的时候，服务端会将读写缓存的key清掉，30s后只读缓存从读写缓存拉取数据的时候，该服务列表获取到的是最新的数据。如果客户端下线，同样地，读写缓存也会被清除掉。==所以极端情况，最长30s后，客户端才能获取到最新的服务列表==。<br>因为注册服务更重要的是可用性，我们可以接受短期内达不到一致性的状况</p>]]></content>
      
      
      <categories>
          
          <category> Eureka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eureka原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gateway原理</title>
      <link href="2020/09/14/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/5%E3%80%81%E7%BD%91%E5%85%B3/4%E3%80%81gateway%E5%8E%9F%E7%90%86/"/>
      <url>2020/09/14/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/5%E3%80%81%E7%BD%91%E5%85%B3/4%E3%80%81gateway%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Spring Cloud Gateway 依赖 Spring Boot 和 Spring WebFlux，基于 Netty 运行。它不能在传统的 servlet 容器中工作，也不能构建成 war 包。struts2，springmvc等都是基于Servlet API与Servlet容器基础之上运行的</p><p>Gateway是基于WebFlux的. webflux，基于 spring 5.x 和 reactor-netty 构建，不依赖于 Servlet 容器，但是可以在支持 Servlet 3.1 Non-Blocking IO API 的容器上运行。</p><p>Spring Cloud Gateway 核心概念</p><p>Route<br>Route 是网关的基础元素，由 ID、目标 URI、断言、过滤器组成。当请求到达网关时，由 Gateway Handler Mapping 通过断言进行路由匹配（Mapping），当断言为真时，匹配到路由。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Route implements Ordered &#123;</span><br><span class="line">    &#x2F;&#x2F;id，标识符，区别于其他 Route。</span><br><span class="line">    private final String id;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;路由指向的目的地 uri</span><br><span class="line">    private final URI uri;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;用于多个 Route 之间的排序，数值越小排序越靠前</span><br><span class="line">    private final int order;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;谓语，表示匹配该 Route 的前置条件，即满足相应的条件才会被路由到目的地 uri。</span><br><span class="line">    private final AsyncPredicate&lt;ServerWebExchange&gt; predicate;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;过滤器用于处理切面逻辑，如路由转发前修改请求头等。</span><br><span class="line">    private final List&lt;GatewayFilter&gt; gatewayFilters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）Predicate<br>Predicate 是 Java 8 中提供的一个函数。输入类型是 Spring Framework ServerWebExchange。它允许开发人员匹配来自 HTTP 的请求，例如请求头或者请求参数。简单来说它就是匹配条件。</p><p>3）Filter<br>Filter 是 Gateway 中的过滤器，可以在请求发出前后进行一些业务上的处理。</p><p>gateway 的工作机制：Gateway 接收客户端请求。客户端请求与路由信息进行匹配，匹配成功的才能够被发往相应的下游服务。请求经过 Filter 过滤器链，执行 pre 处理逻辑，如修改请求头信息等。请求被转发至下游服务并返回响应。响应经过 Filter 过滤器链，执行 post 处理逻辑。向客户端响应应答。<br><img src="https://docs.spring.io/spring-cloud-gateway/docs/2.2.5.RELEASE/reference/html/images/spring_cloud_gateway_diagram.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 网关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gateway原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFF</title>
      <link href="2020/09/14/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/BFF/"/>
      <url>2020/09/14/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/BFF/</url>
      
        <content type="html"><![CDATA[<p>将组装、聚合、裁剪这部分业务单独拎出来，组成一个叫Back-end for Front-end的中间层。</p><p>BFF作为中间层，优点是：</p><p>前后端彻底分离，即便是后期有微服务迁移，也不需改动前端代码</p><p>业务更向前靠拢，琐碎的api由前端开发自己决定，更适配前端框架</p><p>BFF可以自开mock，插件也能生成API文档，相比后端单开这类服务要方便些吧</p><p>留给后端更清晰的服务边界，只需要提供粗粒度的接口即可</p><p>BFF的缺点</p><p>中间层转发会增加请求延迟。</p><p>需要保证端到端测试</p><p>必须随时准备好后端异常请求</p><p>BFF分成会增加开发成本</p>]]></content>
      
      
      <categories>
          
          <category> spring-cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何存储IP地址</title>
      <link href="2020/09/14/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8IP%E5%9C%B0%E5%9D%80/"/>
      <url>2020/09/14/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8IP%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<p> IP地址 本来就是一个字符串，存放在数据库作为字符穿类型</p><p> 网络地址：<br>192.168.33.123每一个值最大不会越过255，也就是十六进制的FF，两个Byte刚好表示的最大值是255，<br>这样子，就可以用一个32位的整形来保存这个IP<br>1100 0000 1010 1000 0010 0001 0111 1011<br>把这些二进制合在一起就是32位的数了<br>11000000101010000010000101111011<br>十进制为<br>3232244091</p><p>《高性能MySQL 第3版》第4.1.7节时，作者建议当存储IPv4地址时，应该使用32位的无符号整数（UNSIGNED INT）来存储IP<br>地址<br>优点：</p><ul><li>节省空间，不管是数据存储空间，还是索引存储空间</li><li>便于使用范围查询（BETWEEN…AND），且效率更高</li></ul><p>如果是 IPv4地址 的话 可通过数据库自带的函数 INET_ATON 和 INET_NTOA 进行转化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT INET_ATON(&#39;209.207.224.40&#39;);</span><br><span class="line">-&gt; 3520061480</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT INET_NTOA(3520061480);</span><br><span class="line">-&gt; &#39;209.207.224.40&#39;</span><br></pre></td></tr></table></figure><p>如果是 IPv6地址 的话，MySQL 5.6 版本之后。则使用函数 INET6_ATON 和 INET6_NTOA 进行转化。然后数据库定义为 varbinary 类型，分配 128bits 空间（因为 ipv6采用的是128bits，16个字节）；或者定义为 char 类型，分配<br>32bits 空间</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 如何存储IP地址 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布隆算法</title>
      <link href="2020/09/13/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E5%B8%83%E9%9A%86%E7%AE%97%E6%B3%95/"/>
      <url>2020/09/13/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E5%B8%83%E9%9A%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>如何判断一个元素在亿级数据中是否存在？</p><p>想判断一个元素是不是在一个集合中存在，传统做法都是将集合中的元素某种数据结构中。如：数组、链表、hash表等等。然后通过比较判断是否存在。<br>常见思路：</p><ul><li>1、将数据存储在数据库中，然后判断是否存在</li><li>2、使用hash表，可以接近O(1)的代价查询是否存在（大数据量很耗费空间，内存溢出）</li><li>3、数据先经过MD5或SHA-1等单向哈希函数，再保存到hash表中。较方法二更节约空间。（节约了空间，但多了一次hash,就增加了时间成本）</li><li>4、使用位图算法。建立一个BitSet，判断数据是否存在。（单一哈希函数冲突太高）</li></ul><p>总结：</p><ul><li>储存在内存中，效率快，但是对内存消耗高。以空间换时间</li><li>存储在磁盘中，效率低，内存消耗小。以空间换时间</li></ul><p>以上方式都是在保证100%准确的前提解决方案。若允许小概率错误，可以找到时间和空间消耗都比较小的数据结构和算法的解决方案：Bloom Filter</p><p>优点：时间和空间消耗都比较小的 大规模数据排重算法<br>缺点：有一定的误识别率和删除困难。</p><p><a href="https://www.jianshu.com/p/b9bd502a386a">https://www.jianshu.com/p/b9bd502a386a</a>  </p><p>其原理比较简单，如下图所示，S集合中有n个元素，利用k个哈希函数，将S中的每个元素映射到一个长度为m的位（bit）数组B中不同的位置上，这些位置上的二进制数均置为1，如果待检测的元素经过这k个哈希函数的映射后，发现其k个位置上的二进制数不全是1，那么这个元素一定不在集合S中，反之，该元素可能是S中的某一个元素（参考1）；<img src="https://img2018.cnblogs.com/blog/1775037/201910/1775037-20191008173752927-1989369488.png" alt="image"></p><p>那么到底需要多少个哈希函数，以及创建长度为多少的bit数组比较合适，为了估算出k和m的值，在构造一个布隆过滤器时，需要传入两个参数，即可以接受的误判率fpp和元素总个数n（不一定完全精确）。至于参数估计的方法，有兴趣的同学可以参考维基英文页面，下面直接给出公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以用2个哈希函数来模拟k个哈希函数，</span><br><span class="line">即gi(x) &#x3D; h1(x) + ih2(x) ，其中0&lt;&#x3D;i&lt;&#x3D;k-1；</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 布隆算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth2.0</title>
      <link href="2020/09/13/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/aouth2.0/OAuth2.0/"/>
      <url>2020/09/13/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/aouth2.0/OAuth2.0/</url>
      
        <content type="html"><![CDATA[<p>OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。</p><p>OAuth1.0协议太复杂，易用性差。2.0是一个新的设计，协议简单清晰，但它并不兼容1.0，可以说与1.0没什么关系。</p><p>OAuth 2.0是==应用之间彼此访问数据的开源授权协议==，就是保证第三方（软件）只有在获得授权之后，才可以进一步访问授权者的数据。==授权的核心就是颁发访问令牌、使用访问令牌==。</p><p>OAuth 2.0 针对不同的使用场景，提供了4 种基础的许可类型，分别是</p><ul><li>授权码许可（最常用授权方式）</li><li>隐式许可（Implicit）、</li><li>客户端凭据许可（Client Credentials）、</li><li>资源拥有者凭据许可（Resource Owner Password Credentials）</li></ul><p>使用一个APP如果重新注册用户，那你还得上传头像、输手机号等信息（导致营销短信轰炸）。使用第三方帐号微信来登录，那极客时间会直接使用你微信的这些信息作为基础信息</p><p>OAuth 2.0 的体系里面有 4 种角色，按照官方的称呼它们分别是资源拥有者（用户）、客户端(三方软件)、授权服务（微信，facebook）和受保护资源(微信的头像等信息，京东的订单等)</p><p>授权码许可流程有两种通信方式。</p><p>一种是前端通信，因为它通过浏览器促成了授权码的交互流程，比如京东商家开放平台的授权服务生成授权码发送到浏览器，第三方软件小兔从浏览器获取授权码。正因为获取授权码的时候小兔软件和授权服务并没有发生直接的联系，也叫做间接通信。另外一种是后端通信，在小兔软件获取到授权码之后，在后端服务直接发起换取访问令牌的请求，也叫做直接通信。</p><p>在 OAuth 2.0 中，访问令牌被要求有极高的安全保密性，因此我们不能让它暴露在浏览器上面，只能通过第三方软件（比如小兔）的后端服务来获取和使用，以最大限度地保障访问令牌的安全性。正因为访问令牌的这种安全要求特性，当需要前端通信，比如浏览器上面的流转的时候，OAuth 2.0 才又提供了一个临时的凭证：授权码。通过授权码的方式，可以让用户小明在授权服务上给小兔授权之后，还能重新回到小兔的操作页面上。这样，在保障安全性的情况下，提升了小明在小兔上的体验</p><p>没有授权码的思路继续想，如果这里直接返回访问令牌，那我们肯定不能使用重定向的方式。因为这样会把安全保密性要求极高的访问令牌暴露在浏览器上，从而将会面临访问令牌失窃的安全风险</p><p>没有授权码的话，我们就只能把访问令牌发送给第三方软件小兔的后端服务<br>为了重新建立起这样的一次连接，我们又不能让访问令牌暴露出去，就有了这样一个临时的、间接的凭证：授权码。</p><p><img src="https://gw.alipayobjects.com/zos/skylark-tools/public/files/d59072bc8f690dd26cfa45f5d08017f4.png" alt="image"></p><p>第一步，用户访问客户端web应用。应用中的按钮”通过Facebook登录”(或者其他的系统，如Google或Twitter)。</p><p>第二步，当用户点击了按钮后，会被重定向到授权的应用(如Facebook)。用户登录并确认授权应用中的数据给客户端应用。</p><p>第三步，授权应用Facebook将用户重定向到客户端应用提供的URI，提供这种重定向的URI通常是通过注册客户端应用程序与授权应用程序完成。在注册中，客户端应用的拥有者组注册该重定向URI，在注册过程中认证应用也会给客户端应用客户端标识和密码。在URI后追加一个认证码。该认证码代表了授权。</p><p>第四步，用户在客户端应用访问网页被定位到重定向的URI。在背后客户端应用连接授权应用，并且发送在重定向请求参数中接收到的客户端标识，客户端密码和认证码。授权应用将返回一个访问口令。</p><p>一旦客户端有了访问口令，该口令便可以被发送到Facebook、Google、Twitter等来访问登录用户的资源。重点步骤，也就是两次重定向</p>]]></content>
      
      
      <categories>
          
          <category> aouth2.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAuth2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用OAuth2.0构建一个授权服务</title>
      <link href="2020/09/12/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/aouth2.0/%E4%BD%BF%E7%94%A8OAuth2.0%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1/"/>
      <url>2020/09/12/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/aouth2.0/%E4%BD%BF%E7%94%A8OAuth2.0%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>1、为三方软件提供注册入口，分配app_id 和 app_secret、以及授权范围</p><p>2、颁发授权码 code</p>]]></content>
      
      
      <categories>
          
          <category> aouth2.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 使用OAuth2.0构建一个授权服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三方软件接入OAuth2.0</title>
      <link href="2020/09/12/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/aouth2.0/%E4%B8%89%E6%96%B9%E8%BD%AF%E4%BB%B6%E6%8E%A5%E5%85%A5OAuth2.0/"/>
      <url>2020/09/12/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/aouth2.0/%E4%B8%89%E6%96%B9%E8%BD%AF%E4%BB%B6%E6%8E%A5%E5%85%A5OAuth2.0/</url>
      
        <content type="html"><![CDATA[<h4 id="1、注册信息"><a href="#1、注册信息" class="headerlink" title="1、注册信息"></a>1、注册信息</h4><p>先拥有自己的 app_id 和 app_serect 等信息，同时还要填写自己的回调地址 redirect_uri、申请scope 权限范围等信息。</p><h4 id="2、引导授权"><a href="#2、引导授权" class="headerlink" title="2、引导授权"></a>2、引导授权</h4><p>将用户引导至授权服务如微信，让用户为第三方软件授权。得到了授权之后，第三方软件才可以代表用户去访问数据</p><h4 id="3、使用访问令牌"><a href="#3、使用访问令牌" class="headerlink" title="3、使用访问令牌"></a>3、使用访问令牌</h4><p>OAuth 2.0 的令牌只支持一种类型，那就是 bearer 令牌，也就是我之前讲到的可以是任意字符串格式的令牌。<br>官方规范给出的使用访问令牌请求的方式，有三种，分别是</p><ul><li>Form-Encoded Body Parameter（表单参数）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">POST &#x2F;resource HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">access_token&#x3D;b1a64d5c-5e0c-4a70-9711-7af6568a61fb</span><br></pre></td></tr></table></figure>URI Query Parameter（URI 查询参数）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET &#x2F;resource?access_token&#x3D;b1a64d5c-5e0c-4a70-9711-7af6568a61fb HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></table></figure>Authorization Request Header Field（授权请求头部字段）【推荐】<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET &#x2F;resource HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Bearer b1a64d5c-5e0c-4a70-9711-7af6568a61fb</span><br></pre></td></tr></table></figure></li></ul><h4 id="4、使用刷新令牌。"><a href="#4、使用刷新令牌。" class="headerlink" title="4、使用刷新令牌。"></a>4、使用刷新令牌。</h4><p>一个设计良好的第三方应用，应该将 expires_in 值保存下来并定时检测；如果发现 expires_in 即将过期</p>]]></content>
      
      
      <categories>
          
          <category> aouth2.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三方软件接入OAuth2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDos攻击</title>
      <link href="2020/09/10/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/4%E3%80%81DDos%E6%94%BB%E5%87%BB/"/>
      <url>2020/09/10/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/4%E3%80%81DDos%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p>DDoS(Distributed Denial of Service)即分布式拒绝服务攻击，是目前最为强大、最难以防御的攻击方式之一</p><p>DDoS指的是攻击者借助公共网络，将数量庞大的计算机设备联合起来作为攻击平台，在同一时刻对一个或多个目标发动攻击，从而达到瘫痪目标主机的目的。利用TCP/UDP协议规律，通过占用协议栈资源或者发起大流量拥塞，达到消耗目标机器性能或者网络的目的</p><p>常见的DDoS攻击手段：</p><h4 id="SYN-Flood"><a href="#SYN-Flood" class="headerlink" title="SYN Flood"></a>SYN Flood</h4><p>TCP协议为实现可靠传输，在三次握手的过程中设置了一些异常处理机制，如果服务器没有收到客户端的ACK报文，服务端一般会进行重试，也就是再次发送SYN+ACK报文给客户端，并且一直处于SYN_RECV状态，将客户端加入等待列表。重发一般会进行3~5次，大约每隔30秒左右会轮询一遍等待队列，重试所有客户端；另一方面，服务器在发出SYN+ACK报文后，会预分配一部分资源给即将建立的TCP连接，这个资源在等待重试期间一直保留，更为重要的是，服务器资源有限，可以维护的等待列表超过极限后就不再接收新的SYN报文，也就是拒绝建立新的TCP连接</p><p>SYN Flood正是利用了TCP协议三次握手的过程来达到攻击的目的，攻击者伪造大量的IP地址给服务器发送SYN报文，但是由于伪造的IP地址几乎不可能存在，也就不可能从客户端得到任何回应，服务端将维护一个非常大的半连接等待列表，并且不断对这个列表中的IP地址进行遍历和重试，占用了大量的系统资源，更为严重的是，由于服务器资源有限，大量的恶意客户端信息占满了服务器的等待队列，导致服务器不再接收新的SYN请求，正常用户无法完成三次握手与服务器进行通信，这便是SYN Flood攻击</p><p>可以在收到客户端第三次握手reset 、第二次握手发送错误的ack，等Client回复Reset，结合信任机制进行判断。</p><p>ack flood：<br>丢弃三次ack，让对方重连：重发syn建立链接，后续是syn flood防护原理；学习正常ack的源，超过阈值后，该ack没有在正常源列表里面就丢弃ack三次，让对方重连：重发syn建立链接，后续是syn flood防护。</p><p>DNS Query Flood</p><p>DNS Query Flood实际上是UDP Flood攻击的一种变形，由于DNS服务在互联网中具有不可替代的作用，一旦DNS服务器瘫痪，影响甚大</p><p>DNS Query Flood攻击采用的方法是向被攻击的服务器发送海量的域名解析请求，通常， 请求解析的域名是随机生成的，大部分根本不存在，并且通过伪造端口和客户端IP，防止查询请求被ACL（访问控制列表）过滤，被攻击的DNS服务器在接收到域名解析请求后，首先会在服务器上查找是否有对应的缓存，由于域名是随机生成的，几乎不可能有相应的缓存信息，当没有缓存，且该域名无法直接由该DNS服务器进行解析时，DNS服务器会向其上层DNS服务器递归查询域名信息，直到全球互联网的13台根DNS服务器。大量不存在的域名解析请求给服务器带来了很大的负载，当解析请求超过一定量时，就会造成DNS服务器解析域名超时，这样攻击者便达成了攻击目的</p><p>CC攻击</p><p>CC(Challenge Collapsar)攻击属于DDoS的一种，是基于应用层HTTP协议发起的DDoS攻击，也被称为HTTP Flood</p><p>CC攻击的原理是：攻击者通过控制的大量”肉鸡”或者利用从互联网上搜寻的大量匿名的HTTP代理，模拟正常用户给网站发起请求直到该网站拒绝服务为止，大部分网站会通过CDN以及分布式缓存来加快服务端响应，提升网站的吞吐量，而这些精心构造的HTTP请求往往有意避开这些缓存，需要进行多次DB查询操作或者一次请求返回大量的数据，加速系统资源消耗，从而拖垮后端的业务处理系统，甚至连相关存储与日志收集系统也无法幸免</p>]]></content>
      
      
      <categories>
          
          <category> web攻击 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDos攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传漏洞</title>
      <link href="2020/09/10/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/3%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
      <url>2020/09/10/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/3%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>文件上传攻击指的是恶意攻击者利用一些站点没有对文件的类型做很好的校验，上传了可执行的文件或者脚本，并且通过脚本获得服务器上相应的权力，或者是通过诱导外部用户访问、下载上传的病毒或木马文件，达到攻击的目的</p><ul><li>1、文件上传的目录设置为不可执行</li><li>2、上传的文件需要使用随机数等进行重命名，使攻击者无法猜测到上传文件的访问路径</li><li>3、对于图片类型的文件，可以在上传后，利用imagemagick等工具对图片进行相应的缩放，破坏恶意用户上传的二进制可执行文件的结构，来避免恶意代码执行</li><li>4、对HTTP包头的content-type也和上传文件的大小也需要进行检查。</li><li>5、不能简单地通过后缀名来判断文件类型，很多类型的文件起始的几个字节内容是固定的，根据这几个字节(魔数)的内容就可以确定文件类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public enum FileType&#123;</span><br><span class="line">    JPEG(&quot;FFD8FF&quot;),</span><br><span class="line">    PNG(&quot;89504E47&quot;),</span><br><span class="line">    GIF(&quot;47494638&quot;),</span><br><span class="line">    TIFF(&quot;49492A00&quot;),</span><br><span class="line">    BMP(&quot;424D&quot;),</span><br><span class="line">    DWG(&quot;41433130&quot;),</span><br><span class="line">    PSD(&quot;38425053&quot;),</span><br><span class="line">    XML(&quot;3C3F786D6C&quot;),</span><br><span class="line">    HTML(&quot;68746D6C3E&quot;),</span><br><span class="line">    PDF(&quot;255044462D312E&quot;),</span><br><span class="line">    ZIP(&quot;504B0304&quot;),</span><br><span class="line">    RAR(&quot;52617221&quot;),</span><br><span class="line">    WAV(&quot;57415645&quot;),</span><br><span class="line">    AVI(&quot;41564920&quot;),</span><br><span class="line"></span><br><span class="line">    private String value &#x3D; &quot;&quot;;</span><br><span class="line">    private FileType(String value)&#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getValue()&#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setValue(String value)&#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *读取文件头</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"> private static String getFileHeader(String filePath) throws IOException &#123;</span><br><span class="line">     &#x2F;&#x2F;这里需要注意的是，每个文件的魔数的长度都不相同，因此需要使用startwith</span><br><span class="line">     byte[] b &#x3D; new byte[28];</span><br><span class="line">     InputStream is &#x3D; null;</span><br><span class="line">     is &#x3D; new FileInputStream(filePath);</span><br><span class="line">     is.read(b, 0, 28);</span><br><span class="line">     is.close();</span><br><span class="line"></span><br><span class="line">     return bytes2hex(b);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">  *判断文件类型</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static FileType getType(String filePath) throws IOException &#123;</span><br><span class="line">      String fileHead &#x3D; getFileHeader(filePath);</span><br><span class="line">      if(fileHead &#x3D;&#x3D; null || fileHead.length() &#x3D;&#x3D; 0)&#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">      fileHead &#x3D; fileHead.toUpperCase();</span><br><span class="line">      FileType[] fileTypes &#x3D; FileType.values();</span><br><span class="line">      for(FileType type : fileTypes)&#123;</span><br><span class="line">          if(fileHead.startsWith(type.getValue()))&#123;</span><br><span class="line">              return type;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web攻击 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRSF攻击</title>
      <link href="2020/09/08/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/2%E3%80%81CRSF%E6%94%BB%E5%87%BB/"/>
      <url>2020/09/08/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/2%E3%80%81CRSF%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p>跨站请求伪造。你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求<img src="https://pic002.cnblogs.com/img/hyddd/200904/2009040916453171.jpg" alt="image"></p><p>要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><p>　　1.登录受信任网站A，并在本地生成Cookie。</p><p>　　2.在不登出A的情况下，访问危险网站B。</p><p>示例1：</p><p>银行网站A，它以GET请求来完成银行转账的操作，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.mybank.com&#x2F;Transfer.php?toBankId&#x3D;11&amp;money&#x3D;1000</span><br></pre></td></tr></table></figure><p>危险网站B，它里面有一段HTML的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　&lt;img src&#x3D;http:&#x2F;&#x2F;www.mybank.com&#x2F;Transfer.php?toBankId&#x3D;11&amp;money&#x3D;1000&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web攻击 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CRSF攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS攻击</title>
      <link href="2020/09/08/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/1%E3%80%81XSS%E6%94%BB%E5%87%BB/"/>
      <url>2020/09/08/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/1%E3%80%81XSS%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p>XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击</p><p>恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行</p><p>假设页面上有个需要用户填写的表单，表单填好后的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;nick&quot; value&#x3D;&quot;xiaomao&quot;&gt;</span><br></pre></td></tr></table></figure><p>但是当输入的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&#x2F;&gt;&lt;script&gt;alert(&quot;haha&quot;)&lt;&#x2F;script&gt;&lt;!-</span><br></pre></td></tr></table></figure><p>这一串就会被当做用户名提交到服务器，服务端验证不通过时，重定向到登录页面并带上刚才输入的用户名因为输入框input的后面带上了一段脚本，所以浏览器会执行，这里的效果是会弹出一个提示框”haha“。若指引用户点击跳转的病毒链接，这危害较大。</p><h4 id="反射型XSS："><a href="#反射型XSS：" class="headerlink" title="反射型XSS："></a>反射型XSS：</h4><p>特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行。例如上面的例子</p><h4 id="存储型XSS："><a href="#存储型XSS：" class="headerlink" title="存储型XSS："></a>存储型XSS：</h4><p>将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面就会执行恶意代码。</p><p>例如攻击者在博客网站上面发布了一篇文章，输入内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;window.open(&quot;www.gongji.com?param&#x3D;&quot;+document.cookie)&lt;&#x2F;script&gt; </span><br></pre></td></tr></table></figure><p>没有进行任何处理的话，直接存入到数据库中，那么下一次当其他用户访问该文章的时候.服务器会从数据库中读取后然后响应给客户端，那么浏览器就会执行这段脚本，然后攻击者就会获取到用户的cookie然后会把cookie发送到攻击者的服务器上了。</p><h4 id="DOM-based型XSS："><a href="#DOM-based型XSS：" class="headerlink" title="DOM-based型XSS："></a>DOM-based型XSS：</h4><p>js可以对页面dom节点进行动态的操作，比如插入、修改页面的内容 如果用户在客户端输入的数据包含了恶意的js脚本的话，但是这些脚本又没有做任何过滤处理的话，那么我们的应用程序就有可能受到DOM-based XSS的攻击。</p><h4 id="XSS防范："><a href="#XSS防范：" class="headerlink" title="XSS防范："></a>XSS防范：</h4><p>XSS攻击的起源都是来自页面的输入，因此我们只需对==用户的输入所有内容强校验==。</p><ul><li>1、在前端进行用户输入内容过滤，如电话号码，用户名可直接限制只能输入对应字符。</li><li><ol start="2"><li>将用户输入的内容进行HTML转义存储，如尖括号，斜杠，单/双引号（消毒几乎是所有网站最必备的XSS防攻击手段）</li></ol></li><li>3、对于cookie劫持，我们可以为关键的cookie字段设置http-only，然后就无法通过document对象获取cookie，但不影响其加载网页。</li></ul>]]></content>
      
      
      <categories>
          
          <category> web攻击 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web前端性能优化</title>
      <link href="2020/09/08/Study%20notes/%E5%89%8D%E7%AB%AF/Web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>2020/09/08/Study%20notes/%E5%89%8D%E7%AB%AF/Web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h4 id="浏览器访问优化："><a href="#浏览器访问优化：" class="headerlink" title="浏览器访问优化："></a>浏览器访问优化：</h4><p>1、减少http请求<br> 合并CSS、合并Javascript、合并图片。将浏览器一次访问所需要的的js css合并成一个文件</p><p>2、使用浏览器缓存<br>对于更新频率低的资源，通过设置HTTP头中的Cache-Control和Expires属性，可设定浏览器缓存，缓存时间可以是数天，甚至几个月。</p><p>3、启用压缩#<br> 对文本文件，HTML、CSS、Javascript文件启用GZip压缩可达到较好的效果。但是压缩对服务器和浏览器产生一定的压力，在通信带宽良好，而服务器资源不足的情况下要权衡考虑。</p><p>4、CSS放在页面最上面、Javascript放在页面最下面#<br>== 浏览器在下载完全部的CSS之后才对整个页面进行渲染，所以最好将CSS放在页面最上面==，让浏览器尽快下载CSS。</p><p>浏览器在加载Javascript后立即执行，有可能会阻塞整个页面，造成页面显示缓慢，因此最好将Javascript放在页面最下面。</p><p>但是如果页面解析就需要用到Javascript，这时放在底部就不合适了。</p><p>5、减少Cookie传输#<br> Cookie包含在每次请求中，太大的Cookie会严重影响数据传输，因此哪些数据需要写入Cookie需要慎重考虑，尽量减少Cookie中传输的数据量。</p><p>==静态资源如CSS、Script使用独立域名访问==，避免请求静态资源时发送Cookie，减少Cookie传输的次数。</p><h4 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h4><p>CDN(Content Distribute Network)本质仍然是一个缓存，而且将数据缓存在离用户最近的地方，使用户以最快速度获取数据，即网络访问第一跳。</p><p>CDN能够缓存的一般时静态资源，如图片、文件、CSS、Script脚本、静态网页等，但是这些文本访问频度很高，将其缓存在CDN可极大改善网页的打开速度。</p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理#"></a>反向代理#</h4><p> 反向代理服务器位于网站机房一侧，代理网站Web服务器接收HTTP请求。</p><p> 代理服务器可以通过配置缓存功能加速Web请求。</p><p>负载均衡也是主要功能，通过负载均衡构建应用集群可以提高系统处理能力，进而改善网站高并发情况下的性能。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web前端性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsonp</title>
      <link href="2020/09/02/Study%20notes/3%E3%80%81java/12%E3%80%81javaWeb/%E8%B7%A8%E5%9F%9F/3%E3%80%81jsonp/"/>
      <url>2020/09/02/Study%20notes/3%E3%80%81java/12%E3%80%81javaWeb/%E8%B7%A8%E5%9F%9F/3%E3%80%81jsonp/</url>
      
        <content type="html"><![CDATA[<p>JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。</p><p>核心思想：网页通过添加一个<script>元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;test.com&#x2F;data.php?callback&#x3D;dosomething&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F; 向服务器test.com发出请求，该请求的查询字符串有一个callback参数，用来指定回调函数的名字</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 处理服务器返回回调函数的数据</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    function dosomething(res)&#123;</span><br><span class="line">        &#x2F;&#x2F; 处理获得的数据</span><br><span class="line">        console.log(res.data)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &#39;http:&#x2F;&#x2F;www.test.com:8080&#x2F;login&#39;,</span><br><span class="line">    type: &#39;get&#39;,</span><br><span class="line">    dataType: &#39;jsonp&#39;,  &#x2F;&#x2F; 请求方式为jsonp</span><br><span class="line">    jsonpCallback: &quot;handleCallback&quot;,    &#x2F;&#x2F; 自定义回调函数名</span><br><span class="line">    data: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 跨域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsonp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网关</title>
      <link href="2020/09/02/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/5%E3%80%81%E7%BD%91%E5%85%B3/1%E3%80%81%E7%BD%91%E5%85%B3/"/>
      <url>2020/09/02/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/5%E3%80%81%E7%BD%91%E5%85%B3/1%E3%80%81%E7%BD%91%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>API 网关出现的原因是微服务架构的出现，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信，会有以下的问题：</p><p>客户端会多次请求不同的微服务，增加了客户端的复杂性。<br>存在跨域请求，在一定场景下处理相对复杂。<br>认证复杂，每个服务都需要独立认证。<br>难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将会很难实施。<br>某些微服务可能使用了防火墙 / 浏览器不友好的协议，直接访问会有一定的困难。</p><p>提高安全性，只有网关系统对外进行暴露，微服务可以隐藏在内网，通过防火墙保护。<br>易于监控。可以在网关收集监控数据并将其推送到外部系统进行分析。<br>易于认证。可以在网关上进行认证，然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。<br>减少了客户端与各个微服务之间的交互次数，易于统一授权。</p><ul><li>kong</li><li>nginx Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务</li><li>zuul ,Zuul 是 Netflix 出品的一个基于 JVM 路由和服务端的负载均衡器。</li><li>spring-cloud-gateway, 是spring 出品的 基于spring 的网关项目，集成断路器，路径重写，性能比Zuul好。Spring Cloud Gateway 依赖 Spring Boot 和 Spring WebFlux，基于 Netty 运行。它不能在传统的 servlet 容器中工作，也不能构建成 war 包。</li></ul><p>服务网关 = 路由转发 + 过滤器</p><p>Open API。企业需要将自身数据、能力等作为开发平台向外开放</p><p>Open API开放平台必然涉及到客户应用的接入、API权限的管理、调用次数管理等，必然会有一个统一的入口进行管理，这正是API网关可以发挥作用的时候。</p><p>在微服务架构中，有一个组件可以说是必不可少的，那就是微服务网关，微服务网关处理了负载均衡，缓存，路由，访问控制，服务代理，监控，日志等。API网关在微服务架构中正是以微服务网关的身份存在。</p><p>一个请求过来，首先经过nginx的一层负载，到达网关，然后由网关负载到真实后端，若后端有问题，网关会进行重试访问，多次访问后仍返回失败，可以通过熔断或服务降级立即返回结果。而且，由于是负载均衡，网关重试时不一定会访问到出错的后端</p><p>网关的高可用：</p><p>微服务网关调用微服务A和微服务B时，利用Ribbon实现了负载均衡，，微服务网关的负载均衡只能借助于其它的反向代理工具，比如Nginx、Haproxy</p><p>Keepalive 实现Nginx高可用:首先Keepalived可以在主机上产生一个虚拟的ip，这里叫做vip(v是virtual的意思)，keepalived会将这个vip绑定到交换机上，当主机宕机时，备机会收不到心跳检测，备机会自动生成vip并绑定到交换机上，成为新主机，当客户端访问时，交换机会将请求转发给新主机，当旧主机恢复后，新主机会自动切换为备机，从而保证Nginx的高可用。</p>]]></content>
      
      
      <categories>
          
          <category> 网关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网关鉴权</title>
      <link href="2020/09/01/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/5%E3%80%81%E7%BD%91%E5%85%B3/5%E3%80%81%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/"/>
      <url>2020/09/01/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/5%E3%80%81%E7%BD%91%E5%85%B3/5%E3%80%81%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>重发攻击：</p><p>入侵者从网络上截取主机A发送给主机B的报文，并把由A加密的报文发送给B，使主机B误以为入侵者就是主机A，然后主机B向伪装成A的入侵者发送应当发送给A的报文。</p><p>只有经过认证之后的系统才能调用我们的服务端接口</p><p>1、给每个调用方，派发一个应用名appid和秘钥。服务方每次收到请求后，对客户端的appid和秘钥进行验证。【明文传输密码。密码很容易被截获，进行重发攻击】<br>http:xxx.com?appId=abc&amp;pwd=dam</p><p>2、借助加密算法，将秘钥进行加密传输到服务端进行认证【加密之后的数据被劫持，一样可以重发攻击】<br>SHA(dam)=dawffe<br>http:xxx.com?appId=abc&amp;pwd=dawffe</p><p>3、借助 OAuth 的验证思路,客户端将请求接口的 URL 跟 AppID、秘钥拼接在一起，然后进行加密，得到sign。<br>传输到后端认证。后端同样得方法根据URL和appID和库里的秘钥生产sign进行比对认证【每个 URL 拼接上 AppID、密码生成的 token 都是固定的。被劫持后也存在重发攻击】</p><p>SHA(pwd+url+appid)=sign=dawffe1x</p><p>http:xxx.com?appId=abc&amp;sign=dawffe1x</p><p>4、引入随机量。在第三步的基础上，加入时间戳。SHA(URL+AppId+分配给客户端的秘钥+客户端的当前时间戳)得到sign。<br>服务端同样得方式</p><p>SHA(pwd+url+appid+timeStamp)=sign=dawffe1x</p><p>http:xxx.com?appId=abc&amp;sign=dawffe1x&amp;timeStamp=213423</p><p>微服务端在收到这些数据之后，<br>4.1、会验证当前时间戳跟传递过来的时间戳，是否在一定的时间窗口内（比如一分钟）。如果超过一分钟，则判定 sign过期<br>4.2、同样得方式SHA(URL+AppId+服务端秘钥+客户端的当前时间戳)得到sign。与客户端的sign不一致，则sign非法【在窗口期内存在重发攻击的风险】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 网关鉴权</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class AuthFilter implements GatewayFilter, Ordered &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">exchange.getResponse().setStatusCode(HttpStatus.OK);</span><br><span class="line">exchange.getResponse().getHeaders().add(&quot;Content-Type&quot;, &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);</span><br><span class="line">&#x2F;&#x2F;是否跳过验签</span><br><span class="line">if (false) &#123;</span><br><span class="line">return chain.filter(exchange);</span><br><span class="line">&#125;</span><br><span class="line">FailResultBean failResultBean &#x3D; new FailResultBean();</span><br><span class="line">String clientSign &#x3D; exchange.getRequest().getQueryParams().getFirst(&quot;sign&quot;);</span><br><span class="line">if (StringUtils.isEmpty(clientSign)) &#123;</span><br><span class="line">log.info(&quot;验证失败，验签参数sign为空&quot;);</span><br><span class="line">failResultBean.setErrorMessage(&quot;验证失败，验签参数为空&quot;);</span><br><span class="line">return exchange.getResponse().writeWith(Flux.just(this.getBodyBuffer(exchange.getResponse(), failResultBean)));</span><br><span class="line">&#125;</span><br><span class="line">String appId &#x3D; exchange.getRequest().getHeaders().getFirst(&quot;appId&quot;);</span><br><span class="line">if (StringUtils.isEmpty(appId)) &#123;</span><br><span class="line">log.info(&quot;验证失败，验签参数appId为空&quot;);</span><br><span class="line">return exchange.getResponse().writeWith(Flux.just(this.getBodyBuffer(exchange.getResponse(), failResultBean)));</span><br><span class="line">&#125;</span><br><span class="line">String privateKey &#x3D; null;</span><br><span class="line">&#x2F;&#x2F;通过appId获取秘钥 redisUtil.getValueStr(appId);</span><br><span class="line">if (StringUtils.isEmpty(privateKey)) &#123;</span><br><span class="line">log.info(&quot;验证失败，非系统认证appId&quot;);</span><br><span class="line">&#125;</span><br><span class="line">Long expiredTime &#x3D; 1 * 60 * 1000L;</span><br><span class="line">String timeStamp &#x3D; exchange.getRequest().getQueryParams().getFirst(&quot;timeStamp&quot;);</span><br><span class="line">if (System.currentTimeMillis() - Long.parseLong(timeStamp) &gt; expiredTime) &#123;</span><br><span class="line">log.info(&quot;验证失败，sign过期&quot;);</span><br><span class="line">&#125;</span><br><span class="line">String url &#x3D; exchange.getRequest().getURI().getPath();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        SHA(pwd+url+appid+timeStamp)&#x3D;dawffe1x</span><br><span class="line">&#x2F;&#x2F;生产服务端的sign</span><br><span class="line">String serverSign &#x3D; getServerSign(privateKey, appId, timeStamp, url);</span><br><span class="line">if (!clientSign.equals(serverSign)) &#123;</span><br><span class="line">log.info(&quot;验证失败，验签参数sign非法&quot;);</span><br><span class="line">return exchange.getResponse().writeWith(Flux.just(this.getBodyBuffer(exchange.getResponse(), failResultBean)));</span><br><span class="line">&#125;</span><br><span class="line">return chain.filter(exchange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private String getServerSign(String privateKey, String appId, String timeStamp, String url) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 封装返回值</span><br><span class="line"> *</span><br><span class="line"> * @param response</span><br><span class="line"> * @param failResultBean</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">private DataBuffer getBodyBuffer(ServerHttpResponse response, FailResultBean failResultBean) &#123;</span><br><span class="line">&#x2F;&#x2F;return response.bufferFactory().wrap(JSONObject.toJSONBytes(failResultBean));</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int getOrder() &#123;</span><br><span class="line">return -200;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网关鉴权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gateway网关</title>
      <link href="2020/08/30/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/5%E3%80%81%E7%BD%91%E5%85%B3/3%E3%80%81gateway%E7%BD%91%E5%85%B3/"/>
      <url>2020/08/30/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/5%E3%80%81%E7%BD%91%E5%85%B3/3%E3%80%81gateway%E7%BD%91%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;spring.io&#x2F;projects&#x2F;spring-cloud-gateway</span><br></pre></td></tr></table></figure><p>搭建一个网关微服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.1.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;Finchley.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p>如果引入spring-boot-starter-web。会和springcloud中Gateway有冲突，需要在web中排除mvc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;exclusions&gt;</span><br><span class="line">     &lt;exclusion&gt;</span><br><span class="line">         &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">     &lt;&#x2F;exclusion&gt;</span><br><span class="line"> &lt;&#x2F;exclusions&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">public class GatewayApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sysgateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      globalcors:</span><br><span class="line">        cors-configurations:</span><br><span class="line">          &#39;[&#x2F;**]&#39;: # 匹配所有请求（微服务网关跨域）</span><br><span class="line">            allowedOrigins: &quot;*&quot; #跨域处理 允许所有的域</span><br><span class="line">            allowedMethods: # 支持的方法</span><br><span class="line">            - GET</span><br><span class="line">            - POST</span><br><span class="line">            - PUT</span><br><span class="line">            - DELETE</span><br><span class="line">      routes:</span><br><span class="line">      - id: goods</span><br><span class="line">        uri: lb:&#x2F;&#x2F;goods</span><br><span class="line">        predicates:</span><br><span class="line">        - Path&#x3D;&#x2F;goods&#x2F;**</span><br><span class="line">        filters:</span><br><span class="line">        - StripPrefix&#x3D; 1</span><br><span class="line">server:</span><br><span class="line">  port: 9101</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;127.0.0.1:6868&#x2F;eureka</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以通过网关过滤器，实现一些逻辑的处理，比如ip黑白名单拦截、特定地址的拦截等。下面的代码中做了两个过滤器，并且设定的先后顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class IpFilter implements GlobalFilter, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;经过第1个过滤器IpFilter&quot;);</span><br><span class="line">        ServerHttpRequest request &#x3D; exchange.getRequest();</span><br><span class="line">        InetSocketAddress remoteAddress &#x3D; request.getRemoteAddress();</span><br><span class="line">        System.out.println(&quot;ip:&quot;+remoteAddress.getHostName());</span><br><span class="line">        return chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UrlFilter implements GlobalFilter, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        System.out.println(&quot;经过第2个过滤器UrlFilter&quot;);</span><br><span class="line">        ServerHttpRequest request &#x3D; exchange.getRequest();</span><br><span class="line">        String url &#x3D; request.getURI().getPath();</span><br><span class="line">        System.out.println(&quot;url:&quot;+url);</span><br><span class="line">        return chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class AuthorizeFilter implements GlobalFilter, Ordered &#123;</span><br><span class="line">    private static final String AUTHORIZE_TOKEN &#x3D; &quot;token&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">&#x2F;&#x2F;1. 获取请求</span><br><span class="line">        ServerHttpRequest request &#x3D; exchange.getRequest();</span><br><span class="line">        &#x2F;&#x2F;2. 则获取响应</span><br><span class="line">        ServerHttpResponse response &#x3D; exchange.getResponse();</span><br><span class="line">        &#x2F;&#x2F;3. 如果是登录请求则放行</span><br><span class="line">        if (request.getURI().getPath().contains(&quot;&#x2F;admin&#x2F;login&quot;)) &#123;</span><br><span class="line">            return chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;4. 获取请求头</span><br><span class="line">        HttpHeaders headers &#x3D; request.getHeaders();</span><br><span class="line">        &#x2F;&#x2F;5. 请求头中获取令牌</span><br><span class="line">        String token &#x3D; headers.getFirst(AUTHORIZE_TOKEN);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;6. 判断请求头中是否有令牌</span><br><span class="line">        if (StringUtils.isEmpty(token)) &#123;</span><br><span class="line">            &#x2F;&#x2F;7. 响应中放入返回的状态吗, 没有权限访问</span><br><span class="line">            response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            &#x2F;&#x2F;8. 返回</span><br><span class="line">            return response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;9. 如果请求头中有令牌则解析令牌</span><br><span class="line">        try &#123;</span><br><span class="line">            JwtUtil.parseJWT(token);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            &#x2F;&#x2F;10. 解析jwt令牌出错, 说明令牌过期或者伪造等不合法情况出现</span><br><span class="line">            response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            &#x2F;&#x2F;11. 返回</span><br><span class="line">            return response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;12. 放行</span><br><span class="line">        return chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用redis的RateLimter限流算法来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--redis--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.3.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在GatewayApplicatioin引导类中添加如下代码，KeyResolver用于计算某一个类型的限流的KEY也就是说，可以通过KeyResolver来指定限流的Key。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个KeyResolver</span><br><span class="line">@Bean</span><br><span class="line">public KeyResolver ipKeyResolver() &#123;</span><br><span class="line">    return new KeyResolver() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Mono&lt;String&gt; resolve(ServerWebExchange exchange) &#123;</span><br><span class="line">            return Mono.just(exchange.getRequest().getRemoteAddress().getHostName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改application.yml中配置项，指定限制流量的配置以及REDIS的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sysgateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      globalcors:</span><br><span class="line">        cors-configurations:</span><br><span class="line">          &#39;[&#x2F;**]&#39;: # 匹配所有请求</span><br><span class="line">            allowedOrigins: &quot;*&quot; #跨域处理 允许所有的域</span><br><span class="line">            allowedMethods: # 支持的方法</span><br><span class="line">            - GET</span><br><span class="line">            - POST</span><br><span class="line">            - PUT</span><br><span class="line">            - DELETE</span><br><span class="line">      routes:</span><br><span class="line">      - id: goods</span><br><span class="line">        uri: lb:&#x2F;&#x2F;goods</span><br><span class="line">        predicates:</span><br><span class="line">        - Path&#x3D;&#x2F;goods&#x2F;**</span><br><span class="line">        filters:</span><br><span class="line">        - StripPrefix&#x3D; 1</span><br><span class="line">        - name: RequestRateLimiter #请求数限流 名字不能随便写 </span><br><span class="line">          args:</span><br><span class="line">            key-resolver: &quot;#&#123;@ipKeyResolver&#125;&quot; #用于限流的键的解析器的 Bean 对象的名字。它使用 SpEL 表达式根据#&#123;@beanName&#125;从 Spring 容器中获取 Bean 对象。</span><br><span class="line">            redis-rate-limiter.replenishRate: 1 #令牌桶每秒填充平均速率。</span><br><span class="line">            redis-rate-limiter.burstCapacity: 1 #令牌桶总容量。以上：表示 一秒内，允许 一个请求通过，令牌桶的填充速率也是一秒钟添加一个令牌。</span><br><span class="line">      - id: system</span><br><span class="line">        uri: lb:&#x2F;&#x2F;system</span><br><span class="line">        predicates:</span><br><span class="line">        - Path&#x3D;&#x2F;system&#x2F;**</span><br><span class="line">        filters:</span><br><span class="line">        - StripPrefix&#x3D; 1</span><br><span class="line">  # 配置Redis 127.0.0.1可以省略配置</span><br><span class="line">  redis:</span><br><span class="line">    host: 192.168.200.128</span><br><span class="line">    port: 6379</span><br><span class="line">server:</span><br><span class="line">  port: 9101</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;127.0.0.1:6868&#x2F;eureka</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>快速刷新，当1秒内发送多次请求，就会返回429错误。【HTTP 429 - Too Many Requests】</p>]]></content>
      
      
      <categories>
          
          <category> 网关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gateway网关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池在业务中的实践</title>
      <link href="2020/08/25/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/2%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
      <url>2020/08/25/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/2%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>场景1：快速响应用户请求</p><p>商详页的商品信息，由商品基本信息，活动信息，库存信息等聚合展示。串行查询这些三方服务，响应速度势必很慢。<br>使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。</p><p>快速处理批量任务</p><p>线程池使用面临的核心的问题在于：==线程池的参数配置==</p><ul><li>没有预估好调用的流量，导致最大核心数设置偏小，大量抛出RejectedExecutionException，触发接口降级条件</li><li>没有预估服务执行时间，由于队列设置过长，最大线程数设置失效，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败</li></ul><p>其他并发性方案代替线程池<br>IO密集型和CPU密集型的任务运行起来的情况差异非常大，但这种占比是较难合理预估的。导致业界并没有一个通用公式帮我们直接计算出结果，得到最优的线程池参数配置。</p><p>落地方案：搭建一个线程池监控平台，动态化线程池</p><p>1、动态调参：例如将线程池参数放在apollo平台，支持线程池参数动态调整、线程池构造参数有8个，但是最核心的是3个：corePoolSize、maximumPoolSize，workQueue。参数修改后及时生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void setCorePoolSize(int corePoolSize) </span><br><span class="line">public void setKeepAliveTime(long time, TimeUnit unit)</span><br><span class="line">public void setMaximumPoolSize(int maximumPoolSize)</span><br></pre></td></tr></table></figure><pre><code>需要修改的时候拿到ThreadPoolExecutor实例动态设置线程池的核心策略线程池内部会处理好当前状态做到平滑修改。例如：在运行期线程池使用方调用此方法设置corePoolSize之后，线程池会直接覆盖原来的corePoolSize值，并且基于当前值和原始值的比较结果采取不同的处理策略。对于当前值小于当前工作线程数的情况，说明有多余的worker线程，此时会向当前idle的worker线程发起中断请求以实现回收，多余的worker在下次idle的时候也会被回收；对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的worker线程来执行队列任务</code></pre><p>2、任务监控：支持应用粒度、线程池粒度、任务粒度的Transaction监控；可以看到线程池的任务执行情况、最大任务执行时间、平均任务执行时间、95/99线等。</p><p>ThreadPoolExecutor的getter方法。可以读取到当前线程池的运行状态以及参数</p><p>3、负载告警：线程池负载关注的核心问题是：基于当前线程池参数分配的资源够不够。线程池队列任务积压到阈值及时告警告知应用开发负责人。</p><p>4、线程池活跃度计算公式为：线程池活跃度 = activeCount/maximumPoolSize。这个公式代表当活跃线程数趋向于maximumPoolSize的时候，代表线程负载趋高。</p><p>5、操作监控：创建/修改和删除线程池都会通知到应用的开发负责人。<br>6、操作日志：可以查看线程池参数的修改记录，谁在什么时候修改了线程池参数、修改前的参数值是什么。<br>7、权限校验：只有应用开发负责人才能够修改应用的线程池参数。</p>]]></content>
      
      
      <categories>
          
          <category> 线程池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池在业务中的实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis延时队列</title>
      <link href="2020/08/24/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/12%E3%80%81redis%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/"/>
      <url>2020/08/24/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/12%E3%80%81redis%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<ul><li>超时订单自动取消</li><li>用户未点击确认收货，超时订单自动完成</li></ul><p>定时任务扫表处理的缺点：</p><ul><li>数据量大的情况下延时较高，若在规定时间处理不完，影响业务</li><li>维护多个定时任务，重复扫描业务表</li></ul><h5 id="JDK的DelayQueue延时队列"><a href="#JDK的DelayQueue延时队列" class="headerlink" title="JDK的DelayQueue延时队列"></a>JDK的DelayQueue延时队列</h5><h5 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h5><p>实现原理</p><p>利用 Redis 的 sorted set 结构，使用 timeStamp 作为 score，比如你的任务是要延迟5分钟，那么就在当前时间上加5分钟作为 score ，客户端做轮询处理，且轮询任务每秒只轮询 score 大于当前时间的 key即可</p><p>优点：简单易用</p><p>缺点</p><ul><li>单个 zset 支持不了太大的数据量，百万级的延迟任务需求，则处理不过来</li><li>定时器轮询方案可能会有异常终止的情况需要自己处理，同时消息处理失败的回滚方案，您也要自己处理。</li></ul><h5 id="RabbitMQ-延时队列（常用的落地方式）"><a href="#RabbitMQ-延时队列（常用的落地方式）" class="headerlink" title="RabbitMQ 延时队列（常用的落地方式）"></a>RabbitMQ 延时队列（常用的落地方式）</h5><p>利用RabbitMQ 有两个特性，一个是 Time-To-Live Extensions，另一个是 Dead Letter Exchanges。</p><p>TTL：消息的存活时间，单位为微秒。</p><p>DLX：死信交换机。绑定在死信交换机上的即死信队列。RabbitMQ的Queue（队列）可以配置两个参数x-dead-letter-exchange和x-dead-letter-routing-key（可选），一旦队列内出现了Dead Letter（死信），则按照这两个参数可以将消息重新路由到另一个Exchange（交换机），让消息重新被消费</p><p>我们将订单消息A0001发送到延迟队列order.delay.queue，并设置x-message-tt消息存活时间为30分钟，当到达30分钟后订单消息A0001成为了Dead Letter（死信），延迟队列检测到有死信，通过配置x-dead-letter-exchange，将死信重新转发到能正常消费的关单队列，直接监听关单队列处理关单逻辑即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void send(String delayTimes) &#123;</span><br><span class="line">    amqpTemplate.convertAndSend(&quot;order.pay.exchange&quot;, &quot;order.pay.queue&quot;,&quot;大家好我是延迟数据&quot;, message -&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 设置延迟毫秒值</span><br><span class="line">        message.getMessageProperties().setExpiration(String.valueOf(delayTimes));</span><br><span class="line">        return message;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Bean(name &#x3D; &quot;order.delay.queue&quot;)</span><br><span class="line">public Queue getMessageQueue() &#123;</span><br><span class="line">    return QueueBuilder</span><br><span class="line">            .durable(RabbitConstant.DEAD_LETTER_QUEUE)</span><br><span class="line">            &#x2F;&#x2F; 配置到期后转发的交换</span><br><span class="line">            .withArgument(&quot;x-dead-letter-exchange&quot;, &quot;order.close.exchange&quot;)</span><br><span class="line">            &#x2F;&#x2F; 配置到期后转发的路由键</span><br><span class="line">            .withArgument(&quot;x-dead-letter-routing-key&quot;, &quot;order.close.queue&quot;)</span><br><span class="line">            .build();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>优点：</p><p>如果面临大数据量需求可以很容易的横向扩展，同时消息支持持久化，有问题可回滚。</p><p>缺点：</p><p>配置麻烦，额外增加一个死信交换机和一个死信队列的配置；</p><p>RabbitMQ的定位是消息中间件，TTL 和 DLX 特性去实现一个功能。若需要替换其他MQ，则不满足</p><p>需要考虑不同延迟的消息要放到不同的队列：消息队列具有先进先出的特点，如果第一个进入队列的消息 A 的延迟是10分钟，第二个进入队列的消息B 的延迟是5分钟，期望的是谁先到 TTL谁先出，但是事实是B已经到期了，而还要等到 A 的延迟10分钟结束A先出之后，B 才能出</p><p>当用户发送一个消息请求给服务器后台的时候，服务器会检测这条消息是否需要进行延时处理，如果需要就放入到延时队列中，由延时任务检测器进行检测和处理，对于不需要进行延时处理的任务，服务器会立马对消息进行处理，并把处理后的结果返会给用户。</p><h5 id="Netty-HashedWheelTimer"><a href="#Netty-HashedWheelTimer" class="headerlink" title="Netty#HashedWheelTimer"></a>Netty#HashedWheelTimer</h5><p>HashedWheelTimer 是 Netty 中 的一个基础工具类，主要用来高效处理大量定时任务，且任务对时间精度要求相对不高， 在Netty 中的应用场景就是连接超时或者任务处理超时，一般都是操作比较快速的任务，缺点是内存占用相对较高</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis延时队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志系统</title>
      <link href="2020/08/16/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/9%E3%80%81%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
      <url>2020/08/16/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/9%E3%80%81%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>slf4j是java的一个日志门面（抽象层），实现了日志框架一些通用的api，而log4j和logback或者java.util.logging则是slf4j背后具体的日志框架。具体输出方式规则会去对应的日志框架配置文件（logback.xml或者log4j.xml）</p><p>各个日志框架单独的使用时可以的（不推荐），也可以绑定slf4j一起使用。因为各具体的日志系统会实现slf4j相关接口，log4j、和logback可以随时替换，而不用修改项目的日志输出相关代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;slf4j</span><br><span class="line">　　private static final Logger logger &#x3D; LoggerFactory.getLogger(Tester.class);  &#x2F;&#x2F;通过LoggerFactory获取Logger实例</span><br><span class="line"></span><br><span class="line">　　public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;接口里的统一的调用方法，各具体的日志系统都有实现这些方法</span><br><span class="line">　　logger.info(&quot;testlog: &#123;&#125;&quot;, &quot;test&quot;); </span><br><span class="line"></span><br><span class="line">       logger.debug(&quot;testlog: &#123;&#125;&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">       logger.error(&quot;testlog: &#123;&#125;&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">       logger.trace(&quot;testlog: &#123;&#125;&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">       logger.warn(&quot;testlog: &#123;&#125;&quot;, &quot;test&quot;);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为 ogback 自身实现了 问的<br>接口，无须额外引人适配器，另外 log back lo g4j 的升级版，具备比 log句更多的优点，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4]&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;slf4j-apverson&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;ch.qos.logback&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;logback-classic&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;&#123;logback-classc.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;ch.qos.logback&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;logback-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;logback-core.version)&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>log4j依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--若直接使用了 log 日志库,人曰志库适配器--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j-over-slf4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>slf4j-api(接口层) </li><li>各日志实现包的连接层( slf4j-jdk14, slf4j-log4j) </li><li>结合各日志实现包使用时提供的jar包情况为：</li></ul><p>SLF4J和logback结合使用时需要提供的jar:slf4j-api.jar,logback-classic.jar,logback-core.jar</p><p>SLF4J和log4j结合使用时需要提供的jar:slf4j-api.jar,slf4j-log412.jar,log4j.jar</p><p>SLF4J和JDK中java.util.logging结合使用时需要提供的jar:slf4j-api.jar,slf4j-jdk14.jar</p><p>SLF4J和simple(SLF4J本身提供的一个接口的简单实现)结合使用时需要提供的jar:slf4j-api.jar,slf4j-simple.jar</p><p>==注意==：以上slf4j和各日志实现包结合使用时最好只使用一种结合，不然的话会提示重复绑定日志，并且会导致日志无法输出。</p><p>slf4j-api.jar:对外提供统一的日志调用接口</p><h3 id="lobback-xml配置示例"><a href="#lobback-xml配置示例" class="headerlink" title="lobback.xml配置示例"></a>lobback.xml配置示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration debug&#x3D;&quot;false&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;LOG_HOME&quot; value&#x3D;&quot;&#x2F;home&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--控制台日志， 控制台输出 --&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;STDOUT&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;encoder class&#x3D;&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;</span><br><span class="line">            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度,%msg：日志消息，%n是换行符--&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;&#x2F;pattern&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--文件日志， 按照每天生成日志文件 --&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;FILE&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;!--日志文件输出的文件名--&gt;</span><br><span class="line">            &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;&#x2F;TestWeb.log.%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;FileNamePattern&gt;</span><br><span class="line">            &lt;!--日志文件保留天数--&gt;</span><br><span class="line">            &lt;MaxHistory&gt;30&lt;&#x2F;MaxHistory&gt;</span><br><span class="line">        &lt;&#x2F;rollingPolicy&gt;</span><br><span class="line">        &lt;encoder class&#x3D;&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;</span><br><span class="line">            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;&#x2F;pattern&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">        &lt;!--日志文件最大的大小--&gt;</span><br><span class="line">        &lt;triggeringPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;</span><br><span class="line">            &lt;MaxFileSize&gt;10MB&lt;&#x2F;MaxFileSize&gt;</span><br><span class="line">        &lt;&#x2F;triggeringPolicy&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- show parameters for hibernate sql 专为 Hibernate 定制 --&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;org.hibernate.type.descriptor.sql.BasicBinder&quot; level&#x3D;&quot;TRACE&quot; &#x2F;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;org.hibernate.type.descriptor.sql.BasicExtractor&quot; level&#x3D;&quot;DEBUG&quot; &#x2F;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;org.hibernate.SQL&quot; level&#x3D;&quot;DEBUG&quot; &#x2F;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;org.hibernate.engine.QueryParameters&quot; level&#x3D;&quot;DEBUG&quot; &#x2F;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;org.hibernate.engine.query.HQLQueryPlan&quot; level&#x3D;&quot;DEBUG&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--myibatis log configure--&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;com.apache.ibatis&quot; level&#x3D;&quot;TRACE&quot;&#x2F;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;java.sql.Connection&quot; level&#x3D;&quot;DEBUG&quot;&#x2F;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;java.sql.Statement&quot; level&#x3D;&quot;DEBUG&quot;&#x2F;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;java.sql.PreparedStatement&quot; level&#x3D;&quot;DEBUG&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 日志输出级别 --&gt;</span><br><span class="line">    &lt;root level&#x3D;&quot;DEBUG&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;STDOUT&quot; &#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;FILE&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;root&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="log4j-xml配置示例"><a href="#log4j-xml配置示例" class="headerlink" title="log4j.xml配置示例"></a>log4j.xml配置示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;log4j:configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 将日志信息输出到控制台 --&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;ConsoleAppender&quot; class&#x3D;&quot;org.apache.log4j.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;!-- 设置日志输出的样式 --&gt;</span><br><span class="line">        &lt;layout class&#x3D;&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">            &lt;!-- 设置日志输出的格式 --&gt;</span><br><span class="line">            &lt;param name&#x3D;&quot;ConversionPattern&quot; value&#x3D;&quot;[%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;] [%-5p] [method:%l]%n%m%n%n&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;layout&gt;</span><br><span class="line">        &lt;!--过滤器设置输出的级别--&gt;</span><br><span class="line">        &lt;filter class&#x3D;&quot;org.apache.log4j.varia.LevelRangeFilter&quot;&gt;</span><br><span class="line">            &lt;!-- 设置日志输出的最小级别 --&gt;</span><br><span class="line">            &lt;param name&#x3D;&quot;levelMin&quot; value&#x3D;&quot;WARN&quot; &#x2F;&gt;</span><br><span class="line">            &lt;!-- 设置日志输出的最大级别 --&gt;</span><br><span class="line">            &lt;param name&#x3D;&quot;levelMax&quot; value&#x3D;&quot;ERROR&quot; &#x2F;&gt;</span><br><span class="line">            &lt;!-- 设置日志输出的xxx，默认是false --&gt;</span><br><span class="line">            &lt;param name&#x3D;&quot;AcceptOnMatch&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;filter&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 将日志信息输出到文件，但是当文件的大小达到某个阈值的时候，日志文件会自动回滚 --&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;RollingFileAppender&quot; class&#x3D;&quot;org.apache.log4j.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;!-- 设置日志信息输出文件全路径名 --&gt;</span><br><span class="line">        &lt;param name&#x3D;&quot;File&quot; value&#x3D;&quot;D:&#x2F;log4j&#x2F;RollingFileAppender.log&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- 设置是否在重新启动服务时，在原有日志的基础添加新日志 --&gt;</span><br><span class="line">        &lt;param name&#x3D;&quot;Append&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- 设置保存备份回滚日志的最大个数 --&gt;</span><br><span class="line">        &lt;param name&#x3D;&quot;MaxBackupIndex&quot; value&#x3D;&quot;10&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- 设置当日志文件达到此阈值的时候自动回滚，单位可以是KB，MB，GB，默认单位是KB --&gt;</span><br><span class="line">        &lt;param name&#x3D;&quot;MaxFileSize&quot; value&#x3D;&quot;10KB&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- 设置日志输出的样式 --&gt;</span><br><span class="line">        &lt;layout class&#x3D;&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">            &lt;!-- 设置日志输出的格式 --&gt;</span><br><span class="line">            &lt;param name&#x3D;&quot;ConversionPattern&quot; value&#x3D;&quot;[%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;] [%-5p] [method:%l]%n%m%n%n&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;layout&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 将日志信息输出到文件，可以配置多久产生一个新的日志信息文件 --&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;DailyRollingFileAppender&quot; class&#x3D;&quot;org.apache.log4j.DailyRollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;!-- 设置日志信息输出文件全路径名 --&gt;</span><br><span class="line">        &lt;param name&#x3D;&quot;File&quot; value&#x3D;&quot;D:&#x2F;log4j&#x2F;DailyRollingFileAppender.log&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- 设置日志每分钟回滚一次，即产生一个新的日志文件 --&gt;</span><br><span class="line">        &lt;param name&#x3D;&quot;DatePattern&quot; value&#x3D;&quot;&#39;.&#39;yyyy-MM-dd-HH-mm&#39;.log&#39;&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- 设置日志输出的样式 --&gt;</span><br><span class="line">        &lt;layout class&#x3D;&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">            &lt;!-- 设置日志输出的格式 --&gt;</span><br><span class="line">            &lt;param name&#x3D;&quot;ConversionPattern&quot; value&#x3D;&quot;[%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;] [%-5p] [method:%l]%n%m%n%n&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;layout&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">     注意：</span><br><span class="line">     1：当additivity&#x3D;&quot;false&quot;时，root中的配置就失灵了，不遵循缺省的继承机制</span><br><span class="line">     2：logger中的name非常重要，它代表记录器的包的形式，有一定的包含关系，试验表明</span><br><span class="line">        2-1：当定义的logger的name同名时，只有最后的那一个才能正确的打印日志</span><br><span class="line">        2-2：当对应的logger含有包含关系时，比如：name&#x3D;test.log4j.test8 和 name&#x3D;test.log4j.test8.UseLog4j，则2-1的情况是一样的</span><br><span class="line">        2-3：logger的name表示所有的包含在此名的所有记录器都遵循同样的配置，name的值中的包含关系是指记录器的名称哟！注意啦！</span><br><span class="line">     3：logger中定义的level和appender中的filter定义的level的区间取交集</span><br><span class="line">     4：如果appender中的filter定义的 levelMin &gt; levelMax ，则打印不出日志信息</span><br><span class="line">     --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 指定logger的设置，additivity指示是否遵循缺省的继承机制--&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;test.log4j.test8.UseLog4j&quot; additivity&#x3D;&quot;false&quot;&gt;</span><br><span class="line">        &lt;level value &#x3D;&quot;WARN&quot;&#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;DailyRollingFileAppender&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;logger&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--指定logger的设置，additivity指示是否遵循缺省的继承机制 --&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;test.log4j.test8.UseLog4j_&quot; additivity&#x3D;&quot;false&quot;&gt;</span><br><span class="line">        &lt;level value &#x3D;&quot;ERROR&quot;&#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;RollingFileAppender&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;logger&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 根logger的设置--&gt;</span><br><span class="line">    &lt;root&gt;</span><br><span class="line">        &lt;level value &#x3D;&quot;INFO&quot;&#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;ConsoleAppender&quot;&#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;DailyRollingFileAppender&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;root&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;log4j:configuration&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 日志系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类</title>
      <link href="2020/08/16/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>2020/08/16/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<ul><li>静态内部类，如 static class StaticinnerC!ass {} ; </li><li>·成员内部类，如： private class InstancelnnerC!ass {} ; </li><li>·局部内部类，定义在方法或者表达式内部，</li><li>·匿名内部类，如： (new Thread(){} ).start（）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内部类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无标题Markdown</title>
      <link href="2020/08/15/Study%20notes/%E6%B5%8B%E8%AF%95/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/"/>
      <url>2020/08/15/Study%20notes/%E6%B5%8B%E8%AF%95/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/</url>
      
        <content type="html"><![CDATA[<p>测试阶段的测试方法，可以大致分为五种：白盒测试，黑盒测试，灰盒测试，静态测试与动态测试。</p><p>==白盒测试==</p><p>就是关注代码实现逻辑，从而产生的测试行为，仔细检查代码内部有无错误。</p><p>不关注代码实现逻辑，而产生的测试行为，就是黑盒测试。在这个测试过程中，我们只关注系统的输出是否满足我们的要求。</p><p>冒烟测试</p><p>冒烟测试最关心的不是功能的覆盖，而是对重要功能或者核心功能的保障。到了这一步，通常在线上部署完成后，为了进一步确保它是一次成功的部署，需要有快速而易于执行的测试来覆盖核心测试用例。冒烟测试目的是确认系统和程序基本功能正常。冒烟测试的执行者往往就是开发人员，</p><p>冒烟测试最容易出现的问题，是用例简洁程度和核心功能覆盖的不平衡。冒烟测试要求用例尽可能简单，这样也能保证执行迅速，不拖慢整个部署的过程；但是，另一方面我们也希望核心功能都被覆盖到，许多团队容易犯的错误，就是在产品一开始的时候可以将冒烟测试的用例管理得非常好，但是随着时间进展，冒烟测试变得越来越笨重而庞大，最终失去了平衡。</p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标题Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="2020/08/15/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/1%E3%80%81HTTP/"/>
      <url>2020/08/15/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/1%E3%80%81HTTP/</url>
      
        <content type="html"><![CDATA[<p>连接超时参数 ConnectTimeout，让用户配置建连阶段的最长等待时间。</p><h4 id="ConnectTimeout"><a href="#ConnectTimeout" class="headerlink" title="ConnectTimeout"></a>ConnectTimeout</h4><p>让用户配置建连阶段的最长等待时间</p><p>一般来说，TCP 三次握手建立连接需要的时间非常短，通常在毫秒级最多到秒级，如果几秒连接不上，那么可能永远也连接不上。因此，设置特别长的连接超时意义不大，将其配置得短一些（比如 1~5 秒）即可。如果是纯内网调用的话，这个参数可以设置得更短，在下游服务离线无法连接的时候，可以快速失败。</p><h4 id="ReadTimeout"><a href="#ReadTimeout" class="headerlink" title="ReadTimeout"></a>ReadTimeout</h4><p>是建立连接后从服务器读取到可用资源所用的时间。</p><p>HTTP 请求通过 URL 传递参数时，不能超过 2048 字节。</p><p>HTTP 请求通过 body 传递内容时，nginx 默认限制是 1MB，tomcat 默认限制为 2MB，当确实有业务需要传较大内容时，可以通过调<br>大服务器端的限制</p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>持久化</title>
      <link href="2020/08/14/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/8%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>2020/08/14/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/8%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="1、RDB（默认持久化方式）"><a href="#1、RDB（默认持久化方式）" class="headerlink" title="1、RDB（默认持久化方式）"></a>1、RDB（默认持久化方式）</h2><p>RDB生成数据快照（以文件的形式将某一时刻的数据全部写到磁盘上）。RDB持久化配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 时间策略</span><br><span class="line">#表示900s内如果有1条是写入命令，就触发产生一次快照，可以理解为就进行一次备份</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">#禁用RDB配置，也是非常容易的，只需要在save的最后一行写上：save &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 文件名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># 文件保存路径</span><br><span class="line">dir &#x2F;home&#x2F;work&#x2F;app&#x2F;redis&#x2F;data&#x2F;</span><br><span class="line"></span><br><span class="line"># 如果持久化出错，主进程是否停止写入</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># 是否压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line">#Redis本身就属于CPU密集型服务器，再开启压缩会带来更多的CPU消耗，相比硬盘成本，CPU更值钱。</span><br><span class="line"></span><br><span class="line"># 导入时是否检查</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure><p>RDB给哪些内存数据做快照</p><p>为了提供所有数据的可靠性保证，它执行的是全量快照</p><h3 id="2、RDB快照方式："><a href="#2、RDB快照方式：" class="headerlink" title="2、RDB快照方式："></a>2、RDB快照方式：</h3><p>save命令（已废弃）：阻塞当前Redis服务器，直到RDB过程完成为止，线上环境不建议使用</p><p>bgsave命令：Redis进程执行fork操作创建子进程（fork阶段会阻塞，但是很短）</p><p>一旦有新写数据时，redis数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件。</p><p>同时允许主线程可以修改数据，只是修改的数并不在本次的RDB中</p><h3 id="2、RDB过程："><a href="#2、RDB过程：" class="headerlink" title="2、RDB过程："></a>2、RDB过程：</h3><ul><li>执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进程，如RDB/AOF子进程，如果存在bgsave命令直接返回</li><li>父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞</li><li>父进程fork完成后，bgsave命令返回“Background saving started”信息</li><li>并不再阻塞父进程，可以继续响应其他命令</li><li>子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后<br>对原有文件进行原子替换</li></ul><h3 id="2、RDB快照频率"><a href="#2、RDB快照频率" class="headerlink" title="2、RDB快照频率"></a>2、RDB快照频率</h3><p>频率过高</p><ul><li>一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力</li><li>另一方面频繁的每次fork 操作，会阻塞主线程</li></ul><p>频率过低，发送一次宕机，则数据丢失严重。</p><p>RDB的优点：</p><ul><li>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份</li><li>Redis加载RDB恢复数据远远快于AOF的方式（因为只是恢复数据，不是执行语句）</li></ul><p>RDB的缺点：</p><ul><li>RDB方式数据没办法做到实时持久化/秒级持久化。因为不能实时创建fork子进程。会造成部分数据丢失</li></ul><h2 id="3、AOF"><a href="#3、AOF" class="headerlink" title="3、AOF"></a>3、AOF</h2><p>记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据。（类似于记录sql语句）</p><p>Redis 是先执行命令，把数据写入内存，然后才记录日志。与数据库的写前日志顺序相反。<br>1、不会阻塞当前的写操作<br>2、避免记录错误命令，导致数据恢复异常。【为了避免额外开销，记录日志的时候，并不会先去对这些命令进行语法检查。所以命令检查交给redis本身去做】</p><p>AOF的两个分享：</p><p>1、redis刚执行完一个命令，还没有来得及记日志就宕机了.导致数据丢失<br>2、AOF 日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。</p><p>解决方案：控制AOF 日志写回磁盘的时机</p><p>AOF 机制给我们提供了三个选择，也就是 AOF 配置项 appendfsync 的三个可选值。但都不能完美解决数据丢失的风险</p><ul><li>Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；【写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能】</li><li>Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；【但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失】</li><li>No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。【落盘的时机已经不在 Redis 手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了】</li></ul><p>AOF 的重写机制</p><p>定期对AOF文件进行重写，达到压缩AOF日志的目的</p><p>AOF 文件是以追加的方式，逐一记录接收到的写命令的，当一个键值对被多条写命令反复修改时，AOF 文件会记录相应的多条命令。但是，在AOF重写的时候，是根据这个键值对当前的最新状态，为它生成对应的一条写入命令。在日志恢复时，只用执行这条命令，就可以直接完成这个键值对的写入了。</p><p>AOF 的重写过程：一个拷贝，两处日志<br><img src="https://static001.geekbang.org/resource/image/57/e1/5770a4f81fb0469656fef2b35d354fe1.jpg" alt="image"></p><p>重写过程是由后台线程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。</p><p>“一个拷贝”就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p><p>AOF日志：因为主线程未阻塞，仍然可以处理新来的操作，如果有写操作，第一处日志就是指正在使用的 AOF 日志。</p><p>AOF 重写日志：这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件。此时，就可以用新的 AOF 文件替代旧文件了</p><p>总结：每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失</p><p>AOF配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 是否开启aof</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"># 文件名称</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># 同步方式</span><br><span class="line">appendfsync everysec</span><br><span class="line">#always：把每个写命令都立即同步到aof，很慢，但是很安全</span><br><span class="line">#everysec：每秒同步一次，是折中方案，一般情况下都采用 everysec 配置，这样可以兼顾速度与安全，最多损失1s的数据。</span><br><span class="line">#no：redis不处理交给OS来处理，非常快，但是也最不安全</span><br><span class="line"></span><br><span class="line"># aof重写期间是否同步</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># 重写触发配置</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># 加载aof时如果有错如何处理</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 文件重写策略</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure><p>AOF流程：</p><ul><li>所有的写入命令会追加到aof_buf（缓冲区）中</li><li>AOF缓冲区根据对应的策略向硬盘做同步操作</li><li>随着AOF文件越来越大，需要定期对AOF文件进行重写（已经确认过时数据操作记录重写的时候不再保存），达到压缩的目的。</li><li>当Redis服务器重启时，可以加载AOF文件，执行redis语句，进行数据恢复</li></ul><h2 id="4、从持久化中恢复数据"><a href="#4、从持久化中恢复数据" class="headerlink" title="4、从持久化中恢复数据"></a>4、从持久化中恢复数据</h2><p>如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？数据库的职责都是在保证数据完整性的前提下再追求性能。所以redis会优先加载AOF文件。因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。</p><p>较优方案：</p><p>Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。<br>内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p><p>既避免了频繁 fork 对主线程的影响，AOF 日志也只用记录两次快照间的操作，避免AOF日志过大重写的开销。颇有点“鱼和熊掌可以兼得”</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hash表</title>
      <link href="2020/08/13/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8/1%E3%80%81hash%E8%A1%A8/"/>
      <url>2020/08/13/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8/1%E3%80%81hash%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>哈希表本质上是一个数组，只是数组只能根据下标，像a[0] a[1] a[2] a[3] 这样来访问，而哈希表的key则是以字符串类型为主的。</p><p>通过哈希函数，我们可以把字符串或其他类型的key，转化成数组的下标index。</p><h3 id="1、hash函数"><a href="#1、hash函数" class="headerlink" title="1、hash函数"></a>1、hash函数</h3><p>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法。在安全领域应用最为广泛的是SHA-x系列和MDx系列。如MD5,就是一种被广泛使用的密码散列函数。</p><p>MD5(12)=C20AD4D76FE97759AA27A0C99BFF6710  </p><p>MD5(123)=202CB962AC59075B964B07152D234B70</p><h3 id="2、hash表"><a href="#2、hash表" class="headerlink" title="2、hash表"></a>2、hash表</h3><p>散列表（Hash table，也叫哈希表），就是通过散列函数将关键码值(key值)映射到数组中一个位置，该位置用于存储key对应的value，存放记录的数组叫做散列表。</p><p>可以通过key的散列函数，快速定位到数据的位置，取出value值。时间复杂度O（1）（hasn不冲突的情况）</p><h3 id="3、为什么hash函数无法做到零冲突？"><a href="#3、为什么hash函数无法做到零冲突？" class="headerlink" title="3、为什么hash函数无法做到零冲突？"></a>3、为什么hash函数无法做到零冲突？</h3><p>比如上面 MD5 的例子，哈希值是固定的 128 位二进制串，能表示的数据是有限的，最多能表示 2^128 个数据，而我们要哈希的key是无穷的。基于鸽巢原理，如果我们对 2^128+1 个数据求哈希值，就必然会存在哈希值相同的情况。所以哈希值越长的哈希算法，散列冲突的概率越低。</p><h3 id="3、hash函数设计考虑的因素："><a href="#3、hash函数设计考虑的因素：" class="headerlink" title="3、hash函数设计考虑的因素："></a>3、hash函数设计考虑的因素：</h3><p>（1）基于数据安全性考虑，从哈希值不能反向推导出原始数据</p><p>（2）对输入数据非常敏感，哪怕原始数据只修改了一个 Bit位，最后得到的哈希值也大不相同；</p><p>（3）散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</p><p>（4）哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</p><h3 id="4、优秀的hash函数的构造方式："><a href="#4、优秀的hash函数的构造方式：" class="headerlink" title="4、优秀的hash函数的构造方式："></a>4、优秀的hash函数的构造方式：</h3><p>（1）直接定址法：取关键字的某个线性函数值为散列地址 f(key) = a × key + b</p><p>（2）除留余数法 (用的较多) ：f( key ) = key mod p ( p ≤ m )。mod是取模（求余数）的意思。事实上，这方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。</p><p>（3）平方取中法</p><p>（4）折叠法：将关键字拆分成几部分，然后将这几部分组合在一起，以特定的方式进行转化形成Hash地址。假如知道图书的ISBN号为8903-241-23，可以将Hash(key)=89+03+24+12+3作为Hash地址</p><p>（5）数字分析法</p><p>（6）随机数法</p><p>（7）time33算法(PHP的数组就是把这个作为哈希函数）</p><p>以上hash函数感兴趣可以查询相关资料，了解其原理</p><h3 id="5、hash函数的应用："><a href="#5、hash函数的应用：" class="headerlink" title="5、hash函数的应用："></a>5、hash函数的应用：</h3><p>（1）安全加密：最常用于加密的哈希算法是MD5和SHA、DES、AES；利用散列函数散列值不能反向推导出原始数据的特性</p><p>（2）唯一标识：如海量图片中判断某张图片是否存在、数据库主键等应用</p><p>（3）负载均衡：</p><p>对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。 这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。</p><p>（4）分布式存储：数据根据哈希函数映射到某台机器上存储</p><h3 id="6、hash表的应用："><a href="#6、hash表的应用：" class="headerlink" title="6、hash表的应用："></a>6、hash表的应用：</h3><p>工业级的散列表：HashMap</p><p>Redis的数据类型Hash，底层就是散列表</p><p>Redis的数据类型Set，内部实现是一个value永远为null的散列表</p><p>Redis的数据类型Sorted Set(有序集合)，底层编码实现ziplist和skiplist，skiplist底层就是跳跃链表+hash表</p><h3 id="7、哈希表中哈希冲突解决方式："><a href="#7、哈希表中哈希冲突解决方式：" class="headerlink" title="7、哈希表中哈希冲突解决方式："></a>7、哈希表中哈希冲突解决方式：</h3><p><strong>（1）探测法</strong></p><p>当key1和key2的hash值发生冲突时，使用某种探测技术在Hash表中形成一个探测序列，然后沿着这个探测序列依次查找下去，当碰到一个空的单元时，则插入其中。</p><p>探测技术有线性探测、二次探测、随机探测</p><p>这里以线性探测为例：</p><p><img src="https://img-blog.csdnimg.cn/20190820213718211.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzMwMTMwNzgz,size_16,color_FFFFFF,t_70" alt="image"></p><p><strong>（2）再哈希法</strong>，同时构造多个不同的哈希函数，若对于k1和k2的hash函数的值相同，则为hash冲突，这是再用hash2函数计算k2的hash值，放入哈希表中。这种方式增加了计算时间</p><p><strong>（3）链地址法</strong></p><p><img src="https://img-blog.csdnimg.cn/2019082021450745.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzMwMTMwNzgz,size_16,color_FFFFFF,t_70" alt="image"></p><h3 id="8、hash表的性能"><a href="#8、hash表的性能" class="headerlink" title="8、hash表的性能"></a>8、hash表的性能</h3><p>查找或者插入的情况在大多数情况下可以达到O(1)，因为可以通过key的hasn函数，直接定位到数据存放位置。所以操作的时间主要花在计算hash上。</p><p>最坏的情况就是hash值全都映射到同一个地址上，这样哈希表就会退化成链表，查找的时间复杂度变成O(n)。这种情况有人蓄意攻击，需要了解基于哈希冲突的拒绝服务攻击。</p>]]></content>
      
      
      <categories>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hash表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树（BST）</title>
      <link href="2020/08/13/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6%E3%80%81%E6%A0%91/2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88BST%EF%BC%89/"/>
      <url>2020/08/13/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6%E3%80%81%E6%A0%91/2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88BST%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>二叉树定义：</p><p>每个节点最多只能有两个子节点的一种形式称为二叉树<br>，二叉树==按照关键字来进行排列（小的在左，大的在右）的的特殊二叉树，就是二叉搜索树==。  </p><ul><li><p>满二叉树：一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。</p></li><li><p>完全二叉树：如果二叉树的深度为k，则除第k层外其余所有层节点的度都为2，且叶子节点从左到右依次存在。<br><img src="https://static001.geekbang.org/resource/image/18/60/18413c6597c2850b75367393b401ad60.jpg" alt="image"><br>完全二叉树比较适合用数组来存储，节省空间</p></li></ul><h3 id="树的存储方式一：基于数组"><a href="#树的存储方式一：基于数组" class="headerlink" title="树的存储方式一：基于数组"></a>树的存储方式一：基于数组</h3><p>基于数组的顺序存储法。我们把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。<br><img src="https://static001.geekbang.org/resource/image/14/30/14eaa820cb89a17a7303e8847a412330.jpg" alt="image"></p><p>==如果节点 X 存储在数组中下标为 i 的位置，<br>下标为 2 * i 的位置存储的就是左子节点，<br>下标为 2 * i + 1 的位置存储的就是右子节点。==</p><p>反过来，下标为 i/2 的位置存储就是它的父节点。</p><p>通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。</p><p>==堆其实就是一种完全二叉树，最常用的存储方式就是数组。==</p><h3 id="树的存储方式二：链式存储"><a href="#树的存储方式二：链式存储" class="headerlink" title="树的存储方式二：链式存储"></a>树的存储方式二：链式存储</h3><p><img src="https://static001.geekbang.org/resource/image/12/8e/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg" alt="image"></p><h3 id="二叉树遍历O-n-："><a href="#二叉树遍历O-n-：" class="headerlink" title="二叉树遍历O(n)："></a>二叉树遍历O(n)：</h3><ul><li>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</li><li>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</li><li>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</li><li>层次遍历：仅仅需按层次遍历就可以</li></ul><p><img src="https://images2017.cnblogs.com/blog/1120165/201712/1120165-20171218095635037-690274195.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void preOrder(Node* root) &#123;</span><br><span class="line">  if (root &#x3D;&#x3D; null) return;</span><br><span class="line">  print root &#x2F;&#x2F; 此处为伪代码，表示打印 root 节点</span><br><span class="line">  preOrder(root-&gt;left);</span><br><span class="line">  preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void inOrder(Node* root) &#123;</span><br><span class="line">  if (root &#x3D;&#x3D; null) return;</span><br><span class="line">  inOrder(root-&gt;left);</span><br><span class="line">  print root &#x2F;&#x2F; 此处为伪代码，表示打印 root 节点</span><br><span class="line">  inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void postOrder(Node* root) &#123;</span><br><span class="line">  if (root &#x3D;&#x3D; null) return;</span><br><span class="line">  postOrder(root-&gt;left);</span><br><span class="line">  postOrder(root-&gt;right);</span><br><span class="line">  print root &#x2F;&#x2F; 此处为伪代码，表示打印 root 节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="二叉树的节点："><a href="#二叉树的节点：" class="headerlink" title="　二叉树的节点："></a>　二叉树的节点：</h4><p>二叉查找树一个节点：节点值、节点的左子节点的地址、节点的右子节点的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line">    private Object data;    &#x2F;&#x2F;节点数据</span><br><span class="line">    private Node leftChild; &#x2F;&#x2F;左子节点的引用</span><br><span class="line">    private Node rightChild; &#x2F;&#x2F;右子节点的引用</span><br><span class="line">    &#x2F;&#x2F;打印节点内容</span><br><span class="line">    public void display()&#123;</span><br><span class="line">        System.out.println(data);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的接口："><a href="#二叉树的接口：" class="headerlink" title="　二叉树的接口："></a>　二叉树的接口：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public interface Tree &#123;</span><br><span class="line">     &#x2F;&#x2F;查找节点</span><br><span class="line">    public Node find(int key);</span><br><span class="line">    &#x2F;&#x2F;插入新节点</span><br><span class="line">    public boolean insert(int data);</span><br><span class="line">    &#x2F;&#x2F;中序遍历</span><br><span class="line">    public void infixOrder(Node current);</span><br><span class="line">    &#x2F;&#x2F;前序遍历</span><br><span class="line">    public void preOrder(Node current);</span><br><span class="line">    &#x2F;&#x2F;后序遍历</span><br><span class="line">    public void postOrder(Node current);</span><br><span class="line">    &#x2F;&#x2F;查找最大值</span><br><span class="line">    public Node findMax();</span><br><span class="line">    &#x2F;&#x2F;查找最小值</span><br><span class="line">    public Node findMin()</span><br><span class="line">    &#x2F;&#x2F;删除节点</span><br><span class="line">    public boolean delete(int key);</span><br><span class="line">    &#x2F;&#x2F;Other Method......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、查找节点（while循环）"><a href="#1、查找节点（while循环）" class="headerlink" title="1、查找节点（while循环）"></a>1、查找节点（while循环）</h4><p>查询节点的步骤：</p><p>必须从根节点开始遍历。</p><p>　　①、查找值比当前节点值大，则搜索右子树；</p><p>　　②、查找值等于当前节点值，停止搜索（终止条件）；</p><p>　　③、查找值小于当前节点值，则搜索左子树；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Node find(int key) &#123;</span><br><span class="line">    Node current &#x3D; root;</span><br><span class="line">    while(current !&#x3D; null)&#123;</span><br><span class="line">        if(current.data &gt; key)&#123;&#x2F;&#x2F;当前值比查找值大，搜索左子树</span><br><span class="line">            current &#x3D; current.leftChild;</span><br><span class="line">        &#125;else if(current.data &lt; key)&#123;&#x2F;&#x2F;当前值比查找值小，搜索右子树</span><br><span class="line">            current &#x3D; current.rightChild;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;&#x2F;&#x2F;遍历完整个树没找到，返回null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树的效率：查找节点的时间取决于这个节点所在的层数，每一层最多有2n-1个节点，总共N层共有2n-1个节点，那么时间复杂度为O(logn),底数为2。</p><h4 id="2、插入节点"><a href="#2、插入节点" class="headerlink" title="2、插入节点"></a>2、插入节点</h4><p>要插入节点，必须先找到插入的位置。与查找操作相似，由于二叉搜索树的特殊性，待插入的节点也需要从根节点开始进行比较，小于根节点则与根节点左子树比较，反之则与右子树比较，直到左子树为空或右子树为空，则插入到相应为空的位置，在比较的过程中要注意保存父节点的信息 及 待插入的位置是父节点的左子树还是右子树，才能插入到正确的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;插入节点</span><br><span class="line">public boolean insert(int data) &#123;</span><br><span class="line">    Node newNode &#x3D; new Node(data);</span><br><span class="line">    if(root &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;当前树为空树，没有任何节点</span><br><span class="line">        root &#x3D; newNode;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        Node current &#x3D; root;</span><br><span class="line">        Node parentNode &#x3D; null;</span><br><span class="line">        while(current !&#x3D; null)&#123;</span><br><span class="line">            parentNode &#x3D; current;</span><br><span class="line">            if(current.data &gt; data)&#123;&#x2F;&#x2F;当前值比插入值大，搜索左子节点</span><br><span class="line">                current &#x3D; current.leftChild;</span><br><span class="line">                if(current &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;左子节点为空，直接将新值插入到该节点</span><br><span class="line">                    parentNode.leftChild &#x3D; newNode;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                current &#x3D; current.rightChild;</span><br><span class="line">                if(current &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;右子节点为空，直接将新值插入到该节点</span><br><span class="line">                    parentNode.rightChild &#x3D; newNode;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、遍历树-递归法"><a href="#3、遍历树-递归法" class="headerlink" title="3、遍历树 (递归法)"></a>3、遍历树 (递归法)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;中序遍历</span><br><span class="line">public void infixOrder(Node current)&#123;</span><br><span class="line">    if(current !&#x3D; null)&#123;</span><br><span class="line">        infixOrder(current.leftChild);</span><br><span class="line">        System.out.print(current.data+&quot; &quot;);</span><br><span class="line">        infixOrder(current.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;前序遍历</span><br><span class="line">public void preOrder(Node current)&#123;</span><br><span class="line">    if(current !&#x3D; null)&#123;</span><br><span class="line">        System.out.print(current.data+&quot; &quot;);</span><br><span class="line">        preOrder(current.leftChild);</span><br><span class="line">        preOrder(current.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;后序遍历</span><br><span class="line">public void postOrder(Node current)&#123;</span><br><span class="line">    if(current !&#x3D; null)&#123;</span><br><span class="line">        postOrder(current.leftChild);</span><br><span class="line">        postOrder(current.rightChild);</span><br><span class="line">        System.out.print(current.data+&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、查找最值"><a href="#4、查找最值" class="headerlink" title="4、查找最值"></a>4、查找最值</h4><p>要找最小值，先找根的左节点，然后一直找这个左节点的左节点，直到找到没有左节点的节点，那么这个节点就是最小值。同理要找最大值，一直找根节点的右节点，直到没有右节点，则就是最大值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;找到最大值</span><br><span class="line">public Node findMax()&#123;</span><br><span class="line">    Node current &#x3D; root;</span><br><span class="line">    Node maxNode &#x3D; current;</span><br><span class="line">    while(current !&#x3D; null)&#123;</span><br><span class="line">        maxNode &#x3D; current;</span><br><span class="line">        current &#x3D; current.rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxNode;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;找到最小值</span><br><span class="line">public Node findMin()&#123;</span><br><span class="line">    Node current &#x3D; root;</span><br><span class="line">    Node minNode &#x3D; current;</span><br><span class="line">    while(current !&#x3D; null)&#123;</span><br><span class="line">        minNode &#x3D; current;</span><br><span class="line">        current &#x3D; current.leftChild;</span><br><span class="line">    &#125;</span><br><span class="line">    return minNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、删除节点"><a href="#5、删除节点" class="headerlink" title="5、删除节点　"></a>5、删除节点　</h4><p>　　删除节点是二叉搜索树中最复杂的操作，删除的节点有三种情况，前两种比较简单，但是第三种却很复杂。</p><ul><li>该节点是叶节点（没有子节点）</li><li>该节点有一个子节点</li><li>该节点有两个子节点</li></ul><ul><li>5.1、删除没有子节点的节点(叶节点)</li></ul><p>删除节点，我们要先找到该节点，并记录该节点的父节点。在检查该节点是否有子节点。如果没有子节点，接着检查其是否是根节点，如果是根节点，只需要将其设置为null即可。如果不是根节点，是叶节点，那么断开父节点和其的关系即可。<br>　<br>　<img src="https://images2017.cnblogs.com/blog/1120165/201712/1120165-20171218104533818-844513438.png" alt="image">　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean delete(int key) &#123;</span><br><span class="line">    Node current &#x3D; root;</span><br><span class="line">    Node parent &#x3D; root;</span><br><span class="line">    boolean isLeftChild &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;查找删除值，找不到直接返回false</span><br><span class="line">    while(current.data !&#x3D; key)&#123;</span><br><span class="line">        parent &#x3D; current;</span><br><span class="line">        if(current.data &gt; key)&#123;</span><br><span class="line">            isLeftChild &#x3D; true;</span><br><span class="line">            current &#x3D; current.leftChild;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            isLeftChild &#x3D; false;</span><br><span class="line">            current &#x3D; current.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">        if(current &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果当前节点没有子节点</span><br><span class="line">    if(current.leftChild &#x3D;&#x3D; null &amp;&amp; current.rightChild &#x3D;&#x3D; null)&#123;</span><br><span class="line">        if(current &#x3D;&#x3D; root)&#123;</span><br><span class="line">            root &#x3D; null;</span><br><span class="line">        &#125;else if(isLeftChild)&#123;</span><br><span class="line">            parent.leftChild &#x3D; null;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            parent.rightChild &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>5.2、删除有一个子节点的节点</li></ul><p>我们只需要将其父节点原本指向该节点的引用，改为指向该节点的子节点即可。</p><p><img src="https://images2017.cnblogs.com/blog/1120165/201712/1120165-20171218124801818-344487472.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;当前节点有一个子节点</span><br><span class="line">if(current.leftChild &#x3D;&#x3D; null &amp;&amp; current.rightChild !&#x3D; null)&#123;</span><br><span class="line">    if(current &#x3D;&#x3D; root)&#123;</span><br><span class="line">        root &#x3D; current.rightChild;</span><br><span class="line">    &#125;else if(isLeftChild)&#123;</span><br><span class="line">        parent.leftChild &#x3D; current.rightChild;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        parent.rightChild &#x3D; current.rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    &#x2F;&#x2F;current.leftChild !&#x3D; null &amp;&amp; current.rightChild &#x3D;&#x3D; null</span><br><span class="line">    if(current &#x3D;&#x3D; root)&#123;</span><br><span class="line">        root &#x3D; current.leftChild;</span><br><span class="line">    &#125;else if(isLeftChild)&#123;</span><br><span class="line">        parent.leftChild &#x3D; current.leftChild;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        parent.rightChild &#x3D; current.leftChild;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>5.3、 删除有两个子节点的节点(此处注意理解)</li></ul><p>删除有两个子节点的节点后，那么该删除的节点的两个子节点放在哪儿?</p><p>==要找比删除节点关键值大的节点集合中最小的一个节点，来代替删除节点的位置==</p><p><img src="https://images2017.cnblogs.com/blog/1120165/201712/1120165-20171218152127162-7787702.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public Node getSuccessor(Node delNode)&#123;</span><br><span class="line">    Node successorParent &#x3D; delNode;</span><br><span class="line">    Node successor &#x3D; delNode;</span><br><span class="line">    Node current &#x3D; delNode.rightChild;</span><br><span class="line">    while(current !&#x3D; null)&#123;</span><br><span class="line">        successorParent &#x3D; successor;</span><br><span class="line">        successor &#x3D; current;</span><br><span class="line">        current &#x3D; current.leftChild;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;将后继节点替换删除节点</span><br><span class="line">    if(successor !&#x3D; delNode.rightChild)&#123;</span><br><span class="line">        successorParent.leftChild &#x3D; successor.rightChild;</span><br><span class="line">        successor.rightChild &#x3D; delNode.rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    return successor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除节点的简单方式："><a href="#删除节点的简单方式：" class="headerlink" title="删除节点的简单方式："></a>删除节点的简单方式：</h2><p>只需要在Node类中增加一个标识字段isDelete，当该字段为true时，表示该节点已经删除，反正没有删除。那么我们在做比如find()等操作的时候，要先判断isDelete字段是否为true。这样删除的节点并不会改变树的结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line">    int data;   &#x2F;&#x2F;节点数据</span><br><span class="line">    Node leftChild; &#x2F;&#x2F;左子节点的引用</span><br><span class="line">    Node rightChild; &#x2F;&#x2F;右子节点的引用</span><br><span class="line">    boolean isDelete;&#x2F;&#x2F;表示节点是否被删除</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h2><p>节点数据重复处理方式：</p><ul><li><p>第一种方法比较容易。通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p></li><li><p>第二种，把这个新插入的相同的数据当作大于这个节点的值来处理。放到这个节点的右子树</p></li></ul><p>（1）当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。</p><p>（2）删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。</p>]]></content>
      
      
      <categories>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树（BST） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="2020/08/13/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7%E3%80%81%E5%A0%86/%E5%A0%86/"/>
      <url>2020/08/13/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7%E3%80%81%E5%A0%86/%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<ul><li>堆是一个完全二叉树；==完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。==</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</li></ul><p>完全二叉树：如果二叉树的深度为k，则除第k层外其余所有层节点的度都为2，且叶子节点从左到右依次存在。也即是，将满二叉树的最后一层从左到右依次删除若干节点就得到完全二叉树。满二叉树是一棵特殊的完全二叉树，但完全二叉树不一定是满二叉树。<br><img src="https://static001.geekbang.org/resource/image/18/60/18413c6597c2850b75367393b401ad60.jpg" alt="image"></p><p>堆是具有以下性质的完全二叉树：==每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。==<br><img src="https://static001.geekbang.org/resource/image/4c/99/4c452a1ad3b2d152daa2727d06097099.jpg" alt="image"></p><p>第 1 个和第 2 个是大顶堆，第 3 个是小顶堆，第 4 个不是堆</p><h3 id="堆的实现："><a href="#堆的实现：" class="headerlink" title="堆的实现："></a>堆的实现：</h3><p>完全二叉树比较适合用数组来存储，节省空间<br><img src="https://static001.geekbang.org/resource/image/4d/1e/4d349f57947df6590a2dd1364c3b0b1e.jpg" alt="image"></p><p>数组中下标为 i 的节点的左子节点，就是下标为 i∗2 的节点，右子节点就是下标为 i∗2+1 的节点，父节点就是下标为 i/2 的节点。</p>]]></content>
      
      
      <categories>
          
          <category> 堆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>限流框架</title>
      <link href="2020/08/13/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98/%E9%99%90%E6%B5%81%E6%A1%86%E6%9E%B6/1%E3%80%81%E9%99%90%E6%B5%81%E6%A1%86%E6%9E%B6/"/>
      <url>2020/08/13/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98/%E9%99%90%E6%B5%81%E6%A1%86%E6%9E%B6/1%E3%80%81%E9%99%90%E6%B5%81%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>中台服务需要对每个调用方的每个接口做到接口限流，比如，限制 调用方app-1 对接口 /user/query 的访问频率为每秒钟不超过 100 次。</p><p>设计一个限流框架项目，将它抽象成通用的框架、组件、类库等。集成到三方服务中</p><p>为了做到在不修改代码的前提下修改限流规则，我们一般会把规则放到配置文件中（比如 XML、YAML 配置文件）：unit 表示限流时间粒度，默认情况下是 1 秒。第一条规则来举例，它表示的意思就是：调用方 app-1 对接口 /v1/user 每分钟的最大请求次数不能超过 100 次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">configs:</span><br><span class="line">- appId: app-1</span><br><span class="line">  limits:</span><br><span class="line">  - api: &#x2F;v1&#x2F;user</span><br><span class="line">    limit: 100</span><br><span class="line">    unit：60</span><br><span class="line">  - api: &#x2F;v1&#x2F;order</span><br><span class="line">    limit: 50</span><br><span class="line">- appId: app-2</span><br><span class="line">  limits:</span><br><span class="line">  - api: &#x2F;v1&#x2F;user</span><br><span class="line">    limit: 50</span><br><span class="line">  - api: &#x2F;v1&#x2F;order</span><br><span class="line">    limit: 50</span><br></pre></td></tr></table></figure><p>在接收到接口请求之后，应用会将请求发送给限流框架，限流框架会告诉应用，这个接口请求是允许继续处理，还是触发限流熔断。如果项目使用的是 Spring 框架可以放到切面或者拦截器中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String appId &#x3D; &quot;app-1&quot;; &#x2F;&#x2F; 调用方APP-ID</span><br><span class="line">String url &#x3D; &quot;http:&#x2F;&#x2F;www.eudemon.com&#x2F;v1&#x2F;user&#x2F;12345&quot;;&#x2F;&#x2F; 请求url</span><br><span class="line">RateLimiter ratelimiter &#x3D; new RateLimiter();</span><br><span class="line">boolean passed &#x3D; ratelimiter.limit(appId, url);</span><br><span class="line">if (passed) &#123;</span><br><span class="line">  &#x2F;&#x2F; 放行接口请求，继续后续的处理。</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 接口请求被限流。</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>以上是功能性代码。</p><p>非功能性需求。</p><p>易用性方面，我们希望限流规则的配置、编程接口的使用都很简单。我们希望提供各种不同的限流算法，比如基于内存的单机限流算法、基于 Redis 的分布式限流算法，能够让使用者自由选择。除此之外，因为大部分项目都是基于 Spring 开发的，我们还希望限流框架能否非常方便地集成到使用 Spring 框架的项目中。代码侵入性做到最低</p><p>扩展性、灵活性方面，我们希望能够灵活地扩展各种限流算法。同时，我们还希望支持不同格式（JSON、YAML、XML 等格式）、不同数据源（本地文件配置或 Zookeeper 集中配置等）的限流规则的配置方式</p><p>性能方面，因为每个接口请求都要被检查是否限流，这或多或少会增加接口请求的响应时间。而对于响应时间比较敏感的接口服务来说，我们要让限流框架尽可能低延迟，尽可能减少对接口请求本身响应时间的影响</p><p>容错性方面，接入限流框架是为了提高系统的可用性、稳定性，不能因为限流框架的异常，反过来影响到服务本身的可用性。所以，限流框架要有高度的容错性。比如，分布式限流算法依赖集中存储器 Redis。如果 Redis 挂掉了，限流逻辑无法正常运行，这个时候业务接口也要能正常服务才行</p><p>redis异常我们可以捕获，向上抛出或者吞掉，Redis 访问超时会严重影响接口的响应时间。所以必须设置合理的超时时间</p><p>限流规则：</p><p>限流算法：两窗两桶算法</p><p>限流模式：单机限流和分布式限流。为了提高服务能力，我们部署了 5 个实例。我们限制某个调用方，对单个实例的某个接口的访问频率，不能超过 100 次 / 秒。这就是单机限流。我们限制某个调用方，对 5 个实例的某个接口的总访问频率，不能超过 500 次 / 秒。这就是所谓的分布式限流。</p><p>集成：我们也可以借鉴 MyBatis-Spring，开发一个 Ratelimiter-Spring 类库，能够方便使用了 Spring 的项目集成限流框架，将易用性做到极致。</p>]]></content>
      
      
      <categories>
          
          <category> 限流框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 限流框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO模型</title>
      <link href="2020/08/10/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/0%E3%80%81IO%E6%A8%A1%E5%9E%8B/"/>
      <url>2020/08/10/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/0%E3%80%81IO%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Unix网络编程的五种IO模型：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO。</p><p>操作系统的IO模型是底层基石，Java有三种IO模型的基础：NIO、NIO、AIO就是对于IO的操作其实就是进一步的封装。</p><p>==Java的三种IO模型，BIO就是操作系统提供的阻塞IO模型，NIO是IO复用模型，而AIO是异步IO模型==</p><h5 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h5><p>==不管是网络IO还是磁盘IO，对于读操作而言，都是等到网络的某个数据分组到达后/数据准备好后，将数据拷贝到内核空间的缓冲区中，再从内核空间拷贝到用户空间的缓冲区==。</p><h5 id="（1）用户空间-内核空间"><a href="#（1）用户空间-内核空间" class="headerlink" title="（1）用户空间 / 内核空间"></a>（1）用户空间 / 内核空间</h5><p>为了保证用户进程不能直接操作内核（kernel）（随意修改内核可以直接黑掉计算机），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。【内核空间与用户空间的有自己的通信方式】  </p><h5 id="（2）文件描述符"><a href="#（2）文件描述符" class="headerlink" title="（2）文件描述符"></a>（2）文件描述符</h5><p>计算机科学中的一个术语，它是一个文件索引值（非负整数）。这一概念只适用于UNIX、Linux这样的操作系统。</p><p>该索引指向内核为每一个进程所维护的 该进程打开文件的记录表</p><h5 id="（3）系统调用函数-重要"><a href="#（3）系统调用函数-重要" class="headerlink" title="（3）系统调用函数(重要)"></a>（3）系统调用函数(重要)</h5><ul><li><p>select<br>select系统调用允许程序同时在多个底层文件描述符上，等待输入的到达或输出的完成。以数组形式存储文件描述符，64位机器默认2048个。当有数据准备好时，无法感知具体是哪个流OK了，所以需要一个一个的遍历，函数的时间复杂度为O(n)。</p></li><li><p>poll<br>以链表形式存储文件描述符，没有长度限制。本质与select相同，也无法感知具体是哪个流OK了，所以需要一个一个的遍历，函数的时间复杂度为O(n)。</p></li><li><p>epoll【nginx采用的模式】<br>以红黑树形式存储文件描述符,是基于事件驱动的，如果某个流准备好了，会以事件通知，知道具体是哪个流，因此不需要遍历，函数的时间复杂度为O(1)。</p></li></ul><h5 id="（4）I-O多路复用"><a href="#（4）I-O多路复用" class="headerlink" title="（4）I/O多路复用"></a>（4）I/O多路复用</h5><p>I/O就是指的我们网络I/O,多路指多个TCP连接(或多个Channel)，复用指复用一个或少量线程。串起来理解就是很多个网络I/O复用一个或少量的线程来处理这些连接。（select，poll，epoll都是IO多路复用的机制）</p><h5 id="Unix网络编程的五种IO模型"><a href="#Unix网络编程的五种IO模型" class="headerlink" title="Unix网络编程的五种IO模型"></a>Unix网络编程的五种IO模型</h5><h5 id="1、阻塞IO模型"><a href="#1、阻塞IO模型" class="headerlink" title="1、阻塞IO模型"></a>1、阻塞IO模型</h5><p>阻塞IO的执行过程是进程进行系统调用，等待内核将数据准备好并复制到用户态缓冲区后，进程放弃使用CPU并一直阻塞在此，直到数据准备好。</p><h5 id="2、非阻塞IO模型"><a href="#2、非阻塞IO模型" class="headerlink" title="2、非阻塞IO模型"></a>2、非阻塞IO模型</h5><p>等待数据阶段：未阻塞， 用户进程需要盲等，不停的去轮询内核。<br>数据复制阶段：阻塞，此时进行数据复制。</p><h5 id="3、IO多路复用模型"><a href="#3、IO多路复用模型" class="headerlink" title="3、IO多路复用模型"></a>3、IO多路复用模型</h5><p>相比于阻塞IO模型，多路复用只是多了一个select/poll/epoll函数。select函数会不断地轮询自己所负责的文件描述符/套接字的到达状态，当某个套接字就绪时，就对这个套接字进行处理。select负责轮询等待，recvfrom负责拷贝。当用户进程调用该select，select会监听所有注册好的IO，如果所有IO都没注册好，调用进程就阻塞。</p><h5 id="4、信号驱动IO模型"><a href="#4、信号驱动IO模型" class="headerlink" title="4、信号驱动IO模型"></a>4、信号驱动IO模型</h5><p>数据准备阶段：未阻塞，当数据准备完成之后，会主动的通知用户进程数据已经准备完成，对用户进程做一个回调。<br>数据拷贝阶段：阻塞用户进程，等待数据拷贝。</p><h5 id="5、异步IO模型"><a href="#5、异步IO模型" class="headerlink" title="5、异步IO模型"></a>5、异步IO模型</h5><p>异步I/O执行的两个阶段都不会阻塞读写操作，由内核完成。<br>完成后内核将数据放到指定的缓冲区，通知应用程序来取。</p><h5 id="Redis的底层多路复用的机制："><a href="#Redis的底层多路复用的机制：" class="headerlink" title="Redis的底层多路复用的机制："></a>Redis的底层多路复用的机制：</h5><p>Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</p><p>redis是基于内存、高效的数据结构等优点，他的瓶颈往往不在cpu。所以多线程只会增加线程开销（线程切换，锁的维护等）。但Redis 却能使用单线程模型达到每秒数十万级别的处理能力。另一方面得益于采用多路复用。</p><p>Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis单进程单线程为什么还这么快</title>
      <link href="2020/08/10/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/14%E3%80%81Redis%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%BF%99%E4%B9%88%E5%BF%AB/"/>
      <url>2020/08/10/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/14%E3%80%81Redis%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%BF%99%E4%B9%88%E5%BF%AB/</url>
      
        <content type="html"><![CDATA[<p>Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</p><h2 id="1、redis单线程为什么这么快？"><a href="#1、redis单线程为什么这么快？" class="headerlink" title="1、redis单线程为什么这么快？"></a>1、redis单线程为什么这么快？</h2><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。（如何测试redis的速度？10w+/s）数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p><p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p><p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；因为Redis是基于内存的操作，CPU不是Redis的瓶颈，==Redis的瓶颈最有可能是机器内存的大小或者网络带宽==</p><p>4、使用多路I/O复用模型，非阻塞IO；</p><p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p><h2 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h2><p>1、单进程多线程模型：MySQL、Memcached、Oracle（Windows版本）；</p><p>2、多进程模型：Oracle（Linux版本）；</p><p>3、Nginx有两类进程，一类称为Master进程(相当于管理进程)，另一类称为Worker进程（实际工作进程）。启动方式有两种：</p><p>（1）单进程启动：此时系统中仅有一个进程，该进程既充当Master进程的角色，也充当Worker进程的角色。</p><p>（2）多进程启动：此时系统有且仅有一个Master进程，至少有一个Worker进程工作。</p><p>（3）Master进程主要进行一些全局性的初始化工作和管理Worker的工作；事件处理是在Worker中进行的。</p><h2 id="2、redis阻塞和性能监控"><a href="#2、redis阻塞和性能监控" class="headerlink" title="2、redis阻塞和性能监控"></a>2、redis阻塞和性能监控</h2><p>Redis的事件循环在一个线程中处理，作为一个单线程程序，重要的是要保证事件处理的时延短，这样，事件循环中的后续任务才不会阻塞；<br>当redis的数据量达到一定级别后（比如20G），阻塞操作对性能的影响尤为严重； </p><ul><li><p>keys、sort等命令<br>keys命令用于查找所有符合给定模式 pattern 的 key，时间复杂度为O(N)， N 为数据库中 key 的数量。当数据库中的个数达到千万时，这个命令会造成读写线程阻塞数秒；<br>类似的命令有sunion sort等操作； </p></li><li><p>smembers命令</p></li></ul><p>smembers命令用于获取集合全集，时间复杂度为O(N),N为集合中的数量；<br>如果一个集合中保存了千万量级的数据，一次取回也会造成事件处理线程的长时间阻塞；</p><ul><li>save命令</li></ul><p>save命令使用事件处理线程进行数据的持久化；当数据量大的时候，会造成线程长时间阻塞（我们的生产上，reids内存中1个G保存需要12s左右），整个redis被block；<br>save阻塞了事件处理的线程，我们甚至无法使用redis-cli查看当前的系统状态，造成“何时保存结束，目前保存了多少”这样的信息都无从得知；</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis单进程单线程为什么还这么快 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netstat端口的网络情况</title>
      <link href="2020/08/10/Study%20notes/7%E3%80%81linux/netstat%E7%AB%AF%E5%8F%A3%E7%9A%84%E7%BD%91%E7%BB%9C%E6%83%85%E5%86%B5/"/>
      <url>2020/08/10/Study%20notes/7%E3%80%81linux/netstat%E7%AB%AF%E5%8F%A3%E7%9A%84%E7%BD%91%E7%BB%9C%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<p>进程ID和端口互相查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、查看进程pid</span><br><span class="line">ps -ef | grep 进程名</span><br><span class="line"></span><br><span class="line">2、通过pid查看占用端口</span><br><span class="line">netstat -nap | grep 进程pid</span><br><span class="line"></span><br><span class="line">3、通过端口查看进程</span><br><span class="line">netstat -nap | grep 端口号</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.查看有哪些IP地址连接到本机</span><br><span class="line"></span><br><span class="line">netstat –an</span><br><span class="line">2.查看TCP连接数</span><br><span class="line">2.1 统计80端口的连接数</span><br><span class="line"></span><br><span class="line">netstat –ant | grep –I “80” | wc –l</span><br><span class="line">2.2 统计http协议连接数</span><br><span class="line"></span><br><span class="line">ps –ef | grep httpd | wc –l</span><br><span class="line">2.3.统计已经连接上的，状态为established（查看当前并发访问数）</span><br><span class="line"></span><br><span class="line">netstat –an | grep ESTABLISHED | wc –l</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">netstat -nupl (UDP类型的端口)</span><br><span class="line">netstat -ntpl (TCP类型的端口)</span><br><span class="line">a 表示所有</span><br><span class="line"></span><br><span class="line">n表示不查询dns</span><br><span class="line"></span><br><span class="line">t表示tcp协议</span><br><span class="line"></span><br><span class="line">u表示udp协议</span><br><span class="line"></span><br><span class="line">p表示查询占用的程序</span><br><span class="line"></span><br><span class="line">l表示查询正在监听的程序</span><br></pre></td></tr></table></figure><p>状态说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LISTEN：侦听来自远方的TCP端口的连接请求</span><br><span class="line"></span><br><span class="line">SYN-SENT：再发送连接请求后等待匹配的连接请求（如果有大量这样的状态包，检查是否中招了）</span><br><span class="line"></span><br><span class="line">SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认（如有大量此状态，估计被flood攻击了）</span><br><span class="line"></span><br><span class="line">ESTABLISHED：代表一个打开的连接</span><br><span class="line"></span><br><span class="line">FIN-WAIT-1：等待远程TCP连接中断请求，或先前的连接中断请求的确认</span><br><span class="line"></span><br><span class="line">FIN-WAIT-2：从远程TCP等待连接中断请求</span><br><span class="line"></span><br><span class="line">CLOSE-WAIT：等待从本地用户发来的连接中断请求</span><br><span class="line"></span><br><span class="line">CLOSING：等待远程TCP对连接中断的确认</span><br><span class="line"></span><br><span class="line">LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认（不是什么好东西，此项出现，检查是否被攻击）</span><br><span class="line"></span><br><span class="line">TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认</span><br><span class="line"></span><br><span class="line">CLOSED：没有任何连接状态</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netstat端口的网络情况 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayBlockingQueue</title>
      <link href="2020/08/08/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/8%E3%80%81ArrayBlockingQueue/"/>
      <url>2020/08/08/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/8%E3%80%81ArrayBlockingQueue/</url>
      
        <content type="html"><![CDATA[<p>ArrayBlockingQueue的底层数据结构是数组,对数组的访问添加了锁的机制，使其能够支持多线程并发。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性　　"></a>属性　　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span><br><span class="line">        implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">    &#x2F;&#x2F; 版本序列号</span><br><span class="line">    private static final long serialVersionUID &#x3D; -817911632652898426L;</span><br><span class="line">    &#x2F;&#x2F; 存放实际元素的数组</span><br><span class="line">    final Object[] items;</span><br><span class="line">    &#x2F;&#x2F; 取元素索引</span><br><span class="line">    int takeIndex;</span><br><span class="line">    &#x2F;&#x2F; 获取元素索引</span><br><span class="line">    int putIndex;</span><br><span class="line">    &#x2F;&#x2F; 队列中的项</span><br><span class="line">    int count;</span><br><span class="line">    &#x2F;&#x2F; 可重入锁</span><br><span class="line">    final ReentrantLock lock;</span><br><span class="line">    &#x2F;&#x2F; 等待获取条件</span><br><span class="line">    private final Condition notEmpty;</span><br><span class="line">    &#x2F;&#x2F; 等待存放条件</span><br><span class="line">    private final Condition notFull;</span><br><span class="line">    &#x2F;&#x2F; 迭代器</span><br><span class="line">    transient Itrs itrs &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　说明：从类的属性中可以清楚的看到其底层的结构是Object类型的数组，取元素和存元素有不同的索引，有一个可重入锁ReentrantLock，两个条件Condition　</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="　构造函数"></a>　构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建一个带有给定的（固定）容量和默认访问策略的 ArrayBlockingQueue。    </span><br><span class="line"> public ArrayBlockingQueue(int capacity) &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用两个参数的构造函数</span><br><span class="line">        this(capacity, false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue。</span><br><span class="line">    public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始容量必须大于0</span><br><span class="line">        if (capacity &lt;&#x3D; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        &#x2F;&#x2F; 初始化数组</span><br><span class="line">        this.items &#x3D; new Object[capacity];</span><br><span class="line">        &#x2F;&#x2F; 初始化可重入锁</span><br><span class="line">        lock &#x3D; new ReentrantLock(fair);</span><br><span class="line">        &#x2F;&#x2F; 初始化等待条件</span><br><span class="line">        notEmpty &#x3D; lock.newCondition();</span><br><span class="line">        notFull &#x3D;  lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue，它最初包含给定 collection 的元素，并以 collection 迭代器的遍历顺序添加元素。</span><br><span class="line">    public ArrayBlockingQueue(int capacity, boolean fair,</span><br><span class="line">                              Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用两个参数的构造函数</span><br><span class="line">        this(capacity, fair);</span><br><span class="line">        &#x2F;&#x2F; 可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 上锁</span><br><span class="line">        lock.lock(); &#x2F;&#x2F; Lock only for visibility, not mutual exclusion</span><br><span class="line">        try &#123;</span><br><span class="line">            int i &#x3D; 0;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (E e : c) &#123; &#x2F;&#x2F; 遍历集合</span><br><span class="line">                    &#x2F;&#x2F; 检查元素是否为空</span><br><span class="line">                    checkNotNull(e);</span><br><span class="line">                    &#x2F;&#x2F; 存入ArrayBlockingQueue中</span><br><span class="line">                    items[i++] &#x3D; e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ArrayIndexOutOfBoundsException ex) &#123; &#x2F;&#x2F; 当初始化容量小于传入集合的大小时，会抛出异常</span><br><span class="line">                throw new IllegalArgumentException();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 元素数量</span><br><span class="line">            count &#x3D; i;</span><br><span class="line">            &#x2F;&#x2F; 初始化存元素的索引</span><br><span class="line">            putIndex &#x3D; (i &#x3D;&#x3D; capacity) ? 0 : i;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="put函数"><a href="#put函数" class="headerlink" title="put函数　　"></a>put函数　　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        &#x2F;&#x2F; 获取可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 如果当前线程未被中断，则获取锁</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count &#x3D;&#x3D; items.length) &#x2F;&#x2F; 判断元素是否已满</span><br><span class="line">                &#x2F;&#x2F; 若满，则等待</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#x2F;&#x2F; 入队列</span><br><span class="line">            enqueue(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　说明：put函数用于存放元素，在当前线程被中断时会抛出异常，并且当队列已经满时，会阻塞一直等待。其中，put会调用enqueue函数，enqueue函数源码如下　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">        &#x2F;&#x2F; assert lock.getHoldCount() &#x3D;&#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F; assert items[putIndex] &#x3D;&#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 获取数组</span><br><span class="line">        final Object[] items &#x3D; this.items;</span><br><span class="line">        &#x2F;&#x2F; 将元素放入</span><br><span class="line">        items[putIndex] &#x3D; x;</span><br><span class="line">        if (++putIndex &#x3D;&#x3D; items.length) &#x2F;&#x2F; 放入后存元素的索引等于数组长度（表示已满）</span><br><span class="line">            &#x2F;&#x2F; 重置存索引为0</span><br><span class="line">            putIndex &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 元素数量加1</span><br><span class="line">        count++;</span><br><span class="line">        &#x2F;&#x2F; 唤醒在notEmpty条件上等待的线程</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：enqueue函数用于将元素存入底层Object数组中，并且会唤醒等待notEmpty条件的线程。</p><h3 id="offer函数"><a href="#offer函数" class="headerlink" title="offer函数　　"></a>offer函数　　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">        &#x2F;&#x2F; 检查元素不能为空</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        &#x2F;&#x2F; 可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (count &#x3D;&#x3D; items.length) &#x2F;&#x2F; 元素个数等于数组长度，则返回</span><br><span class="line">                return false; </span><br><span class="line">            else &#123; &#x2F;&#x2F; 添加进数组</span><br><span class="line">                enqueue(e);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放数组</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：offer函数也用于存放元素，在调用ArrayBlockingQueue的add方法时，会间接的调用到offer函数，offer函数添加元素不会抛出异常，当底层Object数组已满时，则返回false，否则，会调用enqueue函数，将元素存入底层Object数组。并唤醒等待notEmpty条件的线程。</p><h3 id="take函数"><a href="#take函数" class="headerlink" title="take函数　"></a>take函数　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F; 可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 如果当前线程未被中断，则获取锁，中断会抛出异常</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count &#x3D;&#x3D; 0) &#x2F;&#x2F; 元素数量为0，即Object数组为空</span><br><span class="line">                &#x2F;&#x2F; 则等待notEmpty条件</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#x2F;&#x2F; 出队列</span><br><span class="line">            return dequeue();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：take函数用于从ArrayBlockingQueue中获取一个元素，其与put函数相对应，在当前线程被中断时会抛出异常，并且==当队列为空时，会阻塞一直等待==。其中，take会调用dequeue函数，dequeue函数源码如下　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private E dequeue() &#123;</span><br><span class="line">        &#x2F;&#x2F; assert lock.getHoldCount() &#x3D;&#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F; assert items[takeIndex] !&#x3D; null;</span><br><span class="line">        final Object[] items &#x3D; this.items;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        &#x2F;&#x2F; 取元素</span><br><span class="line">        E x &#x3D; (E) items[takeIndex];</span><br><span class="line">        &#x2F;&#x2F; 该索引的值赋值为null</span><br><span class="line">        items[takeIndex] &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 取值索引等于数组长度</span><br><span class="line">        if (++takeIndex &#x3D;&#x3D; items.length)</span><br><span class="line">            &#x2F;&#x2F; 重新赋值取值索引</span><br><span class="line">            takeIndex &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 元素个数减1</span><br><span class="line">        count--;</span><br><span class="line">        if (itrs !&#x3D; null) </span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">        &#x2F;&#x2F; 唤醒在notFull条件上等待的线程</span><br><span class="line">        notFull.signal();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：dequeue函数用于将取元素，并且会唤醒等待notFull条件的线程。</p><h3 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数　　"></a>poll函数　　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">        &#x2F;&#x2F; 重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 若元素个数为0则返回null，否则，调用dequeue，出队列</span><br><span class="line">            return (count &#x3D;&#x3D; 0) ? null : dequeue();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　说明：poll函数用于获取元素，其与offer函数相对应，不会抛出异常，当元素个数为0是，返回null，否则，调用dequeue函数，并唤醒等待notFull条件的线程。并返回。</p><h3 id="clear函数"><a href="#clear函数" class="headerlink" title="　 clear函数　　"></a>　 clear函数　　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">        &#x2F;&#x2F; 数组</span><br><span class="line">        final Object[] items &#x3D; this.items;</span><br><span class="line">        &#x2F;&#x2F; 可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 保存元素个数</span><br><span class="line">            int k &#x3D; count;</span><br><span class="line">            if (k &gt; 0) &#123; &#x2F;&#x2F; 元素个数大于0</span><br><span class="line">                &#x2F;&#x2F; 存数元素索引</span><br><span class="line">                final int putIndex &#x3D; this.putIndex;</span><br><span class="line">                &#x2F;&#x2F; 取元素索引</span><br><span class="line">                int i &#x3D; takeIndex;</span><br><span class="line">                do &#123;</span><br><span class="line">                    &#x2F;&#x2F; 赋值为null</span><br><span class="line">                    items[i] &#x3D; null;</span><br><span class="line">                    if (++i &#x3D;&#x3D; items.length) &#x2F;&#x2F; 重新赋值i</span><br><span class="line">                        i &#x3D; 0;</span><br><span class="line">                &#125; while (i !&#x3D; putIndex);</span><br><span class="line">                &#x2F;&#x2F; 重新赋值取元素索引</span><br><span class="line">                takeIndex &#x3D; putIndex;</span><br><span class="line">                &#x2F;&#x2F; 元素个数为0</span><br><span class="line">                count &#x3D; 0;</span><br><span class="line">                if (itrs !&#x3D; null)</span><br><span class="line">                    itrs.queueIsEmpty();</span><br><span class="line">                for (; k &gt; 0 &amp;&amp; lock.hasWaiters(notFull); k--) &#x2F;&#x2F; 若有等待notFull条件的线程，则逐一唤醒</span><br><span class="line">                    notFull.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure><p>clear函数用于清空ArrayBlockingQueue，并且会释放所有等待notFull条件的线程（存放元素的线程）。</p><p>ArrayBlockingQueue是通过ReentrantLock和Condition条件来保证多线程的正确访问的</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayBlockingQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BlockingQueue</title>
      <link href="2020/08/08/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/7%E3%80%81BlockingQueue/"/>
      <url>2020/08/08/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/7%E3%80%81BlockingQueue/</url>
      
        <content type="html"><![CDATA[<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><ul><li>在队列为空时，获取元素的线程会等待队列变为非空</li><li>当队列满时，存储元素的线程会等待队列可用</li></ul><p>应用：阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>阻塞队列提供了四种处理方法:<br>方法\处理方式 | 抛出异常| 返回特殊值| 一直阻塞| 超时退出<br>—|—|—|—|—<br>插入方法 | add(e)| offer(e)| put(e)| offer(e,time,unit)<br>移除方法 | remove()|poll()|take()|     poll(time,unit)<br>检查方法| element()| peek()| | </p><p>插入方法    add(e)    offer(e)    put(e)    offer(e,time,unit)<br>移除方法    remove()    poll()    take()    poll(time,unit)<br>检查方法    element()    peek()    不可用    不可用</p><ul><li>抛出异常：是指当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</li><li>返回特殊值：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元素，如果没有则返回null</li><li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻塞消费者线程，直到队列可用。</li><li>超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。</li></ul><p>JDK7提供了7个阻塞队列。分别是</p><ul><li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</li><li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。默认情况下元素采取自然顺序排列，也可以通过比较器comparator来指定元素的排序规则。元素按照升序排列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul><p>阻塞队列简单实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class BlockingQueue &#123;</span><br><span class="line"></span><br><span class="line">    private List queue &#x3D; new LinkedList();</span><br><span class="line">    </span><br><span class="line">    private int  limit &#x3D; 10;</span><br><span class="line">    </span><br><span class="line">    public BlockingQueue(int limit)&#123;</span><br><span class="line">    </span><br><span class="line">    this.limit &#x3D; limit;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public synchronized void enqueue(Object item)</span><br><span class="line">    </span><br><span class="line">    throws InterruptedException  &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;当队列满时，存储元素的线程会等待队列可用</span><br><span class="line">    </span><br><span class="line">    while(this.queue.size() &#x3D;&#x3D; this.limit) &#123;</span><br><span class="line">    </span><br><span class="line">    wait();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(this.queue.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    </span><br><span class="line">    notifyAll();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    this.queue.add(item);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public synchronized Object dequeue()</span><br><span class="line">    </span><br><span class="line">    throws InterruptedException&#123;</span><br><span class="line">    &#x2F;&#x2F;在队列为空时，获取元素的线程会等待队列变为非空</span><br><span class="line">    </span><br><span class="line">    while(this.queue.size() &#x3D;&#x3D; 0)&#123;</span><br><span class="line">    </span><br><span class="line">    wait();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(this.queue.size() &#x3D;&#x3D; this.limit)&#123;</span><br><span class="line">    </span><br><span class="line">    notifyAll();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return this.queue.remove(0);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BlockingQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized优化</title>
      <link href="2020/08/02/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/6%E3%80%81synchronized%E4%BC%98%E5%8C%96/"/>
      <url>2020/08/02/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/6%E3%80%81synchronized%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h4 id="Synchronized的实现："><a href="#Synchronized的实现：" class="headerlink" title="Synchronized的实现："></a>Synchronized的实现：</h4><ul><li>Synchronized同步代码块基于monitorenter进入和monitorexit退出（JVM保证其成对出现） Monitor监视器对象实现</li><li>Synchronized同步方法基于ACC_SYNCHRONIZED 标志来隐式实现的</li><li></li></ul><p>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。==任何对象都有 一个monitor与之关联==，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter 指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象在内存中的布局分为三块区域：对象头、实例变量和填充数据</p><p><img src="https://images2017.cnblogs.com/blog/918656/201708/918656-20170824180707777-1312147323.png" alt="image"></p><ul><li><p>实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</p></li><li><p>填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点了解即可。</p></li><li><p>对象头：Hotspot虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、KlassPointer（类型指针）虚拟机通过这个指针来确定这个对象是哪个类的实例</p></li></ul><p>（1）Mark Word它是实现轻量级锁和偏向锁的关键。用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>jdk1.6以后对synchronized的锁进行了优化：==无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁==(单向)</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让其获得锁的代价更低而引入了偏向锁。</p><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。</p><p>如果测试成功，表示线程已经获得了锁。</p><p>如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成01（表示当前是偏向锁）。</p><p>如果没有设置，则使用轻量级锁使用CAS竞争。</p><p>如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p><p><img src="http://s4.sinaimg.cn/mw690/003wfAbNzy6MSO08bIvf3&690" alt="image"></p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>通过CAS竞争锁，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p><p><img src="http://s1.sinaimg.cn/mw690/003wfAbNzy6MSOsRjkAa0&690" alt="image"></p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。<br><img src="https://img2018.cnblogs.com/blog/1323383/201903/1323383-20190306134123353-740044884.png" alt="image"></p><h2 id="jvm其他对锁的其他优化方式："><a href="#jvm其他对锁的其他优化方式：" class="headerlink" title="jvm其他对锁的其他优化方式："></a>jvm其他对锁的其他优化方式：</h2><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void synchronized()&#123;</span><br><span class="line">    &#x2F;&#x2F;业务处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程获取锁，并执行过程中，切换到线程B，线程不能获取锁，便放弃CPU执行时间。挂起线程和恢复线程的操作比较耗费性能。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行。让线程执行一个忙循环（自旋），不放弃CPU执行时间，等待一下线程A释放锁。这项技术就是所谓的自旋锁。</p><p>JDK6之前使用-XX：+UseSpinning参数来开启。jdk6之后默认开启。自旋次数的默认值是10次，用户可以使用参数-XX：PreBlockSpin来更改。超过自旋次数，线程便挂起。</p><p>如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源。</p><p>在JDK 1.6中引入了自适应的自旋锁。==由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定自旋次数==。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。 另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。 </p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>==虚拟机对检测到不可能存在共享数据竞争的锁进行消除==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String concatString（String s1，String s2，String s3）&#123;</span><br><span class="line">    return s1+s2+s3；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK5之后编辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String concatString（String s1，String s2，String s3）&#123;</span><br><span class="line">    StringBuffer sb&#x3D;new StringBuffer（）；</span><br><span class="line">    sb.append（s1）；</span><br><span class="line">    sb.append（s2）；</span><br><span class="line">    sb.append（s3）；</span><br><span class="line">    return sb.toString（）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个StringBuffer.append（）方法中都有一个同步块，锁就是sb对象。 虚拟机观察变量sb，很快就会发现它的动态作用域被限制在concatString（）方法内部。 也就是说，sb的所有引用永远不会“逃逸”到concatString（）方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>==将连续的加锁操作， 精简到只加一次锁==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String concatString（String s1，String s2，String s3）&#123;</span><br><span class="line">    StringBuffer sb&#x3D;new StringBuffer（）；</span><br><span class="line">    sb.append（s1）；</span><br><span class="line">    sb.append（s2）；</span><br><span class="line">    sb.append（s3）；</span><br><span class="line">    return sb.toString（）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，示例代码就是扩展到第一个append（）操作之前直至最后一个append（）操作之后，这样只需要加锁一次就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> synchronized优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue</title>
      <link href="2020/08/02/Study%20notes/%E5%89%8D%E7%AB%AF/vue/vue/"/>
      <url>2020/08/02/Study%20notes/%E5%89%8D%E7%AB%AF/vue/vue/</url>
      
        <content type="html"><![CDATA[<p>view 是一套用于构建用户界面的渐进式框架。vue所有东西都是响应式的(浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 app.message 的值，你将看到上例相应地更新。)</p><p>==不再和 HTML 直接交互了。一个 Vue 应用会将其挂载到一个 DOM 元素上 (对于这个例子是 #app) 然后对其进行完全控制。那个 HTML 是我们的入口，所有的 DOM 操作都由 Vue 来处理，你编写的代码只需要关注逻辑层面即可==</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP三次握手四次挥手</title>
      <link href="2020/08/01/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/2%E3%80%81TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>2020/08/01/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/2%E3%80%81TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="1、建立TCP连接三次握手"><a href="#1、建立TCP连接三次握手" class="headerlink" title="1、建立TCP连接三次握手"></a>1、建立TCP连接三次握手</h5><p><img src="https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p><ul><li>SYN：同步序号。它表示建立连接。TCP规定SYN=1时不能携带数据，但要消耗一个序号, 因此随机选取一个序列号为seq=x 数据包（该数据包里就是一个标记seq，并没有任何有效的数据）。</li><li>ACK ：确认序号。它表示响应（都能响应了 那肯定上一步就连接成功了啊，所以说ACK=1代表确认连接成功啦）</li></ul><p>三次握手</p><ul><li>第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；</li><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>（握手过程中传送的包里不包含数据，原则上任何数据传输都无法确保绝对可靠，三次握手只是确保可靠的基本需要。）</li></ul><h5 id="2、为什么需要握手？"><a href="#2、为什么需要握手？" class="headerlink" title="2、为什么需要握手？"></a>2、为什么需要握手？</h5><p>TCP 与 UDP 的一个基本区别， TCP 是可靠通信协议， 而 UDP 是不可靠通信协议（UDP没有握手这个操作的。 UDP是只管发）。</p><p>TCP 协议为了实现可靠传输， 通信双方需要判断自己已经发送的数据包是否都被接收方收到， 如果没收到， 就需要重发。 为了实现这个需求， 很自然地就会引出序号（sequence number） 和 确认号（acknowledgement number） 的使用。</p><p>==TCP三次握手的目的是为了建立可靠连接通信,确认client和server两端收发数据都是正常的==</p><h5 id="3、为什么是3次握手"><a href="#3、为什么是3次握手" class="headerlink" title="3、为什么是3次握手"></a>3、为什么是3次握手</h5><p>Client向Server发送了一个连接请求分组，Server收到这个分组，并发送了确认应答分组</p><p>如果按照两次握手的协定，此时Server认为已经成功的建立连接，server就开始发送数据分组，但此时若Server的应答分组传输丢失了，Client不知道Server是否已准备好以及建立的什么样的序列号，在这种情况下，Client认为连接还未建立成功，将忽略Server发来的任何数据请求，只等待连接确认应答分组。而Server在发出的分组超时后，重复发送同样的分组，资源就形成了死锁。</p><p>如果四次+握手，那么就造成了浪费，因为在三次结束之后，就已经可以保证A可以给B发信息</p><h5 id="4、终止TCP连接四次挥手"><a href="#4、终止TCP连接四次挥手" class="headerlink" title="4、终止TCP连接四次挥手"></a>4、终止TCP连接四次挥手</h5><ul><li><p>（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p></li><li><p>（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p></li><li><p>（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p></li><li><p>（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p></li></ul><h5 id="5、为什么是四次握手？"><a href="#5、为什么是四次握手？" class="headerlink" title="5、为什么是四次握手？"></a>5、为什么是四次握手？</h5><p>三次握手确认双方收发功能都正常<br>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简单讲A和B即将通话时，</span><br><span class="line">A：我没啥要说的了</span><br><span class="line">B：我知道了</span><br><span class="line">B：我说完了</span><br><span class="line">A：我知道了</span><br></pre></td></tr></table></figure><h5 id="5、如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#5、如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="5、如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>5、如果已经建立了连接，但是客户端突然出现故障了怎么办？</h5><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><ul><li>TCP是底层通讯协议，定义的是数据传输和连接方式的规范</li><li>HTTP是应用层协议，定义的是传输数据的内容的规范</li><li>HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP   </li></ul>]]></content>
      
      
      <categories>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP三次握手四次挥手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty处理半包粘包问题</title>
      <link href="2020/08/01/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/11%E3%80%81netty%E5%A4%84%E7%90%86%E5%8D%8A%E5%8C%85%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>2020/08/01/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/11%E3%80%81netty%E5%A4%84%E7%90%86%E5%8D%8A%E5%8C%85%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>无论是服务端还是客户端，当我们读取或者发送消息的时候，都需要考虑TCP底层的粘包/拆包机制。</p><p>TCP是个“流”协议，所谓流，就是没有界限的一串数据。大家可以想想河里的流水，是连成一片的，其间并没有分界线。</p><p>==注意：==<br>对于TCP数据，应用层就不需要考虑这个问题了，因为传输层已经帮我们做了。在建立连接的三次握手的过程中，连接双方会相互通告MSS（Maximum Segment Size，最大报文段长度），MSS一般是MTU—IP首部（20）—TCP首部（20），每次发送的TCP数据都不会超过双方MSS的最小值，所以就保证了IP数据报不会超过MTU，避免了IP分片。</p><h5 id="拆包、粘包场景"><a href="#拆包、粘包场景" class="headerlink" title="拆包、粘包场景"></a>拆包、粘包场景</h5><p>假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下5种情况。</p><ul><li><p>（1）服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；</p></li><li><p>（2）服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；</p></li><li><p>（3）服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；</p></li><li><p>（4）服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。</p></li><li><p>(5)如果此时服务端TCP接收滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种可能，即服务端分多次才能将D1和D2包接收完全，期间发生多次拆包。</p></li></ul><h5 id="TCP粘包-拆包发生的根本原因【流式协议，消息无边界】"><a href="#TCP粘包-拆包发生的根本原因【流式协议，消息无边界】" class="headerlink" title="TCP粘包/拆包发生的根本原因【流式协议，消息无边界】"></a>TCP粘包/拆包发生的根本原因【流式协议，消息无边界】</h5><p>粘包主要原因</p><ul><li>发送方每次写入数据 &lt; 套接字缓冲区大小</li><li>接收方读取套接字缓冲区数据不够及时</li></ul><p>半包的主要原因：</p><ul><li>发送方写入数据 &gt; 套接字缓冲区大小</li><li>发送的数据大于协议的 MTU（Maximum Transmission Unit，最大传输单元），必须拆包</li></ul><h5 id="解决问题的根本手段：找出消息的边界进行封帧："><a href="#解决问题的根本手段：找出消息的边界进行封帧：" class="headerlink" title="解决问题的根本手段：找出消息的边界进行封帧："></a>解决问题的根本手段：找出消息的边界进行封帧：</h5><p>（1）方式一：消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格；【空间浪费，不推荐】</p><p>（2）方式二：在包尾增加回车换行符进行分割，例如FTP协议；【推荐】</p><p>（3）方式三：将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32来表示消息的总长度；【推荐+】</p><h5 id="Netty处理粘包、半包"><a href="#Netty处理粘包、半包" class="headerlink" title="Netty处理粘包、半包"></a>Netty处理粘包、半包</h5><p>Netty针对三种封帧方式提供了对应的处理器：</p><ul><li>LineBasedFrameDecoder：通过换行符来区分每个包</li><li>DelimiterBasedFrameDecoder：通过特殊分隔符来区分每个包</li><li>FixedLengthFrameDecoder：通过定长的报文来分包</li><li>LengthFieldBasedFrameDecoder：跟据包头部定义的长度来区分包</li></ul><p>服务端添加解码器：DelimiterBasedFrameDecoder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf delimiter &#x3D; Unpooled.copiedBuffer(&quot;&amp;&quot;.getBytes());</span><br><span class="line">ch.pipeline().addLast(new DelimiterBasedFrameDecoder(1024,delimiter));</span><br><span class="line">&#x2F;&#x2F;1024表示单条消息的最大长度，解码器在查找分隔符的时候，达到该长度还没找到的话会抛异常</span><br><span class="line">ch.pipeline().addLast(new StringDecoder());</span><br><span class="line">ch.pipeline().addLast(new StringEncoder());</span><br></pre></td></tr></table></figure><h5 id="Netty处理粘包、半包的源码解析"><a href="#Netty处理粘包、半包的源码解析" class="headerlink" title="Netty处理粘包、半包的源码解析"></a>Netty处理粘包、半包的源码解析</h5><p>Netty处理粘包、半包的源码——-解码核心工作流程</p><p>处理器都拥有一个共同的父类：ByteToMessageDecoder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ByteToMessageDecoder extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F;msg相当于我们的消息数据</span><br><span class="line">        if (msg instanceof ByteBuf) &#123;</span><br><span class="line">            CodecOutputList out &#x3D; CodecOutputList.newInstance();</span><br><span class="line">            boolean var10 &#x3D; false;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                var10 &#x3D; true;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1、把数据转换成data,,</span><br><span class="line">                ByteBuf data &#x3D; (ByteBuf)msg;</span><br><span class="line">&#x2F;&#x2F;2、cumulation是数据积累器，用来积累数据。判断是否为空。</span><br><span class="line">&#x2F;&#x2F;第一次的时候肯定为null  所以first是true，直接把data数据给了cumulation。再接下来就是解码：</span><br><span class="line">                this.first &#x3D; this.cumulation &#x3D;&#x3D; null;</span><br><span class="line">                if (this.first) &#123;</span><br><span class="line">                    this.cumulation &#x3D; data;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;3、具体数据解码。底层调用对应的解码器的decode方法</span><br><span class="line">                    this.cumulation &#x3D; this.cumulator.cumulate(ctx.alloc(), this.cumulation, data);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                this.callDecode(ctx, this.cumulation, out);</span><br><span class="line">                var10 &#x3D; false;</span><br><span class="line">            &#125; catch (DecoderException var11) &#123;</span><br><span class="line">                throw var11;</span><br><span class="line">            &#125; catch (Exception var12) &#123;</span><br><span class="line">                throw new DecoderException(var12);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (var10) &#123;</span><br><span class="line">                    if (this.cumulation !&#x3D; null &amp;&amp; !this.cumulation.isReadable()) &#123;</span><br><span class="line">                        this.numReads &#x3D; 0;</span><br><span class="line">                        this.cumulation.release();</span><br><span class="line">                        this.cumulation &#x3D; null;</span><br><span class="line">                    &#125; else if (++this.numReads &gt;&#x3D; this.discardAfterReads) &#123;</span><br><span class="line">                        this.numReads &#x3D; 0;</span><br><span class="line">                        this.discardSomeReadBytes();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    int size &#x3D; out.size();</span><br><span class="line">                    this.decodeWasNull &#x3D; !out.insertSinceRecycled();</span><br><span class="line">                    fireChannelRead(ctx, out, size);</span><br><span class="line">                    out.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (this.cumulation !&#x3D; null &amp;&amp; !this.cumulation.isReadable()) &#123;</span><br><span class="line">                this.numReads &#x3D; 0;</span><br><span class="line">                this.cumulation.release();</span><br><span class="line">                this.cumulation &#x3D; null;</span><br><span class="line">            &#125; else if (++this.numReads &gt;&#x3D; this.discardAfterReads) &#123;</span><br><span class="line">                this.numReads &#x3D; 0;</span><br><span class="line">                this.discardSomeReadBytes();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int size &#x3D; out.size();</span><br><span class="line">            this.decodeWasNull &#x3D; !out.insertSinceRecycled();</span><br><span class="line">            fireChannelRead(ctx, out, size);</span><br><span class="line">            out.recycle();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ctx.fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FixedLengthFrameDecoder的decode为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected Object decode(</span><br><span class="line">        @SuppressWarnings(&quot;UnusedParameters&quot;) ChannelHandlerContext ctx, ByteBuf in) throws Exception &#123;</span><br><span class="line">    if (in.readableBytes() &lt; frameLength) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return in.readRetainedSlice(frameLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty处理半包粘包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven</title>
      <link href="2020/08/01/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/3%E3%80%81%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/maven/2%E3%80%81maven/"/>
      <url>2020/08/01/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/3%E3%80%81%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/maven/2%E3%80%81maven/</url>
      
        <content type="html"><![CDATA[<h5 id="1、maven的依赖传递（继承、聚合）、依赖排除"><a href="#1、maven的依赖传递（继承、聚合）、依赖排除" class="headerlink" title="1、maven的依赖传递（继承、聚合）、依赖排除"></a>1、maven的依赖传递（继承、聚合）、依赖排除</h5><p>继承：A继承B，A就可以继承B的dependencies依赖。<br>继承<br>什么是继承，我们可以定义项目的父类项目，用于继承父项目的依赖、插件、属性等信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;dubbo-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.8.4&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure><p>如dubbo的父类项目为dubbo-parent，dubbo-parent项目中定义的dependencies依赖、properties等配置都可以传递到dubbo子项目中来，而dubbo子项目不需要重新定义依赖。<br>聚合：A依赖C，C依赖D，那么A就要依赖D自然也就获取了D的依赖。</p><p>Controller项目依赖Service,Service依赖Dao,Dao依赖util<br>依赖排除：在依赖传递过程中，如A依赖B、S2.0，B依赖C、S1.0，这样A就有了S1.0和S2.0两个依赖，这样某些情况下会造成冲突需要手动把B间接传递过来的依赖排除掉，就是不依赖B带过来的S1.0的包。</p><p>排除B的S1.0依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.testgroupId&gt;</span><br><span class="line">&lt;artifactId&gt;B&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;exclusions&gt;</span><br><span class="line">&lt;exclusion&gt;&lt;!--排除--&gt;</span><br><span class="line">&lt;groupId&gt;com.test&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;S&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;exclusion&gt;</span><br><span class="line">&lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>排除所有间接依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.testgroupId&gt;</span><br><span class="line">&lt;artifactId&gt;B&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;exclusions&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;groupId&gt;*&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;*&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;exclusion&gt;</span><br><span class="line">&lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="2、maven的三个仓库"><a href="#2、maven的三个仓库" class="headerlink" title="2、maven的三个仓库"></a>2、maven的三个仓库</h5><p>1、本地仓库<br>本地仓库就是开发者本地已经下载下来的或者自己打包所有jar包的依赖仓库，本地仓库路径配置在maven对应的conf/settings.xml配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- localRepository</span><br><span class="line">   | The path to the local repository maven will use to store artifacts.</span><br><span class="line">   | Default: $&#123;user.home&#125;&#x2F;.m2&#x2F;repository</span><br><span class="line">  &lt;localRepository&gt;&#x2F;path&#x2F;to&#x2F;local&#x2F;repo&lt;&#x2F;localRepository&gt;</span><br><span class="line">  --&gt;</span><br></pre></td></tr></table></figure><p>2、中央仓库<br>中央仓库即maven默认下载的仓库地址，是maven维护的，默认的中央仓库地址是：<a href="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</a></p><p>3、镜像仓库<br>配置阿里云私服</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirrors&gt;  </span><br><span class="line">    &lt;mirror&gt;  </span><br><span class="line">      &lt;id&gt;alimaven&lt;&#x2F;id&gt;  </span><br><span class="line">      &lt;name&gt;aliyun maven&lt;&#x2F;name&gt;  </span><br><span class="line">      &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;  </span><br><span class="line">      &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;          </span><br><span class="line">    &lt;&#x2F;mirror&gt;  </span><br><span class="line">  &lt;&#x2F;mirrors&gt;</span><br></pre></td></tr></table></figure><h4 id="3、maven-deploy上传jar包。"><a href="#3、maven-deploy上传jar包。" class="headerlink" title="3、maven deploy上传jar包。"></a>3、maven deploy上传jar包。</h4><p>在maven安装目录 /conf/setting.xml 中的servers下添加：此处的用户，需要有相应的权限才能deploy成功</p><ul><li>(1)Release代表稳定的版本 如果deploy到远程服务器 只能deploy一次，以后部署的话，就会报错冲突，因此很稳定</li><li>(2)Snapshot版本代表不稳定、尚处于开发中的版本，可以deploy多次，每一次都会冲掉原来的版本，因此不稳定<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;servers&gt;</span><br><span class="line">     &lt;server&gt;</span><br><span class="line">       &lt;id&gt;snapshots&lt;&#x2F;id&gt;</span><br><span class="line">       &lt;username&gt;admin&lt;&#x2F;username&gt;</span><br><span class="line">       &lt;password&gt;123456&lt;&#x2F;password&gt;</span><br><span class="line">     &lt;&#x2F;server&gt;</span><br><span class="line">     &lt;server&gt;</span><br><span class="line">       &lt;id&gt;releases&lt;&#x2F;id&gt;</span><br><span class="line">       &lt;username&gt;admin&lt;&#x2F;username&gt;</span><br><span class="line">       &lt;password&gt;123456&lt;&#x2F;password&gt;</span><br><span class="line">     &lt;&#x2F;server&gt;</span><br><span class="line">&lt;&#x2F;servers&gt;</span><br></pre></td></tr></table></figure></li></ul><p>在要上传的模块的pom.xml文件中添加</p><p>pom文件中的id要跟settings.xml文件中的id一定要对应上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;distributionManagement&gt;</span><br><span class="line">           &lt;repository&gt;</span><br><span class="line">              &lt;id&gt;releases&lt;&#x2F;id&gt;</span><br><span class="line">              &lt;name&gt;internal releases&lt;&#x2F;name&gt;</span><br><span class="line">              &lt;url&gt;http:&#x2F;&#x2F;192.168.1.221:8081&#x2F;repository&#x2F;maven-releases&lt;&#x2F;url&gt;</span><br><span class="line">          &lt;&#x2F;repository&gt;</span><br><span class="line">          &lt;snapshotRepository&gt;</span><br><span class="line">              &lt;id&gt;snapshots&lt;&#x2F;id&gt;</span><br><span class="line">              &lt;name&gt;internal snapshot&lt;&#x2F;name&gt;</span><br><span class="line">              &lt;url&gt;http:&#x2F;&#x2F;192.168.1.221:8081&#x2F;repository&#x2F;maven-snapshots&lt;&#x2F;url&gt;</span><br><span class="line">          &lt;&#x2F;snapshotRepository&gt;</span><br><span class="line">  &lt;&#x2F;distributionManagement&gt;</span><br></pre></td></tr></table></figure><p>执行生命周期命令中的deploy命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn deploy -Dmaven.test.skip&#x3D;true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者Idea开发工具中直接双击deploy即可</p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UDP协议</title>
      <link href="2020/08/01/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/4%E3%80%81UDP%E5%8D%8F%E8%AE%AE/"/>
      <url>2020/08/01/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/4%E3%80%81UDP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<ul><li>1、面向无连接、不可靠性</li><li>2、有单播，多播，广播的功能</li><li>3、UDP是面向报文的，对应用层交下来的报文，不合并，不拆分，保留原报文的边界；</li><li>4、UDP的首部开销小，只有８字节。对于UDP包，我们需要在应用层去限制每个包的大小，一般不要超过1472字节，即以太网MTU（1500）—UDP首部（8）—IP首部（20）</li></ul><p>UDP应用</p><p>流媒体<br>实时游戏<br>物联网  </p>]]></content>
      
      
      <categories>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UDP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希冲突的拒绝服务攻击</title>
      <link href="2020/08/01/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8/2%E3%80%81%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/"/>
      <url>2020/08/01/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8/2%E3%80%81%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p>查找或者插入的情况在大多数情况下可以达到O(1)，因为可以通过key的hasn函数，直接定位到数据存放位置。所以操作的时间主要花在计算hash上。</p><p>最坏的情况就是hash值全都映射到同一个地址上，这样哈希表就会退化成链表，查找的时间复杂度变成O(n)。这种情况有人蓄意攻击，就需要了解基于哈希冲突的拒绝服务攻击。实际测试中，针对8万条级别的数据，原本只需要数毫秒即可完成的插入或者查询操作，在退化为链表后则需要长达30秒以上的时间才能完成。</p><p>目前绝大多数的web应用，都存在着一个叫做【哈希碰撞式拒绝服务】攻击的漏洞（Hash Collision DoS）</p><p>构造一个哈希表完全退化成链表的键值集合：</p><p>就是要找到一个字符串集合，使得该集合的每个元素要么满足哈希值相等；目前常见的哈希表的哈希函数实现，都是基于著名的DJBX33哈希算法或者其变形算法。</p><ul><li>相等子串法<br>由于DJBX33A系列哈希算法满足一个很有意思的特性：如果hash(“string1”) = hash(“string2”)，那么在相同位置包含此2个子串的父串哈希结果将会产生碰撞，既：hash(“prefix_string1_postfix”) = hash(“prefix_string2_postfix”)。根据这一特性，攻击者如果能找到最简单的两个碰撞字符串，那么就可以很快通过反复组合，生成2的n次方个长度为2n的碰撞字符串</li></ul><ul><li><p>中间相遇法</p></li><li><p>通过算法构造哈希结果完全一致的字符串集合有难度满足哈希值对哈希表数组长度取余的最终结果相等 形成攻击</p></li></ul><p>web应用中HTTP Request中的Header, Form以及QueryString，都使用了哈希表进行存储。通过在单机上重复构造大量的HTTP Post请求，向Web服务器发送大量表单数据，会使得目标服务器的CPU迅速被占满而失去服务能力，达到攻击目的。</p><p>目前绝大部分Web服务器的补丁都是针对每次HTTP请求中表单项的数量加以限制(每次请求都重新构建一个hashmap进行存储，所以不用考虑多次请求导致hash碰撞拒绝服务)。测试数据显示，1000个元素的链表操作对性能的影响还是可以接受的</p><p>但如果在业务代码中使用全局map进行存储表单数据，则可以<br>在哈希算法中引入随机盐使得构造哈希冲突变为不可能。缺点是不能取出来来</p>]]></content>
      
      
      <categories>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希冲突的拒绝服务攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务产生的场景</title>
      <link href="2020/08/01/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/1%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%BA%A7%E7%94%9F%E7%9A%84%E5%9C%BA%E6%99%AF/"/>
      <url>2020/08/01/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/1%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%BA%A7%E7%94%9F%E7%9A%84%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>本地事务：，在同一JVM进程中，利用关系型数据库本身的事务特性实现（ACID）</p><p>分布式事务：<br>==只要是跨JVM进程就产生分布式事务==<br>因为不同JVN进程无论连接同一数据源还是非同一数据源，都是持有非同一数据库连接，对数据库操作。就会产生分布式事务</p><p>如以下场景：</p><ul><li>1、微服务之间通过远程调用来实现事务控制。</li></ul><p>比如：订单微服务和库存微服务分别对应自己的数据库，下单的同时订单微服务请求库存服务减少库存。</p><ul><li>2、当单体系统访问多个数据库实例时就产生分布式事务</li></ul><p>比如：用户信息和订单信息分别在两个不同的(MySQL)关系数据库实例。用户管理系统删除用户信息，需要分别删除用户信息和用户的订单信息。由于数据分布在不同的数据库实例上，需要操作不同的数据库连接池来操作数据，此时就产生了分布式事务。</p><ul><li>3、多个服务访问同一个数据库实例</li></ul><p>订单微服务和库存微服务同时访问同一个数据库实例也会产生分布式事务。用于两个服务跨JVM进程，两个微服务分别持有了不同的数据库链接，进行数据库的数据操作。这样同样也会产生分布式事务。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式事务解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务产生的场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务-两阶段提交</title>
      <link href="2020/08/01/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/7%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/"/>
      <url>2020/08/01/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/7%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<p>两阶段提交具有强一致性, 是CP系统的一种典型实现.【不推荐】</p><p>2PC即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit phase），2是指两个阶段，P是指准备阶段，C是指提交阶段。</p><p>两阶段提交中的第二阶段, 协调者需要等待所有参与者发出yes请求, 或者一个参与者发出no请求后, 才能执行提交或者中断操作. 这会造成长时间同时锁住多个资源, 造成性能瓶颈, 如果参与者有一个耗时长的操作, 性能损耗会更明显.实现复杂, 不利于系统的扩展, 不推荐.</p>]]></content>
      
      
      <categories>
          
          <category> 分布式事务解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务-两阶段提交 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty的介绍</title>
      <link href="2020/07/23/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/9%E3%80%81Netty%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/07/23/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/9%E3%80%81Netty%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h5 id="传统NIO编程的缺点："><a href="#传统NIO编程的缺点：" class="headerlink" title="传统NIO编程的缺点："></a>传统NIO编程的缺点：</h5><ul><li>NIO 的类库和 API 繁杂，使用麻烦：需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。</li><li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。</li><li>JDK NIO 的 Bug：例如臭名昭著的 Epoll Bug<br>空轮询：<br>在NIO中通过Selector的轮询当前是否有IO事件，根据JDK NIO api描述，Selector的select方法会一直阻塞，直到IO事件达到或超时，但是在Linux平台上这里有时会出现问题，在某些场景下select方法会直接返回，即使没有超时并且也没有IO事件到达，它会导致线程陷入死循环，会让CPU飙到100%，极大地影响系统的可靠性，到目前为止，JDK都没有完全解决这个问题。</li></ul><h5 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h5><p>Netty 是由 JBOSS 提供的一个Java开源框架，是一个==异步的、基于事件驱动的网络应用框架==，用以快速开发高性能、高可靠性的网络 IO 程序。（netty在github上的star数2w+，排名前25的）</p><ul><li>支持常用应用层协议</li><li>解决传输问题：粘包、半包问题</li><li>支持流量整形。流量控制，黑白名单等功能</li><li>完善的断连、ldle等异常</li><li>API功能更强大</li><li>屏蔽JDK的实现细节。如使用NIO切换到AIO需要修改很多代码，使用netty可以做到轻易切换</li><li>解决NIO的已知bug 如：</li></ul><p>空轮询BUG：</p><p>Netty的处理空轮询的方式：检测问题的存在，然后处理</p><p>记录select空转的次数，定义一个阀值，这个阀值默认是512，可以在应用层通过设置系统属性io.netty.selectorAutoRebuildThreshold传入，当空转的次数超过了这个阀值，重新构建新Selector，将老Selector上注册的Channel转移到新建的Selector上，关闭老Selector，用新的Selector代替老Selector，详细实现可以查看NioEventLoop中的selector和rebuildSelector方法：</p><p>Option not found异常：</p><p>IP_TOS参数使用时抛出Option not found异常：<br>。解决方式：规避这个问题。从根本上就不支持设置该参数</p><h5 id="同类型框架："><a href="#同类型框架：" class="headerlink" title="同类型框架："></a>同类型框架：</h5><ul><li>Apache Mina 同一作者开发。本人回答：nima是作者与另一人协同开发。netty是nima的增强版，使用比mima更简单。netty的自由性更高因为nima是属于apache下管理。</li><li>Sun Grizzly 用的很少、文档较少</li><li>Apple Swift NIO 、ACE .非java语言</li><li>Cindy 淘汰产品</li><li>tomcat jetty 底层通信框架并未独立出来，都只是为了更好的服务于Servlet容器。不具有通用型。</li></ul><h5 id="netty应用场景"><a href="#netty应用场景" class="headerlink" title="netty应用场景"></a>netty应用场景</h5><ul><li>数据库：阿里云的NoSql:cassandra</li><li>大数据：Hadoop、Spark</li><li>MQ: RocketMQ</li><li>检索：elasticsearch</li><li>RPC框架：gRPC、Dubbo、Spring5（springboot2为webflux选择的默认部署就是netty，而不再是tomcat和jetty）、zookeeper、分布式计算框架 Storm</li><li>Netty 基本是 Java 语言处理网络 IO 的首选框架，性能和稳定性都有保障，社区比较活跃，基于 Netty 进行二次定制服务成本小。</li></ul><h5 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class NettyServer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1. 创建一个线程组：接收客户端连接</span><br><span class="line">        EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">        &#x2F;&#x2F;2. 创建一个线程组：处理网络操作</span><br><span class="line">        EventLoopGroup workerGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">        &#x2F;&#x2F;3. 创建服务器端启动助手来配置参数【辅助启动类，降低服务端的开发复杂度】</span><br><span class="line">        ServerBootstrap b &#x3D; new ServerBootstrap();</span><br><span class="line">        b.group(bossGroup, workerGroup) &#x2F;&#x2F;4.设置两个线程组</span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * FileChannel:用于文件的数据读写</span><br><span class="line">                 * DatagramChannel:用于 UDP 的数据读写</span><br><span class="line">                 * ServerSocketChannel 和 SocketChannel:用于 TCP 的数据读写</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                .channel(NioServerSocketChannel.class) &#x2F;&#x2F;5.使用NioServerSocketChannel作为服务器端通道的实现</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, 128) &#x2F;&#x2F;6.设置线程队列中等待连接的个数</span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, true) &#x2F;&#x2F;7.保持活动连接状态</span><br><span class="line">                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;  &#x2F;&#x2F;8. 创建一个通道初始化对象</span><br><span class="line">                    public void initChannel(SocketChannel sc) &#123;   &#x2F;&#x2F;9. 往Pipeline链中添加自定义的handler类</span><br><span class="line">                        sc.pipeline().addLast(new NettyServerHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(&quot;......Server is ready......&quot;);</span><br><span class="line">        ChannelFuture cf &#x3D; b.bind(6668).sync();  &#x2F;&#x2F;10. 绑定端口 bind方法是异步的  sync方法是同步阻塞的</span><br><span class="line">        System.out.println(&quot;......Server is starting......&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;11. 关闭通道，关闭线程组</span><br><span class="line">        cf.channel().closeFuture().sync(); &#x2F;&#x2F;异步</span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;服务器端的业务处理类</span><br><span class="line">public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;读取数据事件</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">        System.out.println(&quot;Server:&quot; + ctx);</span><br><span class="line">        ByteBuf buf &#x3D; (ByteBuf) msg;</span><br><span class="line">        System.out.println(&quot;客户端发来的消息：&quot; + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;数据读取完毕事件</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello client(&gt;^ω^&lt;)喵&quot;, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;异常发生事件</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable t) &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class NettyClient &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1. 创建一个线程组</span><br><span class="line">        EventLoopGroup group &#x3D; new NioEventLoopGroup();</span><br><span class="line">        &#x2F;&#x2F;2. 创建客户端的启动助手，完成相关配置</span><br><span class="line">        Bootstrap b &#x3D; new Bootstrap();</span><br><span class="line">        b.group(group)  &#x2F;&#x2F;3. 设置线程组</span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * FileChannel:用于文件的数据读写</span><br><span class="line">                 * DatagramChannel:用于 UDP 的数据读写</span><br><span class="line">                 * ServerSocketChannel 和 SocketChannel:用于 TCP 的数据读写</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                .channel(NioSocketChannel.class)  &#x2F;&#x2F;4. 设置客户端通道的实现类</span><br><span class="line">                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;  &#x2F;&#x2F;5. 创建一个通道初始化对象</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                        socketChannel.pipeline().addLast(new NettyClientHandler()); &#x2F;&#x2F;6.往Pipeline链中添加自定义的handler</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(&quot;......Client is  ready......&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;7.启动客户端去连接服务器端  connect方法是异步的   sync方法是同步阻塞的</span><br><span class="line">        ChannelFuture cf &#x3D; b.connect(&quot;127.0.0.1&quot;, 6668).sync();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;8.关闭连接(异步非阻塞)</span><br><span class="line">        cf.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;客户端业务处理类</span><br><span class="line">public class NettyClientHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通道就绪事件</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        System.out.println(&quot;Client:&quot; + ctx);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, server ^(*￣(oo)￣)^&quot;, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;读取数据事件</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">        ByteBuf buf &#x3D; (ByteBuf) msg;</span><br><span class="line">        System.out.println(&quot;服务器端发来的消息：&quot; + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生命周期管理，所引入的 Bootstrapping 机制。我们通常要做的创建 Channel、绑定端口、注册 Handler 等，都可以通过这个统一的入口，以 Fluent API 等形式完成，相对简化了 API 使用。与之相对应， Bootstrap则是 Client 端的通常入口。</li><li>Channel，作为一个基于 NIO 的扩展框架，Channel 和 Selector 等概念仍然是 Netty 的基础组件，但是针对应用开发具体需求，提供了相对易用的抽象。</li><li>EventLoop，这是 Netty 处理事件的核心机制。例子中使用了 EventLoopGroup。我们在 NIO 中通常要做的几件事情，如注册感兴趣的事件、调度相应的 Handler 等，都是 EventLoop 负责。</li><li>ChannelFuture，这是 Netty 实现异步 IO 的基础之一，保证了同一个 Channel 操作的调用顺序。Netty 扩展了 Java 标准的 Future，提供了针对自己场景的特有Future定义。</li><li>ChannelHandler，这是应用开发者放置业务逻辑的主要地方，也是我上面提到的“Separation Of Concerns”原则的体现。</li><li>ChannelPipeline，它是 ChannelHandler 链条的容器，每个 Channel 在创建后，自动被分配一个 ChannelPipeline。在上面的示例中，我们通过 ServerBootstrap 注册了 ChannelInitializer，并且实现了 initChannel 方法，而在该方法中则承担了向 ChannelPipleline 安装其他 Handler 的任务。</li></ul>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty的介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reactor模式</title>
      <link href="2020/07/22/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/8%E3%80%81Reactor%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/22/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/8%E3%80%81Reactor%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Reactor模式也叫反应器模式，大多数IO相关组件如Netty、Redis在使用的IO模式。</p><h5 id="传统同步阻塞IO模式"><a href="#传统同步阻塞IO模式" class="headerlink" title="传统同步阻塞IO模式"></a>传统同步阻塞IO模式</h5><p>传统同步阻塞IO，读写阻塞，线程等待时间过长<br>且每个连接开一个线程处理优化版本：使用线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主线程维护连接</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Socket socket &#x3D; serverSocket.accept();</span><br><span class="line">                &#x2F;&#x2F;方式一：每个连接开一个线程处理</span><br><span class="line">                &#x2F;&#x2F;方式二：提交线程池处理</span><br><span class="line">                executorService.submit(new Handler(socket));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 处理读写服务</span><br><span class="line">    class Handler implements Runnable &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;获取Socket的输入流，接收数据</span><br><span class="line">                BufferedReader buf &#x3D; new BufferedReader(newInputStreamReader(socket.getInputStream()));</span><br><span class="line">                String readData &#x3D; buf.readLine();</span><br><span class="line">                while (readData !&#x3D; null) &#123;</span><br><span class="line">                    readData &#x3D; buf.readLine();</span><br><span class="line">                    System.out.println(readData);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="Reactor的影子"><a href="#Reactor的影子" class="headerlink" title="Reactor的影子"></a>Reactor的影子</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public NIOServer(int port) throws Exception &#123;</span><br><span class="line">        selector &#x3D; Selector.open();</span><br><span class="line">        serverSocket &#x3D; ServerSocketChannel.open();</span><br><span class="line">        serverSocket.socket().bind(new InetSocketAddress(port));</span><br><span class="line">        serverSocket.configureBlocking(false);</span><br><span class="line">        serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (!Thread.interrupted()) &#123;</span><br><span class="line">            &#x2F;&#x2F;阻塞等待事件</span><br><span class="line">            selector.select();</span><br><span class="line">            &#x2F;&#x2F; 事件列表</span><br><span class="line">            Set selected &#x3D; selector.selectedKeys();</span><br><span class="line">            Iterator it &#x3D; selected.iterator();</span><br><span class="line">            while (it.hasNext()) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                &#x2F;&#x2F;分发事件,统一处理</span><br><span class="line">                dispatch((SelectionKey) (it.next()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dispatch(SelectionKey key) throws Exception &#123;</span><br><span class="line">        if (key.isAcceptable()) &#123;</span><br><span class="line">            register(key);&#x2F;&#x2F;新链接建立，注册</span><br><span class="line">        &#125; else if (key.isReadable()) &#123;</span><br><span class="line">            read(key);&#x2F;&#x2F;读事件处理</span><br><span class="line">        &#125; else if (key.isWritable()) &#123;</span><br><span class="line">            wirete(key);&#x2F;&#x2F;写事件处理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述的NIO例子已经拥有reactor的影子<br>1、基于事件驱动-&gt; selector（支持对多个socketChannel的监听）</p><p>2、统一的事件分派中心-&gt; dispatch</p><p>首先Reactor 是一种设计模式。I/O 复用结合线程池，就是 Reactor 模式基本设计思想</p><p>Reactor模式，是基于Java NIO的，在他的基础上，抽象出来三个组件：</p><ul><li>Reactor：负责响应事件，将事件分发给绑定了该事件的Handler处理；</li><li>Handler：事件处理器，绑定了某类事件，负责执行对应事件的Task对事件进行处理；</li><li>Acceptor：Handler的一种，绑定了ACCEPT事件，当客户端发起connect请求时，Reactor会将accept事件分发给Acceptor处理。</li></ul><h5 id="单Reactor单线程；"><a href="#单Reactor单线程；" class="headerlink" title="单Reactor单线程；"></a>单Reactor单线程；</h5><ul><li>Reactor 对象通过select 监控客户端请求事件, 收到事件后，通过dispatch进行分发</li><li>如果建立连接事件, 则由Acceptor 通过accept 处理连接请求, 然后创建一个Handler对象处理完成连接后的各种事件</li><li>如果是IO读写就绪事件，则由reactor分发调用连接对应的handler 来处理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 负责处理IO事件到来，分发事件处理</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Reactor implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private Reactor() throws Exception &#123;</span><br><span class="line">        SelectionKey sk &#x3D; serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#x2F;&#x2F; attach Acceptor 处理新连接</span><br><span class="line">        sk.attach(new Acceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (!Thread.interrupted()) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set selected &#x3D; selector.selectedKeys();</span><br><span class="line">            Iterator it &#x3D; selected.iterator();</span><br><span class="line">            while (it.hasNext()) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                &#x2F;&#x2F;分发事件处理</span><br><span class="line">                dispatch((SelectionKey) (it.next()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dispatch(SelectionKey k) &#123;</span><br><span class="line">        &#x2F;&#x2F; 若是连接事件获取是acceptor</span><br><span class="line">        &#x2F;&#x2F; 若是IO读写事件获取是handler</span><br><span class="line">        Runnable runnable &#x3D; (Runnable) (k.attachment());</span><br><span class="line">        if (runnable !&#x3D; null) &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 连接事件就绪,处理连接事件</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Acceptor implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            SocketChannel c &#x3D; serverSocket.accept();</span><br><span class="line">            if (c !&#x3D; null) &#123;&#x2F;&#x2F; Handler构造器中注册读写</span><br><span class="line">                new Handler(c, selector);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 处理读写业务逻辑</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Handler implements Runnable &#123;</span><br><span class="line">    final SelectionKey sk;</span><br><span class="line"></span><br><span class="line">    public Handler(SocketChannel socket, Selector selector) throws Exception &#123;</span><br><span class="line">        sk &#x3D; socket.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        sk.attach(this);</span><br><span class="line">        socket.configureBlocking(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (sk.isReadable()) &#123;</span><br><span class="line">            read(sk);&#x2F;&#x2F;读事件处理</span><br><span class="line">        &#125; else if (sk.isWritable()) &#123;</span><br><span class="line">            wirete(sk);&#x2F;&#x2F;写事件处理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于单线程模型，acceptor处理和handler处理都在一个线程中处理；这个的缺点显而易见，当某个handler阻塞时，会导致其他所有的client的handler都得不到执行，并且更严重的是，handler的阻塞会导致整个服务不能接收新的client请求，因为acceptor也被阻塞了。</p><h5 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程"></a>单 Reactor 多线程</h5><p>与单Reactor单线程模型的区别在于：</p><ul><li>handler 只负责响应事件，不做具体的业务处理, 通过read 读取数据后，会分发给后面的worker线程池的某个线程处理业务</li><li>worker 线程池会分配独立线程完成真正的业务，并将结果返回给handler</li><li>handler收到响应后，通过send 将结果返回给client</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;多线程处理业务逻辑</span><br><span class="line">ExecutorService executorService &#x3D; Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    if (sk.isReadable()) &#123;</span><br><span class="line">        &#x2F;&#x2F;任务异步处理读事件处理，通过send 将读写结果返回给client</span><br><span class="line">        executorService.submit(() -&gt; read(sk));</span><br><span class="line">    &#125; else if (sk.isWritable()) &#123;</span><br><span class="line">        &#x2F;&#x2F;任务异步处理读事件处理，通过send 将读写结果返回给client</span><br><span class="line">        executorService.submit(() -&gt; write(sk));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="主从-Reactor-多线程-："><a href="#主从-Reactor-多线程-：" class="headerlink" title="主从 Reactor 多线程 ："></a>主从 Reactor 多线程 ：</h5><p>单Reactor 多线程的缺点是：<br>如果服务器需要同时处理大量的客户端连接请求或在进行客户单连接时，进行一些权限的检查，那么单线程的Acceptor很有可能处理不过来，造成大量的客户端不能连接到服务器。<br>所以主从Reactor多线程模型中，服务器端接收客户端的连接请求不在是一个线程，而是由一个独立的线程池组成的。主从Reactor的方式，将连接和数据处理完全分开维护，将大大提高并发量</p><hr><ul><li>Reactor主线程 MainReactor 对象通过select 监听连接事件, 收到事件后，通过Acceptor 处理连接事件</li><li>当 Acceptor  处理连接事件后，MainReactor 将连接分配给SubReactor </li><li>subreactor 将连接加入到连接队列进行监听,并创建handler进行各种事件处理</li><li>当有新事件发生时， subreactor 就会调用对应的handler处理</li><li>handler 通过read 读取数据，分发给后面的worker 线程处理</li><li>worker 线程池分配独立的worker 线程进行业务处理，并返回结果</li><li>handler 收到响应的结果后，再通过send 将结果返回给client</li><li>Reactor 主线程可以对应多个Reactor 子线程, 即MainRecator 可以关联多个SubReactor</li></ul><p>Netty 主要基于主从 Reactors 多线程模型（如图）做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor</p><p>Netty的线程模型是Reactor模型的变种，那就是去掉线程池的第三种形式的变种，这也是Netty NIO的默认模式。</p><p>Netty 中使用 Reactor 模式</p><p>Reactor 单线程模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup eventGroup &#x3D; new NioEventLoopGroup(1);</span><br><span class="line">ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();</span><br><span class="line">serverBootstrap.group(eventGroup);</span><br></pre></td></tr></table></figure><p>非主从 Reactor 多线程模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup eventGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();</span><br><span class="line">serverBootstrap.group(eventGroup);</span><br></pre></td></tr></table></figure><p>主从 Reactor 多线程模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup &#x3D; new NioEventLoopGroup(); </span><br><span class="line">ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();</span><br><span class="line">serverBootstrap.group(bossGroup, workerGroup);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reactor模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择器selector</title>
      <link href="2020/07/22/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/5%E3%80%81%E9%80%89%E6%8B%A9%E5%99%A8selector/"/>
      <url>2020/07/22/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/5%E3%80%81%E9%80%89%E6%8B%A9%E5%99%A8selector/</url>
      
        <content type="html"><![CDATA[<p>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接,避免了多线程之间的上下文切换导致的开销（注意：多核CPU，不使用多任务可能是在浪费CPU能力）</p><p>为了将Channel和Selector配合使用，==channel必须注册到selector上==。通过SelectableChannel.register()方法来实现.Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key &#x3D; channel.register(selector,Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure><p>第二个参数,Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p><ul><li><p>SelectionKey.OP_CONNECT   某个channel成功连接到另一个服务器称为“连接就绪”</p></li><li><p>SelectionKey.OP_ACCEPT 一个server socket channel准备好接收新进入的连接称为“接收就绪”</p></li><li><p>SelectionKey.OP_READ 一个有数据可读的通道可以说是“读就绪”</p></li><li><p>SelectionKey.OP_WRITE 等待写数据的通道可以说是“写就绪</p></li><li><p>多个事件驱动 用|隔开<br>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</p></li></ul><p>==注意：==</p><ul><li>client的socketChannel:只监听 连接、读、写事件</li><li>server的serverSocketChannel 只监听OP_ACCEPT</li><li>server的socketChannel只监听 读、写事件<br>注册好之后会有一个多路复用器selector去循环检测对于管道上是否有该事件发生。</li></ul><p>注册后返回一个 SelectionKey，SelectionKey，表示 Selector 和网络通道的注册关系</p><p>通过SelectionKey可以获取与之关联的Selector，channel,再完成后续业务处理</p><p>SelectionKey相关方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class SelectionKey &#123;</span><br><span class="line">     public abstract Selector selector();&#x2F;&#x2F;得到与之关联的 Selector 对象</span><br><span class="line">    public abstract SelectableChannel channel();&#x2F;&#x2F;得到与之关联的通道</span><br><span class="line">    public final Object attachment();&#x2F;&#x2F;得到与之关联的共享数据</span><br><span class="line">    public abstract SelectionKey interestOps(int ops);&#x2F;&#x2F;设置或改变监听事件</span><br><span class="line">    public final boolean isAcceptable();&#x2F;&#x2F;是否可以 accept</span><br><span class="line">    public final boolean isReadable();&#x2F;&#x2F;是否可以读</span><br><span class="line">    public final boolean isWritable();&#x2F;&#x2F;是否可以写</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Selector 常用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Selector implements Closeable &#123; </span><br><span class="line">    public static Selector open();&#x2F;&#x2F;得到一个选择器对象</span><br><span class="line">    public int select();&#x2F;&#x2F;阻塞到至少有一个通道在你注册的事件上就绪了。返回有事件发生的通道的个数.</span><br><span class="line">    public int select(long timeout);&#x2F;&#x2F;监控所有注册的通道，当其中有 IO 操作可以进行时，将</span><br><span class="line">    对应的 SelectionKey 加入到内部集合中并返回，参数用来设置超时时间，返回有事件发生的通道的个数.</span><br><span class="line">    public int selectNow();&#x2F;&#x2F;不阻塞，立马返还。此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零，返回有事件发生的通道的个数.</span><br><span class="line">    public Set&lt;SelectionKey&gt; selectedKeys();&#x2F;&#x2F;从内部集合中得到所有的 SelectionKey</span><br><span class="line">    </span><br><span class="line">    public abstract Selector wakeup();&#x2F;&#x2F;某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。</span><br><span class="line">    public abstract void close() throws IOException;&#x2F;&#x2F;用完Selector后调用其close()方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ServerSocketChannel【功能类似ServerSocket】 在服务器端监听新的客户端 Socket 连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ServerSocketChannel    extends AbstractSelectableChannel   implements NetworkChannel&#123;</span><br><span class="line">    public static ServerSocketChannel open()，得到一个 ServerSocketChannel 通道</span><br><span class="line">    public final ServerSocketChannel bind(SocketAddress local)，设置服务器端端口号</span><br><span class="line">    public final SelectableChannel configureBlocking(boolean block)，设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式</span><br><span class="line">    public SocketChannel accept()，接受一个连接，返回代表这个连接的通道对象</span><br><span class="line">    public final SelectionKey register(Selector sel, int ops)，注册一个选择器并设置监听事件</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SocketChannel，网络 IO 通道，具体负责进行读写操作。NIO 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class SocketChannel extends AbstractSelectableChannel implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, NetworkChannel&#123;</span><br><span class="line">    public static SocketChannel open();&#x2F;&#x2F;得到一个 SocketChannel 通道</span><br><span class="line">    public final SelectableChannel configureBlocking(boolean block);&#x2F;&#x2F;设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式</span><br><span class="line">    public boolean connect(SocketAddress remote);&#x2F;&#x2F;连接服务器</span><br><span class="line">    public boolean finishConnect();&#x2F;&#x2F;如果上面的方法连接失败，接下来就要通过该方法完成连接操作</span><br><span class="line">    public int write(ByteBuffer src);&#x2F;&#x2F;往通道里写数据</span><br><span class="line">    public int read(ByteBuffer dst);&#x2F;&#x2F;从通道里读数据</span><br><span class="line">    public final SelectionKey register(Selector sel, int ops, Object att);&#x2F;&#x2F;注册一个选择器并设置监听事件，最后一个参数可以设置共享数据</span><br><span class="line">    public final void close();&#x2F;&#x2F;关闭通道</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="实现服务器端和客户端之间的数据简单通讯的DEMO"><a href="#实现服务器端和客户端之间的数据简单通讯的DEMO" class="headerlink" title="实现服务器端和客户端之间的数据简单通讯的DEMO"></a>实现服务器端和客户端之间的数据简单通讯的DEMO</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;网络服务器端程序</span><br><span class="line">public class NIOServer &#123;</span><br><span class="line">    public static void main(String[] args) throws  Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;1. 得到一个ServerSocketChannel对象</span><br><span class="line">        ServerSocketChannel serverSocketChannel&#x3D;ServerSocketChannel.open();</span><br><span class="line">        &#x2F;&#x2F;2. 得到一个Selector对象</span><br><span class="line">        Selector selector&#x3D;Selector.open();</span><br><span class="line">        &#x2F;&#x2F;3. 绑定一个端口号, 在服务器的6666监听</span><br><span class="line">        &#x2F;&#x2F;serverSocketChannel.bind(new InetSocketAddress(6666));</span><br><span class="line">        serverSocketChannel.socket().bind(new InetSocketAddress(6666));</span><br><span class="line">        &#x2F;&#x2F;4. 设置非阻塞方式</span><br><span class="line">        serverSocketChannel.configureBlocking(false);</span><br><span class="line">        &#x2F;&#x2F;5. 把ServerSocketChannel对象注册给Selector对象</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#x2F;&#x2F;6. 干活</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            &#x2F;&#x2F;6.1 监控客户端</span><br><span class="line">            &#x2F;&#x2F;如果使用 selector.select() 就会阻塞在这里的</span><br><span class="line">            if(selector.select(1000)&#x3D;&#x3D;0)&#123;  &#x2F;&#x2F;nio非阻塞式的优势</span><br><span class="line">                System.out.println(&quot;Server:等待了1秒，无客户端连接&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;6.2 得到SelectionKey,判断通道里的事件</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator&#x3D;selector.selectedKeys().iterator();</span><br><span class="line">            while(keyIterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key&#x3D;keyIterator.next();</span><br><span class="line">                if(key.isAcceptable())&#123;  &#x2F;&#x2F;客户端连接请求事件</span><br><span class="line"></span><br><span class="line">                    SocketChannel socketChannel&#x3D;serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(false);</span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(1024));</span><br><span class="line">                &#125;</span><br><span class="line">                if(key.isReadable())&#123;  &#x2F;&#x2F;读取客户端数据事件</span><br><span class="line">                    SocketChannel channel&#x3D;(SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer buffer&#x3D;(ByteBuffer) key.attachment();</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(&quot;接收到客户端数据：&quot;+new String(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 6.3 手动从集合中移除当前key,防止重复处理</span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;网络客户端程序</span><br><span class="line">public class NIOClient &#123;</span><br><span class="line">    public static void main(String[] args) throws  Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;1. 得到一个网络通道</span><br><span class="line">        SocketChannel channel&#x3D;SocketChannel.open();</span><br><span class="line">        &#x2F;&#x2F;2. 设置非阻塞方式</span><br><span class="line">        channel.configureBlocking(false);</span><br><span class="line">        &#x2F;&#x2F;3. 提供服务器端的IP地址和端口号</span><br><span class="line">        InetSocketAddress address&#x3D;new InetSocketAddress(&quot;127.0.0.1&quot;,6666);</span><br><span class="line">        &#x2F;&#x2F;4. 连接服务器端</span><br><span class="line">        if(!channel.connect(address))&#123;</span><br><span class="line">            while(!channel.finishConnect())&#123;  &#x2F;&#x2F;nio非阻塞式</span><br><span class="line">                System.out.println(&quot;客户端: 因为连接需要时间，客户端不会阻塞，可以做个计算工作...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;连接成功了..</span><br><span class="line">        &#x2F;&#x2F;5. 得到一个缓冲区并存入数据</span><br><span class="line">        String msg&#x3D;&quot;hello,尚硅谷&quot;;</span><br><span class="line">        ByteBuffer writeBuf &#x3D; ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">        &#x2F;&#x2F;6. 发送数据</span><br><span class="line">        channel.write(writeBuf);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 选择器selector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO模型-NIO</title>
      <link href="2020/07/22/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/2%E3%80%81IO%E6%A8%A1%E5%9E%8B-NIO/"/>
      <url>2020/07/22/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/2%E3%80%81IO%E6%A8%A1%E5%9E%8B-NIO/</url>
      
        <content type="html"><![CDATA[<p>Java 1.4 中引入了 NIO。NIO 以块的方式处理数据,块 I/O 的效率比流 I/O 高很多</p><p> NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据先总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道 。</p><p>BIO同步阻塞：<br>阻塞节点1：等待客户端的连接<br>阻塞节点2：客户端连接请求进来后，需要创建独立的线程处理，且当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上</p><p>相比于BIO</p><p>第个阶段大量的连接统统都可以过来直接注册到Selector复用器上面，同时只要单个或者少量的线程来循环处理这些连接事件就可以了，一旦达到“就绪”的条件，就可以立即执行真正的I/O操作。</p><p> Selector 、 Channel 和 Buffer 的关系图：</p><ul><li>一个Selector实例对应一个线程，</li><li>一个Selector可以注册多个channel 实例，每个channel都有唯一一个与之对应的Buffer实例</li><li>Selector 会根据不同的事件，在各个channel上切换【事件决定】</li><li>Buffer 就是一个内存块 ， 底层是有一个数组。数据读和写都必须通过Buffer【连接点其实是Channle，而读写的容器是Buffer。】</li><li>channel中数据的读取写入是双向的【flip 方法切换】, 可以返回底层操作系统的情况, 比如Linux ， 底层的操作系统通道就是双向的</li></ul><p>总结：<br>NIO的三个主要特点：面向缓冲、同步非阻塞和多路复用。</p><p>再谈Unix的I/O多路复用模型：</p><p>I/O多路复用，I/O就是指的我们网络I/O,多路指多个TCP连接(或多个Channel)，复用指复用一个或少量线程。串起来理解就是很多个网络I/O复用一个或少量的线程来处理这些连接。（select，poll，epoll都是IO多路复用的机制）</p><p>epoll是Linux目前大规模网络并发程序开发的首选模型。在绝大多数情况下性能远超select和poll。目前流行的高性能web服务器Nginx正式依赖于epoll提供的高效网络套接字轮询服务。但是，在并发连接不高的情况下，多线程+阻塞I/O方式可能性能更好。</p><p>redis<br>1.单线程 避免了锁 线程之间的互相竞争<br>2、内存的读取I/O多路复用</p><p>nginx 采用的是多进程（单线程） + io多路复用(epoll)模型 实现高并发</p><h5 id="NIO-一定优于-BIO-么"><a href="#NIO-一定优于-BIO-么" class="headerlink" title="NIO 一定优于 BIO 么"></a>NIO 一定优于 BIO 么</h5><ul><li>相比NIO,BIO的代码简单</li><li>特定场景：连接数少，并发度低，BIO 性能不输 NIO。只是为了考虑后期拓展，才习惯选用NIO</li></ul><h5 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;网络服务器端程序</span><br><span class="line">public class NIOServer &#123;</span><br><span class="line">    public static void main(String[] args) throws  Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;1. 得到一个ServerSocketChannel对象</span><br><span class="line">        ServerSocketChannel serverSocketChannel&#x3D;ServerSocketChannel.open();</span><br><span class="line">        &#x2F;&#x2F;2. 得到一个Selector对象</span><br><span class="line">        Selector selector&#x3D;Selector.open();</span><br><span class="line">        &#x2F;&#x2F;3. 绑定一个端口号, 在服务器的6666监听</span><br><span class="line">        &#x2F;&#x2F;serverSocketChannel.bind(new InetSocketAddress(6666));</span><br><span class="line">        serverSocketChannel.socket().bind(new InetSocketAddress(6666));</span><br><span class="line">        &#x2F;&#x2F;4. 设置非阻塞方式</span><br><span class="line">        serverSocketChannel.configureBlocking(false);</span><br><span class="line">        &#x2F;&#x2F;5. 把ServerSocketChannel对象注册给Selector对象</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#x2F;&#x2F;6. 干活</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            &#x2F;&#x2F;6.1 监控客户端</span><br><span class="line">            &#x2F;&#x2F;如果使用 selector.select() 就会阻塞在这里的</span><br><span class="line">            if(selector.select(1000)&#x3D;&#x3D;0)&#123;  &#x2F;&#x2F;nio非阻塞式的优势</span><br><span class="line">                System.out.println(&quot;Server:等待了1秒，无客户端连接&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;6.2 得到SelectionKey,判断通道里的事件</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator&#x3D;selector.selectedKeys().iterator();</span><br><span class="line">            while(keyIterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key&#x3D;keyIterator.next();</span><br><span class="line">                if(key.isAcceptable())&#123;  &#x2F;&#x2F;客户端连接请求事件</span><br><span class="line"></span><br><span class="line">                    SocketChannel socketChannel&#x3D;serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(false);</span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(1024));</span><br><span class="line">                &#125;</span><br><span class="line">                if(key.isReadable())&#123;  &#x2F;&#x2F;读取客户端数据事件</span><br><span class="line">                    SocketChannel channel&#x3D;(SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer buffer&#x3D;(ByteBuffer) key.attachment();</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(&quot;接收到客户端数据：&quot;+new String(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 6.3 手动从集合中移除当前key,防止重复处理</span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;网络客户端程序</span><br><span class="line">public class NIOClient &#123;</span><br><span class="line">    public static void main(String[] args) throws  Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;1. 得到一个网络通道</span><br><span class="line">        SocketChannel channel&#x3D;SocketChannel.open();</span><br><span class="line">        &#x2F;&#x2F;2. 设置非阻塞方式</span><br><span class="line">        channel.configureBlocking(false);</span><br><span class="line">        &#x2F;&#x2F;3. 提供服务器端的IP地址和端口号</span><br><span class="line">        InetSocketAddress address&#x3D;new InetSocketAddress(&quot;127.0.0.1&quot;,6666);</span><br><span class="line">        &#x2F;&#x2F;4. 连接服务器端</span><br><span class="line">        if(!channel.connect(address))&#123;</span><br><span class="line">            while(!channel.finishConnect())&#123;  &#x2F;&#x2F;nio非阻塞式</span><br><span class="line">                System.out.println(&quot;客户端: 因为连接需要时间，客户端不会阻塞，可以做个计算工作...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;连接成功了..</span><br><span class="line">        &#x2F;&#x2F;5. 得到一个缓冲区并存入数据</span><br><span class="line">        String msg&#x3D;&quot;hello,尚硅谷&quot;;</span><br><span class="line">        ByteBuffer writeBuf &#x3D; ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">        &#x2F;&#x2F;6. 发送数据</span><br><span class="line">        channel.write(writeBuf);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO模型-NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管道</title>
      <link href="2020/07/21/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/4%E3%80%81%E7%AE%A1%E9%81%93/"/>
      <url>2020/07/21/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/4%E3%80%81%E7%AE%A1%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h5 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h5><p>==所有的 IO 在NIO 中都从一个Channel开始,数据可以从Channel读到Buffer中，也可以从Buffer写到Channel中==</p><p>channel必须注册到selector</p><h5 id="Channel与流的区别："><a href="#Channel与流的区别：" class="headerlink" title="Channel与流的区别："></a>Channel与流的区别：</h5><ul><li><p>BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel)是双向的，可以读操作，也可以写操作。</p></li><li><p>通道可以异步地读写。</p></li><li><p>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入</p></li><li><p>Channel在NIO中是一个接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface Channel extends Closeable&#123;&#125; </span><br></pre></td></tr></table></figure><h5 id="常用的-Channel-类"><a href="#常用的-Channel-类" class="headerlink" title="常用的 Channel 类"></a>常用的 Channel 类</h5></li><li><p>FileChannel:用于文件的数据读写</p></li><li><p>DatagramChannel:用于 UDP 的数据读写</p></li><li><p>ServerSocketChannel 和 SocketChannel:用于 TCP 的数据读写。【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</p></li></ul><p>FileChannel:用于文件的数据读写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public int read(ByteBuffer dst) ，从通道读取数据并放到缓冲区中</span><br><span class="line">public int write(ByteBuffer src) ，把缓冲区的数据写到通道中</span><br><span class="line">public long transferFrom(ReadableByteChannel src, long position, long count)，从目标通道中复制数据到当前通道</span><br><span class="line">public long transferTo(long position, long count, WritableByteChannel target)，把数据从当前通道复制给目标通道</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写入和读取文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class NIOFileOper01 &#123;</span><br><span class="line"></span><br><span class="line">public static void write() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">String str&#x3D;&quot;hello,world&quot;;</span><br><span class="line">FileOutputStream fos&#x3D;new FileOutputStream(&quot;d:\\file01.txt&quot;);</span><br><span class="line">&#x2F;&#x2F;使用FileChannel 通道</span><br><span class="line">&#x2F;&#x2F;fos.getChannle 返回的是 FileChanel 的实现子类 FileChannelImpl</span><br><span class="line">&#x2F;&#x2F;可以追下源代码</span><br><span class="line">FileChannel fc&#x3D;fos.getChannel();</span><br><span class="line">ByteBuffer buffer&#x3D;ByteBuffer.allocate(1024);</span><br><span class="line">&#x2F;*</span><br><span class="line"> *NIO 中的通道是从输出流对象里通过 getChannel 方法获取到的，该通道是双向的，既可</span><br><span class="line">以读，又可以写。在往通道里写数据之前，必须通过 put 方法把数据存到 ByteBuffer 中，然</span><br><span class="line">后通过通道的 write 方法写数据。在 write 之前，需要调用 flip 方法翻转缓冲区，把内部重置</span><br><span class="line">到初始位置，这样在接下来写数据时才能把所有数据写到通道里 </span><br><span class="line"> *&#x2F;</span><br><span class="line">buffer.put(str.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line">fc.write(buffer);</span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void read() throws Exception &#123;</span><br><span class="line">File file &#x3D; new File(&quot;d:\\file01.txt&quot;);</span><br><span class="line">FileInputStream fis &#x3D; new FileInputStream(file);</span><br><span class="line">&#x2F;&#x2F;说明:</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 从输入流中获得一个通道，然后提供 ByteBuffer 缓冲区，该缓冲区的初始容量</span><br><span class="line">和文件的大小一样，最后通过通道的 read 方法把数据读取出来并存储到了 ByteBuffer 中</span><br><span class="line"> *&#x2F;</span><br><span class="line">FileChannel fc &#x3D; fis.getChannel();</span><br><span class="line">ByteBuffer buffer &#x3D; ByteBuffer.allocate((int) file.length());</span><br><span class="line">&#x2F;&#x2F;该通道可以写操作，也可以读操作</span><br><span class="line"></span><br><span class="line">fc.read(buffer);</span><br><span class="line">System.out.print(new String(buffer.array()));</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 FileChannel(通道) 和 方法  transferFrom ，完成文件的拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class NIOFileCopy &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">FileInputStream fis&#x3D;new FileInputStream(&quot;d:\\Koala.jpg&quot;);</span><br><span class="line">FileOutputStream fos&#x3D;new FileOutputStream(&quot;d:\\Koala2.jpg&quot;);</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 说明</span><br><span class="line"> * 从两个流中得到两个通道，sourCh ,destCh ，</span><br><span class="line"> * 然后直接调用 transferFrom 完成文件复制</span><br><span class="line"> *&#x2F;</span><br><span class="line">FileChannel sourCh &#x3D; fis.getChannel();</span><br><span class="line">FileChannel destCh &#x3D; fos.getChannel();</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * transferFrom 方法可以将两个通道连接起来，进行数据传输</span><br><span class="line"> * @param  src</span><br><span class="line">     *         The source channel</span><br><span class="line">     *</span><br><span class="line">     * @param  position</span><br><span class="line">     *         The position within the file at which the transfer is to begin;</span><br><span class="line">     *         must be non-negative</span><br><span class="line">     *</span><br><span class="line">     * @param  count</span><br><span class="line">     *         The maximum number of bytes to be transferred; must be</span><br><span class="line">     *         non-negative</span><br><span class="line">     *</span><br><span class="line">     * @return  The number of bytes, possibly zero,</span><br><span class="line">     *          that were actually transferred</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">destCh.transferFrom(sourCh, 0, sourCh.size()); </span><br><span class="line">sourCh.close();</span><br><span class="line">destCh.close();</span><br><span class="line">fis.close();</span><br><span class="line">fos.close();</span><br><span class="line">System.out.println(&quot;图片拷贝完毕~~&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Buffer 和 Channel的注意事项和细节</p><p>ByteBuffer 支持类型化的put 和 get, put 放入的是什么数据类型，get就应该使用相应的数据类型来取出，否则可能有 BufferUnderflowException 异常。</p><p>可以将一个普通Buffer 转成只读Buffer<br>NIO 还提供了 MappedByteBuffer， 可以让文件直接在内存（堆外的内存）中进行修改， 而如何同步到文件由NIO 来完成. </p><p>前面我们讲的读写操作，都是通过一个Buffer 完成的，NIO 还支持 通过多个Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 和 Gathering</p><h5 id="通道之间的数据传输"><a href="#通道之间的数据传输" class="headerlink" title="通道之间的数据传输"></a>通道之间的数据传输</h5><ul><li>FileChannel的transferFrom()方法可以将数据从其他通道传输到FileChannel中</li><li>transferTo()方法将数据从FileChannel传输到其他的channel中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile &#x3D; new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel fromChannel &#x3D; fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile &#x3D; new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel toChannel &#x3D; toFile.getChannel();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从position处开始向目标文件写入数据</span><br><span class="line">long position &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;count表示最多传输的字节数。</span><br><span class="line">&#x2F;&#x2F; 如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。</span><br><span class="line">long count &#x3D; fromChannel.size();</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">toChannel.transferFrom(position, count, fromChannel);</span><br><span class="line">&#x2F;&#x2F;transferTo()方法将数据从FileChannel传输到其他的channel中</span><br><span class="line">&#x2F;&#x2F;fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure><p>注意：在SoketChannel的实现中，SocketChannel只会传输此刻准备好的数据（可能不足count字节）。因此，SocketChannel可能不会将请求的所有数据(count个字节)全部传输到FileChannel中。</p><p>面试题：Java 有几种文件拷贝方式？哪一种最高效？</p><p>利用 java.io 类库，直接为源文件构建一个 FileInputStream 读取，然后再为目标文件构建一个 FileOutputStream，完成写入工作。</p><p>利用 java.nio 类库提供的 transferTo 或 transferFrom 方法实现。  NIO transferTo/From 的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。</p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 管道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO模型-BIO</title>
      <link href="2020/07/20/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/1%E3%80%81IO%E6%A8%A1%E5%9E%8B-BIO/"/>
      <url>2020/07/20/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/1%E3%80%81IO%E6%A8%A1%E5%9E%8B-BIO/</url>
      
        <content type="html"><![CDATA[<p>I/O 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能</p><p>Java共支持3种网络编程模型/IO模式：BIO、NIO、AIO</p><h5 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h5><p>BIO 以流的方式处理数据。</p><ul><li>阻塞节点1：等待客户端的连接</li><li>阻塞节点2：读取客户端的输入内容</li></ul><p>BIO ： 同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销 </p><p>应用场景：BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class BIOServer &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建一个线程池,每连接到一个客户端，就启动一个线程和客户端进行通信</span><br><span class="line">ExecutorService newCachedThreadPool &#x3D; Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;resource&quot;)</span><br><span class="line">ServerSocket server&#x3D;new ServerSocket(6666);</span><br><span class="line">System.out.println(&quot;tomcat服务器启动...&quot;);</span><br><span class="line">while(true)&#123;</span><br><span class="line">&#x2F;&#x2F;阻塞节点1：等待客户端的连接</span><br><span class="line">final Socket socket &#x3D; server.accept();</span><br><span class="line">System.out.println(&quot;连接到一个客户端！&quot;);</span><br><span class="line">newCachedThreadPool.execute(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">&#x2F;&#x2F;业务处理</span><br><span class="line">handler(socket);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 处理</span><br><span class="line"> * @param socket</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void handler(Socket socket)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">byte[] bytes &#x3D; new byte[1024];</span><br><span class="line">InputStream inputStream &#x3D; socket.getInputStream();</span><br><span class="line"></span><br><span class="line">while(true)&#123;</span><br><span class="line">&#x2F;&#x2F;阻塞节点2：读取客户端的输入内容</span><br><span class="line">int read &#x3D; inputStream.read(bytes);</span><br><span class="line">if(read !&#x3D; -1)&#123;</span><br><span class="line">System.out.println(new String(bytes, 0, read));</span><br><span class="line">&#125;else&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">try &#123;</span><br><span class="line">System.out.println(&quot;关闭和client的连接..&quot;);</span><br><span class="line">socket.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题分析：</p><ul><li>每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write</li><li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li><li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费</li></ul>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO模型-BIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git全局配置</title>
      <link href="2020/07/19/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/2%E3%80%81%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/git/git%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/"/>
      <url>2020/07/19/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/2%E3%80%81%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/git/git%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p> 在使用git之前我们可以配置一下git的用户名称和用户邮箱,这听起来好像挺鸡肋的,不过有时候也是有必要的,配置了git的用户名称和邮箱后,我们提交版本都会带上我们自己的信息哦.</p><h4 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config [--local | --global | --system] user.name &#39;Your name&#39;</span><br><span class="line">git config [--local | --global | --system] user.email &#39;Your email&#39;</span><br></pre></td></tr></table></figure><ul><li>local：区域为本仓库</li><li>global: 当前用户的所有仓库</li><li>system: 本系统的所有用户</li></ul><h4 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h4><p>这个指令添加local参数时候需要进入某个仓库里面才能使用，不然会提示错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list [--local | --global | --system]</span><br></pre></td></tr></table></figure><h4 id="清除配置"><a href="#清除配置" class="headerlink" title="清除配置"></a>清除配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --unset [--local | --global | --system] user.name &#39;Your name&#39;</span><br></pre></td></tr></table></figure><p>HTTPS协议 和 ssh 协议 进行代码的推送/拉取。两种协议的差别仅在于同一个仓库使用不同协议时的地址不同，以及对应的授权实现不同。</p><p>https 协议 克隆 对初学者来说会比较方便 ，复制 https url 然后到 git Bash 里面直接用 clone 命令克隆到本地就好了，但是 每次fetch和push代码都需要输入账号和密码 ，这也是 https 协议 的麻烦之处。</p><p>而使用 SSH 协议 克隆需要在克隆之前先配置和添加好 SSH key，因此， 如果用户想要使用 SSH url 克隆的话，必须是这个仓库的拥有者 。</p><p>1、客户端生成ssh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot;</span><br><span class="line">#SHA256:4fVSSBu8wbB39xRT9&#x2F;PdBjaK+K7mXNC3XBXmAaz1ecQ x@qq.com</span><br></pre></td></tr></table></figure><p>2、客户端查看生成的key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>3、在服务端仓库管理中配置客户端的公钥</p><p>4、客户端验证key的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gitee.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git全局配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty工作原理</title>
      <link href="2020/07/16/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/10%E3%80%81netty%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>2020/07/16/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/10%E3%80%81netty%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ul><li>Netty抽象出两组线程池 BossGroup 专门负责接收客户端的连接, WorkerGroup 专门负责网络的读写</li><li>BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup</li><li>NioEventLoopGroup 相当于一个事件循环组, 这个组中含有多个事件循环 ，每一个事件循环是 NioEventLoop</li><li>NioEventLoop 表示一个不断循环的执行处理任务的线程， 每个NioEventLoop 都有一个selector , 用于监听绑定在其上的socket的网络通讯</li><li>NioEventLoopGroup 可以有多个线程, 即可以含有多个NioEventLoop</li><li>每个Boss NioEventLoop 循环执行的步骤有3步</li><li>轮询accept 事件</li><li>处理accept 事件 , 与client建立连接 , 生成NioScocketChannel , 并将其注册到某个worker NIOEventLoop 上的 selector </li><li>处理任务队列的任务 ， 即 runAllTasks</li><li><ol start="7"><li>每个 Worker NIOEventLoop 循环执行的步骤</li></ol></li><li>轮询read, write 事件</li><li>处理i/o事件， 即read , write 事件，在对应NioScocketChannel 处理</li><li>处理任务队列的任务 ， 即 runAllTasks</li><li><ol start="8"><li>每个Worker NIOEventLoop  处理业务时，会使用pipeline(管道), pipeline 中包含了 channel , 即通过pipeline 可以获取到对应通道, 管道中维护了很多的 处理器</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty工作原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓冲区</title>
      <link href="2020/07/13/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/3%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA/"/>
      <url>2020/07/13/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/3%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h5 id="缓冲区（Buffer）："><a href="#缓冲区（Buffer）：" class="headerlink" title="缓冲区（Buffer）："></a>缓冲区（Buffer）：</h5><p>==缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存（底层是数组）。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存==。</p><p>理解Buffer的工作原理，需要熟悉它的三个属性：</p><h5 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h5><p>容量，即可以容纳的最大数据量；在缓冲区创建时被设定并且不能改变.设定后只能往里写capacity个byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</p><h5 id="position"><a href="#position" class="headerlink" title="position"></a>position</h5><p>==表示缓冲区的当前操作位置==，</p><p>当你写数据到Buffer中时，position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.</p><p>当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。</p><h5 id="limit："><a href="#limit：" class="headerlink" title="limit："></a>limit：</h5><p>==表示缓冲区的当前终点==，不能对缓冲区超过极限的位置进行读写操作。且极限是可以修改的<br>在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。</p><p>当切换Buffer到读模式时， limit表示你最多能读到多少数据</p><h5 id="Mark-标记"><a href="#Mark-标记" class="headerlink" title="Mark    标记"></a>Mark    标记</h5><p><img src="http://ifeve.com/wp-content/uploads/2013/06/buffers-modes.png" alt="image"></p><p>使用Buffer读写数据一般遵循以下四个步骤：<br>1、分配buffer内存 ByteBuffer.allocate(48);</p><ul><li>2、先写入数据到Buffer，buffer会记录下写了多少数据</li><li>3、调用flip()方法（切换读写模式）</li><li>4、从Buffer中读取数据</li><li>5、读取完之后清空缓冲区，调用clear()方法清空整个缓冲区。compact()方法只会清除已经读过的数据.</li></ul><p>读写数据到Buffer有两种方式：</p><p>从Channel写到Buffer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;写入数据到Channel</span><br><span class="line">int bytesRead &#x3D; inChannel.read(buf); &#x2F;&#x2F;read into buffer.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;读取数据到Channel</span><br><span class="line">int bytesWritten &#x3D; inChannel.write(buf);</span><br></pre></td></tr></table></figure><p>通过Buffer的put()和get() 方法读写到Buffer里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buf.put(127);</span><br><span class="line">byte aByte &#x3D; buf.get();</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">RandomAccessFile aFile &#x3D; new RandomAccessFile(&quot;data&#x2F;nio-data.txt&quot;, &quot;rw&quot;);</span><br><span class="line"></span><br><span class="line">FileChannel inChannel &#x3D; aFile.getChannel();</span><br><span class="line">&#x2F;&#x2F;1、分配buffer内存</span><br><span class="line">ByteBuffer buf &#x3D; ByteBuffer.allocate(48);</span><br><span class="line">&#x2F;&#x2F;2、先写入数据到Buffer，buffer会记录下写了多少数据</span><br><span class="line">int bytesRead &#x3D; inChannel.read(buf); &#x2F;&#x2F;read into buffer.</span><br><span class="line">while (bytesRead !&#x3D; -1) &#123;</span><br><span class="line">&#x2F;&#x2F;3、切换读写模式</span><br><span class="line">buf.flip(); </span><br><span class="line">while(buf.hasRemaining())&#123;</span><br><span class="line">System.out.print((char) buf.get());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;5、清空缓存区</span><br><span class="line">buf.clear(); &#x2F;&#x2F;make buffer ready for writing</span><br><span class="line">&#x2F;&#x2F;4、从Buffer中读取数据</span><br><span class="line">bytesRead &#x3D; inChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用Buffer子类一览【Java 中的基本数据类型(boolean除外)，都有一个 Buffer 类型与之相对应】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer，存储字节数据到缓冲区【最常用】</span><br><span class="line">ShortBuffer，存储字符串数据到缓冲区</span><br><span class="line">CharBuffer，存储字符数据到缓冲区</span><br><span class="line">IntBuffer，存储整数数据到缓冲区</span><br><span class="line">LongBuffer，存储长整型数据到缓冲区</span><br><span class="line">DoubleBuffer，存储小数到缓冲区</span><br><span class="line">FloatBuffer，存储小数到缓冲区</span><br><span class="line">MappedByteBuffer </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ByteBuffer &#123;</span><br><span class="line">    &#x2F;&#x2F;缓冲区创建相关api</span><br><span class="line">    public static ByteBuffer allocateDirect(int capacity)&#x2F;&#x2F;创建直接缓冲区</span><br><span class="line">    public static ByteBuffer allocate(int capacity)&#x2F;&#x2F;设置缓冲区的初始容量</span><br><span class="line">    public static ByteBuffer wrap(byte[] array)&#x2F;&#x2F;把一个数组放到缓冲区中使用</span><br><span class="line">    &#x2F;&#x2F;构造初始化位置offset和上界length的缓冲区</span><br><span class="line">    public static ByteBuffer wrap(byte[] array,int offset, int length)</span><br><span class="line">     &#x2F;&#x2F;缓存区存取相关API</span><br><span class="line">    public abstract byte get( );&#x2F;&#x2F;从当前位置position上get，get之后，position会自动+1</span><br><span class="line">    public abstract byte get (int index);&#x2F;&#x2F;从绝对位置get</span><br><span class="line">    public abstract ByteBuffer put (byte b);&#x2F;&#x2F;从当前位置上添加，put之后，position会自动+1</span><br><span class="line">    public abstract ByteBuffer put (int index, byte b);&#x2F;&#x2F;从绝对位置上put</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Buffer常用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Buffer &#123;</span><br><span class="line">    &#x2F;&#x2F;JDK1.4时，引入的api</span><br><span class="line">    public final int capacity( )&#x2F;&#x2F;返回此缓冲区的容量</span><br><span class="line">    public final int position( )&#x2F;&#x2F;返回此缓冲区的位置</span><br><span class="line">    public final Buffer position (int newPositio)&#x2F;&#x2F;设置此缓冲区的位置</span><br><span class="line">    public final int limit( )&#x2F;&#x2F;返回此缓冲区的限制</span><br><span class="line">    public final Buffer limit (int newLimit)&#x2F;&#x2F;设置此缓冲区的限制</span><br><span class="line">    public final Buffer mark( )&#x2F;&#x2F;在此缓冲区的位置设置标记，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position</span><br><span class="line">    public final Buffer reset( )&#x2F;&#x2F;将此缓冲区的位置重置为以前标记的位置，</span><br><span class="line">    public final Buffer clear( )&#x2F;&#x2F;清除此缓冲区, 即将各个标记恢复到初始状态，但是数据并没有真正擦除, 后面操作会覆盖</span><br><span class="line">    public final Buffer flip( )&#x2F;&#x2F;反转此缓冲区</span><br><span class="line">    public final Buffer rewind( )&#x2F;&#x2F;重绕此缓冲区，将position设回0</span><br><span class="line">    public final int remaining( )&#x2F;&#x2F;返回当前位置与限制之间的元素数</span><br><span class="line">    public final boolean hasRemaining( )&#x2F;&#x2F;告知在当前位置和限制之间是否有元素</span><br><span class="line">    public abstract boolean isReadOnly( );&#x2F;&#x2F;告知此缓冲区是否为只读缓冲区</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;JDK1.6时引入的api</span><br><span class="line">    public abstract boolean hasArray();&#x2F;&#x2F;告知此缓冲区是否具有可访问的底层实现数组</span><br><span class="line">    public abstract Object array();&#x2F;&#x2F;返回此缓冲区的底层实现数组</span><br><span class="line">    public abstract int arrayOffset();&#x2F;&#x2F;返回此缓冲区的底层实现数组中第一个缓冲区元素的偏移量</span><br><span class="line">    public abstract boolean isDirect();&#x2F;&#x2F;告知此缓冲区是否为直接缓冲区</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：equals()<br>当满足下列条件时，表示两个Buffer相等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有相同的类型（byte、char、int等）。</span><br><span class="line">Buffer中剩余的byte、char等的个数相等。</span><br><span class="line">Buffer中所有剩余的byte、char等都相同。</span><br></pre></td></tr></table></figure><p>ByteBuffer 支持类型化的put 和 get, put 放入的是什么数据类型，get就应该使用相应的数据类型来取出，否则可能有 BufferUnderflowException 异常。</p><p>可以将一个普通Buffer 转成只读Buffer<br>NIO 还提供了 MappedByteBuffer， 可以让文件直接在内存（堆外的内存）中进行修改， 而如何同步到文件由NIO 来完成.</p><p>NIO 还支持 通过多个Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 和 Gathering </p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓冲区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>积分系统设计</title>
      <link href="2020/07/12/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%A7%AF%E5%88%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
      <url>2020/07/12/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%A7%AF%E5%88%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<ul><li>1、设计模式要干的事情就是解耦</li><li>2、设计模式是思想，不用强记定义</li><li>3、抛开业务谈设计模式是空谈，设计模式学习最注重应用场景</li></ul><p>设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦</p><p>笼统地来讲，积分系统无外乎就两个大的功能点，一个是赚取积分，另一个是消费积分。</p><p>赚取积分功能包括积分赚取渠道，比如下订单、每日签到、评论等；还包括积分兑换规则，比如订单金额与积分的兑换比例，每日签到赠送多少积分等。</p><p>消费积分功能包括积分消费渠道，比如抵扣订单金额、兑换优惠券、积分换购、参与活动扣积分等；还包括积分兑换规则，比如多少积分可以换算成抵扣订单的多少金额，一张优惠券需要多少积分来兑换等等。</p><p>第一种划分方式是：积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护（增删改查），不划分到积分系统中，而是放到更上层的营销系统中。这样积分系统就会变得非常简单，只需要负责增加积分、减少积分、查询积分、查询积分明细等这几个工作。</p><p>第二种划分方式是：积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护，分散在各个相关业务系统中，比如订单系统、评论系统、签到系统、换购商城、优惠券系统等。还是刚刚那个下订单赚取积分的例子，在这种情况下，用户下订单成功之后，订单系统根据商品对应的积分兑换比例，计算所能兑换的积分数量，然后直接调用积分系统给用户增加积分。</p><p>第三种划分方式是：所有的功能都划分到积分系统中，包括积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护。还是同样的例子，用户下订单成功之后，订单系统直接告知积分系统订单交易成功，积分系统根据订单信息查询积分兑换规则，给用户增加积分。</p><p>我们可以反过来通过看它是否符合高内聚、低耦合特性来判断。如果一个功能的修改或添加，经常要跨团队、跨项目、跨系统才能完成，那说明模块划分的不够合理，职责不够清晰，耦合过于严重。除此之外，为了避免业务知识的耦合，让下层系统更加通用，一般来讲，我们不希望下层系统（也就是被调用的系统）包含太多上层系统（也就是调用系统）的业务信息，但是，可以接受上层系统包含下层系统的业务信息。比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息。但是，反过来，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。所以，综合考虑，我们更倾向于第一种和第二种模块划分方式。但是，不管选择这两种中的哪一种，积分系统所负责的工作是一样的，只包含积分的增、减、查询，以及积分明细的记录和查询。</p><p>为什么要分 MVC 三层开发？</p><p>分层能起到代码复用的作用分层能起到隔离变化的作用分层能起到隔离关注点的作用分层能提高代码的可测试性分层能应对系统的复杂性</p><p>BO、VO、Entity 存在的意义是什么？</p><p>从设计的角度来说，VO、BO、Entity 的设计思路并不违反 DRY 原则，为了分层清晰、减少耦合，多维护几个类的成本也并不是不能接受的。但是，如果你真的有代码洁癖，对于代码重复的问题，我们可以通过继承或者组合来解决</p><p>数据对象之间的转化？也可以使用 Java 中提供了数据对象转化工具，比如 BeanUtils、Dozer 等，可以大大简化繁琐的对象转化工作。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 积分系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="2020/07/10/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/10/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>适配器模式：==一个类和一个不兼容该类的接口不能一起工作，但通过类的继承或组合，让其兼容==。</p><p>示例：ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口</p><p>两种实现方式，<br>类适配器：使用继承关系来实现，对象适配器使用组合关系来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 类适配器: 基于继承</span><br><span class="line">public interface ITarget &#123;</span><br><span class="line">  void f1();</span><br><span class="line">  void f2();</span><br><span class="line">  void fc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptee &#123;</span><br><span class="line">  public void fa() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  public void fb() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  public void fc() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptor extends Adaptee implements ITarget &#123;</span><br><span class="line">  public void f1() &#123;</span><br><span class="line">    super.fa();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f2() &#123;</span><br><span class="line">    &#x2F;&#x2F;...重新实现f2()...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对象适配器：使用继承关系来实现，对象适配器使用组合关系来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象适配器：基于组合</span><br><span class="line">public interface ITarget &#123;</span><br><span class="line">  void f1();</span><br><span class="line">  void f2();</span><br><span class="line">  void fc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptee &#123;</span><br><span class="line">  public void fa() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  public void fb() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">  public void fc() &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptor implements ITarget &#123;</span><br><span class="line">  private Adaptee adaptee;</span><br><span class="line">  </span><br><span class="line">  public Adaptor(Adaptee adaptee) &#123;</span><br><span class="line">    this.adaptee &#x3D; adaptee;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f1() &#123;</span><br><span class="line">    adaptee.fa(); &#x2F;&#x2F;委托给Adaptee</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void f2() &#123;</span><br><span class="line">    &#x2F;&#x2F;...重新实现f2()...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void fc() &#123;</span><br><span class="line">    adaptee.fc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有两个，<br>Adaptee 接口的个数，<br>以及 Adaptee 和 ITarget 的契合程度。</p><ul><li>如果 Adaptee 接口并不多，那两种实现方式都可以。</li><li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。</li><li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活</li></ul><p>应用场景是“接口不兼容”</p><p>1、封装有缺陷的接口设计<br>2、统一多个类的接口设计<br>3、替换依赖的外部系统<br>4、 兼容老版本接口<br>5、适配不同格式的数据</p><p>配器模式在 Java 日志中的应用</p><p>总结：</p><ul><li>代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</li><li>桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</li><li>装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</li><li>适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 适配器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥梁模式</title>
      <link href="2020/07/10/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6%E3%80%81%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/10/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6%E3%80%81%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>GoF 的《设计模式》一书中对桥接模式的定义：将抽象和实现解耦，让它们可以独立变化</p><p>JDBC 驱动是桥接模式的经典应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&#x2F;&#x2F;加载及注册JDBC驱动程序</span><br><span class="line">String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;sample_db?user&#x3D;root&amp;password&#x3D;your_password&quot;;</span><br><span class="line">Connection con &#x3D; DriverManager.getConnection(url);</span><br><span class="line">Statement stmt &#x3D; con.createStatement()；</span><br><span class="line">String query &#x3D; &quot;select * from test&quot;;</span><br><span class="line">ResultSet rs&#x3D;stmt.executeQuery(query);</span><br><span class="line">while(rs.next()) &#123;</span><br><span class="line">  rs.getString(1);</span><br><span class="line">  rs.getInt(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想要把 MySQL 数据库换成 Oracle 数据库，只需要把第一行代码中的 com.mysql.jdbc.Driver 换成 oracle.jdbc.driver.OracleDriver 就可以了。如此优雅的数据库切换是如何实现？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.mysql.jdbc;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123;</span><br><span class="line">  static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      java.sql.DriverManager.registerDriver(new Driver());</span><br><span class="line">    &#125; catch (SQLException E) &#123;</span><br><span class="line">      throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Construct a new driver and register it with DriverManager</span><br><span class="line">   * @throws SQLException if a database error occurs.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public Driver() throws SQLException &#123;</span><br><span class="line">    &#x2F;&#x2F; Required for Class.forName().newInstance()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 Class.forName(“com.mysql.jdbc.Driver”) 这条语句的时候，实际上是做了两件事情。</p><ul><li>第一件事情是要求 JVM 查找并加载指定的 Driver 类，</li><li>第二件事情是执行该类的静态代码，也就是将 MySQL Driver 注册到 DriverManager 类中。</li></ul><p>把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后，后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class DriverManager &#123;</span><br><span class="line">  private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers &#x3D; new CopyOnWriteArrayList&lt;DriverInfo&gt;();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  static &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(&quot;JDBC DriverManager initialized&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line"></span><br><span class="line">  public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException &#123;</span><br><span class="line">    if (driver !&#x3D; null) &#123;</span><br><span class="line">      registeredDrivers.addIfAbsent(new DriverInfo(driver));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Connection getConnection(String url, String user, String password) throws SQLException &#123;</span><br><span class="line">    java.util.Properties info &#x3D; new java.util.Properties();</span><br><span class="line">    if (user !&#x3D; null) &#123;</span><br><span class="line">      info.put(&quot;user&quot;, user);</span><br><span class="line">    &#125;</span><br><span class="line">    if (password !&#x3D; null) &#123;</span><br><span class="line">      info.put(&quot;password&quot;, password);</span><br><span class="line">    &#125;</span><br><span class="line">    return (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>弄懂定义中“抽象”和“实现”两个概念，就是理解桥接模式的关键</p><h5 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h5><p>JDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。</p><p>====JDBC== 和 Driver 独立开发，通过对象之间的组合关系，组装桥接在一起==。JDBC 的所有逻辑操作，最终都委托给 Driver 来执行。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桥梁模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中介者模式</title>
      <link href="2020/07/10/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/10/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>采购、销售、库存这三个模块都有自己的行为，并且与其他模块之间的行为产生关联。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Purchase &#123;</span><br><span class="line">    &#x2F;&#x2F;采购IBM电脑</span><br><span class="line">    public void buyIBMcomputer(int number) &#123;</span><br><span class="line">        &#x2F;&#x2F;访问库存 </span><br><span class="line">        Stock stock &#x3D; new Stock();</span><br><span class="line">        &#x2F;&#x2F;访问销售 </span><br><span class="line">        Sale sale &#x3D; new Sale();</span><br><span class="line">        &#x2F;&#x2F;电脑的销售情况</span><br><span class="line">        int saleStatus &#x3D; sale.getSaleStatus();</span><br><span class="line">        if (saleStatus &gt; 80) &#123;</span><br><span class="line">            &#x2F;&#x2F;销售情况良好</span><br><span class="line">            System.out.println(&quot;采购IBM电脑:&quot; + number + &quot;台&quot;);</span><br><span class="line">            stock.increase(number);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;销售情况不好</span><br><span class="line">            int buyNumber &#x3D; number &#x2F; 2;</span><br><span class="line">            &#x2F;&#x2F;折半采购 </span><br><span class="line">            System.out.println(&quot;采购IBM电脑：&quot; + buyNumber + &quot;台&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;不再采购IBM电脑</span><br><span class="line">    public void refuseBuyIBM() &#123;</span><br><span class="line">        System.out.println(&quot;不再采购IBM电脑&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Stock &#123;</span><br><span class="line">    &#x2F;&#x2F;刚开始有100台电脑 private static int COMPUTER_NUMBER &#x3D;100; </span><br><span class="line">    &#x2F;&#x2F;库存增加 </span><br><span class="line">    public void increase(int number) &#123;</span><br><span class="line">        COMPUTER_NUMBER &#x3D; COMPUTER_NUMBER + number;</span><br><span class="line">        System.out.println(&quot;库存数量为：&quot; + COMPUTER_NUMBER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;库存降低</span><br><span class="line">    public void decrease(int number) &#123;</span><br><span class="line">        COMPUTER_NUMBER &#x3D; COMPUTER_NUMBER - number;</span><br><span class="line">        System.out.println(&quot;库存数量为：&quot; + COMPUTER_NUMBER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获得库存数量 </span><br><span class="line">    public int getStockNumber() &#123;</span><br><span class="line">        return COMPUTER_NUMBER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;存货压力大了，就要通知采购人员不要采购，销售人员要尽快销售 </span><br><span class="line">    public void clearStock() &#123;</span><br><span class="line">        Purchase purchase &#x3D; new Purchase();</span><br><span class="line">        Sale sale &#x3D; new Sale();</span><br><span class="line">        System.out.println(&quot;清理存货数量为：&quot; + COMPUTER_NUMBER);</span><br><span class="line">    &#x2F;&#x2F;要求折价销售 </span><br><span class="line">        sale.offSale();</span><br><span class="line">    &#x2F;&#x2F;要求采购人员不要采购 </span><br><span class="line">        purchase.refuseBuyIBM();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Sale &#123;</span><br><span class="line">    &#x2F;&#x2F;销售IBM电脑 </span><br><span class="line">    public void sellIBMComputer(int number) &#123;</span><br><span class="line">        &#x2F;&#x2F;访问库存 </span><br><span class="line">        Stock stock &#x3D; new Stock();</span><br><span class="line">        &#x2F;&#x2F;访问采购 </span><br><span class="line">        Purchase purchase &#x3D; new Purchase();</span><br><span class="line">        if (stock.getStockNumber() &lt; number) &#123;</span><br><span class="line">            &#x2F;&#x2F;库存数量不够销售</span><br><span class="line">            purchase.buyIBMcomputer(number);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;销售IBM电脑&quot; + number + &quot;台&quot;);</span><br><span class="line">        stock.decrease(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;反馈销售情况，0～100之间变化，0代表根本就没人卖，100代表非常畅销，出一个卖一个 </span><br><span class="line">    public int getSaleStatus() &#123;</span><br><span class="line">        Random rand &#x3D; new Random(System.currentTimeMillis());</span><br><span class="line">        int saleStatus &#x3D; rand.nextInt(100);</span><br><span class="line">        System.out.println(&quot;IBM电脑的销售情况为：&quot; + saleStatus);</span><br><span class="line">        return saleStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;折价处理 </span><br><span class="line">    public void offSale() &#123;</span><br><span class="line">        &#x2F;&#x2F;库房有多少卖多少 Stock stock &#x3D; new Stock(); System.out.println(&quot;折价销售IBM电脑&quot;+stock.getStockNumber()+&quot;台&quot;); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个不同类型的参与者完成了各自的活动。你有没有发现这 三个类是彼此关联的？每个类都与其他两个类产生了关联关系。迪米特法则认为“每个类只 和朋友类交流”，这个朋友类并非越多越好，朋友类越多，耦合性越大，要想修改一个就得 修改一片。</p><p>建立了两个抽象类AbstractMediator和AbstractColeague，每个对象只是与中介者Mediator 之间产生依赖，与其他对象之间没有直接关系，AbstractMediator的作用是实现中介者的抽象 定义，定义了一个抽象方法execute</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractMediator &#123;</span><br><span class="line">    protected Purchase purchase;</span><br><span class="line">    protected Sale sale;</span><br><span class="line">    protected Stock stock;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造函数 </span><br><span class="line">    public AbstractMediator() &#123;</span><br><span class="line">        purchase &#x3D; new Purchase(this);</span><br><span class="line">        sale &#x3D; new Sale(this);</span><br><span class="line">        stock &#x3D; new Stock(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;中介者最重要的方法叫做事件方法，处理多个对象之间的关系 </span><br><span class="line">    public abstract void execute(String str, Object... objects);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看具体的中介者，我们可以根据业务的要求产生多个中介者，并划分各中介者的职 责。具体中介者如代码清单14-6所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Mediator extends AbstractMediator &#123;</span><br><span class="line">    &#x2F;&#x2F;中介者最重要的方法 </span><br><span class="line">    public void execute(String str, Object... objects) &#123;</span><br><span class="line">        if (str.equals(&quot;purchase.buy&quot;)) &#123;</span><br><span class="line">&#x2F;&#x2F;采购电脑 </span><br><span class="line">            this.buyComputer((Integer) objects[0]);</span><br><span class="line">        &#125; else if (str.equals(&quot;sale.sell&quot;)) &#123;</span><br><span class="line">&#x2F;&#x2F;销售电脑 </span><br><span class="line">            this.sellComputer((Integer) objects[0]);</span><br><span class="line">        &#125; else if (str.equals(&quot;sale.offsell&quot;)) &#123;</span><br><span class="line">&#x2F;&#x2F;折价销售</span><br><span class="line">            this.offSell();</span><br><span class="line">        &#125; else if (str.equals(&quot;stock.clear&quot;)) &#123;</span><br><span class="line">&#x2F;&#x2F;清仓处理 </span><br><span class="line">            this.clearStock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;采购电脑 </span><br><span class="line">    private void buyComputer(int number) &#123;</span><br><span class="line">        int saleStatus &#x3D; super.sale.getSaleStatus();</span><br><span class="line">        if (saleStatus &gt; 80) &#123;</span><br><span class="line">&#x2F;&#x2F;销售情况良好</span><br><span class="line">            System.out.println(&quot;采购IBM电脑:&quot; + number + &quot;台&quot;);</span><br><span class="line">            super.stock.increase(number);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;销售情况不好 </span><br><span class="line">            int buyNumber &#x3D; number &#x2F; 2;</span><br><span class="line">&#x2F;&#x2F;折半采购 </span><br><span class="line">            System.out.println(&quot;采购IBM电脑：&quot; + buyNumber + &quot;台&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;销售电脑 </span><br><span class="line">    private void sellComputer(int number) &#123;</span><br><span class="line">        if (super.stock.getStockNumber() &lt; number) &#123;</span><br><span class="line">&#x2F;&#x2F;库存数量不够销售 </span><br><span class="line">            super.purchase.buyIBMcomputer(number);</span><br><span class="line">        &#125;</span><br><span class="line">        super.stock.decrease(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;折价销售电脑 </span><br><span class="line">    private void offSell() &#123;</span><br><span class="line">        System.out.println(&quot;折价销售IBM电脑&quot; + stock.getStockNumber() + &quot;台&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;清仓处理 </span><br><span class="line">    private void clearStock() &#123;</span><br><span class="line">&#x2F;&#x2F;要求清仓销售</span><br><span class="line">        super.sale.offSale();</span><br><span class="line">&#x2F;&#x2F;要求采购人员不要采购 </span><br><span class="line">        super.purchase.refuseBuyIBM();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中介者Mediator定义了多个private方法，其目的是处理各个对象之间的依赖关系，就是 说把原有一个对象要依赖多个对象的情况移到中介者的private方法中实现。在实际项目中， 一般的做法是中介者按照职责进行划分，每个中介者处理一个或多个类似的关联请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractColleague &#123; </span><br><span class="line">    protected AbstractMediator mediator; </span><br><span class="line">    public AbstractColleague(AbstractMediator _mediator)&#123; </span><br><span class="line">        this.mediator &#x3D; _mediator; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Purchase extends AbstractColleague&#123; </span><br><span class="line">public Purchase(AbstractMediator _mediator)&#123; super(_mediator); &#125;</span><br><span class="line">&#x2F;&#x2F;采购IBM电脑 </span><br><span class="line">public void buyIBMcomputer(int number)&#123; super.mediator.execute(&quot;purchase.buy&quot;, number); &#125;</span><br><span class="line">&#x2F;&#x2F;不再采购IBM电脑 </span><br><span class="line">public void refuseBuyIBM()&#123; System.out.println(&quot;不再采购IBM电脑&quot;); &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述Purchase类简化了很多，也清晰了很多，处理自己的职责，与外界有关系的事件处 理则交给了中介者来完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Stock extends AbstractColleague &#123; public Stock(AbstractMediator _mediator)&#123; super(_mediator); &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 刚开始有100台电脑 </span><br><span class="line"> private static int COMPUTER_NUMBER &#x3D;100; </span><br><span class="line"> &#x2F;&#x2F; 库存增加 </span><br><span class="line"> public void increase(int number)&#123; COMPUTER_NUMBER &#x3D; COMPUTER_NUMBER + number; System.out.println(&quot;库存数量为：&quot;+COMPUTER_NUMBER); &#125;</span><br><span class="line"> &#x2F;&#x2F; 库存降低 </span><br><span class="line"> public void decrease(int number)&#123; COMPUTER_NUMBER &#x3D; COMPUTER_NUMBER - number; System.out.println(&quot;库存数量为：&quot;+COMPUTER_NUMBER); &#125;</span><br><span class="line"> &#x2F;&#x2F; 获得库存数量 </span><br><span class="line"> public int getStockNumber()&#123; return COMPUTER_NUMBER; &#125;</span><br><span class="line"> &#x2F;&#x2F; 存货压力大了，就要通知采购人员不要采购，销售人员要尽快销售 </span><br><span class="line"> public void clearStock()&#123; System.out.println(&quot;清理存货数量为：&quot;+COMPUTER_NUMBER); super.mediator.execute(&quot;stock.clear&quot;); &#125; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Sale extends AbstractColleague &#123; public Sale(AbstractMediator _mediator)&#123; super(_mediator); &#125;</span><br><span class="line"> &#x2F;&#x2F; 销售IBM电脑 </span><br><span class="line"> public void sellIBMComputer(int number)&#123; super.mediator.execute(&quot;sale.sell&quot;, number); System.out.println(&quot;销售IBM电脑&quot;+number+&quot;台&quot;); &#125;</span><br><span class="line"> &#x2F;&#x2F; 反馈销售情况，0～100变化，0代表根本就没人买，100代表非常畅销，出一个卖一个 </span><br><span class="line"> public int getSaleStatus()&#123; Random rand &#x3D; new Random(System.currentTimeMillis()); int saleStatus &#x3D; rand.nextInt(100); System.out.println(&quot;IBM电脑的销售情况为：&quot;+saleStatus); return saleStatus; &#125;</span><br><span class="line"> &#x2F;&#x2F; 折价处理 </span><br><span class="line"> public void offSale()&#123; super.mediator.execute(&quot;sale.offsell&quot;); &#125; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123; public static void main(String[] args) &#123; AbstractMediator mediator &#x3D; new Mediator(); </span><br><span class="line"> &#x2F;&#x2F; 采购人员采购电脑 </span><br><span class="line"> System.out.println(&quot;------采购人员采购电脑--------&quot;);</span><br><span class="line"> Purchase purchase &#x3D; new Purchase(mediator); purchase.buyIBMcomputer(100); </span><br><span class="line"> &#x2F;&#x2F; 销售人员销售电脑 System.out.println(&quot;\n------销售人员销售电脑--------&quot;);</span><br><span class="line"> Sale sale &#x3D; new Sale(mediator); sale.sellIBMComputer(1); </span><br><span class="line"> &#x2F;&#x2F; 库房管理人员管理库存</span><br><span class="line"> System.out.println(&quot;\n------库房管理人员清库处理--------&quot;);</span><br><span class="line"> Stock stock &#x3D; new Stock(mediator); stock.clearStock(); &#125; &#125;</span><br></pre></td></tr></table></figure><p>在场景类中增加了一个中介者，然后分别传递到三个同事类中，三个类都具有相同的特 性：只负责处理自己的活动（行为），与自己无关的活动就丢给中介者处理，程序运行的结 果是相同的。从项目设计上来看，加入了中介者，设计结构清晰了很多，而且类间的耦合性 大大减少，代码质量也有了很大的提升。 在多个对象依赖的情况下，通过加入中介者角色，取消了多个对象的关联或依赖关系， 减少了对象的耦合性</p><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>前端 控制器(Front Controller)，它的作用就是把M(Model，业务逻辑)和V（View，视图）隔离开， 协调M和V协同工作，把M运行的结果和V代表的视图融合成一个前端可以展示的页面，减少 M和V的依赖关系。MVC框架已经成为一个非常流行、成熟的开发框架，这也是中介者模式 的优点的一个体现。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中介者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式应用：如何实现一个DI容器</title>
      <link href="2020/07/10/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.3%E3%80%81%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AADI%E5%AE%B9%E5%99%A8/"/>
      <url>2020/07/10/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.3%E3%80%81%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AADI%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。还包括配置的解析、对象生命周期的管理</p><p>一个简单的 DI 容器的核心功能一般有三个：</p><ul><li>配置解析</li><li>对象创建</li><li>对象生命周期管理。</li><li></li></ul><ol><li>最小原型设计</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">配置文件beans.xml</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;rateLimiter&quot; class&#x3D;&quot;com.xzg.RateLimiter&quot;&gt;</span><br><span class="line">      &lt;constructor-arg ref&#x3D;&quot;redisCounter&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line"> </span><br><span class="line">   &lt;bean id&#x3D;&quot;redisCounter&quot; class&#x3D;&quot;com.xzg.redisCounter&quot; scope&#x3D;&quot;singleton&quot; lazy-init&#x3D;&quot;true&quot;&gt;</span><br><span class="line">     &lt;constructor-arg type&#x3D;&quot;String&quot; value&#x3D;&quot;127.0.0.1&quot;&gt;</span><br><span class="line">     &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;1234&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;bean</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(</span><br><span class="line">            &quot;beans.xml&quot;);</span><br><span class="line">    RateLimiter rateLimiter &#x3D; (RateLimiter) applicationContext.getBean(&quot;rateLimiter&quot;);</span><br><span class="line">    rateLimiter.test();</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface ApplicationContext &#123;</span><br><span class="line">  Object getBean(String beanId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ClassPathXmlApplicationContext implements ApplicationContext &#123;</span><br><span class="line">  private BeansFactory beansFactory;</span><br><span class="line">  private BeanConfigParser beanConfigParser;</span><br><span class="line"></span><br><span class="line">  public ClassPathXmlApplicationContext(String configLocation) &#123;</span><br><span class="line">    this.beansFactory &#x3D; new BeansFactory();</span><br><span class="line">    this.beanConfigParser &#x3D; new XmlBeanConfigParser();</span><br><span class="line">    loadBeanDefinitions(configLocation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void loadBeanDefinitions(String configLocation) &#123;</span><br><span class="line">    InputStream in &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      in &#x3D; this.getClass().getResourceAsStream(&quot;&#x2F;&quot; + configLocation);</span><br><span class="line">      if (in &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Can not find config file: &quot; + configLocation);</span><br><span class="line">      &#125;</span><br><span class="line">      List&lt;BeanDefinition&gt; beanDefinitions &#x3D; beanConfigParser.parse(in);</span><br><span class="line">      beansFactory.addBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (in !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          in.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">          &#x2F;&#x2F; TODO: log error</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Object getBean(String beanId) &#123;</span><br><span class="line">    return beansFactory.getBean(beanId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>1、从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式</p></li><li><p>2、BeanDefinition存储bean的类名、scope、属性、构造函数参数列表、依赖的bean、是否是单例类、是否是懒加载等信息，后面拿到这个BeanDefinition后，可以根据里面的类名、构造函数、构造函数参数，使用反射进行对象创建。</p></li><li><p>3、BeansFactory 根据 BeanDefinition 来创建对象。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface BeanConfigParser &#123;</span><br><span class="line">  List&lt;BeanDefinition&gt; parse(InputStream inputStream);</span><br><span class="line">  List&lt;BeanDefinition&gt; parse(String configContent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class XmlBeanConfigParser implements BeanConfigParser &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public List&lt;BeanDefinition&gt; parse(InputStream inputStream) &#123;</span><br><span class="line">    String content &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; TODO:...</span><br><span class="line">    return parse(content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public List&lt;BeanDefinition&gt; parse(String configContent) &#123;</span><br><span class="line">    List&lt;BeanDefinition&gt; beanDefinitions &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; TODO:...</span><br><span class="line">    return beanDefinitions;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BeanDefinition &#123;</span><br><span class="line">  private String id;</span><br><span class="line">  private String className;</span><br><span class="line">  private List&lt;ConstructorArg&gt; constructorArgs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  private Scope scope &#x3D; Scope.SINGLETON;</span><br><span class="line">  private boolean lazyInit &#x3D; false;</span><br><span class="line">  &#x2F;&#x2F; 省略必要的getter&#x2F;setter&#x2F;constructors</span><br><span class="line"> </span><br><span class="line">  public boolean isSingleton() &#123;</span><br><span class="line">    return scope.equals(Scope.SINGLETON);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public static enum Scope &#123;</span><br><span class="line">    SINGLETON,</span><br><span class="line">    PROTOTYPE</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static class ConstructorArg &#123;</span><br><span class="line">    private boolean isRef;</span><br><span class="line">    private Class type;</span><br><span class="line">    private Object arg;</span><br><span class="line">    &#x2F;&#x2F; 省略必要的getter&#x2F;setter&#x2F;constructors</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class BeansFactory &#123;</span><br><span class="line">  private ConcurrentHashMap&lt;String, Object&gt; singletonObjects &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  private ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void addBeanDefinitions(List&lt;BeanDefinition&gt; beanDefinitionList) &#123;</span><br><span class="line">    for (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class="line">      this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class="line">      if (beanDefinition.isLazyInit() &#x3D;&#x3D; false &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">        createBean(beanDefinition);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Object getBean(String beanId) &#123;</span><br><span class="line">    BeanDefinition beanDefinition &#x3D; beanDefinitions.get(beanId);</span><br><span class="line">    if (beanDefinition &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + beanId);</span><br><span class="line">    &#125;</span><br><span class="line">    return createBean(beanDefinition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @VisibleForTesting</span><br><span class="line">  protected Object createBean(BeanDefinition beanDefinition) &#123;</span><br><span class="line">    if (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;</span><br><span class="line">      return singletonObjects.get(beanDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object bean &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      Class beanClass &#x3D; Class.forName(beanDefinition.getClassName());</span><br><span class="line">      List&lt;BeanDefinition.ConstructorArg&gt; args &#x3D; beanDefinition.getConstructorArgs();</span><br><span class="line">      if (args.isEmpty()) &#123;</span><br><span class="line">        bean &#x3D; beanClass.newInstance();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        Class[] argClasses &#x3D; new Class[args.size()];</span><br><span class="line">        Object[] argObjects &#x3D; new Object[args.size()];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; args.size(); ++i) &#123;</span><br><span class="line">          BeanDefinition.ConstructorArg arg &#x3D; args.get(i);</span><br><span class="line">          if (!arg.getIsRef()) &#123;</span><br><span class="line">            argClasses[i] &#x3D; arg.getType();</span><br><span class="line">            argObjects[i] &#x3D; arg.getArg();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            BeanDefinition refBeanDefinition &#x3D; beanDefinitions.get(arg.getArg());</span><br><span class="line">            if (refBeanDefinition &#x3D;&#x3D; null) &#123;</span><br><span class="line">              throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + arg.getArg());</span><br><span class="line">            &#125;</span><br><span class="line">            argClasses[i] &#x3D; Class.forName(refBeanDefinition.getClassName());</span><br><span class="line">            argObjects[i] &#x3D; createBean(refBeanDefinition);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bean &#x3D; beanClass.getConstructor(argClasses).newInstance(argObjects);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (ClassNotFoundException | IllegalAccessException</span><br><span class="line">            | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">      throw new BeanCreationFailureException(&quot;&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (bean !&#x3D; null &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);</span><br><span class="line">      return singletonObjects.get(beanDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    return bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeansFactory 类中的 createBean() 函数是一个递归函数。当构造函数的参数是 ref 类型时，会递归地创建 ref 属性指向的对象。如果我们在配置文件中错误地配置了对象之间的依赖关系，导致存在循环依赖，那 BeansFactory 的 createBean() 函数是否会出现堆栈溢出？又该如何解决这个问题呢？</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工厂模式应用：如何实现一个DI容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问者模式</title>
      <link href="2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19%E3%80%81%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19%E3%80%81%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>23 种经典设计模式中最难理解的几个之一。因为它难理解、难实现，应用它会导致代码的可读性、可维护性变差，所以，访问者模式在实际的软件开发中很少被用到，在没有特别必要的情况下，建议你不要使用访问者模式。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 访问者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4%E3%80%81%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4%E3%80%81%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>如果对象的创建成本比较大，（如对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取），而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式</p><p>考虑一下广告信这个模块是怎么开发的。那既然是广告信，肯定需要一个 模板，然后再从数据库中把客户的信息一个一个地取出，放到模板中生成一份完整的邮件， 然后扔给发送机进行发送处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class AdvTemplate &#123; </span><br><span class="line">&#x2F;&#x2F;广告信名称 </span><br><span class="line">private String advSubject &#x3D;&quot;XX银行国庆信用卡抽奖活动&quot;; </span><br><span class="line">&#x2F;&#x2F;广告信内容 </span><br><span class="line">private String advContext &#x3D; &quot;国庆抽奖活动通知：只要刷卡就送你一百万！...&quot;; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;get set方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Mail &#123; </span><br><span class="line">&#x2F;&#x2F;收件人 </span><br><span class="line">private String receiver; </span><br><span class="line">&#x2F;&#x2F;邮件名称 </span><br><span class="line">private String subject; </span><br><span class="line">&#x2F;&#x2F;称谓 </span><br><span class="line">private String appellation; </span><br><span class="line">&#x2F;&#x2F;邮件内容 </span><br><span class="line">private String contxt; </span><br><span class="line">&#x2F;&#x2F;邮件的尾部，一般都是加上&quot;XXX版权所有&quot;等信息 </span><br><span class="line">private String tail; </span><br><span class="line">&#x2F;&#x2F;构造函数</span><br><span class="line">public Mail(AdvTemplate advTemplate)&#123; </span><br><span class="line">this.contxt &#x3D; advTemplate.getAdvContext(); </span><br><span class="line">this.subject &#x3D; advTemplate.getAdvSubject(); </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; get set方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    &#x2F;&#x2F;发送账单的数量，这个值是从数据库中获得 </span><br><span class="line">    private static int MAX_COUNT &#x3D; 6;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      &#x2F;&#x2F;模拟发送邮件 int i&#x3D;0; </span><br><span class="line">      &#x2F;&#x2F;把模板定义出来，这个是从数据库中获得 </span><br><span class="line">        Mail mail &#x3D; new Mail(new AdvTemplate());</span><br><span class="line">        mail.setTail(&quot;XX银行版权所有&quot;);</span><br><span class="line">        while (i &lt; MAX_COUNT) &#123;</span><br><span class="line">           &#x2F;&#x2F;以下是每封邮件不同的地方 </span><br><span class="line">            mail.setAppellation(i+ &quot; 先生（女士）&quot;);</span><br><span class="line">            mail.setReceiver(&quot;邮箱地址&quot;+i + &quot;@&quot; + &quot;xxx.com&quot;);</span><br><span class="line">            &#x2F;&#x2F;然后发送邮件 </span><br><span class="line">            sendMail(mail);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送邮件 </span><br><span class="line">    public static void sendMail(Mail mail) &#123;</span><br><span class="line">        System.out.println(&quot;标题：&quot; + mail.getSubject() + &quot;\t收件人： &quot; + mail.getReceiver() + &quot;\t...发送成功！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个 线程在运行，也就是你发送的是单线程的，那按照一封邮件发出去需要0.02秒（够小了，你 还要到数据库中取数据呢），600万封邮件需要33个小时，也就是一个整天都发送不完。</p><p>把sendMail修改为多线程，但是只把sendMail修改为多线程还是有问题的呀，产 生第一封邮件对象，放到线程1中运行，还没有发送出去；线程2也启动了，直接就把邮件对 象mail的收件人地址和称谓修改掉了，线程不安全了。说到这里，你会说这有N多种解决办 法，其中一种是使用一种新型模式来解决这个问题：==通过对象的复制功能来解决这个问题==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Mail implements Cloneable&#123; </span><br><span class="line">&#x2F;&#x2F;收件人 </span><br><span class="line">private String receiver; </span><br><span class="line">&#x2F;&#x2F;邮件名称 </span><br><span class="line">private String subject; </span><br><span class="line">&#x2F;&#x2F;称谓 </span><br><span class="line">private String appellation; </span><br><span class="line">&#x2F;&#x2F;邮件内容 </span><br><span class="line">private String contxt; </span><br><span class="line">&#x2F;&#x2F;邮件的尾部，一般都是加上&quot;XXX版权所有&quot;等信息 </span><br><span class="line">private String tail; </span><br><span class="line">&#x2F;&#x2F;构造函数</span><br><span class="line">public Mail(AdvTemplate advTemplate)&#123; </span><br><span class="line">this.contxt &#x3D; advTemplate.getAdvContext(); </span><br><span class="line">this.subject &#x3D; advTemplate.getAdvSubject(); </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; get set方法</span><br><span class="line">@Override</span><br><span class="line">    public Mail clone() &#123;</span><br><span class="line">        Mail mail &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            mail &#x3D; (Mail) super.clone();</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block e.printStackTrace(); </span><br><span class="line">        &#125;</span><br><span class="line">        return mail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">      &#x2F;&#x2F;模拟发送邮件 int i&#x3D;0; </span><br><span class="line">      &#x2F;&#x2F;把模板定义出来，这个是从数据库中获得 </span><br><span class="line">        Mail mail &#x3D; new Mail(new AdvTemplate());</span><br><span class="line">        mail.setTail(&quot;XX银行版权所有&quot;);</span><br><span class="line">        while (i &lt; MAX_COUNT) &#123;</span><br><span class="line">           &#x2F;&#x2F;以下是每封邮件不同的地方</span><br><span class="line">           Mail cloneMail &#x3D; mail.clone();</span><br><span class="line">            cloneMail.setAppellation(i+ &quot; 先生（女士）&quot;);</span><br><span class="line">            cloneMail.setReceiver(&quot;邮箱地址&quot;+i + &quot;@&quot; + &quot;xxx.com&quot;);</span><br><span class="line">            &#x2F;&#x2F;然后发送邮件 </span><br><span class="line">            sendMail(cloneMail);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果不变，一样完成了电子广告信的发送功能，而且sendMail即使是多线程也没有 关系。注意，看Client类中的粗体字mail.clone()这个方法，把对象复制一份，产生一个新的 对象，和原有对象一样，然后再修改细节的数据，如设置称谓、设置收件人地址等。这种不 通过new关键字来产生一个对象，而是通过对象复制来实现的模式就叫做原型模式。</p><h5 id="原型模式的使用场景"><a href="#原型模式的使用场景" class="headerlink" title="原型模式的使用场景"></a>原型模式的使用场景</h5><ul><li>资源优化场景<br>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。</li><li>性能和安全要求的场景 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li></ul><p>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的 方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与Java融为一体，</p><p>==注意：==</p><p>一个实现了Cloneable并重写了clone方法的类A，有一个无参构造或有参构造B，通过 new关键字产生了一个对象S，再然后通过S.clone()方式产生了一个新的对象T，那么在对象 拷贝时构造函数B是不会被执行的。</p><ul><li>原理：<br>Object类的 clone方法的原理是从内存中（具体地说就是堆内存）以二进制流的方式进行拷贝，重新分配 一个内存块，那构造函数没有被执行也是非常正常的了</li></ul><p>注意 要使用clone方法，类的成员变量上不要增加final关键字。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。比如，你有没有考虑过这样几个问题：</p><ul><li>直接使用构造函数或者配合 set 方法就能创建对象，为什么还需要建造者模式来创建呢？</li><li>建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？</li></ul><p>工厂模式根据不同的参数来决定创建哪种类型的对象<br>建造者模式是用来创建一种类型的复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</p><p>示例：</p><p>我们需要定义一个资源池配置类 ResourcePoolConfig。他有name（必须）,maxTotal、maxIdle、minIdle等属性。</p><p>工厂模式的解决的问题是根据不同的参数，创建不同的池配置如：线程池、连接池、对象池</p><p>创建一个连接池对象，将它相关属性以构造函数的入参，传入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ResourcePoolConfig &#123;</span><br><span class="line">  private static final int DEFAULT_MAX_TOTAL &#x3D; 8;</span><br><span class="line">  private static final int DEFAULT_MAX_IDLE &#x3D; 8;</span><br><span class="line">  private static final int DEFAULT_MIN_IDLE &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  private String name;</span><br><span class="line">  private int maxTotal &#x3D; DEFAULT_MAX_TOTAL;</span><br><span class="line">  private int maxIdle &#x3D; DEFAULT_MAX_IDLE;</span><br><span class="line">  private int minIdle &#x3D; DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">  public ResourcePoolConfig(String name, Integer maxTotal, Integer maxIdle, Integer minIdle) &#123;</span><br><span class="line">    if (StringUtils.isBlank(name)) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;name should not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line"></span><br><span class="line">    if (maxTotal !&#x3D; null) &#123;</span><br><span class="line">      if (maxTotal &lt;&#x3D; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;maxTotal should be positive.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.maxTotal &#x3D; maxTotal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (maxIdle !&#x3D; null) &#123;</span><br><span class="line">      if (maxIdle &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;maxIdle should not be negative.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.maxIdle &#x3D; maxIdle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (minIdle !&#x3D; null) &#123;</span><br><span class="line">      if (minIdle &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;minIdle should not be negative.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.minIdle &#x3D; minIdle;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...省略getter方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：可配置项逐渐增多，变成了 8 个、10 个，甚至更多的时候，构造函数的入参将变得特别臃肿。用set()代替呢。<br>将必填参数以构造函数，非必填的则是暴露set方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ResourcePoolConfig &#123;</span><br><span class="line">  private static final int DEFAULT_MAX_TOTAL &#x3D; 8;</span><br><span class="line">  private static final int DEFAULT_MAX_IDLE &#x3D; 8;</span><br><span class="line">  private static final int DEFAULT_MIN_IDLE &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  private String name;</span><br><span class="line">  private int maxTotal &#x3D; DEFAULT_MAX_TOTAL;</span><br><span class="line">  private int maxIdle &#x3D; DEFAULT_MAX_IDLE;</span><br><span class="line">  private int minIdle &#x3D; DEFAULT_MIN_IDLE;</span><br><span class="line">  </span><br><span class="line">  public ResourcePoolConfig(String name) &#123;</span><br><span class="line">    if (StringUtils.isBlank(name)) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;name should not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setMaxTotal(int maxTotal) &#123;</span><br><span class="line">    if (maxTotal &lt;&#x3D; 0) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;maxTotal should be positive.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.maxTotal &#x3D; maxTotal;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setMaxIdle(int maxIdle) &#123;</span><br><span class="line">    if (maxIdle &lt; 0) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;maxIdle should not be negative.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.maxIdle &#x3D; maxIdle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setMinIdle(int minIdle) &#123;</span><br><span class="line">    if (minIdle &lt; 0) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;minIdle should not be negative.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.minIdle &#x3D; minIdle;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...省略getter方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li><p>1、若必填参数还是很多的时候，构造函数就又会出现参数列表很长的问题，如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。</p></li><li><p>2、假设配置项之间有一定的依赖关系，依赖关系或者约束条件的校验逻辑就无处安放。比如，如果用户设置了 maxTotal、maxIdle、minIdle 其中一个，就必须显式地设置另外两个</p></li><li><p>3、如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。</p></li></ul><p>传统的构造函数和set()组合很难解决以上问题。</p><p>建造者模式，是如何解决这些问题的呢。</p><p>我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，<br>然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。<br>我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ResourcePoolConfig &#123;</span><br><span class="line">  private String name;</span><br><span class="line">  private int maxTotal;</span><br><span class="line">  private int maxIdle;</span><br><span class="line">  private int minIdle;</span><br><span class="line"></span><br><span class="line">  private ResourcePoolConfig(Builder builder) &#123;</span><br><span class="line">    this.name &#x3D; builder.name;</span><br><span class="line">    this.maxTotal &#x3D; builder.maxTotal;</span><br><span class="line">    this.maxIdle &#x3D; builder.maxIdle;</span><br><span class="line">    this.minIdle &#x3D; builder.minIdle;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...省略getter方法...</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;我们将Builder类设计成了ResourcePoolConfig的内部类。</span><br><span class="line">  &#x2F;&#x2F;我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span><br><span class="line">  public static class Builder &#123;</span><br><span class="line">    private static final int DEFAULT_MAX_TOTAL &#x3D; 8;</span><br><span class="line">    private static final int DEFAULT_MAX_IDLE &#x3D; 8;</span><br><span class="line">    private static final int DEFAULT_MIN_IDLE &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int maxTotal &#x3D; DEFAULT_MAX_TOTAL;</span><br><span class="line">    private int maxIdle &#x3D; DEFAULT_MAX_IDLE;</span><br><span class="line">    private int minIdle &#x3D; DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">    public ResourcePoolConfig build() &#123;</span><br><span class="line">      &#x2F;&#x2F; 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span><br><span class="line">      if (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (maxIdle &gt; maxTotal) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return new ResourcePoolConfig(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setName(String name) &#123;</span><br><span class="line">      if (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.name &#x3D; name;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setMaxTotal(int maxTotal) &#123;</span><br><span class="line">      if (maxTotal &lt;&#x3D; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.maxTotal &#x3D; maxTotal;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setMaxIdle(int maxIdle) &#123;</span><br><span class="line">      if (maxIdle &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.maxIdle &#x3D; maxIdle;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setMinIdle(int minIdle) &#123;</span><br><span class="line">      if (minIdle &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.minIdle &#x3D; minIdle;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span><br><span class="line">ResourcePoolConfig config &#x3D; new ResourcePoolConfig.Builder()</span><br><span class="line">        .setName(&quot;dbconnectionpool&quot;)</span><br><span class="line">        .setMaxTotal(16)</span><br><span class="line">        .setMaxIdle(10)</span><br><span class="line">        .setMinIdle(12)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建造者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器模式</title>
      <link href="2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>已经没落的模式</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迭代器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式</title>
      <link href="2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15%E3%80%81%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15%E3%80%81%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p><p>第一种实现方式如下所示。其中，Handler 是所有处理器类的抽象父类，handle() 是抽象方法。每个具体的处理器类（HandlerA、HandlerB）的 handle() 函数的代码结构类似，如果它能处理该请求，就不继续往下传递；如果不能处理，则交由后面的处理器来处理（也就是调用 successor.handle()）。HandlerChain 是处理器链，从数据结构的角度来看，它就是一个记录了链头、链尾的链表。其中，记录链尾是为了方便添加处理器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public abstract class Handler &#123;</span><br><span class="line">  protected Handler successor &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public void setSuccessor(Handler successor) &#123;</span><br><span class="line">    this.successor &#x3D; successor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public abstract void handle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerA extends Handler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void handle() &#123;</span><br><span class="line">    boolean handled &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    if (!handled &amp;&amp; successor !&#x3D; null) &#123;</span><br><span class="line">      successor.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerB extends Handler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void handle() &#123;</span><br><span class="line">    boolean handled &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    if (!handled &amp;&amp; successor !&#x3D; null) &#123;</span><br><span class="line">      successor.handle();</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerChain &#123;</span><br><span class="line">  private Handler head &#x3D; null;</span><br><span class="line">  private Handler tail &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public void addHandler(Handler handler) &#123;</span><br><span class="line">    handler.setSuccessor(null);</span><br><span class="line"></span><br><span class="line">    if (head &#x3D;&#x3D; null) &#123;</span><br><span class="line">      head &#x3D; handler;</span><br><span class="line">      tail &#x3D; handler;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tail.setSuccessor(handler);</span><br><span class="line">    tail &#x3D; handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void handle() &#123;</span><br><span class="line">    if (head !&#x3D; null) &#123;</span><br><span class="line">      head.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用举例</span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    HandlerChain chain &#x3D; new HandlerChain();</span><br><span class="line">    chain.addHandler(new HandlerA());</span><br><span class="line">    chain.addHandler(new HandlerB());</span><br><span class="line">    chain.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看第二种实现方式，代码如下所示。这种实现方式更加简单。HandlerChain 类用数组而非链表来保存所有的处理器，并且需要在 HandlerChain 的 handle() 函数中，依次调用每个处理器的 handle() 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface IHandler &#123;</span><br><span class="line">  boolean handle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerA implements IHandler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean handle() &#123;</span><br><span class="line">    boolean handled &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerB implements IHandler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean handle() &#123;</span><br><span class="line">    boolean handled &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerChain &#123;</span><br><span class="line">  private List&lt;IHandler&gt; handlers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void addHandler(IHandler handler) &#123;</span><br><span class="line">    this.handlers.add(handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void handle() &#123;</span><br><span class="line">    for (IHandler handler : handlers) &#123;</span><br><span class="line">      boolean handled &#x3D; handler.handle();</span><br><span class="line">      if (handled) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用举例</span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    HandlerChain chain &#x3D; new HandlerChain();</span><br><span class="line">    chain.addHandler(new HandlerA());</span><br><span class="line">    chain.addHandler(new HandlerB());</span><br><span class="line">    chain.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用：利用职责链模式来过滤这些敏感词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface SensitiveWordFilter &#123;</span><br><span class="line">  boolean doFilter(Content content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SexyWordFilter implements SensitiveWordFilter &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean doFilter(Content content) &#123;</span><br><span class="line">    boolean legal &#x3D; true;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return legal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; PoliticalWordFilter、AdsWordFilter类代码结构与SexyWordFilter类似</span><br><span class="line"></span><br><span class="line">public class SensitiveWordFilterChain &#123;</span><br><span class="line">  private List&lt;SensitiveWordFilter&gt; filters &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void addFilter(SensitiveWordFilter filter) &#123;</span><br><span class="line">    this.filters.add(filter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; return true if content doesn&#39;t contain sensitive words.</span><br><span class="line">  public boolean filter(Content content) &#123;</span><br><span class="line">    for (SensitiveWordFilter filter : filters) &#123;</span><br><span class="line">      if (!filter.doFilter(content)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ApplicationDemo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    SensitiveWordFilterChain filterChain &#x3D; new SensitiveWordFilterChain();</span><br><span class="line">    filterChain.addFilter(new AdsWordFilter());</span><br><span class="line">    filterChain.addFilter(new SexyWordFilter());</span><br><span class="line">    filterChain.addFilter(new PoliticalWordFilter());</span><br><span class="line"></span><br><span class="line">    boolean legal &#x3D; filterChain.filter(new Content());</span><br><span class="line">    if (!legal) &#123;</span><br><span class="line">      &#x2F;&#x2F; 不发表</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 发表</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="责任链模式在Servlet-Filter中的应用："><a href="#责任链模式在Servlet-Filter中的应用：" class="headerlink" title="责任链模式在Servlet Filter中的应用："></a>责任链模式在Servlet Filter中的应用：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class LogFilter implements Filter &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">    &#x2F;&#x2F; 在创建Filter时自动调用，</span><br><span class="line">    &#x2F;&#x2F; 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">    System.out.println(&quot;拦截客户端发送来的请求.&quot;);</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">    System.out.println(&quot;拦截发送给客户端的响应.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void destroy() &#123;</span><br><span class="line">    &#x2F;&#x2F; 在销毁Filter时自动调用</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在web.xml配置文件中如下配置：</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">  &lt;filter-name&gt;logFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">  &lt;filter-class&gt;com.xzg.cd.LogFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;logFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure><p>Servlet 只是一个规范，并不包含具体的实现，所以，Servlet 中的 FilterChain 只是一个接口定义。具体的实现类由遵从 Servlet 规范的 Web 容器来提供，比如，ApplicationFilterChain 类就是 Tomcat 提供的 FilterChain 的实现类，源码如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public final class ApplicationFilterChain implements FilterChain &#123;</span><br><span class="line">  private int pos &#x3D; 0; &#x2F;&#x2F;当前执行到了哪个filter</span><br><span class="line">  private int n; &#x2F;&#x2F;filter的个数</span><br><span class="line">  private ApplicationFilterConfig[] filters;</span><br><span class="line">  private Servlet servlet;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public void doFilter(ServletRequest request, ServletResponse response) &#123;</span><br><span class="line">    if (pos &lt; n) &#123;</span><br><span class="line">      ApplicationFilterConfig filterConfig &#x3D; filters[pos++];</span><br><span class="line">      Filter filter &#x3D; filterConfig.getFilter();</span><br><span class="line">      filter.doFilter(request, response, this);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; filter都处理完毕后，执行servlet</span><br><span class="line">      servlet.service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void addFilter(ApplicationFilterConfig filterConfig) &#123;</span><br><span class="line">    for (ApplicationFilterConfig filter:filters)</span><br><span class="line">      if (filter&#x3D;&#x3D;filterConfig)</span><br><span class="line">         return;</span><br><span class="line"></span><br><span class="line">    if (n &#x3D;&#x3D; filters.length) &#123;&#x2F;&#x2F;扩容</span><br><span class="line">      ApplicationFilterConfig[] newFilters &#x3D; new ApplicationFilterConfig[n + INCREMENT];</span><br><span class="line">      System.arraycopy(filters, 0, newFilters, 0, n);</span><br><span class="line">      filters &#x3D; newFilters;</span><br><span class="line">    &#125;</span><br><span class="line">    filters[n++] &#x3D; filterConfig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>责任链模式在springMVC拦截器中的应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class LogInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;拦截客户端发送来的请求.&quot;);</span><br><span class="line">    return true; &#x2F;&#x2F; 继续后续的处理</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;拦截发送给客户端的响应.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;这里总是被执行.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在Spring MVC配置文件中配置interceptors</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">   &lt;mvc:interceptor&gt;</span><br><span class="line">       &lt;mvc:mapping path&#x3D;&quot;&#x2F;*&quot;&#x2F;&gt;</span><br><span class="line">       &lt;bean class&#x3D;&quot;com.xzg.cd.LogInterceptor&quot; &#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;mvc:interceptor&gt;</span><br><span class="line">&lt;&#x2F;mvc:interceptors&gt;</span><br></pre></td></tr></table></figure><p>HandlerExecutionChain 类是职责链模式中的处理器链。它的实现相较于 Tomcat 中的 ApplicationFilterChain 来说，逻辑更加清晰，不需要使用递归来实现，主要是因为它将请求和响应的拦截工作，拆分到了两个函数中实现。HandlerExecutionChain 的源码如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class HandlerExecutionChain &#123;</span><br><span class="line"> private final Object handler;</span><br><span class="line"> private HandlerInterceptor[] interceptors;</span><br><span class="line"> </span><br><span class="line"> public void addInterceptor(HandlerInterceptor interceptor) &#123;</span><br><span class="line">  initInterceptorList().add(interceptor);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">  HandlerInterceptor[] interceptors &#x3D; getInterceptors();</span><br><span class="line">  if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">   for (int i &#x3D; 0; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">    HandlerInterceptor interceptor &#x3D; interceptors[i];</span><br><span class="line">    if (!interceptor.preHandle(request, response, this.handler)) &#123;</span><br><span class="line">     triggerAfterCompletion(request, response, null);</span><br><span class="line">     return false;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception &#123;</span><br><span class="line">  HandlerInterceptor[] interceptors &#x3D; getInterceptors();</span><br><span class="line">  if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">   for (int i &#x3D; interceptors.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">    HandlerInterceptor interceptor &#x3D; interceptors[i];</span><br><span class="line">    interceptor.postHandle(request, response, this.handler, mv);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)</span><br><span class="line">   throws Exception &#123;</span><br><span class="line">  HandlerInterceptor[] interceptors &#x3D; getInterceptors();</span><br><span class="line">  if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">   for (int i &#x3D; this.interceptorIndex; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">    HandlerInterceptor interceptor &#x3D; interceptors[i];</span><br><span class="line">    try &#123;</span><br><span class="line">     interceptor.afterCompletion(request, response, this.handler, ex);</span><br><span class="line">    &#125; catch (Throwable ex2) &#123;</span><br><span class="line">     logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 责任链模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14%E3%80%81%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14%E3%80%81%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class OrderService &#123;</span><br><span class="line">  public double discount(Order order) &#123;</span><br><span class="line">    double discount &#x3D; 0.0;</span><br><span class="line">    OrderType type &#x3D; order.getType();</span><br><span class="line">    if (type.equals(OrderType.NORMAL)) &#123; &#x2F;&#x2F; 普通订单</span><br><span class="line">      &#x2F;&#x2F;...省略折扣计算算法代码</span><br><span class="line">    &#125; else if (type.equals(OrderType.GROUPON)) &#123; &#x2F;&#x2F; 团购订单</span><br><span class="line">      &#x2F;&#x2F;...省略折扣计算算法代码</span><br><span class="line">    &#125; else if (type.equals(OrderType.PROMOTION)) &#123; &#x2F;&#x2F; 促销订单</span><br><span class="line">      &#x2F;&#x2F;...省略折扣计算算法代码</span><br><span class="line">    &#125;</span><br><span class="line">    return discount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何来移除掉分支判断逻辑呢？那策略模式就派上用场了。我们使用策略模式对上面的代码重构，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 策略的定义</span><br><span class="line">public interface DiscountStrategy &#123;</span><br><span class="line">  double calDiscount(Order order);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 策略的创建</span><br><span class="line">public class DiscountStrategyFactory &#123;</span><br><span class="line">  private static final Map&lt;OrderType, DiscountStrategy&gt; strategies &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    strategies.put(OrderType.NORMAL, new NormalDiscountStrategy());</span><br><span class="line">    strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy());</span><br><span class="line">    strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static DiscountStrategy getDiscountStrategy(OrderType type) &#123;</span><br><span class="line">    return strategies.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 策略的使用</span><br><span class="line">public class OrderService &#123;</span><br><span class="line">  public double discount(Order order) &#123;</span><br><span class="line">    OrderType type &#x3D; order.getType();</span><br><span class="line">    DiscountStrategy discountStrategy &#x3D; DiscountStrategyFactory.getDiscountStrategy(type);</span><br><span class="line">    return discountStrategy.calDiscount(order);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>策略模式用来解耦策略的定义、创建、使用。实际上，一个完整的策略模式就是由这三个部分组成的。</p><ul><li>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。</li><li>策略的创建由工厂类来完成，封装策略创建的细节。</li><li>策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 策略模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板方法模式</title>
      <link href="2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13%E3%80%81%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13%E3%80%81%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>模板方法模式确实非常简单，仅仅使用了Java的继承机制，定义一个抽象类，定义抽象的基本方法和具体的模板方法（==模板方法中调用基本方法，实现固定逻辑==）</p><p> 基本方法：基本方法也叫做基本操作，是由子类实现的方法，并且在模板方法被调用</p><p> 模板方法：可以有一个或几个，一般是一个具体方法，也就是一个框架，实现对基本方法的调度， 完成固定的逻辑。==为了防止恶意的操作，一般模板方法都加上final关键字，不允许被覆写。==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public abstract class AbstractClass &#123;</span><br><span class="line">  public final void templateMethod() &#123;</span><br><span class="line">    method1();</span><br><span class="line">    method2();</span><br><span class="line">  &#125;</span><br><span class="line">  protected abstract void method1();</span><br><span class="line">  protected abstract void method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteClass1 extends AbstractClass &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void method1() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void method2() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteClass2 extends AbstractClass &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void method1() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void method2() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractClass demo &#x3D; ConcreteClass1();</span><br><span class="line">demo.templateMethod();</span><br></pre></td></tr></table></figure><p> Java Servlet中模板方法的使用。</p><p> HttpServlet 的 service() 方法就是一个模板方法，它实现了整个 HTTP 请求的执行流程，doGet()、doPost() 是模板中可以由子类来定制的部分。实际上，这就相当于 Servlet 框架提供了一个扩展点（doGet()、doPost() 方法），让框架用户在不用修改 Servlet 框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    this.doPost(req, resp);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    resp.getWriter().write(&quot;Hello World.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.xzg.cd.HelloServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;hello&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>当我们在浏览器中输入网址（比如，<a href="http://127.0.0.1:8080/hello">http://127.0.0.1:8080/hello</a> ）的时候，Servlet 容器会接收到相应的请求，并且根据 URL 和 Servlet 之间的映射关系，找到相应的 Servlet（HelloServlet），然后执行它的 service() 方法。service() 方法定义在父类 HttpServlet 中，它会调用 doGet() 或 doPost() 方法，然后输出数据（“Hello world”）到网页。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void service(ServletRequest req, ServletResponse res)</span><br><span class="line">    throws ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    HttpServletRequest  request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line">    if (!(req instanceof HttpServletRequest &amp;&amp;</span><br><span class="line">            res instanceof HttpServletResponse)) &#123;</span><br><span class="line">        throw new ServletException(&quot;non-HTTP request or response&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    request &#x3D; (HttpServletRequest) req;</span><br><span class="line">    response &#x3D; (HttpServletResponse) res;</span><br><span class="line">    service(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void service(HttpServletRequest req, HttpServletResponse resp)</span><br><span class="line">    throws ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    String method &#x3D; req.getMethod();</span><br><span class="line">    if (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        long lastModified &#x3D; getLastModified(req);</span><br><span class="line">        if (lastModified &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            &#x2F;&#x2F; servlet doesn&#39;t support if-modified-since, no reason</span><br><span class="line">            &#x2F;&#x2F; to go through further expensive logic</span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            long ifModifiedSince &#x3D; req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">            if (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                &#x2F;&#x2F; If the servlet mod time is later, call doGet()</span><br><span class="line">                &#x2F;&#x2F; Round down to the nearest second for a proper compare</span><br><span class="line">                &#x2F;&#x2F; A ifModifiedSince of -1 will always be less</span><br><span class="line">                maybeSetLastModified(resp, lastModified);</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        long lastModified &#x3D; getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String errMsg &#x3D; lStrings.getString(&quot;http.method_not_implemented&quot;);</span><br><span class="line">        Object[] errArgs &#x3D; new Object[1];</span><br><span class="line">        errArgs[0] &#x3D; method;</span><br><span class="line">        errMsg &#x3D; MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调的原理解析：</p><p>回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”</p><p>同步回调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface ICallback &#123;</span><br><span class="line">  void methodToCallback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BClass &#123;</span><br><span class="line">  public void process(ICallback callback) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    callback.methodToCallback();</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AClass &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    BClass b &#x3D; new BClass();</span><br><span class="line">    b.process(new ICallback() &#123; &#x2F;&#x2F;回调对象</span><br><span class="line">      @Override</span><br><span class="line">      public void methodToCallback() &#123;</span><br><span class="line">        System.out.println(&quot;Call back me.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调可以细分为同步回调和异步回调。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上。回调基于组合关系来实现，模板模式基于继承关系来实现，回调比模板模式更加灵活。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板方法模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12%E3%80%81%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12%E3%80%81%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>观察者模式：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p><p>根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p><p>进程内的同步阻塞的实现方式示例：</p><p>假设我们在开发一个 P2P 投资理财系统，用户注册成功之后，我们会给用户发放投资体验金：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class UserController &#123;</span><br><span class="line">  private UserService userService; &#x2F;&#x2F; 依赖注入</span><br><span class="line">  private PromotionService promotionService; &#x2F;&#x2F; 依赖注入</span><br><span class="line"></span><br><span class="line">  public Long register(String telephone, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略输入参数的校验代码</span><br><span class="line">    &#x2F;&#x2F;省略userService.register()异常的try-catch代码</span><br><span class="line">    long userId &#x3D; userService.register(telephone, password);</span><br><span class="line">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">    return userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册接口做了两件事情，注册和发放体验金，违反单一职责原则。如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠券或者给用户发送一封“欢迎注册成功”的站内信。则需要改动register方法</p><p>观察者模式对上面的代码进行了重构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface RegObserver &#123;</span><br><span class="line">  void handleRegSuccess(long userId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RegPromotionObserver implements RegObserver &#123;</span><br><span class="line">  private PromotionService promotionService; &#x2F;&#x2F; 依赖注入</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void handleRegSuccess(long userId) &#123;</span><br><span class="line">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RegNotificationObserver implements RegObserver &#123;</span><br><span class="line">  private NotificationService notificationService;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void handleRegSuccess(long userId) &#123;</span><br><span class="line">    notificationService.sendInboxMessage(userId, &quot;Welcome...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserController &#123;</span><br><span class="line">  private UserService userService; &#x2F;&#x2F; 依赖注入</span><br><span class="line">  private List&lt;RegObserver&gt; regObservers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一次性设置好，之后也不可能动态的修改</span><br><span class="line">  public void setRegObservers(List&lt;RegObserver&gt; observers) &#123;</span><br><span class="line">    regObservers.addAll(observers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Long register(String telephone, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略输入参数的校验代码</span><br><span class="line">    &#x2F;&#x2F;省略userService.register()异常的try-catch代码</span><br><span class="line">    long userId &#x3D; userService.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    for (RegObserver observer : regObservers) &#123;</span><br><span class="line">      observer.handleRegSuccess(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实现一个异步非阻塞的EventBus框架？</p><p>同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。</p><p>两种异步实现方式。其中一种是：在每个 handleRegSuccess() 函数中创建一个新的线程执行代码逻辑；另一种是：在 UserController 的 register() 函数中使用线程池来执行每个观察者的 handleRegSuccess() 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第一种实现方式，其他类代码不变，就没有再重复罗列</span><br><span class="line">public class RegPromotionObserver implements RegObserver &#123;</span><br><span class="line">  private PromotionService promotionService; &#x2F;&#x2F; 依赖注入</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void handleRegSuccess(long userId) &#123;</span><br><span class="line">    Thread thread &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第二种实现方式，其他类代码不变，就没有再重复罗列</span><br><span class="line">public class UserController &#123;</span><br><span class="line">  private UserService userService; &#x2F;&#x2F; 依赖注入</span><br><span class="line">  private List&lt;RegObserver&gt; regObservers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  private Executor executor;</span><br><span class="line"></span><br><span class="line">  public UserController(Executor executor) &#123;</span><br><span class="line">    this.executor &#x3D; executor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setRegObservers(List&lt;RegObserver&gt; observers) &#123;</span><br><span class="line">    regObservers.addAll(observers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Long register(String telephone, String password) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略输入参数的校验代码</span><br><span class="line">    &#x2F;&#x2F;省略userService.register()异常的try-catch代码</span><br><span class="line">    long userId &#x3D; userService.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    for (RegObserver observer : regObservers) &#123;</span><br><span class="line">      executor.execute(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">          observer.handleRegSuccess(userId);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第一种实现方式，频繁地创建和销毁线程比较耗时，并且并发线程数无法控制，创建过多的线程会导致堆栈溢出。第二种实现方式，尽管利用了线程池解决了第一种实现方式的问题，但线程池、异步执行逻辑都耦合在了 register() 函数中，增加了这部分业务代码的维护成本。若需要在同步阻塞和异步非阻塞之间灵活切换那就要不停地修改 UserController 的代码</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰模式</title>
      <link href="2020/07/08/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7%E3%80%81%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/08/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7%E3%80%81%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装饰模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="2020/07/07/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.1%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/07/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.1%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>定义：</p><p>一个类只允许创建唯一一个对象（或者实例），那这个类就是一个单例类，这种设计模式就是单例模式。</p><p>对象的唯一性的作用范围是什么呢？进程</p><p>我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，也就是我们平时所说的“可执行文件”（比如 Windows 下的 exe 文件）程序运行时，操作系统会启动一个进程，将这个执行文件从磁盘加载到自己的进程地址空间（可以理解操作系统为进程分配的内存存储区，用来存储代码和数据）。接着，进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的 User user = new User(); 这条语句的时候，它就在自己的地址空间中创建一个 user 临时变量和一个 User 对象。</p><p>进程之间是不共享地址空间的，如果我们在一个进程中创建另外一个进程（比如，代码中有一个 fork() 语句，进程执行到这条语句的时候会创建一个新的进程），==操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中==，这些内容包括代码、数据（比如 user 临时变量、User 对象）。所以，==单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象==，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。</p><h5 id="单例模式的使用场景："><a href="#单例模式的使用场景：" class="headerlink" title="单例模式的使用场景："></a>单例模式的使用场景：</h5><p>spring管理的bean默认为单例模式。</p><p>单例对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">出生：当容器创建时对象初生。</span><br><span class="line">活着：只要容器还在，对象一直活着。</span><br><span class="line">死亡：容器销毁，对象消亡。</span><br><span class="line">总结： 单例对象的生命周期和容器相同。</span><br></pre></td></tr></table></figure><p>多例对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">出生： 当我们使用对象时spring框架为我们创建。</span><br><span class="line">活着：对象只要在使用过程中就一直活着。</span><br><span class="line">死亡：当对象长时间不用，且没有别的对象引用时，由java的垃圾回收机构消除。</span><br></pre></td></tr></table></figure><h5 id="单例模式优点："><a href="#单例模式优点：" class="headerlink" title="单例模式优点："></a>单例模式优点：</h5><ul><li>在内存中只有一个实例，不用频繁的创建或销毁对象，减少了内存开支</li><li>减少了系统的性能开销，当一个对象的产生需要 比较多的资源时，读取配置、产生其他依赖，则可以通过在应用启动时直接产生一 个单例对象，然后用永久驻留内存的方式来解决</li><li>单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在 内存中，避免对同一个资源文件的同时写操作</li></ul><h5 id="单例模式的缺点"><a href="#单例模式的缺点" class="headerlink" title="单例模式的缺点"></a>单例模式的缺点</h5><ul><li>单例对 OOP 特性的支持不友好</li><li>单例会隐藏类之间的依赖关系</li><li>单例对代码的扩展性不友好</li><li>单例对代码的可测试性不友好</li><li>单例不支持有参数的构造函数</li></ul><p>要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类了。比如，通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证</p><h3 id="1、饿汉式—线程安全—浪费资源"><a href="#1、饿汉式—线程安全—浪费资源" class="headerlink" title="1、饿汉式—线程安全—浪费资源"></a>1、饿汉式—线程安全—浪费资源</h3><p>调用效率高，但是不能延时加载。一上来就把单例对象创建出来了，如果程序从头到位都没用使用这个单例的话，这就造成了不必要的资源浪费。</p><p>instance = new Singleton();一样会指令重排，但对于 非构造线程是不可见的。所以是线程安全</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Singleton &#123;</span><br><span class="line">&#x2F;&#x2F;1. 构造器私有化, 外部不能new</span><br><span class="line">private Singleton() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;2.本类内部创建对象实例</span><br><span class="line">private final static Singleton instance &#x3D; new Singleton();</span><br><span class="line"></span><br><span class="line">&#x2F;*  也可使用静态代码块，代替上面的静态变量</span><br><span class="line">static &#123;</span><br><span class="line">instance &#x3D; new Singleton();</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3. 提供一个公有的静态方法，返回实例对象</span><br><span class="line">public static Singleton getInstance() &#123;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-懒汉式1—非线程安全"><a href="#2-懒汉式1—非线程安全" class="headerlink" title="2.懒汉式1—非线程安全"></a>2.懒汉式1—非线程安全</h3><p>当A B线程都执行到//位置1时，会创建两个线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Singleton &#123;</span><br><span class="line">private static Singleton instance;</span><br><span class="line">private Singleton() &#123;&#125;</span><br><span class="line">public static Singleton getInstance() &#123;</span><br><span class="line">if(instance &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;位置1</span><br><span class="line">instance &#x3D; new Singleton();</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、懒汉式2—线程安全—效率低下"><a href="#3、懒汉式2—线程安全—效率低下" class="headerlink" title="3、懒汉式2—线程安全—效率低下"></a>3、懒汉式2—线程安全—效率低下</h3><p>如果getInstance()方法被多个线程频繁的调用，一个线程获取锁，进去创建对象。其他线程将阻塞挂起。导致程序执行性能的下降。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Singleton &#123;</span><br><span class="line">private static Singleton instance;</span><br><span class="line">private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public static synchronized Singleton getInstance() &#123;</span><br><span class="line">if(instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">instance &#x3D; new Singleton();</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、懒汉式3—非线程安全—效率较高"><a href="#4、懒汉式3—非线程安全—效率较高" class="headerlink" title="4、懒汉式3—非线程安全—效率较高"></a>4、懒汉式3—非线程安全—效率较高</h3><p>双重检查 锁定来降低同步的开销。 如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始 化操作。因此，可以大幅降低synchronized带来的性能开销。</p><p>假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。</p><p>看似稳的一逼 实际不堪一击。</p><p>instance = new Singleton();操作并不是一个原子性指令，会被分为多个指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分配一块内存 M；</span><br><span class="line">在内存 M 上初始化 Singleton 对象；</span><br><span class="line">然后 M 的地址赋值给 instance 变量。</span><br></pre></td></tr></table></figure><p>发生指令重排后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分配一块内存 M；</span><br><span class="line">将 M 的地址赋值给 instance 变量；</span><br><span class="line">最后在内存 M 上初始化 Singleton 对象。</span><br></pre></td></tr></table></figure><p>所以A线程执行完重排后的第二步，且未执行初始化对象。此时B线程来取instance时，发现instance不为空，于是便直接返回该值，该单例模式则便返回null.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Singleton &#123;</span><br><span class="line">private static Singleton instance;</span><br><span class="line">private Singleton() &#123;&#125;</span><br><span class="line">&#x2F;&#x2F;提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span><br><span class="line">&#x2F;&#x2F;同时保证了效率, 推荐使用</span><br><span class="line">public static Singleton getInstance() &#123;</span><br><span class="line">if(instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">synchronized (Singleton.class) &#123;</span><br><span class="line">if(instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">instance &#x3D; new Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==注意：==<br>实际上，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）</p><h3 id="5、懒汉式4—线程安全—效率较高（-推荐使用-）"><a href="#5、懒汉式4—线程安全—效率较高（-推荐使用-）" class="headerlink" title="5、懒汉式4—线程安全—效率较高（==推荐使用==）"></a>5、懒汉式4—线程安全—效率较高（==推荐使用==）</h3><p>基于volatile,禁止指令重排。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Singleton &#123;</span><br><span class="line">  private Singleton()&#123;&#125;</span><br><span class="line">  private  static volatile Singleton instance;</span><br><span class="line">  static Singleton getInstance()&#123;</span><br><span class="line">    if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">      synchronized(Singleton.class) &#123;</span><br><span class="line">        if (instance &#x3D;&#x3D; null)</span><br><span class="line">          instance &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、静态内部类—线程安全—浪费资源"><a href="#6、静态内部类—线程安全—浪费资源" class="headerlink" title="6、静态内部类—线程安全—浪费资源"></a>6、静态内部类—线程安全—浪费资源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class IdGenerator &#123; </span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  private static class SingletonHolder&#123;</span><br><span class="line">    private static final IdGenerator instance &#x3D; new IdGenerator();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    return SingletonHolder.instance;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p><h3 id="7、枚举："><a href="#7、枚举：" class="headerlink" title="7、枚举："></a>7、枚举：</h3><p>通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    &#x2F;&#x2F;枚举元素本身就是单例</span><br><span class="line">    INSTANCE;</span><br><span class="line">    &#x2F;&#x2F;添加自己需要的操作</span><br><span class="line">    public void singletonOperation()&#123;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="如何实现线程唯一的单例？"><a href="#如何实现线程唯一的单例？" class="headerlink" title="如何实现线程唯一的单例？"></a>如何实现线程唯一的单例？</h5><p>上面从单例的定义清楚，单例的作用范围是进程。一个进程内，一个类只有一个对象</p><p>通过一个 ConcurrentHashMap 来存储对象，其中 key 是线程 ID，value 是对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class IdGenerator &#123;</span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line"></span><br><span class="line">  private static final ConcurrentHashMap&lt;Long, IdGenerator&gt; instances</span><br><span class="line">          &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    Long currentThreadId &#x3D; Thread.currentThread().getId();</span><br><span class="line">    instances.putIfAbsent(currentThreadId, new IdGenerator());</span><br><span class="line">    return instances.get(currentThreadId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public long getId() &#123;</span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="如何实现集群环境下的单例？"><a href="#如何实现集群环境下的单例？" class="headerlink" title="如何实现集群环境下的单例？"></a>如何实现集群环境下的单例？</h5><p>集群相当于多个进程构成的一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间共享同一个对象，不能创建同一个类的多个对象。</p><p>我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class IdGenerator &#123;</span><br><span class="line">  private AtomicLong id &#x3D; new AtomicLong(0);</span><br><span class="line">  private static IdGenerator instance;</span><br><span class="line">  private static SharedObjectStorage storage &#x3D; FileSharedObjectStorage(&#x2F;*入参省略，比如文件地址*&#x2F;);</span><br><span class="line">  private static DistributedLock lock &#x3D; new DistributedLock();</span><br><span class="line">  </span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  public synchronized static IdGenerator getInstance() </span><br><span class="line">    if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      instance &#x3D; storage.load(IdGenerator.class);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public synchroinzed void freeInstance() &#123;</span><br><span class="line">    storage.save(this, IdGeneator.class);</span><br><span class="line">    instance &#x3D; null; &#x2F;&#x2F;释放对象</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; IdGenerator使用举例</span><br><span class="line">IdGenerator idGeneator &#x3D; IdGenerator.getInstance();</span><br><span class="line">long id &#x3D; idGenerator.getId();</span><br><span class="line">IdGenerator.freeInstance();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂模式（不常用）</title>
      <link href="2020/07/07/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.2%E3%80%81%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8D%E5%B8%B8%E7%94%A8%EF%BC%89/"/>
      <url>2020/07/07/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.2%E3%80%81%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8D%E5%B8%B8%E7%94%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>抽象工厂模式是工厂方法模式的升级版本。</p><p>在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">针对规则配置的解析器：基于接口IRuleConfigParser</span><br><span class="line">JsonRuleConfigParser</span><br><span class="line">XmlRuleConfigParser</span><br><span class="line">YamlRuleConfigParser</span><br><span class="line">PropertiesRuleConfigParser</span><br><span class="line"></span><br><span class="line">针对系统配置的解析器：基于接口ISystemConfigParser</span><br><span class="line">JsonSystemConfigParser</span><br><span class="line">XmlSystemConfigParser</span><br><span class="line">YamlSystemConfigParser</span><br><span class="line">PropertiesSystemConfigParser</span><br></pre></td></tr></table></figure><p>我们要针对每个 parser 都编写一个工厂类，也就是要编写 8 个工厂类。过多的类也会让系统难维护。这个问题该怎么解决呢？</p><p>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface IConfigParserFactory &#123;</span><br><span class="line">  IRuleConfigParser createRuleParser();</span><br><span class="line">  ISystemConfigParser createSystemParser();</span><br><span class="line">  &#x2F;&#x2F;此处可以扩展新的parser类型，比如IBizConfigParser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class JsonConfigParserFactory implements IConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createRuleParser() &#123;</span><br><span class="line">    return new JsonRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public ISystemConfigParser createSystemParser() &#123;</span><br><span class="line">    return new JsonSystemConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class XmlConfigParserFactory implements IConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createRuleParser() &#123;</span><br><span class="line">    return new XmlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public ISystemConfigParser createSystemParser() &#123;</span><br><span class="line">    return new XmlSystemConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抽象工厂模式（不常用） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式拓展-上限的多例模式</title>
      <link href="2020/07/07/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.2%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%8B%93%E5%B1%95-%E4%B8%8A%E9%99%90%E7%9A%84%E5%A4%9A%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/07/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.2%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%8B%93%E5%B1%95-%E4%B8%8A%E9%99%90%E7%9A%84%E5%A4%9A%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>一个类有且仅有一个对象的场景使用单例模式。</p><p>但是如果要求一个类 只能产生两三个对象呢？该怎么实现？</p><p>一个有上限的多例类可以使用静态变量存储所有的实例，特别是在实例数目不多的时候，可以使用一个个静态变量存储一个个的实例，</p><p>在数目较多的时候，就需要使用静态聚集来存储这些实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;让一个类最多产生指定数量的对象,即有上限的多例模式</span><br><span class="line">public class demo3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int ministerNum &#x3D; 5;</span><br><span class="line">        for(int i&#x3D;0;i&lt;ministerNum;i++)&#123;</span><br><span class="line">            Emperor2 emp &#x3D; Emperor2.getInstance();</span><br><span class="line">            System.out.println(&quot;第&quot;+(i+1)+&quot;个大臣参拜的是&quot;);</span><br><span class="line">            emp.say();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Emperor2&#123;</span><br><span class="line">    &#x2F;&#x2F;定义最多能产生的实例的数量</span><br><span class="line">    private static int maxNumOfEmperor &#x3D; 2;</span><br><span class="line">    &#x2F;&#x2F;每个皇帝都有名字，使用一个ArrayList来容纳，每个对象的私有属性</span><br><span class="line">    private static ArrayList&lt;String&gt; nameList &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">    &#x2F;&#x2F;定义一个列表，容纳所有皇帝的实例</span><br><span class="line">    private static ArrayList&lt;Emperor2&gt; emperorList &#x3D;new ArrayList&lt;Emperor2&gt;();</span><br><span class="line">    &#x2F;&#x2F;当前皇帝的序列号</span><br><span class="line">    private static int countNumOfEmperor &#x3D;0;</span><br><span class="line">    &#x2F;&#x2F;产生所有对象</span><br><span class="line">    static&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;maxNumOfEmperor;i++)&#123;</span><br><span class="line">            emperorList.add(new Emperor2(&quot;皇&quot;+(i+1)+&quot;帝&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Emperor2()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Emperor2(String name)&#123;</span><br><span class="line">        nameList.add(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;随机获得一个皇帝对象</span><br><span class="line">    public static Emperor2 getInstance()&#123;</span><br><span class="line">        Random random &#x3D; new Random();</span><br><span class="line">        countNumOfEmperor &#x3D; random.nextInt(maxNumOfEmperor);</span><br><span class="line">        return emperorList.get(countNumOfEmperor);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;皇帝说话</span><br><span class="line">    public static void say()&#123;</span><br><span class="line">        System.out.println(&quot;我是&quot;+nameList.get(countNumOfEmperor));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式拓展-上限的多例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法模式（常用）</title>
      <link href="2020/07/07/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.1%E3%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89/"/>
      <url>2020/07/07/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.1%E3%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>工厂模式分为三种更加细分的类型：</p><ul><li>简单工厂【常用】</li><li>工厂方法（属于工厂方法的一种特例）【常用】</li><li>抽象工厂【不常用】</li></ul><p>备注：</p><p>工厂类都是以“Factory”这个单词结尾<br>工厂类中创建对象的方法一般都是 create </p><p>实例：</p><p>我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……）</p><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>将多个对象的创建逻辑放到一个工厂类中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RuleConfigSource &#123;</span><br><span class="line">  public RuleConfig load(String ruleConfigFilePath) &#123;</span><br><span class="line">    String ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);</span><br><span class="line">    IRuleConfigParser parser &#x3D; null;</span><br><span class="line">    if (&quot;json&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser &#x3D; new JsonRuleConfigParser();</span><br><span class="line">    &#125; else if (&quot;xml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser &#x3D; new XmlRuleConfigParser();</span><br><span class="line">    &#125; else if (&quot;yaml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser &#x3D; new YamlRuleConfigParser();</span><br><span class="line">    &#125; else if (&quot;properties&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser &#x3D; new PropertiesRuleConfigParser();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new InvalidRuleConfigException(</span><br><span class="line">             &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String configText &#x3D; &quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中</span><br><span class="line">    RuleConfig ruleConfig &#x3D; parser.parse(configText);</span><br><span class="line">    return ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getFileExtension(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json</span><br><span class="line">    return &quot;json&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RuleConfigParserFactory &#123;</span><br><span class="line">  private static final Map&lt;String, RuleConfigParser&gt; cachedParsers &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    cachedParsers.put(&quot;json&quot;, new JsonRuleConfigParser());</span><br><span class="line">    cachedParsers.put(&quot;xml&quot;, new XmlRuleConfigParser());</span><br><span class="line">    cachedParsers.put(&quot;yaml&quot;, new YamlRuleConfigParser());</span><br><span class="line">    cachedParsers.put(&quot;properties&quot;, new PropertiesRuleConfigParser());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static IRuleConfigParser createParser(String configFormat) &#123;</span><br><span class="line">    if (configFormat &#x3D;&#x3D; null || configFormat.isEmpty()) &#123;</span><br><span class="line">      return null;&#x2F;&#x2F;返回null还是IllegalArgumentException全凭你自己说了算</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParser parser &#x3D; cachedParsers.get(configFormat.toLowerCase());</span><br><span class="line">    return parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>当每个对象的创建逻辑都比较复杂，要组合其他类对象，做各种初始化操作的时候，为了避免设计一个过于庞大的简单工厂类，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中【简单工厂的工厂】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface IRuleConfigParserFactory &#123;</span><br><span class="line">  IRuleConfigParser createParser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new JsonRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new XmlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new YamlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new PropertiesRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RuleConfigSource &#123;</span><br><span class="line">  public RuleConfig load(String ruleConfigFilePath) &#123;</span><br><span class="line">    String ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);</span><br><span class="line"></span><br><span class="line">    IRuleConfigParserFactory parserFactory &#x3D; RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class="line">    if (parserFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new InvalidRuleConfigException(&quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParser parser &#x3D; parserFactory.createParser();</span><br><span class="line"></span><br><span class="line">    String configText &#x3D; &quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中</span><br><span class="line">    RuleConfig ruleConfig &#x3D; parser.parse(configText);</span><br><span class="line">    return ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getFileExtension(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json</span><br><span class="line">    return &quot;json&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;因为工厂类只包含方法，不包含成员变量，完全可以复用，</span><br><span class="line">&#x2F;&#x2F;不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span><br><span class="line">public class RuleConfigParserFactoryMap &#123; &#x2F;&#x2F;工厂的工厂</span><br><span class="line">  private static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    cachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static IRuleConfigParserFactory getParserFactory(String type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParserFactory parserFactory &#x3D; cachedFactories.get(type.toLowerCase());</span><br><span class="line">    return parserFactory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当我们新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工厂方法模式（常用） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java自定义注解</title>
      <link href="2020/07/05/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/java%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
      <url>2020/07/05/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/java%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="创建Java自定义注解"><a href="#创建Java自定义注解" class="headerlink" title="创建Java自定义注解"></a>创建Java自定义注解</h3><p>创建自定义注解和创建一个接口相似，但是注解的interface关键字需要以@符号开头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.Documented;</span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Inherited;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Inherited</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">    public @interface MethodInfo&#123;</span><br><span class="line">    String author() default &#39;Pankaj&#39;;</span><br><span class="line">    String date();</span><br><span class="line">    int revision() default 1;</span><br><span class="line">    String comments();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注解方法不能带有参数；</li><li>注解方法返回值类型限定为：基本类型、String、Enums、Annotation或者是这些类型的数组；</li><li>注解方法可以有默认值；</li><li>注解本身能够包含元注解，元注解被用来注解其它注解。</li></ul><h4 id="四种类型的元注解："><a href="#四种类型的元注解：" class="headerlink" title="四种类型的元注解："></a>四种类型的元注解：</h4><ul><li>@Documented： 指明拥有这个注解的元素可以被javadoc此类的工具文档化。</li><li>.@Target：说明了Annotation被修饰的范围，可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.ElementType.CONSTRUCTOR:用于描述构造器</span><br><span class="line">2.ElementType.FIELD:用于描述域（类的成员变量）</span><br><span class="line">3.ElementType.LOCAL_VARIABLE:用于描述局部变量（方法内部变量）</span><br><span class="line">4.ElementType.METHOD:用于描述方法</span><br><span class="line">5.ElementType.PACKAGE:用于描述包</span><br><span class="line">6.ElementType.PARAMETER:用于描述参数</span><br><span class="line">7.ElementType.TYPE:用于描述类、接口(包括注解类型) 或enum声明</span><br></pre></td></tr></table></figure></li><li>@Inherited：指明该注解类型被自动继承。</li><li>@Retention：定义了该Annotation被保留的时间长短，有些只在源码中保留，有时需要编译成的class中保留，有些需要程序运行时候保留。即描述注解的生命周期<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">1.RetentionPoicy.SOURCE:在源文件中有效（即源文件保留）</span><br><span class="line">2.RetentionPoicy.CLASS:在class文件中有效（即class保留）</span><br><span class="line">3.RetentionPoicy.RUNTIME:在运行时有效（即运行时保留）</span><br></pre></td></tr></table></figure></li></ul><h4 id="Java提供了三种内建注解。"><a href="#Java提供了三种内建注解。" class="headerlink" title="Java提供了三种内建注解。"></a>Java提供了三种内建注解。</h4><ul><li>@Override：告诉编译器我重写了接口方法</li><li>@Deprecated：告诉编译器这个方法过时了，不建议使用，Ide会在方法上划横线</li><li>@SuppressWarnings(“deprecation”):关闭方法中出现的警告</li></ul><p>我们将使用反射技术来解析java类的注解。那么注解的RetentionPolicy应该设置为RUNTIME否则java类的注解信息在执行过程中将不可用那么我们也不能从中得到任何和注解有关的数据。</p><h4 id="自定义注解-SpringAOP实现日志记录功能示例："><a href="#自定义注解-SpringAOP实现日志记录功能示例：" class="headerlink" title="自定义注解+SpringAOP实现日志记录功能示例："></a>自定义注解+SpringAOP实现日志记录功能示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 注解服务，例如登录校验</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Target(value&#x3D;&#123;ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface CheckLoginAnnotation &#123;</span><br><span class="line"></span><br><span class="line">boolean login() default false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 编写切面(验证登录：token信息)</span><br><span class="line"> *</span><br><span class="line"> * @author wp</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class CheckLoginAspect &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 配置连接点</span><br><span class="line">     * 1、execution(): 表达式主体。</span><br><span class="line">     * 2、第一个*号：表示返回类型，*号表示所有的类型。</span><br><span class="line">     * 3、包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，com.sample.service.impl包、子孙包下所有类的方法。</span><br><span class="line">     * 4、第二个*号：表示类名，*号表示所有的类。</span><br><span class="line">     * 5、*(..):最后这个星号表示方法名，*号表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数。</span><br><span class="line">     *&#x2F;</span><br><span class="line">&#x2F;&#x2F;    @Pointcut(&quot;execution(* com.api.framework..*.*(..)) &amp;&amp; @annotation(com.api.framework.config.aspect.MyAnnotation)&quot;)</span><br><span class="line">    @Pointcut(&quot;@annotation(com.api.framework.config.aspect.CheckLoginAnnotation)&quot;)</span><br><span class="line">    private void cutMethod() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Around(&quot;cutMethod()&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        ServletRequestAttributes servletRequestAttributes &#x3D; (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest httpServletRequest &#x3D; servletRequestAttributes.getRequest();</span><br><span class="line">        String token &#x3D; httpServletRequest.getHeader(JWTUtil.TOKEN_KEY);</span><br><span class="line">        &#x2F;&#x2F;模拟token***************start***************</span><br><span class="line">        UserInfo userInfo2 &#x3D; new UserInfo();</span><br><span class="line">        userInfo2.setMobile(&quot;haha&quot;);</span><br><span class="line">        userInfo2.setId(Long.parseLong(&quot;1&quot;));</span><br><span class="line">        token &#x3D; JWTUtil.createToken(userInfo2);</span><br><span class="line">        &#x2F;&#x2F;模拟token***************end***************</span><br><span class="line">        &#x2F;&#x2F;获取方法注解属性</span><br><span class="line">        CheckLoginAnnotation annotation &#x3D; getDeclaredAnnotation(joinPoint);</span><br><span class="line">        &#x2F;&#x2F;token验证</span><br><span class="line">        UserInfo userInfo &#x3D; JWTUtil.verifyToken(token, UserInfo.class);</span><br><span class="line">        &#x2F;&#x2F;login &#x3D; true 强校验用户登录信息</span><br><span class="line">        if (annotation.login() &amp;&amp; userInfo &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new BusinessException(ResultStatusEnum.TOKEN_INVALID.getStatus(), ResultStatusEnum.TOKEN_INVALID.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        TheadLocalUtil.userId.set(userInfo.getId().toString());</span><br><span class="line">        return joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取方法中声明的注解</span><br><span class="line">     *</span><br><span class="line">     * @param joinPoint</span><br><span class="line">     * @return</span><br><span class="line">     * @throws NoSuchMethodException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public CheckLoginAnnotation getDeclaredAnnotation(ProceedingJoinPoint joinPoint) throws NoSuchMethodException &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取方法名</span><br><span class="line">        String methodName &#x3D; joinPoint.getSignature().getName();</span><br><span class="line">        &#x2F;&#x2F; 反射获取目标类</span><br><span class="line">        Class&lt;?&gt; targetClass &#x3D; joinPoint.getTarget().getClass();</span><br><span class="line">        &#x2F;&#x2F; 拿到方法对应的参数类型</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes &#x3D; ((MethodSignature) joinPoint.getSignature()).getParameterTypes();</span><br><span class="line">        &#x2F;&#x2F; 根据类、方法、参数类型（重载）获取到方法的具体信息</span><br><span class="line">        Method objMethod &#x3D; targetClass.getMethod(methodName, parameterTypes);</span><br><span class="line">        &#x2F;&#x2F; 拿到方法定义的注解信息</span><br><span class="line">        CheckLoginAnnotation annotation &#x3D; objMethod.getDeclaredAnnotation(CheckLoginAnnotation.class);</span><br><span class="line">        &#x2F;&#x2F; 返回</span><br><span class="line">        return annotation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java自定义注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位图算法</title>
      <link href="2020/07/05/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E4%BD%8D%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
      <url>2020/07/05/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E4%BD%8D%E5%9B%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>BitMap算法的核心思想是用bit数组来记录0-1两种状态，然后再将具体数据映射到这个比特数组的具体位置，这个比特位设置成0表示数据不存在，设置成1表示数据存在。</p><p>BitMap算在在大量数据查询、去重等应用场景中使用的比较多，这个算法具有比较高的空间利用率。</p><p>原理：</p><p>给定长度是10的bitmap，每一个bit位分别对应着从0到9的10个整型数。此时bitmap的所有位都是0。</p><p>把整型数4存入bitmap，对应存储的位置就是下标为4的位置，将此bit置为1。</p><p>把整型数2存入bitmap，对应存储的位置就是下标为2的位置，将此bit置为1。</p><p>要问此时bitmap里存储了哪些元素？就一目了然。</p><p>Bitmap不仅方便查询，还可以去除掉重复的整型数。</p><p>位图算法的开源实现有JDK的BitSet和谷歌的EWAHCompressedBitmap。</p><p>BitSet是对BitMap算法的简单实现，而EWAHCompressedBitmap对BitMap的存储空间做了优化。<br>加入现在要插入一个非常大的数，比如10000000，那么BitMap必须要开启一大块空间来存储10000000，但是这篇空间中的很多Bit位是用不到的。在这种数据分布极度不均匀的情况下BitMap的空间利用率是很低的。EWAHCompressedBitmap实现就对这种情况作了优化。</p><p>BitSet是位操作的对象，值只有0或1即false和true，内部维护了一个long数组，初始只有一个long，所以BitSet最小的size是64，当随着存储的元素越来越多，BitSet内部会动态扩充，一次扩充64位，最终内部是由N个long来存储。<br>默认情况下，BitSet的所有位都是false即0。<br>在没有外部同步的情况下，多个线程操作一个BitSet是不安全的。<br>一个1GB的空间，有8102410241024 = 8.5810^9bit，也就是1GB的空间可以表示85亿多个数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> public BitSet() &#123;</span><br><span class="line">        initWords(BITS_PER_WORD); &#x2F;&#x2F;初始化 数组</span><br><span class="line">        sizeIsSticky &#x3D; false; &#x2F;&#x2F;所有位都设置为false</span><br><span class="line">    &#125;</span><br><span class="line">private void initWords(int nbits) &#123;</span><br><span class="line">        words &#x3D; new long[wordIndex(nbits-1) + 1];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">   *符号右移6位 也就是除64</span><br><span class="line">   *&#x2F;</span><br><span class="line"> private static int wordIndex(int bitIndex) &#123;</span><br><span class="line">        return bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void set(int bitIndex) &#123;</span><br><span class="line">        if (bitIndex &lt; 0)</span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;bitIndex &lt; 0: &quot; + bitIndex);</span><br><span class="line"></span><br><span class="line">        int wordIndex &#x3D; wordIndex(bitIndex);</span><br><span class="line">     </span><br><span class="line">        expandTo(wordIndex);</span><br><span class="line"></span><br><span class="line">        words[wordIndex] |&#x3D; (1L &lt;&lt; bitIndex); &#x2F;&#x2F; Restores invariants</span><br><span class="line"></span><br><span class="line">        checkInvariants();</span><br><span class="line">    &#125;</span><br><span class="line">    private void expandTo(int wordIndex) &#123;</span><br><span class="line">    &#x2F;&#x2F;set的值所需要的size</span><br><span class="line">        int wordsRequired &#x3D; wordIndex+1;</span><br><span class="line">        &#x2F;&#x2F;当前使用的&lt; 需要的</span><br><span class="line">        if (wordsInUse &lt; wordsRequired) &#123;</span><br><span class="line">        &#x2F;&#x2F;扩容</span><br><span class="line">            ensureCapacity(wordsRequired);</span><br><span class="line">            wordsInUse &#x3D; wordsRequired;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> private void ensureCapacity(int wordsRequired) &#123;</span><br><span class="line">        if (words.length &lt; wordsRequired) &#123;</span><br><span class="line">            &#x2F;&#x2F;当需要的 大于当前的long数组的size 扩容</span><br><span class="line">            int request &#x3D; Math.max(2 * words.length, wordsRequired);</span><br><span class="line">            words &#x3D; Arrays.copyOf(words, request);</span><br><span class="line">            sizeIsSticky &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean get(int bitIndex) &#123;</span><br><span class="line">if (bitIndex &lt; 0)</span><br><span class="line">throw new IndexOutOfBoundsException(&quot;bitIndex &lt; 0: &quot; + bitIndex);</span><br><span class="line"></span><br><span class="line">    checkInvariants();</span><br><span class="line"></span><br><span class="line">    int wordIndex &#x3D; wordIndex(bitIndex);</span><br><span class="line">    return (wordIndex &lt; wordsInUse)</span><br><span class="line">        &amp;&amp; ((words[wordIndex] &amp; (1L &lt;&lt; bitIndex)) !&#x3D; 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么BitSet使用long数组做内部存储？<br>JDK选择long数组作为BitSet的内部存储结构是出于性能的考虑，因为BitSet提供and和or这种操作，需要对两个BitSet中的所有bit位做and或者or，实现的时候需要遍历所有的数组元素。使用long能够使得循环的次数降到最低，所以Java选择使用long数组作为BitSet的内部存储结构。</p><p>从数据在栈上的存储来说，使用long和byte基本是没有什么差别的，除了编译器强制地址对齐的时候，使用byte最多会浪费7个字节(强制按照8的倍数做地址对其)，另外从内存读数组元素的时候，也是没有什么区别的，因为汇编指令有对不同长度数据的mov指令。所以说，JDK选择使用long数组作为BitSet的内部存储结构的根本原因就是在and和or的时候减少循环次数，提高性能。</p><p>例如我们进行BitSet中的and, or,xor操作时，要对整个bitset中的bit都进行操作，需要依次读出bitset中所有的word，如果是long数组存储，我们可以每次读入64个bit,而int数组存储时，只能每次读入32个bit。另外我们在查找bitset中下一个置为1的bit时,word首先会和0进行比较，如果word的值为0，则表示该word中没有为1的bit，可以忽略这个word，如果是long数组存储，可以一次跳过64个bit，如果是int数组存储时，一次只能跳过32个bit。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位图算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器</title>
      <link href="2020/07/05/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>2020/07/05/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>利用布隆过滤器解决缓存穿透</p><p>布隆过滤器的巨大用处就是，能够迅速判断一个元素是否在一个集合中。因此他有如下三个使用场景:</p><ul><li><p>网页爬虫对URL的去重，避免爬取相同的URL地址</p></li><li><p>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）</p></li><li><p>缓存穿透，将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt;     </span><br><span class="line">        &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt;      </span><br><span class="line">        &lt;version&gt;22.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建字符串布隆过滤器，使用编码UTF-8</span><br><span class="line">     &#x2F;&#x2F;创建时需要传入四个参数，但我们只要关心前三个就行</span><br><span class="line">     &#x2F;&#x2F;Funnel，这是Guava中定义的一个接口，它和PrimitiveSink配套使用，主要是把任意类型的数据转化成Java基本数据类型（primitive value，如char，byte，int……），默认用java.nio.ByteBuffer实现，最终均转化为byte数组</span><br><span class="line">     &#x2F;&#x2F;expectedInsertions 期望插入数据数，int或long</span><br><span class="line">     &#x2F;&#x2F;fpp期望误判率，比如1E-7（千万分之一）</span><br><span class="line">     &#x2F;&#x2F;Strategy 策略，默认选取64位哈希映射函数，BloomFilterStrategies.MURMUR128_MITZ_64</span><br><span class="line">     BloomFilter&lt;CharSequence&gt; bloomFilter &#x3D; BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), 200000, 1E-7);</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;置入元素，其实也有boolean类型返回，但是尊重注解，就不返回值了</span><br><span class="line">     bloomFilter.put(&quot;测试测试&quot;);</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;判断元素是否存在，true存在，false不存在。</span><br><span class="line">     boolean isContain&#x3D;bloomFilter.mightContain(&quot;测试测试&quot;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 布隆过滤器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hash算法</title>
      <link href="2020/07/05/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/5%E3%80%81hash%E7%AE%97%E6%B3%95/"/>
      <url>2020/07/05/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/5%E3%80%81hash%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>4、优秀的hash函数的构造方式：</p><p>（1）直接定址法：取关键字的某个线性函数值为散列地址 f(key) = a × key + b</p><p>（2）除留余数法 (用的较多) ：f( key ) = key mod p ( p ≤ m )。mod是取模（求余数）的意思。事实上，这方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。</p><p>（3）平方取中法</p><p>（4）折叠法：将关键字拆分成几部分，然后将这几部分组合在一起，以特定的方式进行转化形成Hash地址。假如知道图书的ISBN号为8903-241-23，可以将Hash(key)=89+03+24+12+3作为Hash地址</p><p>（5）数字分析法</p><p>（6）随机数法</p><p>（7）time33算法(PHP的数组就是把这个作为哈希函数）</p><p>以上hash函数感兴趣可以查询相关资料，了解其原理</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hash算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻塞队列</title>
      <link href="2020/07/05/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E9%98%9F%E5%88%97/4%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
      <url>2020/07/05/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E9%98%9F%E5%88%97/4%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="阻塞队列是一种当队列满了和队列空了时，会阻塞的队列"><a href="#阻塞队列是一种当队列满了和队列空了时，会阻塞的队列" class="headerlink" title="阻塞队列是一种当队列满了和队列空了时，会阻塞的队列"></a>阻塞队列是一种当队列满了和队列空了时，会阻塞的队列</h3><p>==就是在队列为空的时候，从队头取数据会被阻塞==。因为此时还没有数据可取，直到队列中有了数据才能返回；==如果队列已经满了，那么插入数据的操作就会被阻塞==，直到队列中有空闲位置后再插入数据，然后再返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class BlockingQueue &#123;</span><br><span class="line"></span><br><span class="line">    private List queue &#x3D; new LinkedList();</span><br><span class="line"></span><br><span class="line">    private int limit &#x3D; 10;</span><br><span class="line"></span><br><span class="line">    public BlockingQueue(int limit) &#123;</span><br><span class="line">        this.limit &#x3D; limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;入队列时，如果队列满了，则阻塞</span><br><span class="line">    public synchronized void enqueue(Object item)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        while (this.queue.size() &#x3D;&#x3D; this.limit) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.queue.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        this.queue.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;出队列时，如果队列为空，则阻塞</span><br><span class="line">    public synchronized Object dequeue()</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        while (this.queue.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.queue.size() &#x3D;&#x3D; this.limit) &#123;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        return this.queue.remove(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阻塞队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solr索引MySQL数据</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/5%E3%80%81%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/2%E3%80%81solr/4%E3%80%81Solr%E7%B4%A2%E5%BC%95MySQL%E6%95%B0%E6%8D%AE/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/5%E3%80%81%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/2%E3%80%81solr/4%E3%80%81Solr%E7%B4%A2%E5%BC%95MySQL%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>1、修改索引库下的conf/solrconfig.xml 配置文件 引入数据源配置文件</p><p>找到requestHandler同节点 添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;requestHandler name&#x3D;&quot;&#x2F;dataimport&quot; class&#x3D;&quot;org.apache.solr.handler.dataimport.DataImportHandler&quot;&gt;  </span><br><span class="line">　     &lt;lst name&#x3D;&quot;defaults&quot;&gt;  </span><br><span class="line">　        &lt;str name&#x3D;&quot;config&quot;&gt;data-config.xml&lt;&#x2F;str&gt;  </span><br><span class="line">　     &lt;&#x2F;lst&gt;  </span><br><span class="line">　&lt;&#x2F;requestHandler&gt;</span><br></pre></td></tr></table></figure><p>2、在solrconfig.xml同级目录下添加data-config.xml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;dataConfig&gt;</span><br><span class="line"></span><br><span class="line">&lt;dataSource type&#x3D;&quot;JdbcDataSource&quot; driver&#x3D;&quot;com.mysql.jdbc.Driver&quot; url&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;117.79.92.68:30707&#x2F;companys&quot; user&#x3D;&quot;gaoyang&quot; password&#x3D;&quot;sORePdDEZ0AUYsuG&quot; &#x2F;&gt;</span><br><span class="line">    &lt;document&gt;</span><br><span class="line">    &lt;!--这里的参对应下图中的地方--&gt;</span><br><span class="line">     &lt;!--query是full-import的查询语句--&gt;</span><br><span class="line">               &lt;!-- deltaQuery 是增量更新的查询语句  --&gt;</span><br><span class="line">        &lt;entity name&#x3D;&quot;company_result&quot; query&#x3D;&quot;select * from company_result WHERE id between $&#123;dataimporter.request.id_start&#125; and  $&#123;dataimporter.request.id_end&#125;&quot;&gt;</span><br><span class="line">         &lt;!--field 中的column对应数据库的一个字段，name对应managed-schema中的name--&gt;</span><br><span class="line">&lt;field column&#x3D;&quot;id&quot; name&#x3D;&quot;id&quot; &#x2F;&gt;</span><br><span class="line">&lt;field column&#x3D;&quot;contentId&quot; name&#x3D;&quot;contentId&quot; &#x2F;&gt;</span><br><span class="line">&lt;field column&#x3D;&quot;zhaoBiaoUnit&quot; name&#x3D;&quot;zhaoBiaoUnit&quot; &#x2F;&gt;</span><br><span class="line">           &lt;field column&#x3D;&quot;zhongBiaoUnit&quot; name&#x3D;&quot;zhongBiaoUnit&quot; &#x2F;&gt;</span><br><span class="line">   &lt;field column&#x3D;&quot;zhaoBiaoUnitJson&quot; name&#x3D;&quot;zhaoBiaoUnitJson&quot; &#x2F;&gt;</span><br><span class="line">   &lt;field column&#x3D;&quot;zhongBiaoUnitJson&quot; name&#x3D;&quot;zhongBiaoUnitJson&quot; &#x2F;&gt;</span><br><span class="line">   &lt;field column&#x3D;&quot;intime&quot; name&#x3D;&quot;intime&quot; &#x2F;&gt;</span><br><span class="line">   &lt;field column&#x3D;&quot;status&quot; name&#x3D;&quot;status&quot; &#x2F;&gt;</span><br><span class="line">   &lt;field column&#x3D;&quot;amountUnit&quot; name&#x3D;&quot;amountUnit&quot; &#x2F;&gt;</span><br><span class="line">   &lt;field column&#x3D;&quot;amountUnitJson&quot; name&#x3D;&quot;amountUnitJson&quot; &#x2F;&gt;</span><br><span class="line">   &lt;field column&#x3D;&quot;progid&quot; name&#x3D;&quot;progid&quot; &#x2F;&gt;</span><br><span class="line">   &lt;field column&#x3D;&quot;updatetime&quot; name&#x3D;&quot;updatetime&quot; &#x2F;&gt;</span><br><span class="line">   &lt;field column&#x3D;&quot;bidNumUnit&quot; name&#x3D;&quot;bidNumUnit&quot; &#x2F;&gt;</span><br><span class="line">   &lt;field column&#x3D;&quot;bidNumUnitJson&quot; name&#x3D;&quot;bidNumUnitJson&quot; &#x2F;&gt;</span><br><span class="line">  </span><br><span class="line">        &lt;&#x2F;entity&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;document&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;dataConfig&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="WEBRESOURCE27599b9f2873fbcb1235c742d3cb0cfc" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> solr </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solr索引MySQL数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap(JDK7)</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/11%E3%80%81HashMap(JDK7)/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/11%E3%80%81HashMap(JDK7)/</url>
      
        <content type="html"><![CDATA[<p>它允许 null 值和null键，它不是线程同步的，同时也不保证有序</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>　哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，哈希表的主干就是数组</p><ul><li>存储：通过把当前元素的关键字 通过hash函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</li><li>查询：查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</li></ul><h4 id="哈希冲突："><a href="#哈希冲突：" class="headerlink" title="　哈希冲突："></a>　哈希冲突：</h4><p>　</p><ul><li>　1、开放定址法（发生冲突，继续寻找下一块未被占用的存储地址）　</li><li>　2、散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式（==jdk7==）</li></ul><p>==不同hash值的key的Entry&lt;K,V&gt;存在数组table中—-数组存储；<br>每个相同hash值的key的Entry&lt;K,V&gt;用链表存储==</p><p>HashMap的整体结构如下：<br><img src="http://images2015.cnblogs.com/blog/1024555/201611/1024555-20161113235348670-746615111.png" alt="image"></p><p>==影响 HashMap 性能的两个重要参数：==<br>“initial capacity”（初始化容量）：容量就是哈希表桶的个数（主干数组的长度）</p><p>”loadfactor“（负载因子）：负载因子就是键值对个数与哈希表长度的一个比值，当比值超过负载因子之后，HashMap 就会进行 rehash操作来进行扩容。</p><p>负载因子为什么是0.75 ， 不是0.5或者1？</p><p>如果是1，那意味着每次空间使用完毕才扩容，在一定程度上会增加put时候的时间。</p><p>如果是1，那意味着每次空间使用完毕才扩容，在一定程度上会增加put时候的时间。</p><h4 id="源码分析："><a href="#源码分析：" class="headerlink" title="　源码分析："></a>　源码分析：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br></pre></td><td class="code"><pre><span class="line">package java.util;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class HashMap&lt;K,V&gt;</span><br><span class="line">    extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 默认初始容量，默认为2的4次方 &#x3D; 16，2的n次方是为了加快hash计算速度，；；减少hash冲突，，，h &amp; (length-1)，，1111111</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 最大容量，默认为2的30次方，</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 默认负载因子，默认为0.75</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *当数组表还没扩容的时候，一个共享的空表对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final Entry&lt;?,?&gt;[] EMPTY_TABLE &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 数组表，大小可以改变，且大小必须为2的幂</span><br><span class="line">     *&#x2F;</span><br><span class="line">    transient Entry&lt;K,V&gt;[] table &#x3D; (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当前Map中key-value映射的个数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    transient int size;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 下次扩容阈值，当size &gt; capacity * load factor时，开始扩容</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int threshold;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 负载因子</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final float loadFactor;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Hash表结构性修改次数，用于实现迭代器快速失败行为</span><br><span class="line">     *&#x2F;</span><br><span class="line">    transient int modCount;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 容量阈值，默认大小为Integer.MAX_VALUE</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT &#x3D; Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 静态内部类Holder，存放一些只能在虚拟机启动后才能初始化的值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static class Holder &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 容量阈值，初始化hashSeed的时候会用到该值</span><br><span class="line">         *&#x2F;</span><br><span class="line">        static final int ALTERNATIVE_HASHING_THRESHOLD;</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            &#x2F;&#x2F;获取系统变量jdk.map.althashing.threshold</span><br><span class="line">            String altThreshold &#x3D; java.security.AccessController.doPrivileged(</span><br><span class="line">                new sun.security.action.GetPropertyAction(</span><br><span class="line">                    &quot;jdk.map.althashing.threshold&quot;));</span><br><span class="line"></span><br><span class="line">            int threshold;</span><br><span class="line">            try &#123;</span><br><span class="line">                threshold &#x3D; (null !&#x3D; altThreshold)</span><br><span class="line">                        ? Integer.parseInt(altThreshold)</span><br><span class="line">                        : ALTERNATIVE_HASHING_THRESHOLD_DEFAULT;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; jdk.map.althashing.threshold系统变量默认为-1，如果为-1，则将阈值设为Integer.MAX_VALUE</span><br><span class="line">                if (threshold &#x3D;&#x3D; -1) &#123;</span><br><span class="line">                    threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;阈值需要为正数</span><br><span class="line">                if (threshold &lt; 0) &#123;</span><br><span class="line">                    throw new IllegalArgumentException(&quot;value must be positive integer.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch(IllegalArgumentException failed) &#123;</span><br><span class="line">                throw new Error(&quot;Illegal value for &#39;jdk.map.althashing.threshold&#39;&quot;, failed);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ALTERNATIVE_HASHING_THRESHOLD &#x3D; threshold;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 计算hash值的时候需要用到</span><br><span class="line">     *&#x2F;</span><br><span class="line">    transient int hashSeed &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 生成一个空的HashMap,并指定其容量大小和负载因子</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        &#x2F;&#x2F;保证初始容量大于等于0</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#x2F;&#x2F;保证初始容量不大于最大容量MAXIMUM_CAPACITY</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;loadFactor小于0或为无效数字</span><br><span class="line">        if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        &#x2F;&#x2F;负载因子</span><br><span class="line">        this.loadFactor &#x3D; loadFactor;</span><br><span class="line">        &#x2F;&#x2F;下次扩容大小</span><br><span class="line">        threshold &#x3D; initialCapacity;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 生成一个空的HashMap,并指定其容量大小，负载因子使用默认的0.75</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HashMap(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 生成一个空的HashMap,容量大小使用默认值16，负载因子使用默认值0.75</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HashMap() &#123;</span><br><span class="line">        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据指定的map生成一个新的HashMap,负载因子使用默认值，初始容量大小为Math.max((int) (m.size() &#x2F; DEFAULT_LOAD_FACTOR) + 1,DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this(Math.max((int) (m.size() &#x2F; DEFAULT_LOAD_FACTOR) + 1,</span><br><span class="line">                      DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">        putAllForCreate(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回&gt;&#x3D;number的最小2的n次方值，如number&#x3D;5，则返回8</span><br><span class="line">    private static int roundUpToPowerOf2(int number) &#123;</span><br><span class="line">        &#x2F;&#x2F; assert number &gt;&#x3D; 0 : &quot;number must be non-negative&quot;;</span><br><span class="line">        return number &gt;&#x3D; MAXIMUM_CAPACITY</span><br><span class="line">                ? MAXIMUM_CAPACITY</span><br><span class="line">                : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 对table扩容</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void inflateTable(int toSize) &#123;</span><br><span class="line">        &#x2F;&#x2F; Find a power of 2 &gt;&#x3D; toSize</span><br><span class="line">        &#x2F;&#x2F;找一个值（2的n次方，且&gt;&#x3D;toSize）</span><br><span class="line">        int capacity &#x3D; roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;下次扩容阈值</span><br><span class="line">        threshold &#x3D; (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">        </span><br><span class="line">        table &#x3D; new Entry[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; internal utilities</span><br><span class="line"></span><br><span class="line">    void init() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 初始化hashSeed</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final boolean initHashSeedAsNeeded(int capacity) &#123;</span><br><span class="line">        boolean currentAltHashing &#x3D; hashSeed !&#x3D; 0;</span><br><span class="line">        boolean useAltHashing &#x3D; sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (capacity &gt;&#x3D; Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        boolean switching &#x3D; currentAltHashing ^ useAltHashing;</span><br><span class="line">        if (switching) &#123;</span><br><span class="line">            hashSeed &#x3D; useAltHashing</span><br><span class="line">                ? sun.misc.Hashing.randomHashSeed(this)</span><br><span class="line">                : 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return switching;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 生成hash值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int hash(Object k) &#123;</span><br><span class="line">        int h &#x3D; hashSeed;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;如果key是字符串，调用un.misc.Hashing.stringHash32生成hash值</span><br><span class="line">        &#x2F;&#x2F;Oracle表示能生成更好的hash分布，不过这在jdk8中已删除</span><br><span class="line">        if (0 !&#x3D; h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">            return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;一次散列，调用k的hashCode方法，与hashSeed做异或操作</span><br><span class="line">        h ^&#x3D; k.hashCode();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This function ensures that hashCodes that differ only by</span><br><span class="line">        &#x2F;&#x2F; constant multiples at each bit position have a bounded</span><br><span class="line">        &#x2F;&#x2F; number of collisions (approximately 8 at default load factor).</span><br><span class="line">        &#x2F;&#x2F;二次散列，</span><br><span class="line">        h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回hash值的索引，采用除模取余法，h &amp; (length-1)操作 等价于 hash % length操作， 但&amp;操作性能更优</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static int indexFor(int h, int length) &#123;</span><br><span class="line">        &#x2F;&#x2F; assert Integer.bitCount(length) &#x3D;&#x3D; 1 : &quot;length must be a non-zero power of 2&quot;;</span><br><span class="line">        return h &amp; (length-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回key-value映射个数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断map是否为空</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return size &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回指定key对应的value</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        &#x2F;&#x2F;key为null情况</span><br><span class="line">        if (key &#x3D;&#x3D; null)</span><br><span class="line">            return getForNullKey();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;根据key查找节点</span><br><span class="line">        Entry&lt;K,V&gt; entry &#x3D; getEntry(key);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;返回key对应的值</span><br><span class="line">        return null &#x3D;&#x3D; entry ? null : entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找key为null的value，注意如果key为null，则其hash值为0，默认是放在table[0]里的</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private V getForNullKey() &#123;</span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;在table[0]的链表上查找key为null的键值对，因为null默认是存在table[0]的桶里</span><br><span class="line">        for (Entry&lt;K,V&gt; e &#x3D; table[0]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">            if (e.key &#x3D;&#x3D; null)</span><br><span class="line">                return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *判断是否包含指定的key</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean containsKey(Object key) &#123;</span><br><span class="line">        return getEntry(key) !&#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据key查找键值对，找不到返回null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果key为null，hash值为0，否则调用hash方法，对key生成hash值</span><br><span class="line">        int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : hash(key);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;调用indexFor方法生成hash值的索引，遍历该索引下的链表，查找key“相等”的键值对</span><br><span class="line">        for (Entry&lt;K,V&gt; e &#x3D; table[indexFor(hash, table.length)];</span><br><span class="line">             e !&#x3D; null;</span><br><span class="line">             e &#x3D; e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                return e;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 向map存入一个键值对，如果key已存在，则覆盖</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public V put(K key, V value) &#123;</span><br><span class="line">        &#x2F;&#x2F;数组为空，对数组扩容</span><br><span class="line">        if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;对key为null的键值对调用putForNullKey处理</span><br><span class="line">        if (key &#x3D;&#x3D; null)</span><br><span class="line">            return putForNullKey(value);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;生成hash值</span><br><span class="line">        int hash &#x3D; hash(key);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;生成hash值索引</span><br><span class="line">        int i &#x3D; indexFor(hash, table.length);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;查找是否有key“相等”的键值对，有的话覆盖</span><br><span class="line">        for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue &#x3D; e.value;</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;操作次数加一，用于迭代器快速失败行为</span><br><span class="line">        modCount++;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;在指定hash值索引处的链表上增加该键值对</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 存放key为null的键值对，存放在索引为0的链表上，已存在的话，替换</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private V putForNullKey(V value) &#123;</span><br><span class="line">        for (Entry&lt;K,V&gt; e &#x3D; table[0]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">            &#x2F;&#x2F;已存在key为null，则替换</span><br><span class="line">            if (e.key &#x3D;&#x3D; null) &#123;</span><br><span class="line">                V oldValue &#x3D; e.value;</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;操作次数加一，用于迭代器快速失败行为</span><br><span class="line">        modCount++;</span><br><span class="line">        &#x2F;&#x2F;在指定hash值索引处的链表上增加该键值对</span><br><span class="line">        addEntry(0, null, value, 0);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 添加键值对</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void putForCreate(K key, V value) &#123;</span><br><span class="line">        &#x2F;&#x2F;生成hash值</span><br><span class="line">        int hash &#x3D; null &#x3D;&#x3D; key ? 0 : hash(key);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;生成hash值索引，</span><br><span class="line">        int i &#x3D; indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * key“相等”，则替换</span><br><span class="line">         *&#x2F;</span><br><span class="line">        for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;在指定索引处的链表上创建该键值对</span><br><span class="line">        createEntry(hash, key, value, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;将制定map的键值对添加到map中</span><br><span class="line">    private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">            putForCreate(e.getKey(), e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 对数组扩容</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void resize(int newCapacity) &#123;</span><br><span class="line">        Entry[] oldTable &#x3D; table;</span><br><span class="line">        int oldCapacity &#x3D; oldTable.length;</span><br><span class="line">        </span><br><span class="line">        if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;创建一个指定大小的数组</span><br><span class="line">        Entry[] newTable &#x3D; new Entry[newCapacity];</span><br><span class="line">        </span><br><span class="line">        transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;table索引替换成新数组</span><br><span class="line">        table &#x3D; newTable;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;重新计算阈值</span><br><span class="line">        threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 拷贝旧的键值对到新的哈希表中</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">        int newCapacity &#x3D; newTable.length;</span><br><span class="line">        &#x2F;&#x2F;遍历旧的数组</span><br><span class="line">        for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            while(null !&#x3D; e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">                if (rehash) &#123;</span><br><span class="line">                    e.hash &#x3D; null &#x3D;&#x3D; e.key ? 0 : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;根据新的数组长度，重新计算索引，</span><br><span class="line">                int i &#x3D; indexFor(e.hash, newCapacity);</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F;插入到链表表头</span><br><span class="line">                e.next &#x3D; newTable[i];</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F;将e放到索引为i处</span><br><span class="line">                newTable[i] &#x3D; e;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F;将e设置成下个节点</span><br><span class="line">                e &#x3D; next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将制定map的键值对put到本map，key“相等”的直接覆盖</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        int numKeysToBeAdded &#x3D; m.size();</span><br><span class="line">        if (numKeysToBeAdded &#x3D;&#x3D; 0)</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;空map，扩容</span><br><span class="line">        if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable((int) Math.max(numKeysToBeAdded * loadFactor, threshold));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 判断是否需要扩容</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (numKeysToBeAdded &gt; threshold) &#123;</span><br><span class="line">            int targetCapacity &#x3D; (int)(numKeysToBeAdded &#x2F; loadFactor + 1);</span><br><span class="line">            if (targetCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">                targetCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">            int newCapacity &#x3D; table.length;</span><br><span class="line">            while (newCapacity &lt; targetCapacity)</span><br><span class="line">                newCapacity &lt;&lt;&#x3D; 1;</span><br><span class="line">            if (newCapacity &gt; table.length)</span><br><span class="line">                resize(newCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;依次遍历键值对，并put</span><br><span class="line">        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">            put(e.getKey(), e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 移除指定key的键值对</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public V remove(Object key) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e &#x3D; removeEntryForKey(key);</span><br><span class="line">        return (e &#x3D;&#x3D; null ? null : e.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 移除指定key的键值对</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123;</span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;计算hash值及索引</span><br><span class="line">        int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : hash(key);</span><br><span class="line">        int i &#x3D; indexFor(hash, table.length);</span><br><span class="line">        </span><br><span class="line">        Entry&lt;K,V&gt; prev &#x3D; table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e &#x3D; prev;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;头节点为table[i]的单链表上执行删除节点操作</span><br><span class="line">        while (e !&#x3D; null) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">            Object k;</span><br><span class="line">            &#x2F;&#x2F;找到要删除的节点</span><br><span class="line">            if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                if (prev &#x3D;&#x3D; e)</span><br><span class="line">                    table[i] &#x3D; next;</span><br><span class="line">                else</span><br><span class="line">                    prev.next &#x3D; next;</span><br><span class="line">                e.recordRemoval(this);</span><br><span class="line">                return e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev &#x3D; e;</span><br><span class="line">            e &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 删除指定键值对对象(Entry对象)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final Entry&lt;K,V&gt; removeMapping(Object o) &#123;</span><br><span class="line">        if (size &#x3D;&#x3D; 0 || !(o instanceof Map.Entry))</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        Map.Entry&lt;K,V&gt; entry &#x3D; (Map.Entry&lt;K,V&gt;) o;</span><br><span class="line">        Object key &#x3D; entry.getKey();</span><br><span class="line">        int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : hash(key);</span><br><span class="line">        &#x2F;&#x2F;得到数组索引</span><br><span class="line">        int i &#x3D; indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev &#x3D; table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e &#x3D; prev;</span><br><span class="line">        &#x2F;&#x2F;开始遍历该单链表</span><br><span class="line">        while (e !&#x3D; null) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">            &#x2F;&#x2F;找到节点</span><br><span class="line">            if (e.hash &#x3D;&#x3D; hash &amp;&amp; e.equals(entry)) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                if (prev &#x3D;&#x3D; e)</span><br><span class="line">                    table[i] &#x3D; next;</span><br><span class="line">                else</span><br><span class="line">                    prev.next &#x3D; next;</span><br><span class="line">                e.recordRemoval(this);</span><br><span class="line">                return e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev &#x3D; e;</span><br><span class="line">            e &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 清空map，将table数组所有元素设为null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        Arrays.fill(table, null);</span><br><span class="line">        size &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断是否含有指定value的键值对</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean containsValue(Object value) &#123;</span><br><span class="line">        if (value &#x3D;&#x3D; null)</span><br><span class="line">            return containsNullValue();</span><br><span class="line"></span><br><span class="line">        Entry[] tab &#x3D; table;</span><br><span class="line">        &#x2F;&#x2F;遍历table数组</span><br><span class="line">        for (int i &#x3D; 0; i &lt; tab.length ; i++)</span><br><span class="line">            &#x2F;&#x2F;遍历每条单链表</span><br><span class="line">            for (Entry e &#x3D; tab[i] ; e !&#x3D; null ; e &#x3D; e.next)</span><br><span class="line">                if (value.equals(e.value))</span><br><span class="line">                    return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断是否含有value为null的键值对</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private boolean containsNullValue() &#123;</span><br><span class="line">        Entry[] tab &#x3D; table;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; tab.length ; i++)</span><br><span class="line">            for (Entry e &#x3D; tab[i] ; e !&#x3D; null ; e &#x3D; e.next)</span><br><span class="line">                if (e.value &#x3D;&#x3D; null)</span><br><span class="line">                    return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 浅拷贝，键值对不复制</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        HashMap&lt;K,V&gt; result &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            result &#x3D; (HashMap&lt;K,V&gt;)super.clone();</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; assert false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (result.table !&#x3D; EMPTY_TABLE) &#123;</span><br><span class="line">            result.inflateTable(Math.min(</span><br><span class="line">                (int) Math.min(</span><br><span class="line">                    size * Math.min(1 &#x2F; loadFactor, 4.0f),</span><br><span class="line">                    &#x2F;&#x2F; we have limits...</span><br><span class="line">                    HashMap.MAXIMUM_CAPACITY),</span><br><span class="line">               table.length));</span><br><span class="line">        &#125;</span><br><span class="line">        result.entrySet &#x3D; null;</span><br><span class="line">        result.modCount &#x3D; 0;</span><br><span class="line">        result.size &#x3D; 0;</span><br><span class="line">        result.init();</span><br><span class="line">        result.putAllForCreate(this);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;内部类，节点对象，每个节点包含下个节点的引用</span><br><span class="line">    static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        int hash;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 创建节点</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value &#x3D; v;</span><br><span class="line">            next &#x3D; n;</span><br><span class="line">            key &#x3D; k;</span><br><span class="line">            hash &#x3D; h;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;获取节点的key</span><br><span class="line">        public final K getKey() &#123;</span><br><span class="line">            return key;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;获取节点的value</span><br><span class="line">        public final V getValue() &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;设置新value，并返回旧的value</span><br><span class="line">        public final V setValue(V newValue) &#123;</span><br><span class="line">            V oldValue &#x3D; value;</span><br><span class="line">            value &#x3D; newValue;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断key和value是否相同,两个都“相等”，返回true</span><br><span class="line">        public final boolean equals(Object o) &#123;</span><br><span class="line">            if (!(o instanceof Map.Entry))</span><br><span class="line">                return false;</span><br><span class="line">            Map.Entry e &#x3D; (Map.Entry)o;</span><br><span class="line">            Object k1 &#x3D; getKey();</span><br><span class="line">            Object k2 &#x3D; e.getKey();</span><br><span class="line">            if (k1 &#x3D;&#x3D; k2 || (k1 !&#x3D; null &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">                Object v1 &#x3D; getValue();</span><br><span class="line">                Object v2 &#x3D; e.getValue();</span><br><span class="line">                if (v1 &#x3D;&#x3D; v2 || (v1 !&#x3D; null &amp;&amp; v1.equals(v2)))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final int hashCode() &#123;</span><br><span class="line">            return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final String toString() &#123;</span><br><span class="line">            return getKey() + &quot;&#x3D;&quot; + getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * This method is invoked whenever the value in an entry is</span><br><span class="line">         * overwritten by an invocation of put(k,v) for a key k that&#39;s already</span><br><span class="line">         * in the HashMap.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        void recordAccess(HashMap&lt;K,V&gt; m) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * This method is invoked whenever the entry is</span><br><span class="line">         * removed from the table.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        void recordRemoval(HashMap&lt;K,V&gt; m) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 添加新节点，如有必要，执行扩容操作</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;</span><br><span class="line">            resize(2 * table.length);</span><br><span class="line">            hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;</span><br><span class="line">            bucketIndex &#x3D; indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 插入单链表表头</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e &#x3D; table[bucketIndex];</span><br><span class="line">        table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;hashmap迭代器</span><br><span class="line">    private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next;        &#x2F;&#x2F; 下个键值对索引</span><br><span class="line">        int expectedModCount;   &#x2F;&#x2F; 用于判断快速失败行为</span><br><span class="line">        int index;              &#x2F;&#x2F; current slot</span><br><span class="line">        Entry&lt;K,V&gt; current;     &#x2F;&#x2F; current entry</span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            expectedModCount &#x3D; modCount;</span><br><span class="line">            if (size &gt; 0) &#123; &#x2F;&#x2F; advance to first entry</span><br><span class="line">                Entry[] t &#x3D; table;</span><br><span class="line">                while (index &lt; t.length &amp;&amp; (next &#x3D; t[index++]) &#x3D;&#x3D; null)</span><br><span class="line">                    ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final boolean hasNext() &#123;</span><br><span class="line">            return next !&#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final Entry&lt;K,V&gt; nextEntry() &#123;</span><br><span class="line">            if (modCount !&#x3D; expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            Entry&lt;K,V&gt; e &#x3D; next;</span><br><span class="line">            if (e &#x3D;&#x3D; null)</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line"></span><br><span class="line">            if ((next &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Entry[] t &#x3D; table;</span><br><span class="line">                while (index &lt; t.length &amp;&amp; (next &#x3D; t[index++]) &#x3D;&#x3D; null)</span><br><span class="line">                    ;</span><br><span class="line">            &#125;</span><br><span class="line">            current &#x3D; e;</span><br><span class="line">            return e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            if (current &#x3D;&#x3D; null)</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            if (modCount !&#x3D; expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            Object k &#x3D; current.key;</span><br><span class="line">            current &#x3D; null;</span><br><span class="line">            HashMap.this.removeEntryForKey(k);</span><br><span class="line">            expectedModCount &#x3D; modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;ValueIterator迭代器</span><br><span class="line">    private final class ValueIterator extends HashIterator&lt;V&gt; &#123;</span><br><span class="line">        public V next() &#123;</span><br><span class="line">            return nextEntry().value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;KeyIterator迭代器</span><br><span class="line">    private final class KeyIterator extends HashIterator&lt;K&gt; &#123;</span><br><span class="line">        public K next() &#123;</span><br><span class="line">            return nextEntry().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;&#x2F;KeyIterator迭代器</span><br><span class="line">    private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">        public Map.Entry&lt;K,V&gt; next() &#123;</span><br><span class="line">            return nextEntry();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 返回迭代器方法</span><br><span class="line">    Iterator&lt;K&gt; newKeyIterator()   &#123;</span><br><span class="line">        return new KeyIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;V&gt; newValueIterator()   &#123;</span><br><span class="line">        return new ValueIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()   &#123;</span><br><span class="line">        return new EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Views</span><br><span class="line"></span><br><span class="line">    private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回一个set集合，包含key</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Set&lt;K&gt; keySet() &#123;</span><br><span class="line">        Set&lt;K&gt; ks &#x3D; keySet;</span><br><span class="line">        return (ks !&#x3D; null ? ks : (keySet &#x3D; new KeySet()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final class KeySet extends AbstractSet&lt;K&gt; &#123;</span><br><span class="line">        public Iterator&lt;K&gt; iterator() &#123;</span><br><span class="line">            return newKeyIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        public int size() &#123;</span><br><span class="line">            return size;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean contains(Object o) &#123;</span><br><span class="line">            return containsKey(o);</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean remove(Object o) &#123;</span><br><span class="line">            return HashMap.this.removeEntryForKey(o) !&#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        public void clear() &#123;</span><br><span class="line">            HashMap.this.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回一个value集合，包含value</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Collection&lt;V&gt; values() &#123;</span><br><span class="line">        Collection&lt;V&gt; vs &#x3D; values;</span><br><span class="line">        return (vs !&#x3D; null ? vs : (values &#x3D; new Values()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final class Values extends AbstractCollection&lt;V&gt; &#123;</span><br><span class="line">        public Iterator&lt;V&gt; iterator() &#123;</span><br><span class="line">            return newValueIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        public int size() &#123;</span><br><span class="line">            return size;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean contains(Object o) &#123;</span><br><span class="line">            return containsValue(o);</span><br><span class="line">        &#125;</span><br><span class="line">        public void clear() &#123;</span><br><span class="line">            HashMap.this.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回一个键值对集合</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        return entrySet0();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es &#x3D; entrySet;</span><br><span class="line">        return es !&#x3D; null ? es : (entrySet &#x3D; new EntrySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">        public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            return newEntryIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean contains(Object o) &#123;</span><br><span class="line">            if (!(o instanceof Map.Entry))</span><br><span class="line">                return false;</span><br><span class="line">            Map.Entry&lt;K,V&gt; e &#x3D; (Map.Entry&lt;K,V&gt;) o;</span><br><span class="line">            Entry&lt;K,V&gt; candidate &#x3D; getEntry(e.getKey());</span><br><span class="line">            return candidate !&#x3D; null &amp;&amp; candidate.equals(e);</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean remove(Object o) &#123;</span><br><span class="line">            return removeMapping(o) !&#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        public int size() &#123;</span><br><span class="line">            return size;</span><br><span class="line">        &#125;</span><br><span class="line">        public void clear() &#123;</span><br><span class="line">            HashMap.this.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * map序列化,可实现深拷贝</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">        throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Write out the threshold, loadfactor, and any hidden stuff</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Write out number of buckets</span><br><span class="line">        if (table&#x3D;&#x3D;EMPTY_TABLE) &#123;</span><br><span class="line">            s.writeInt(roundUpToPowerOf2(threshold));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           s.writeInt(table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Write out size (number of Mappings)</span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Write out keys and values (alternating)</span><br><span class="line">        if (size &gt; 0) &#123;</span><br><span class="line">            for(Map.Entry&lt;K,V&gt; e : entrySet0()) &#123;</span><br><span class="line">                s.writeObject(e.getKey());</span><br><span class="line">                s.writeObject(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; 362498820763181265L;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 反序列化，读取字节码转为对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">         throws IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Read in the threshold (ignored), loadfactor, and any hidden stuff</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor)) &#123;</span><br><span class="line">            throw new InvalidObjectException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; set other fields that need values</span><br><span class="line">        table &#x3D; (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Read in number of buckets</span><br><span class="line">        s.readInt(); &#x2F;&#x2F; ignored.</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Read number of mappings</span><br><span class="line">        int mappings &#x3D; s.readInt();</span><br><span class="line">        if (mappings &lt; 0)</span><br><span class="line">            throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +</span><br><span class="line">                                               mappings);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; capacity chosen by number of mappings and desired load (if &gt;&#x3D; 0.25)</span><br><span class="line">        int capacity &#x3D; (int) Math.min(</span><br><span class="line">                    mappings * Math.min(1 &#x2F; loadFactor, 4.0f),</span><br><span class="line">                    &#x2F;&#x2F; we have limits...</span><br><span class="line">                    HashMap.MAXIMUM_CAPACITY);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; allocate the bucket array;</span><br><span class="line">        if (mappings &gt; 0) &#123;</span><br><span class="line">            inflateTable(capacity);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            threshold &#x3D; capacity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        init();  &#x2F;&#x2F; Give subclass a chance to do its thing.</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Read the keys and values, and put the mappings in the HashMap</span><br><span class="line">        for (int i &#x3D; 0; i &lt; mappings; i++) &#123;</span><br><span class="line">            K key &#x3D; (K) s.readObject();</span><br><span class="line">            V value &#x3D; (V) s.readObject();</span><br><span class="line">            putForCreate(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; These methods are used when serializing HashSets</span><br><span class="line">    int   capacity()     &#123; return table.length; &#125;</span><br><span class="line">    float loadFactor()   &#123; return loadFactor;   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容操作："><a href="#扩容操作：" class="headerlink" title="扩容操作："></a>扩容操作：</h2><p>==当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。==</p><h4 id="为何HashMap的数组长度一定是2的次幂？"><a href="#为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="为何HashMap的数组长度一定是2的次幂？"></a>为何HashMap的数组长度一定是2的次幂？</h4><ul><li>如果length为2的次幂  则length-1 转化为二进制必定是11111……的形式，在于h的二进制与操作效率会非常的快，<br>而且空间不浪费；</li><li>如果length不是2的次幂，比如length为15，则length-1为14，对应的二进制为1110，在于h与操作，</li><li>最后一位都为0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费</li></ul><h3 id="HashMap在多线程下，put死循环"><a href="#HashMap在多线程下，put死循环" class="headerlink" title="HashMap在多线程下，put死循环"></a>HashMap在多线程下，put死循环</h3><p>resize()扩容的时候，调用<br>transfer()方法，而这种方法实现的机制就是将每一个链表转化到新链表，而且链表中的位置发生反转，而这在多线程情况下是非常easy造成链表回路。从而发生get()死循环。我们看一下他的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable) &#123;</span><br><span class="line">    Entry[] src &#x3D; table;</span><br><span class="line">    int newCapacity &#x3D; newTable.length;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e &#x3D; src[j];</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            src[j] &#x3D; null;</span><br><span class="line">            do &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">                int i &#x3D; indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next &#x3D; newTable[i];</span><br><span class="line">                newTable[i] &#x3D; e;</span><br><span class="line">                e &#x3D; next;</span><br><span class="line">            &#125; while (e !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假如有两个线程P1、P2，以及链表 a–&gt;b–&gt;null</p><ul><li>1、P1先运行，运行完”Entry&lt;K,V&gt; next = e.next;”代码后发生堵塞，或者其它情况不再运行下去，此时e=a。next=b</li><li>2、而P2已经运行完整段代码，于是当前的新链表newTable[i]为b–&gt;a–&gt;null</li><li>3、P1又继续运行”Entry&lt;K,V&gt; next = e.next;”之后的代码，则运行完”e=next;”后，newTable[i]为a&lt;–&gt;b。则造成回路，while(e!=null)一直死循环</li></ul>]]></content>
      
      
      <categories>
          
          <category> java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap(JDK7) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CocurrentHashMap1.8</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/5%E3%80%81CocurrentHashMap1.8/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/5%E3%80%81CocurrentHashMap1.8/</url>
      
        <content type="html"><![CDATA[<ul><li><p>　HashMap ：HashMap是线程不安全的，在并发环境下，可能会形成环状链表（扩容时可能造成），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的。</p></li><li><p>HashTable ： HashTable和HashMap的实现原理几乎一样，差别无非是</p></li></ul><ol><li>HashTable不允许key和value为null；</li><li>HashTable是线程安全的。但是HashTable线程安全的策略是在get/put所有相关操作都是synchronized的</li></ol><p>HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的”分段锁”思想。</p><h4 id="1-8中放弃了1-7的Segment臃肿的设计，取而代之的是采用Node-CAS-Synchronized来保证并发安全进行实现"><a href="#1-8中放弃了1-7的Segment臃肿的设计，取而代之的是采用Node-CAS-Synchronized来保证并发安全进行实现" class="headerlink" title="==1.8中放弃了1.7的Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现=="></a>==1.8中放弃了1.7的Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现==</h4><h3 id="ConcurrentHashMap源码分析："><a href="#ConcurrentHashMap源码分析：" class="headerlink" title="ConcurrentHashMap源码分析："></a>ConcurrentHashMap源码分析：</h3><ol><li>Node类</li></ol><p>　　Node类主要用于存储具体键值对，其子类有ForwardingNode、ReservationNode、TreeNode和TreeBin四个子类</p><ol start="2"><li>Traverser类</li></ol><p>　　Traverser类主要用于遍历操作，其子类有BaseIterator、KeySpliterator、ValueSpliterator、EntrySpliterator四个类，BaseIterator用于遍历操作。KeySplitertor、ValueSpliterator、EntrySpliterator则用于键、值、键值对的划分。</p><ol start="3"><li>CollectionView类</li></ol><p>　　CollectionView抽象类主要定义了视图操作，其子类KeySetView、ValueSetView、EntrySetView分别表示键视图、值视图、键值对视图。对视图均可以进行操作。</p><ol start="4"><li>Segment类</li></ol><p>　　Segment类在JDK1.8中与之前的版本的JDK作用存在很大的差别，JDK1.8下，其在普通的ConcurrentHashMap操作中已经没有失效，其在序列化与反序列化的时候会发挥作用。</p><ol start="5"><li>CounterCell</li></ol><p>CounterCell类主要用于对baseCount的计数。</p><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements ConcurrentMap&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 7249069246763182397L;</span><br><span class="line">    &#x2F;&#x2F; 表的最大容量</span><br><span class="line">    private static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line">    &#x2F;&#x2F; 默认表的大小</span><br><span class="line">    private static final int DEFAULT_CAPACITY &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 最大数组大小</span><br><span class="line">    static final int MAX_ARRAY_SIZE &#x3D; Integer.MAX_VALUE - 8;</span><br><span class="line">    &#x2F;&#x2F; 默认并发数</span><br><span class="line">    private static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 装载因子</span><br><span class="line">    private static final float LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">    &#x2F;&#x2F; 转化为红黑树的阈值</span><br><span class="line">    static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line">    &#x2F;&#x2F; 由红黑树转化为链表的阈值</span><br><span class="line">    static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line">    &#x2F;&#x2F; 转化为红黑树的表的最小容量</span><br><span class="line">    static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br><span class="line">    &#x2F;&#x2F; 每次进行转移的最小值</span><br><span class="line">    private static final int MIN_TRANSFER_STRIDE &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 生成sizeCtl所使用的bit位数</span><br><span class="line">    private static int RESIZE_STAMP_BITS &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 进行扩容所允许的最大线程数</span><br><span class="line">    private static final int MAX_RESIZERS &#x3D; (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;</span><br><span class="line">    &#x2F;&#x2F; 记录sizeCtl中的大小所需要进行的偏移位数</span><br><span class="line">    private static final int RESIZE_STAMP_SHIFT &#x3D; 32 - RESIZE_STAMP_BITS;    </span><br><span class="line">    &#x2F;&#x2F; 一系列的标识</span><br><span class="line">    static final int MOVED     &#x3D; -1; &#x2F;&#x2F; hash for forwarding nodes</span><br><span class="line">    static final int TREEBIN   &#x3D; -2; &#x2F;&#x2F; hash for roots of trees</span><br><span class="line">    static final int RESERVED  &#x3D; -3; &#x2F;&#x2F; hash for transient reservations</span><br><span class="line">    static final int HASH_BITS &#x3D; 0x7fffffff; &#x2F;&#x2F; usable bits of normal node hash</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    &#x2F;** Number of CPUS, to place bounds on some sizings *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 获取可用的CPU个数</span><br><span class="line">    static final int NCPU &#x3D; Runtime.getRuntime().availableProcessors();</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    &#x2F;** For serialization compatibility. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 进行序列化的属性</span><br><span class="line">    private static final ObjectStreamField[] serialPersistentFields &#x3D; &#123;</span><br><span class="line">        new ObjectStreamField(&quot;segments&quot;, Segment[].class),</span><br><span class="line">        new ObjectStreamField(&quot;segmentMask&quot;, Integer.TYPE),</span><br><span class="line">        new ObjectStreamField(&quot;segmentShift&quot;, Integer.TYPE)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 表</span><br><span class="line">    transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line">    &#x2F;&#x2F; 下一个表</span><br><span class="line">    private transient volatile Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Base counter value, used mainly when there is no contention,</span><br><span class="line">     * but also as a fallback during table initialization</span><br><span class="line">     * races. Updated via CAS.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 基本计数</span><br><span class="line">    private transient volatile long baseCount;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Table initialization and resizing control.  When negative, the</span><br><span class="line">     * table is being initialized or resized: -1 for initialization,</span><br><span class="line">     * else -(1 + the number of active resizing threads).  Otherwise,</span><br><span class="line">     * when table is null, holds the initial table size to use upon</span><br><span class="line">     * creation, or 0 for default. After initialization, holds the</span><br><span class="line">     * next element count value upon which to resize the table.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 对表初始化和扩容控制</span><br><span class="line">    private transient volatile int sizeCtl;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The next table index (plus one) to split while resizing.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 扩容下另一个表的索引</span><br><span class="line">    private transient volatile int transferIndex;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Spinlock (locked via CAS) used when resizing and&#x2F;or creating CounterCells.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 旋转锁</span><br><span class="line">    private transient volatile int cellsBusy;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Table of counter cells. When non-null, size is a power of 2.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; counterCell表</span><br><span class="line">    private transient volatile CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; views</span><br><span class="line">    &#x2F;&#x2F; 视图</span><br><span class="line">    private transient KeySetView&lt;K,V&gt; keySet;</span><br><span class="line">    private transient ValuesView&lt;K,V&gt; values;</span><br><span class="line">    private transient EntrySetView&lt;K,V&gt; entrySet;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Unsafe mechanics</span><br><span class="line">    private static final sun.misc.Unsafe U;</span><br><span class="line">    private static final long SIZECTL;</span><br><span class="line">    private static final long TRANSFERINDEX;</span><br><span class="line">    private static final long BASECOUNT;</span><br><span class="line">    private static final long CELLSBUSY;</span><br><span class="line">    private static final long CELLVALUE;</span><br><span class="line">    private static final long ABASE;</span><br><span class="line">    private static final int ASHIFT;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            U &#x3D; sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k &#x3D; ConcurrentHashMap.class;</span><br><span class="line">            SIZECTL &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;sizeCtl&quot;));</span><br><span class="line">            TRANSFERINDEX &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;transferIndex&quot;));</span><br><span class="line">            BASECOUNT &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;baseCount&quot;));</span><br><span class="line">            CELLSBUSY &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;cellsBusy&quot;));</span><br><span class="line">            Class&lt;?&gt; ck &#x3D; CounterCell.class;</span><br><span class="line">            CELLVALUE &#x3D; U.objectFieldOffset</span><br><span class="line">                (ck.getDeclaredField(&quot;value&quot;));</span><br><span class="line">            Class&lt;?&gt; ak &#x3D; Node[].class;</span><br><span class="line">            ABASE &#x3D; U.arrayBaseOffset(ak);</span><br><span class="line">            int scale &#x3D; U.arrayIndexScale(ak);</span><br><span class="line">            if ((scale &amp; (scale - 1)) !&#x3D; 0)</span><br><span class="line">                throw new Error(&quot;data type scale not a power of two&quot;);</span><br><span class="line">            ASHIFT &#x3D; 31 - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用于创建一个带有默认初始容量 (16)、加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。</span><br><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;创建一个带有指定初始容量、默认加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。</span><br><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity &lt; 0) &#x2F;&#x2F; 初始容量小于0，抛出异常</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        int cap &#x3D; ((initialCapacity &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); &#x2F;&#x2F; 找到最接近该容量的2的幂次方数</span><br><span class="line">        &#x2F;&#x2F; 初始化</span><br><span class="line">        this.sizeCtl &#x3D; cap;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;构造一个与给定映射具有相同映射关系的新映射。</span><br><span class="line">    public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this.sizeCtl &#x3D; DEFAULT_CAPACITY;</span><br><span class="line">        &#x2F;&#x2F; 将集合m的元素全部放入</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个带有指定初始容量、加载因子和默认 concurrencyLevel (1) 的新的空映射。</span><br><span class="line">     public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        this(initialCapacity, loadFactor, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个带有指定初始容量、加载因子和并发级别的新的空映射。</span><br><span class="line">    public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                             float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">        if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0) &#x2F;&#x2F; 合法性判断</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (initialCapacity &lt; concurrencyLevel)   &#x2F;&#x2F; Use at least as many bins</span><br><span class="line">            initialCapacity &#x3D; concurrencyLevel;   &#x2F;&#x2F; as estimated threads</span><br><span class="line">        long size &#x3D; (long)(1.0 + (long)initialCapacity &#x2F; loadFactor);</span><br><span class="line">        int cap &#x3D; (size &gt;&#x3D; (long)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((int)size);</span><br><span class="line">        this.sizeCtl &#x3D; cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="putVal函数"><a href="#putVal函数" class="headerlink" title="putVal函数"></a>putVal函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">        if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException(); &#x2F;&#x2F; 键或值为空，抛出异常</span><br><span class="line">        &#x2F;&#x2F; 键的hash值经过计算获得hash值</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        int binCount &#x3D; 0;</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) &#x2F;&#x2F; 表为空或者表的长度为0</span><br><span class="line">                &#x2F;&#x2F; 初始化表</span><br><span class="line">                tab &#x3D; initTable();</span><br><span class="line">            else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 表不为空并且表的长度大于0，并且该桶不为空</span><br><span class="line">                if (casTabAt(tab, i, null,</span><br><span class="line">                             new Node&lt;K,V&gt;(hash, key, value, null))) &#x2F;&#x2F; 比较并且交换值，如tab的第i项为空则用新生成的node替换</span><br><span class="line">                    break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED) &#x2F;&#x2F; 该结点的hash值为MOVED</span><br><span class="line">                &#x2F;&#x2F; 进行结点的转移（在扩容的过程中）</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                synchronized (f) &#123; &#x2F;&#x2F; 加锁同步</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123; &#x2F;&#x2F; 找到table表下标为i的节点</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 该table表中该结点的hash值大于0</span><br><span class="line">                            &#x2F;&#x2F; binCount赋值为1</span><br><span class="line">                            binCount &#x3D; 1;</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123; &#x2F;&#x2F; 结点的hash值相等并且key也相等</span><br><span class="line">                                    &#x2F;&#x2F; 保存该结点的val值</span><br><span class="line">                                    oldVal &#x3D; e.val;</span><br><span class="line">                                    if (!onlyIfAbsent) &#x2F;&#x2F; 进行判断</span><br><span class="line">                                        &#x2F;&#x2F; 将指定的value保存至结点，即进行了结点值的更新</span><br><span class="line">                                        e.val &#x3D; value;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                &#x2F;&#x2F; 保存当前结点</span><br><span class="line">                                Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 当前结点的下一个结点为空，即为最后一个结点</span><br><span class="line">                                    &#x2F;&#x2F; 新生一个结点并且赋值给next域</span><br><span class="line">                                    pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, null);</span><br><span class="line">                                    &#x2F;&#x2F; 退出循环</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 结点为红黑树结点类型</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            &#x2F;&#x2F; binCount赋值为2</span><br><span class="line">                            binCount &#x3D; 2;</span><br><span class="line">                            if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) !&#x3D; null) &#123; &#x2F;&#x2F; 将hash、key、value放入红黑树</span><br><span class="line">                                &#x2F;&#x2F; 保存结点的val</span><br><span class="line">                                oldVal &#x3D; p.val;</span><br><span class="line">                                if (!onlyIfAbsent) &#x2F;&#x2F; 判断</span><br><span class="line">                                    &#x2F;&#x2F; 赋值结点value值</span><br><span class="line">                                    p.val &#x3D; value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (binCount !&#x3D; 0) &#123; &#x2F;&#x2F; binCount不为0</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD) &#x2F;&#x2F; 如果binCount大于等于转化为红黑树的阈值</span><br><span class="line">                        &#x2F;&#x2F; 进行转化</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    if (oldVal !&#x3D; null) &#x2F;&#x2F; 旧值不为空</span><br><span class="line">                        &#x2F;&#x2F; 返回旧值</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 增加binCount的数量</span><br><span class="line">        addCount(1L, binCount);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：put函数底层调用了putVal进行数据的插入，对于putVal函数的流程大体如下。</p><p>　　① 判断存储的key、value是否为空，若为空，则抛出异常，否则，进入步骤②</p><p>　　② 计算key的hash值，随后进入无限循环，该无限循环可以确保成功插入数据，若table表为空或者长度为0，则初始化table表，否则，进入步骤③</p><p>　　③ 根据key的hash值取出table表中的结点元素，若取出的结点为空（该桶为空），则使用CAS将key、value、hash值生成的结点放入桶中。否则，进入步骤④</p><p>　　④ 若该结点的的hash值为MOVED，则对该桶中的结点进行转移，否则，进入步骤⑤</p><p>　　⑤ 对桶中的第一个结点（即table表中的结点）进行加锁，对该桶进行遍历，桶中的结点的hash值与key值与给定的hash值和key值相等，则根据标识选择是否进行更新操作（用给定的value值替换该结点的value值），若遍历完桶仍没有找到hash值与key值和指定的hash值与key值相等的结点，则直接新生一个结点并赋值为之前最后一个结点的下一个结点。进入步骤⑥</p><p>　　⑥ 若binCount值达到红黑树转化的阈值，则将桶中的结构转化为红黑树存储，最后，增加binCount的值。</p><p>　　在putVal函数中会涉及到如下几个函数：initTable、tabAt、casTabAt、helpTransfer、putTreeVal、treeifyBin、addCount函数。下面对其中涉及到的函数进行分析。</p><h3 id="initTable"><a href="#initTable" class="headerlink" title="　　initTable"></a>　　initTable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">        while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            if ((sc &#x3D; sizeCtl) &lt; 0) &#x2F;&#x2F; sizeCtl小于0，则进行线程让步等待</span><br><span class="line">                Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin</span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; &#x2F;&#x2F; 比较sizeCtl的值与sc是否相等，相等则用-1替换</span><br><span class="line">                try &#123;</span><br><span class="line">                    if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; table表为空或者大小为0</span><br><span class="line">                        &#x2F;&#x2F; sc的值是否大于0，若是，则n为sc，否则，n为默认初始容量</span><br><span class="line">                        int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                        &#x2F;&#x2F; 新生结点数组</span><br><span class="line">                        Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                        &#x2F;&#x2F; 赋值给table</span><br><span class="line">                        table &#x3D; tab &#x3D; nt;</span><br><span class="line">                        &#x2F;&#x2F; sc为n * 3&#x2F;4</span><br><span class="line">                        sc &#x3D; n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    &#x2F;&#x2F; 设置sizeCtl的值</span><br><span class="line">                    sizeCtl &#x3D; sc;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 返回table表</span><br><span class="line">        return tab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于table的大小，会根据sizeCtl的值进行设置，如果没有设置szieCtl的值，那么默认生成的table大小为16，否则，会根据sizeCtl的大小设置table大小。</p><h3 id="tabAt函数"><a href="#tabAt函数" class="headerlink" title="tabAt函数"></a>tabAt函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</span><br><span class="line">        return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数返回table数组中下标为i的结点，可以看到是通过Unsafe对象通过反射获取的，getObjectVolatile的第二项参数为下标为i的偏移地址。</p><h3 id="casTabAt函数"><a href="#casTabAt函数" class="headerlink" title="casTabAt函数"></a>casTabAt函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,</span><br><span class="line">                                      Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</span><br><span class="line">      return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此函数用于比较table数组下标为i的结点是否为c，若为c，则用v交换操作。否则，不进行交换操作。</p><h3 id="helpTransfer函数"><a href="#helpTransfer函数" class="headerlink" title="helpTransfer函数"></a>helpTransfer函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">        if (tab !&#x3D; null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">            (nextTab &#x3D; ((ForwardingNode&lt;K,V&gt;)f).nextTable) !&#x3D; null) &#123; &#x2F;&#x2F; table表不为空并且结点类型使ForwardingNode类型，并且结点的nextTable不为空</span><br><span class="line">            int rs &#x3D; resizeStamp(tab.length);</span><br><span class="line">            while (nextTab &#x3D;&#x3D; nextTable &amp;&amp; table &#x3D;&#x3D; tab &amp;&amp;</span><br><span class="line">                   (sc &#x3D; sizeCtl) &lt; 0) &#123; &#x2F;&#x2F; 条件判断</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                    sc &#x3D;&#x3D; rs + MAX_RESIZERS || transferIndex &lt;&#x3D; 0) &#x2F;&#x2F; </span><br><span class="line">                    break;</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; &#x2F;&#x2F; 比较并交换</span><br><span class="line">                    &#x2F;&#x2F; 将table的结点转移到nextTab中</span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        return table;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此函数用于在扩容时将table表中的结点转移到nextTable中。</p><h3 id="putTreeVal函数"><a href="#putTreeVal函数" class="headerlink" title="putTreeVal函数"></a>putTreeVal函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">final TreeNode&lt;K,V&gt; putTreeVal(int h, K k, V v) &#123;</span><br><span class="line">            Class&lt;?&gt; kc &#x3D; null;</span><br><span class="line">            boolean searched &#x3D; false;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; p &#x3D; root;;) &#123;</span><br><span class="line">                int dir, ph; K pk;</span><br><span class="line">                if (p &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    first &#x3D; root &#x3D; new TreeNode&lt;K,V&gt;(h, k, v, null, null);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else if ((ph &#x3D; p.hash) &gt; h)</span><br><span class="line">                    dir &#x3D; -1;</span><br><span class="line">                else if (ph &lt; h)</span><br><span class="line">                    dir &#x3D; 1;</span><br><span class="line">                else if ((pk &#x3D; p.key) &#x3D;&#x3D; k || (pk !&#x3D; null &amp;&amp; k.equals(pk)))</span><br><span class="line">                    return p;</span><br><span class="line">                else if ((kc &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">                          (kc &#x3D; comparableClassFor(k)) &#x3D;&#x3D; null) ||</span><br><span class="line">                         (dir &#x3D; compareComparables(kc, k, pk)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    if (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched &#x3D; true;</span><br><span class="line">                        if (((ch &#x3D; p.left) !&#x3D; null &amp;&amp;</span><br><span class="line">                             (q &#x3D; ch.findTreeNode(h, k, kc)) !&#x3D; null) ||</span><br><span class="line">                            ((ch &#x3D; p.right) !&#x3D; null &amp;&amp;</span><br><span class="line">                             (q &#x3D; ch.findTreeNode(h, k, kc)) !&#x3D; null))</span><br><span class="line">                            return q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir &#x3D; tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp &#x3D; p;</span><br><span class="line">                if ((p &#x3D; (dir &lt;&#x3D; 0) ? p.left : p.right) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x, f &#x3D; first;</span><br><span class="line">                    first &#x3D; x &#x3D; new TreeNode&lt;K,V&gt;(h, k, v, f, xp);</span><br><span class="line">                    if (f !&#x3D; null)</span><br><span class="line">                        f.prev &#x3D; x;</span><br><span class="line">                    if (dir &lt;&#x3D; 0)</span><br><span class="line">                        xp.left &#x3D; x;</span><br><span class="line">                    else</span><br><span class="line">                        xp.right &#x3D; x;</span><br><span class="line">                    if (!xp.red)</span><br><span class="line">                        x.red &#x3D; true;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        lockRoot();</span><br><span class="line">                        try &#123;</span><br><span class="line">                            root &#x3D; balanceInsertion(root, x);</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            unlockRoot();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            assert checkInvariants(root);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>　说明：此函数用于将指定的hash、key、value值添加到红黑树中，若已经添加了，则返回null，否则返回该结点。</p><h3 id="treeifyBin函数"><a href="#treeifyBin函数" class="headerlink" title="　treeifyBin函数"></a>　treeifyBin函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</span><br><span class="line">        Node&lt;K,V&gt; b; int n, sc;</span><br><span class="line">        if (tab !&#x3D; null) &#123; &#x2F;&#x2F; 表不为空</span><br><span class="line">            if ((n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY) &#x2F;&#x2F; table表的长度小于最小的长度</span><br><span class="line">                &#x2F;&#x2F; 进行扩容，调整某个桶中结点数量过多的问题（由于某个桶中结点数量超出了阈值，则触发treeifyBin）</span><br><span class="line">                tryPresize(n &lt;&lt; 1);</span><br><span class="line">            else if ((b &#x3D; tabAt(tab, index)) !&#x3D; null &amp;&amp; b.hash &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 桶中存在结点并且结点的hash值大于等于0</span><br><span class="line">                synchronized (b) &#123; &#x2F;&#x2F; 对桶中第一个结点进行加锁</span><br><span class="line">                    if (tabAt(tab, index) &#x3D;&#x3D; b) &#123; &#x2F;&#x2F; 第一个结点没有变化</span><br><span class="line">                        TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;</span><br><span class="line">                        for (Node&lt;K,V&gt; e &#x3D; b; e !&#x3D; null; e &#x3D; e.next) &#123; &#x2F;&#x2F; 遍历桶中所有结点</span><br><span class="line">                            &#x2F;&#x2F; 新生一个TreeNode结点</span><br><span class="line">                            TreeNode&lt;K,V&gt; p &#x3D;</span><br><span class="line">                                new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                  null, null);</span><br><span class="line">                            if ((p.prev &#x3D; tl) &#x3D;&#x3D; null) &#x2F;&#x2F; 该结点前驱为空</span><br><span class="line">                                &#x2F;&#x2F; 设置p为头结点</span><br><span class="line">                                hd &#x3D; p;</span><br><span class="line">                            else</span><br><span class="line">                                &#x2F;&#x2F; 尾节点的next域赋值为p</span><br><span class="line">                                tl.next &#x3D; p;</span><br><span class="line">                            &#x2F;&#x2F; 尾节点赋值为p</span><br><span class="line">                            tl &#x3D; p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; 设置table表中下标为index的值为hd</span><br><span class="line">                        setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此函数用于将桶中的数据结构转化为红黑树，其中，值得注意的是，当table的长度未达到阈值时，会进行一次扩容操作，该操作会使得触发treeifyBin操作的某个桶中的所有元素进行一次重新分配，这样可以避免某个桶中的结点数量太大。</p><h3 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private final void addCount(long x, int check) &#123;</span><br><span class="line">        CounterCell[] as; long b, s;</span><br><span class="line">        if ((as &#x3D; counterCells) !&#x3D; null ||</span><br><span class="line">            !U.compareAndSwapLong(this, BASECOUNT, b &#x3D; baseCount, s &#x3D; b + x)) &#123; &#x2F;&#x2F; counterCells不为空或者比较交换失败</span><br><span class="line">            CounterCell a; long v; int m;</span><br><span class="line">            &#x2F;&#x2F; 无竞争标识</span><br><span class="line">            boolean uncontended &#x3D; true;</span><br><span class="line">            if (as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0 ||</span><br><span class="line">                (a &#x3D; as[ThreadLocalRandom.getProbe() &amp; m]) &#x3D;&#x3D; null ||</span><br><span class="line">                !(uncontended &#x3D;</span><br><span class="line">                  U.compareAndSwapLong(a, CELLVALUE, v &#x3D; a.value, v + x))) &#123; &#x2F;&#x2F; </span><br><span class="line">                fullAddCount(x, uncontended);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (check &lt;&#x3D; 1)</span><br><span class="line">                return;</span><br><span class="line">            s &#x3D; sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">        if (check &gt;&#x3D; 0) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; int n, sc;</span><br><span class="line">            while (s &gt;&#x3D; (long)(sc &#x3D; sizeCtl) &amp;&amp; (tab &#x3D; table) !&#x3D; null &amp;&amp;</span><br><span class="line">                   (n &#x3D; tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                int rs &#x3D; resizeStamp(n);</span><br><span class="line">                if (sc &lt; 0) &#123;</span><br><span class="line">                    if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                        sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||</span><br><span class="line">                        transferIndex &lt;&#x3D; 0)</span><br><span class="line">                        break;</span><br><span class="line">                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                    transfer(tab, null);</span><br><span class="line">                s &#x3D; sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数主要完成binCount的值加1的操作。</p><h3 id="get函数"><a href="#get函数" class="headerlink" title="get函数"></a>get函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">        &#x2F;&#x2F; 计算key的hash值</span><br><span class="line">        int h &#x3D; spread(key.hashCode()); </span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123; &#x2F;&#x2F; 表不为空并且表的长度大于0并且key所在的桶不为空</span><br><span class="line">            if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123; &#x2F;&#x2F; 表中的元素的hash值与key的hash值相等</span><br><span class="line">                if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))) &#x2F;&#x2F; 键相等</span><br><span class="line">                    &#x2F;&#x2F; 返回值</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (eh &lt; 0) &#x2F;&#x2F; 结点hash值小于0</span><br><span class="line">                &#x2F;&#x2F; 在桶（链表&#x2F;红黑树）中查找</span><br><span class="line">                return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;</span><br><span class="line">            while ((e &#x3D; e.next) !&#x3D; null) &#123; &#x2F;&#x2F; 对于结点hash值大于0的情况</span><br><span class="line">                if (e.hash &#x3D;&#x3D; h &amp;&amp;</span><br><span class="line">                    ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>get函数根据key的hash值来计算在哪个桶中，再遍历桶，查找元素，若找到则返回该结点，否则，返回null。</p><h3 id="replaceNode函数"><a href="#replaceNode函数" class="headerlink" title="replaceNode函数"></a>replaceNode函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">final V replaceNode(Object key, V value, Object cv) &#123;</span><br><span class="line">        &#x2F;&#x2F; 计算key的hash值</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0 ||</span><br><span class="line">                (f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#x2F;&#x2F; table表为空或者表长度为0或者key所对应的桶为空</span><br><span class="line">                &#x2F;&#x2F; 跳出循环</span><br><span class="line">                break;</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED) &#x2F;&#x2F; 桶中第一个结点的hash值为MOVED</span><br><span class="line">                &#x2F;&#x2F; 转移</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                boolean validated &#x3D; false;</span><br><span class="line">                synchronized (f) &#123; &#x2F;&#x2F; 加锁同步</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123; &#x2F;&#x2F; 桶中的第一个结点没有发生变化</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 结点hash值大于0</span><br><span class="line">                            validated &#x3D; true;</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f, pred &#x3D; null;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123; &#x2F;&#x2F; 结点的hash值与指定的hash值相等，并且key也相等</span><br><span class="line">                                    V ev &#x3D; e.val;</span><br><span class="line">                                    if (cv &#x3D;&#x3D; null || cv &#x3D;&#x3D; ev ||</span><br><span class="line">                                        (ev !&#x3D; null &amp;&amp; cv.equals(ev))) &#123; &#x2F;&#x2F; cv为空或者与结点value相等或者不为空并且相等</span><br><span class="line">                                        &#x2F;&#x2F; 保存该结点的val值</span><br><span class="line">                                        oldVal &#x3D; ev;</span><br><span class="line">                                        if (value !&#x3D; null) &#x2F;&#x2F; value为null</span><br><span class="line">                                            &#x2F;&#x2F; 设置结点value值</span><br><span class="line">                                            e.val &#x3D; value;</span><br><span class="line">                                        else if (pred !&#x3D; null) &#x2F;&#x2F; 前驱不为空</span><br><span class="line">                                            &#x2F;&#x2F; 前驱的后继为e的后继，即删除了e结点</span><br><span class="line">                                            pred.next &#x3D; e.next;</span><br><span class="line">                                        else</span><br><span class="line">                                            &#x2F;&#x2F; 设置table表中下标为index的值为e.next</span><br><span class="line">                                            setTabAt(tab, i, e.next);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                pred &#x3D; e;</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null)</span><br><span class="line">                                    break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 为红黑树结点类型</span><br><span class="line">                            validated &#x3D; true;</span><br><span class="line">                            &#x2F;&#x2F; 类型转化</span><br><span class="line">                            TreeBin&lt;K,V&gt; t &#x3D; (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                            if ((r &#x3D; t.root) !&#x3D; null &amp;&amp;</span><br><span class="line">                                (p &#x3D; r.findTreeNode(hash, key, null)) !&#x3D; null) &#123; &#x2F;&#x2F; 根节点不为空并且存在与指定hash和key相等的结点</span><br><span class="line">                                &#x2F;&#x2F; 保存p结点的value</span><br><span class="line">                                V pv &#x3D; p.val;</span><br><span class="line">                                if (cv &#x3D;&#x3D; null || cv &#x3D;&#x3D; pv ||</span><br><span class="line">                                    (pv !&#x3D; null &amp;&amp; cv.equals(pv))) &#123; &#x2F;&#x2F; cv为空或者与结点value相等或者不为空并且相等</span><br><span class="line">                                    oldVal &#x3D; pv;</span><br><span class="line">                                    if (value !&#x3D; null) </span><br><span class="line">                                        p.val &#x3D; value;</span><br><span class="line">                                    else if (t.removeTreeNode(p)) &#x2F;&#x2F; 移除p结点</span><br><span class="line">                                        setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (validated) &#123;</span><br><span class="line">                    if (oldVal !&#x3D; null) &#123;</span><br><span class="line">                        if (value &#x3D;&#x3D; null)</span><br><span class="line">                            &#x2F;&#x2F; baseCount值减一</span><br><span class="line">                            addCount(-1L, -1);</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数对remove函数提供支持，remove函数底层是调用的replaceNode函数实现结点的删除。　</p><p>ConcurrentHashMap的性能相比HashMap的线程安全同步集合和Hashtable而言，性能都要高出不少。原因是经过Collections封装的线程安全的HashMap和Hashtable都是对整个结构加锁，而ConcurrentHashMap是对每一个桶单独进行锁操作，不同的桶之间的操作不会相互影响，可以并发执行。因此，其速度会快很多。</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocurrentHashMap1.8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建SSM框架</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/spring-mvc/%E6%90%AD%E5%BB%BASSM%E6%A1%86%E6%9E%B6/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/spring-mvc/%E6%90%AD%E5%BB%BASSM%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>1、项目工程结构：</p><pre><code>    demo-parent:pom        demo-api:jar 【存放实体和接口】        demo-utils:jar        demo-mapper:jar (依赖api,utils)        demo-service:jar (依赖mapper)【接口实现】        demo-controller:war (依赖service)</code></pre><h3 id="1、在项目入口web-xml加载mvc和spring的核心配置文件："><a href="#1、在项目入口web-xml加载mvc和spring的核心配置文件：" class="headerlink" title="1、在项目入口web.xml加载mvc和spring的核心配置文件："></a>1、在项目入口web.xml加载mvc和spring的核心配置文件：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_2_5.xsd&quot; version&#x3D;&quot;2.5&quot;&gt;</span><br><span class="line">  &lt;display-name&gt;mcms-rule-controller&lt;&#x2F;display-name&gt;</span><br><span class="line">  &lt;welcome-file-list&gt;</span><br><span class="line">    &lt;welcome-file&gt;index.html&lt;&#x2F;welcome-file&gt;</span><br><span class="line">  &lt;&#x2F;welcome-file-list&gt;</span><br><span class="line">  &lt;context-param&gt;</span><br><span class="line">&lt;!--  spring核心配置文件--&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath*:application-mybatis.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">  &lt;&#x2F;context-param&gt;</span><br><span class="line">  &lt;listener&gt;</span><br><span class="line">    &lt;!--容器启动监听器，加载spring核心配置文件--&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">  &lt;&#x2F;listener&gt;</span><br><span class="line">  &lt;!--springMVC的前端控制器，加载mvc配置文件--&gt;</span><br><span class="line">  &lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">      &lt;param-value&gt;classpath:application-mvc.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;</span><br><span class="line">  &lt;&#x2F;servlet&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class="line">  &lt;&#x2F;servlet-mapping&gt;</span><br><span class="line">  &lt;!--编码过滤器--&gt;</span><br><span class="line">  &lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;SpringEncodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;</span><br><span class="line">      &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;forceEncoding&lt;&#x2F;param-name&gt;</span><br><span class="line">      &lt;param-value&gt;true&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;</span><br><span class="line">  &lt;&#x2F;filter&gt;</span><br><span class="line">  &lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;SpringEncodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">  &lt;&#x2F;filter-mapping&gt;</span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure><h3 id="2、在controller的resource资源文件路径下编写mvc的配置文件"><a href="#2、在controller的resource资源文件路径下编写mvc的配置文件" class="headerlink" title="2、在controller的resource资源文件路径下编写mvc的配置文件"></a>2、在controller的resource资源文件路径下编写mvc的配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;</span><br><span class="line">xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">xmlns:task&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;task&quot;</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-4.0.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc-4.0.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context-4.0.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;task</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;task&#x2F;spring-task-4.0.xsd &quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注解驱动,自动注册 映射器处理器 映射器适配器,加载json数据转换器 --&gt;</span><br><span class="line">&lt;mvc:annotation-driven conversion-service&#x3D;&quot;conversionService&quot;&gt;</span><br><span class="line">&lt;mvc:message-converters&gt;</span><br><span class="line">&lt;bean class&#x3D;&quot;org.springframework.http.converter.StringHttpMessageConverter&quot; &#x2F;&gt;</span><br><span class="line">&lt;bean</span><br><span class="line">class&#x3D;&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mvc:message-converters&gt;</span><br><span class="line">&lt;&#x2F;mvc:annotation-driven&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- &lt;bean id&#x3D;&quot;jsonConverter&quot; class&#x3D;&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;&lt;&#x2F;bean&gt; </span><br><span class="line">&lt;bean class&#x3D;&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt; </span><br><span class="line">&lt;property name&#x3D;&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;ref bean&#x3D;&quot;jsonConverter&quot; &#x2F;&gt; &lt;&#x2F;list&gt; </span><br><span class="line">&lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 扫描controller 排除扫描service --&gt;</span><br><span class="line">&lt;!-- &lt;context:component-scan base-package&#x3D;&quot;com.lxtd.cca.service&quot;&gt;&lt;&#x2F;context:component-scan&gt; --&gt;</span><br><span class="line">&lt;context:component-scan base-package&#x3D;&quot;com.mcms.rule.controller&quot;&gt;</span><br><span class="line">&lt;context:exclude-filter type&#x3D;&quot;annotation&quot;</span><br><span class="line">expression&#x3D;&quot;org.springframework.stereotype.Service&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 没有映射到的URL交给默认的web容器中的servlet进行处理 --&gt;</span><br><span class="line">&lt;mvc:default-servlet-handler &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 视图解析器 --&gt;</span><br><span class="line">&lt;bean</span><br><span class="line">class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 拦截器配置 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 校验错误信息配置文件 --&gt;</span><br><span class="line">&lt;!-- &lt;bean id&#x3D;&quot;messageSource&quot; class&#x3D;&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt; </span><br><span class="line">资源文件名 &lt;property name&#x3D;&quot;basenames&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:LxtdValidationMessage&lt;&#x2F;value&gt; </span><br><span class="line">&lt;&#x2F;list&gt; &lt;&#x2F;property&gt; 资源文件编码格式 &lt;property name&#x3D;&quot;fileEncodings&quot; value&#x3D;&quot;utf-8&quot; </span><br><span class="line">&#x2F;&gt; 对资源文件内容缓存时间，单位秒 &lt;property name&#x3D;&quot;cacheSeconds&quot; value&#x3D;&quot;120&quot; &#x2F;&gt; &lt;&#x2F;bean&gt; --&gt;</span><br><span class="line">&lt;!-- 文件解析器 --&gt;</span><br><span class="line">&lt;!-- 日期参数类型转化器 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;conversionService&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;converters&quot;&gt;</span><br><span class="line">&lt;list&gt;</span><br><span class="line">&lt;bean class&#x3D;&quot;com.mcms.rule.converter.DateConverter&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;list&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 全局异常捕捉执行类 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;exceptionResolver&quot; class&#x3D;&quot;com.mcms.rule.exception.resolve.GlobalExceptionResolver&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3、配置spring的核心配置文件"><a href="#3、配置spring的核心配置文件" class="headerlink" title="3、配置spring的核心配置文件"></a>3、配置spring的核心配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;</span><br><span class="line">xmlns:c&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;c&quot; xmlns:util&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&quot;</span><br><span class="line">xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot; xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;</span><br><span class="line">xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">xmlns:ehcache&#x3D;&quot;http:&#x2F;&#x2F;www.springmodules.org&#x2F;schema&#x2F;ehcache&quot;</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-3.1.xsd  </span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&#x2F;spring-util-3.1.xsd  </span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx-3.1.xsd  </span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context-3.1.xsd  </span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc-3.1.xsd  </span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop-3.1.xsd  </span><br><span class="line">        http:&#x2F;&#x2F;www.springmodules.org&#x2F;schema&#x2F;ehcache http:&#x2F;&#x2F;www.springmodules.org&#x2F;schema&#x2F;cache&#x2F;springmodules-ehcache.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Spring中引入其他配置文件 --&gt;</span><br><span class="line">&lt;import resource&#x3D;&quot;drools-config.xml&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 扫描service 排除扫描controller --&gt;</span><br><span class="line">&lt;context:component-scan base-package&#x3D;&quot;com.mcms.rule.service&quot;&gt;</span><br><span class="line">&lt;context:exclude-filter type&#x3D;&quot;annotation&quot;</span><br><span class="line">expression&#x3D;&quot;org.springframework.stereotype.Controller&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 加载相关properties文件 --&gt;</span><br><span class="line">&lt;context:property-placeholder location&#x3D;&quot;classpath:db.properties&quot; &#x2F;&gt;</span><br><span class="line">&lt;!-- 配置druid数据源 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span><br><span class="line">destroy-method&#x3D;&quot;close&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot; &#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot; &#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;mdms&quot; &#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;mdms&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 配置sqlSessionFaction --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置事务 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;transactionManager&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注解方式配置事务 --&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot; &#x2F;&gt;</span><br><span class="line">&lt;!--如果不用注解式事物，则将上面的注解驱动注释，改为以下声明式事物</span><br><span class="line">&lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;transactionManager&quot;&gt;</span><br><span class="line">&lt;tx:attributes&gt;</span><br><span class="line">&lt;tx:method name&#x3D;&quot;save*&quot; propagation&#x3D;&quot;REQUIRED&quot;</span><br><span class="line">rollback-for&#x3D;&quot;java.lang.Exception&quot; &#x2F;&gt;</span><br><span class="line">&lt;tx:method name&#x3D;&quot;delete*&quot; propagation&#x3D;&quot;REQUIRED&quot;</span><br><span class="line">rollback-for&#x3D;&quot;java.lang.Exception&quot; &#x2F;&gt;</span><br><span class="line">&lt;tx:method name&#x3D;&quot;update*&quot; propagation&#x3D;&quot;REQUIRED&quot;</span><br><span class="line">rollback-for&#x3D;&quot;java.lang.Exception&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;tx:attributes&gt;</span><br><span class="line">&lt;&#x2F;tx:advice&gt;</span><br><span class="line"></span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">&lt;aop:pointcut id&#x3D;&quot;pointcut1&quot;</span><br><span class="line">expression&#x3D;&quot;execution(* com.lxtd.cca.service.interfaces..*.*(..))&quot; &#x2F;&gt;</span><br><span class="line">&lt;aop:advisor pointcut-ref&#x3D;&quot;pointcut1&quot; advice-ref&#x3D;&quot;txAdvice&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;aop:config&gt;</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置扫描mapper --&gt;</span><br><span class="line">&lt;!-- 配置mapper扫描器 --&gt;</span><br><span class="line">&lt;bean class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">&lt;!-- 扫描包的路径，如果需要扫描多个包，中间使用半角 逗号隔开 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.mcms.rule.mapper&quot; &#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;sqlSessionFactoryBeanName&quot; value&#x3D;&quot;sqlSessionFactory&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、在spring核心配置文件中会加载mybatis的配置文件"><a href="#4、在spring核心配置文件中会加载mybatis的配置文件" class="headerlink" title="4、在spring核心配置文件中会加载mybatis的配置文件"></a>4、在spring核心配置文件中会加载mybatis的配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;  </span><br><span class="line">&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!-- 配置别名 --&gt;</span><br><span class="line">&lt;!-- &lt;typeAliases&gt; &lt;typeAlias alias&#x3D;&quot;user&quot; type&#x3D;&quot;com.gray.user.entity.User&quot;&#x2F;&gt; </span><br><span class="line">&lt;&#x2F;typeAliases&gt; --&gt;</span><br><span class="line">&lt;!-- 开启驼峰映射 --&gt;</span><br><span class="line">&lt;!-- &lt;settings&gt; &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;true&quot; &#x2F;&gt; </span><br><span class="line">&lt;&#x2F;settings&gt; --&gt;</span><br><span class="line"></span><br><span class="line">&lt;settings&gt;</span><br><span class="line">&lt;!-- 打印查询语句 --&gt;</span><br><span class="line">&lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;STDOUT_LOGGING&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;settings&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- &lt;plugins&gt;</span><br><span class="line">com.github.pagehelper为PageHelper类所在包名</span><br><span class="line">&lt;plugin interceptor&#x3D;&quot;com.github.pagehelper.PageHelper&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;dialect&quot; value&#x3D;&quot;mysql&quot; &#x2F;&gt;</span><br><span class="line">该参数默认为false</span><br><span class="line">设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用</span><br><span class="line">和startPage中的pageNum效果一样</span><br><span class="line">&lt;property name&#x3D;&quot;offsetAsPageNum&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">该参数默认为false</span><br><span class="line">设置为true时，使用RowBounds分页会进行count查询</span><br><span class="line">&lt;property name&#x3D;&quot;rowBoundsWithCount&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">设置为true时，如果pageSize&#x3D;0或者RowBounds.limit &#x3D; 0就会查询出全部的结果</span><br><span class="line">（相当于没有执行分页查询，但是返回结果仍然是Page类型）</span><br><span class="line">&lt;property name&#x3D;&quot;pageSizeZero&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">3.3.0版本可用 - 分页参数合理化，默认false禁用</span><br><span class="line">启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页</span><br><span class="line">禁用合理化时，如果pageNum&lt;1或pageNum&gt;pages会返回空数据</span><br><span class="line">&lt;property name&#x3D;&quot;reasonable&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;</span><br><span class="line">3.5.0版本可用 - 为了支持startPage(Object params)方法</span><br><span class="line">增加了一个&#96;params&#96;参数来配置参数映射，用于从Map或ServletRequest中取值</span><br><span class="line">可以配置pageNum,pageSize,count,pageSizeZero,reasonable,不配置映射的用默认值</span><br><span class="line">不理解该含义的前提下，不要随便复制该配置</span><br><span class="line">&lt;property name&#x3D;&quot;params&quot; value&#x3D;&quot;pageNum&#x3D;start;pageSize&#x3D;limit;&quot; &#x2F;&gt;</span><br><span class="line">always总是返回PageInfo类型,check检查返回类型是否为PageInfo,none返回Page</span><br><span class="line">&lt;property name&#x3D;&quot;returnPageInfo&quot; value&#x3D;&quot;check&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br><span class="line">&lt;&#x2F;plugins&gt; --&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;  </span><br></pre></td></tr></table></figure><h3 id="5、编写mapper接口和xml文件"><a href="#5、编写mapper接口和xml文件" class="headerlink" title="5、编写mapper接口和xml文件"></a>5、编写mapper接口和xml文件</h3><p>java:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface TestMapper &#123;</span><br><span class="line">TestData testGetData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.mcms.rule.mapper.TestMapper&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id&#x3D;&quot;testGetData&quot; resultType&#x3D;&quot;com.mcms.rule.api.entity.TestData&quot;&gt;</span><br><span class="line">    select REGION_CODE regionCode</span><br><span class="line">     from mt_administration_region where id&#x3D;&#39;930C41111D6E447792545533970CA9DB&#39;</span><br><span class="line">  &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure><p>附上baseController和项目所需jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br></pre></td><td class="code"><pre><span class="line">package com.mcms.rule.controller;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.validation.BindingResult;</span><br><span class="line">import org.springframework.validation.ObjectError;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.core.JsonGenerationException;</span><br><span class="line">import com.fasterxml.jackson.databind.JsonMappingException;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import com.mcms.rule.api.entity.DataResult;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class BaseController &#123;</span><br><span class="line"></span><br><span class="line">protected Logger logger &#x3D; null;</span><br><span class="line"></span><br><span class="line">public final Logger getLogger() &#123;</span><br><span class="line">if (this.logger &#x3D;&#x3D; null)</span><br><span class="line">this.logger &#x3D; LoggerFactory.getLogger(BaseController.class);</span><br><span class="line">return this.logger;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int OK &#x3D; 200;&#x2F;&#x2F; 正常</span><br><span class="line">public static int BAD_REQUEST &#x3D; 400;&#x2F;&#x2F; 请求出现语法错误</span><br><span class="line">public static int INVALID_PARAM &#x3D; 405;&#x2F;&#x2F; 请求出现语法错误</span><br><span class="line">public static int UNAUTHORIZED &#x3D; 401;&#x2F;&#x2F; 客户试图未经授权访问受密码保护的页面</span><br><span class="line">public static int FORBIDDEN &#x3D; 403;&#x2F;&#x2F; 拒绝访问 forbidden</span><br><span class="line">public static int SERVER_ERROR &#x3D; 500;&#x2F;&#x2F; 服务器错误</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 参数校验</span><br><span class="line"> * </span><br><span class="line"> * @param result</span><br><span class="line"> * @param response</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean isInvalid(BindingResult result, HttpServletResponse response) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (result.hasErrors()) &#123;</span><br><span class="line">System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;参数检验 start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">Map&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">for (ObjectError oe : result.getAllErrors()) &#123;</span><br><span class="line">String[] item &#x3D; oe.getDefaultMessage().split(&quot;:&quot;);</span><br><span class="line">map.put(item[0], item[1]);</span><br><span class="line">System.out.println(item[0] + &quot;:&quot; + item[1]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;参数检验 end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">List data &#x3D; new ArrayList();</span><br><span class="line">data.add(map);</span><br><span class="line">DataResult dr &#x3D; new DataResult(INVALID_PARAM, &quot;参数验证失败&quot;, data);</span><br><span class="line"></span><br><span class="line">response.setHeader(&quot;Content-type&quot;, &quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line">response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">mapper.writeValue(response.getWriter(), dr);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 正常返回数据 ok 200</span><br><span class="line"> * </span><br><span class="line"> * @param response</span><br><span class="line"> *            response</span><br><span class="line"> * @param data</span><br><span class="line"> *            数据信息Obj</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void writeResult(HttpServletResponse response, Object data) &#123;</span><br><span class="line"></span><br><span class="line">writeResult(response, &quot;OK&quot;, data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 正常返回数据，自定义状态说明msg</span><br><span class="line"> * </span><br><span class="line"> * @param response</span><br><span class="line"> *            response</span><br><span class="line"> * @param msg</span><br><span class="line"> *            自定义状态说明</span><br><span class="line"> * @param data</span><br><span class="line"> *            返回数据</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void writeResult(HttpServletResponse response, String msg, Object data) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">response.setHeader(&quot;Content-type&quot;, &quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">response.setStatus(OK);</span><br><span class="line">DataResult result &#x3D; new DataResult(OK, msg, null);</span><br><span class="line">if (data instanceof List) &#123;</span><br><span class="line">result.setData((List) data);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">List list &#x3D; new ArrayList();</span><br><span class="line">if (data !&#x3D; null)</span><br><span class="line">list.add(data);</span><br><span class="line">result.setData(list);</span><br><span class="line">&#125;</span><br><span class="line">ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">mapper.writeValue(response.getWriter(), result);</span><br><span class="line">&#125; catch (JsonGenerationException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (JsonMappingException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 返回200 ok 无数据</span><br><span class="line"> * </span><br><span class="line"> * @param response</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void writeResult(HttpServletResponse response) &#123;</span><br><span class="line"></span><br><span class="line">writeResult(response,&quot;OK&quot;,null);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 客户端异常，有返回数据</span><br><span class="line"> * </span><br><span class="line"> * @param response</span><br><span class="line"> *            response</span><br><span class="line"> * @param message</span><br><span class="line"> *            错误状态说明</span><br><span class="line"> * @param data</span><br><span class="line"> *            返回错误信息数据</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void writeError400(HttpServletResponse response, String message, Object data) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">response.setHeader(&quot;Content-type&quot;, &quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">response.setStatus(OK);</span><br><span class="line">DataResult result &#x3D; new DataResult(BAD_REQUEST, message, null);</span><br><span class="line">if (data !&#x3D; null) &#123;</span><br><span class="line">if (data instanceof List) &#123;</span><br><span class="line">result.setData((List) data);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">List list &#x3D; new ArrayList();</span><br><span class="line">if (data !&#x3D; null)</span><br><span class="line">list.add(data);</span><br><span class="line">result.setData(list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">mapper.writeValue(response.getWriter(), result);</span><br><span class="line">&#125; catch (JsonGenerationException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (JsonMappingException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 服务器异常,打印异常信息</span><br><span class="line"> * </span><br><span class="line"> * @param response</span><br><span class="line"> * @param exception</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void writeError500(HttpServletResponse response, Exception exception) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">exception.printStackTrace();</span><br><span class="line">response.setHeader(&quot;Content-type&quot;, &quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">response.setStatus(OK);</span><br><span class="line">DataResult result &#x3D; new DataResult(SERVER_ERROR, &quot;服务器内部错误！&quot;, null);</span><br><span class="line">ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">mapper.writeValue(response.getWriter(), result);</span><br><span class="line">&#125; catch (JsonGenerationException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (JsonMappingException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 服务器异常,返回自定义错误信息</span><br><span class="line"> * </span><br><span class="line"> * @param response</span><br><span class="line"> * @param obj</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void writeError500(HttpServletResponse response, Object obj) &#123;</span><br><span class="line">response.setHeader(&quot;Content-type&quot;, &quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">response.setStatus(500);</span><br><span class="line">ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">try &#123;</span><br><span class="line">mapper.writeValue(response.getWriter(), obj);</span><br><span class="line">&#125; catch (JsonGenerationException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (JsonMappingException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 服务器请求失败,返回自定义错误信息</span><br><span class="line"> * </span><br><span class="line"> * @param response</span><br><span class="line"> * @param obj</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void writeError400(HttpServletResponse response, String msg) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">response.setHeader(&quot;Content-type&quot;, &quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">response.setStatus(OK);&#x2F;&#x2F; 200</span><br><span class="line">DataResult result &#x3D; new DataResult(BAD_REQUEST, msg, null);</span><br><span class="line">ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">mapper.writeValue(response.getWriter(), result);</span><br><span class="line">&#125; catch (JsonGenerationException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (JsonMappingException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 服务器请求失败,返回自定义错误信息</span><br><span class="line"> * </span><br><span class="line"> * @param response</span><br><span class="line"> * @param obj</span><br><span class="line"> * @param status</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void writeError(HttpServletResponse response, String msg, Integer status) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">response.setHeader(&quot;Content-type&quot;, &quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">response.setStatus(status);&#x2F;&#x2F; 200</span><br><span class="line">DataResult result &#x3D; new DataResult(status, msg, null);</span><br><span class="line">ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">mapper.writeValue(response.getWriter(), result);</span><br><span class="line">&#125; catch (JsonGenerationException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (JsonMappingException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void writeError400(HttpServletResponse response) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">response.setHeader(&quot;Content-type&quot;, &quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">response.setStatus(OK);&#x2F;&#x2F; 200</span><br><span class="line">DataResult result &#x3D; new DataResult(BAD_REQUEST, &quot;系统繁忙，请稍后再试。。。&quot;, null);</span><br><span class="line">ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">mapper.writeValue(response.getWriter(), result);</span><br><span class="line">&#125; catch (JsonGenerationException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (JsonMappingException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 正常返回数据，自定义状态说明msg</span><br><span class="line"> * </span><br><span class="line"> * @param response</span><br><span class="line"> *            response</span><br><span class="line"> * @param msg</span><br><span class="line"> *            自定义状态说明</span><br><span class="line"> * @param data</span><br><span class="line"> *            返回数据</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void writeResult(HttpServletResponse response, String msg) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">response.setHeader(&quot;Content-type&quot;, &quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">response.setStatus(OK);</span><br><span class="line">DataResult result &#x3D; new DataResult(OK, msg);</span><br><span class="line">ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">mapper.writeValue(response.getWriter(), result);</span><br><span class="line">&#125; catch (JsonGenerationException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (JsonMappingException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="所需jar包："><a href="#所需jar包：" class="headerlink" title="所需jar包："></a>所需jar包：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;project</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;</span><br><span class="line">xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;com.ebest.mdms&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mcms-rule&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br><span class="line">&lt;groupId&gt;com.ebest.mdms&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mcms-rule-service&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;name&gt;mcms-rule-service&lt;&#x2F;name&gt;</span><br><span class="line">&lt;url&gt;http:&#x2F;&#x2F;maven.apache.org&lt;&#x2F;url&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;3.8.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.ebest.mdms&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mcms-rule-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.ebest.mdms&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mcms-rule-utils&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-dataformat-xml&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;net.sf.ehcache&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;ehcache-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;version.log4j&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;version.log4j&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.4.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.data&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.3.4.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;version.pool2&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;commons-pool&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-pool&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;version.pool&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;commons-lang&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-lang&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;commons-codec&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-codec&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javassist&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;javassist&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;jstl&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;version.jstl&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;version.mybatis&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;version.mybatis-spring&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;version.spring&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;commons-logging&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-logging&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework&#x2F;spring-core --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;4.3.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.oracle&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;ojdbc6&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- jackson json --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-annotations&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- drools内部依赖包 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.sun.xml.bind&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jaxb-xjc&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring-mvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建SSM框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis安装</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/2%E3%80%81redis%E5%AE%89%E8%A3%85/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/2%E3%80%81redis%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<ul><li><p>(先安装gcc环境：yum install gcc-c++)</p></li><li><p>1、下载redis.tar并上传至服务器</p></li><li><p>2、解压<br>tar -zxvf redis-5.0.5.tar.gz -C /usr/local/redis/</p></li><li><p>3、编译并安装<br>cd /usr/local/redis/redis-5.0.5  </p><p>make PREFIX=/usr/local/redis install  </p></li></ul><p>会在同级目录下生成：redis-benchmark  redis-check-aof  redis-check-rdb  redis-cli  redis-sentinel  redis-server文件夹</p><ul><li>4、指定配置文件启动redis</li></ul><p>　./bin/redis-server ./redis.conf　</p><ul><li>　5、登录<br>　./redis-cli -h 127.0.0.1 -p 6379 -a myPassword</li></ul><p>修改配置文件<br>允许有所ip访问 指定密码 后台运行等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line">#redis.conf</span><br><span class="line"># Redis configuration file example.</span><br><span class="line"># .&#x2F;redis-server &#x2F;path&#x2F;to&#x2F;redis.conf</span><br><span class="line"></span><br><span class="line">################################## INCLUDES ###################################</span><br><span class="line">#这在你有标准配置模板但是每个redis服务器又需要个性设置的时候很有用。</span><br><span class="line"># include &#x2F;path&#x2F;to&#x2F;local.conf</span><br><span class="line"># include &#x2F;path&#x2F;to&#x2F;other.conf</span><br><span class="line"></span><br><span class="line">################################ GENERAL #####################################</span><br><span class="line"></span><br><span class="line">#是否在后台执行，yes：后台运行；no：不是后台运行（老版本默认）</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line">  #3.2里的参数，是否开启保护模式，默认开启。要是配置里没有指定bind和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。要是开启了密码   和bind，可以开启。否   则最好关闭，设置为no。</span><br><span class="line">  protected-mode yes</span><br><span class="line">#redis的进程文件</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis&#x2F;redis-server.pid</span><br><span class="line"></span><br><span class="line">#redis监听的端口号。</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line">#此参数确定了TCP连接中已完成队列(完成三次握手之后)的长度， 当然此值必须不大于Linux系统定义的&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn值，默认是511，而Linux的默认参数值是128。当系统并发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定。该内核参数默认值一般是128，对于负载很大的服务程序来说大大的不够。一般会将它修改为2048或者更大。在&#x2F;etc&#x2F;sysctl.conf中添加:net.core.somaxconn &#x3D; 2048，然后在终端中执行sysctl -p。</span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line">#指定 redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line">#配置unix socket来让redis支持监听本地连接。</span><br><span class="line"># unixsocket &#x2F;var&#x2F;run&#x2F;redis&#x2F;redis.sock</span><br><span class="line">#配置unix socket使用文件的权限</span><br><span class="line"># unixsocketperm 700</span><br><span class="line"></span><br><span class="line"># 此参数为设置客户端空闲超过timeout，服务端会断开连接，为0则服务端不会主动断开连接，不能小于0。</span><br><span class="line">timeout 0</span><br><span class="line"></span><br><span class="line">#tcp keepalive参数。如果设置不为0，就使用配置tcp的SO_KEEPALIVE值，使用keepalive有两个好处:检测挂掉的对端。降低中间设备出问题而导致网络看似连接却已经与对端端口的问题。在Linux内核中，设置了keepalive，redis会定时给对端发送ack。检测到对端关闭需要两倍的设置值。</span><br><span class="line">tcp-keepalive 0</span><br><span class="line"></span><br><span class="line">#指定了服务端日志的级别。级别包括：debug（很多信息，方便开发、测试），verbose（许多有用的信息，但是没有debug级别信息多），notice（适当的日志级别，适合生产环境），warn（只有非常重要的信息）</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line">#指定了记录日志的文件。空字符串的话，日志会打印到标准输出设备。后台运行的redis标准输出是&#x2F;dev&#x2F;null。</span><br><span class="line">logfile &#x2F;var&#x2F;log&#x2F;redis&#x2F;redis-server.log</span><br><span class="line"></span><br><span class="line">#是否打开记录syslog功能</span><br><span class="line"># syslog-enabled no</span><br><span class="line"></span><br><span class="line">#syslog的标识符。</span><br><span class="line"># syslog-ident redis</span><br><span class="line"></span><br><span class="line">#日志的来源、设备</span><br><span class="line"># syslog-facility local0</span><br><span class="line"></span><br><span class="line">#数据库的数量，默认使用的数据库是DB 0。可以通过”SELECT “命令选择一个db</span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line">################################ SNAPSHOTTING ################################</span><br><span class="line"># 快照配置</span><br><span class="line"># 注释掉“save”这一行配置项就可以让保存数据库功能失效</span><br><span class="line"># 设置sedis进行数据库镜像的频率。</span><br><span class="line"># 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化） </span><br><span class="line"># 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化） </span><br><span class="line"># 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">#当RDB持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no：可以继续进行工作，可以通过info中的rdb_last_bgsave_status了解RDB持久化是否有错误</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line">#使用压缩rdb文件，rdb文件压缩使用LZF压缩算法，yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line">#是否校验rdb文件。从rdb格式的第五个版本开始，在rdb文件的末尾会带上CRC64的校验和。这跟有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗，所以如果你追求高性能，可以关闭该配置。</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line">#rdb文件的名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">#数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录</span><br><span class="line">dir &#x2F;var&#x2F;lib&#x2F;redis</span><br><span class="line"></span><br><span class="line">################################# REPLICATION #################################</span><br><span class="line">#复制选项，slave复制对应的master。</span><br><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line">#如果master设置了requirepass，那么slave要连上master，需要有master的密码才行。masterauth就是用来配置master的密码，这样可以在连上master后进行认证。</span><br><span class="line"># masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line">#当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：1) 如果slave-serve-stale-data设置为yes(默认设置)，从库会继续响应客户端的请求。2) 如果slave-serve-stale-data设置为no，除去INFO和SLAVOF命令之外的任何请求都会返回一个错误”SYNC with master in progress”。</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"></span><br><span class="line">#作为从服务器，默认情况下是只读的（yes），可以修改成NO，用于写（不建议）。</span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line">#是否使用socket方式复制数据。目前redis复制提供两种方式，disk和socket。如果新的slave连上来或者重连的slave无法部分同步，就会执行全量同步，master会生成rdb文件。有2种方式：disk方式是master创建一个新的进程把rdb文件保存到磁盘，再把磁盘上的rdb文件传递给slave。socket是master创建一个新的进程，直接把rdb文件以socket的方式发给slave。disk方式的时候，当一个rdb保存的过程中，多个slave都能共享这个rdb文件。socket的方式就的一个个slave顺序复制。在磁盘速度缓慢，网速快的情况下推荐用socket方式。</span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line">#diskless复制的延迟时间，防止设置为0。一旦复制开始，节点不会再接收新slave的复制请求直到下一个rdb传输。所以最好等待一段时间，等更多的slave连上来。</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line">#slave根据指定的时间间隔向服务器发送ping请求。时间间隔可以通过 repl_ping_slave_period 来设置，默认10秒。</span><br><span class="line"># repl-ping-slave-period 10</span><br><span class="line"></span><br><span class="line">#复制连接超时时间。master和slave都有超时时间的设置。master检测到slave上次发送的时间超过repl-timeout，即认为slave离线，清除该slave信息。slave检测到上次和master交互的时间超过repl-timeout，则认为master离线。需要注意的是repl-timeout需要设置一个比repl-ping-slave-period更大的值，不然会经常检测到超时。</span><br><span class="line"># repl-timeout 60</span><br><span class="line"></span><br><span class="line">#是否禁止复制tcp链接的tcp nodelay参数，可传递yes或者no。默认是no，即使用tcp nodelay。如果master设置了yes来禁止tcp nodelay设置，在把数据复制给slave的时候，会减少包的数量和更小的网络带宽。但是这也可能带来数据的延迟。默认我们推荐更小的延迟，但是在数据量传输很大的场景下，建议选择yes。</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line">#复制缓冲区大小，这是一个环形复制缓冲区，用来保存最新复制的命令。这样在slave离线的时候，不需要完全复制master的数据，如果可以执行部分同步，只需要把缓冲区的部分数据复制给slave，就能恢复正常复制状态。缓冲区的大小越大，slave离线的时间可以更长，复制缓冲区只有在有slave连接的时候才分配内存。没有slave的一段时间，内存会被释放出来，默认1m。</span><br><span class="line"># repl-backlog-size 5mb</span><br><span class="line"></span><br><span class="line">#master没有slave一段时间会释放复制缓冲区的内存，repl-backlog-ttl用来设置该时间长度。单位为秒。</span><br><span class="line"># repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line">#当master不可用，Sentinel会根据slave的优先级选举一个master。最低的优先级的slave，当选master。而配置成0，永远不会被选举。</span><br><span class="line">slave-priority 100</span><br><span class="line"></span><br><span class="line">#redis提供了可以让master停止写入的方式，如果配置了min-slaves-to-write，健康的slave的个数小于N，mater就禁止写入。master最少得有多少个健康的slave存活才能执行写命令。这个配置虽然不能保证N个slave都一定能接收到master的写操作，但是能避免没有足够健康的slave的时候，master不能写入来避免数据丢失。设置为0是关闭该功能。</span><br><span class="line"># min-slaves-to-write 3</span><br><span class="line"></span><br><span class="line">#延迟小于min-slaves-max-lag秒的slave才认为是健康的slave。</span><br><span class="line"># min-slaves-max-lag 10</span><br><span class="line"></span><br><span class="line"># 设置1或另一个设置为0禁用这个特性。</span><br><span class="line"># Setting one or the other to 0 disables the feature.</span><br><span class="line"># By default min-slaves-to-write is set to 0 (feature disabled) and</span><br><span class="line"># min-slaves-max-lag is set to 10.</span><br><span class="line"></span><br><span class="line">################################## SECURITY ###################################</span><br><span class="line">#requirepass配置可以让用户使用AUTH命令来认证密码，才能使用其他命令。这让redis可以使用在不受信任的网络中。为了保持向后的兼容性，可以注释该命令，因为大部分用户也不需要认证。使用requirepass的时候需要注意，因为redis太快了，每秒可以认证15w次密码，简单的密码很容易被攻破，所以最好使用一个更复杂的密码。</span><br><span class="line"># requirepass foobared</span><br><span class="line"></span><br><span class="line">#把危险的命令给修改成其他名称。比如CONFIG命令可以重命名为一个很难被猜到的命令，这样用户不能使用，而内部工具还能接着使用。</span><br><span class="line"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line"></span><br><span class="line">#设置成一个空的值，可以禁止一个命令</span><br><span class="line"># rename-command CONFIG &quot;&quot;</span><br><span class="line">################################### LIMITS ####################################</span><br><span class="line"></span><br><span class="line"># 设置能连上redis的最大客户端连接数量。默认是10000个客户端连接。由于redis不区分连接是客户端连接还是内部打开文件或者和slave连接等，所以maxclients最小建议设置到32。如果超过了maxclients，redis会给新的连接发送’max number of clients reached’，并关闭连接。</span><br><span class="line"># maxclients 10000</span><br><span class="line"></span><br><span class="line">#redis配置的最大内存容量。当内存满了，需要配合maxmemory-policy策略进行处理。注意slave的输出缓冲区是不计算在maxmemory内的。所以为了防止主机内存使用完，建议设置的maxmemory需要更小一些。</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br><span class="line">#内存容量超过maxmemory后的处理策略。</span><br><span class="line">#volatile-lru：利用LRU算法移除设置过过期时间的key。</span><br><span class="line">#volatile-random：随机移除设置过过期时间的key。</span><br><span class="line">#volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）</span><br><span class="line">#allkeys-lru：利用LRU算法移除任何key。</span><br><span class="line">#allkeys-random：随机移除任何key。</span><br><span class="line">#noeviction：不移除任何key，只是返回一个写错误。</span><br><span class="line">#上面的这些驱逐策略，如果redis没有合适的key驱逐，对于写命令，还是会返回错误。redis将不再接收写请求，只接收get请求。写命令包括：set setnx setex append incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby getset mset msetnx exec sort。</span><br><span class="line"># maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line">#lru检测的样本数。使用lru或者ttl淘汰算法，从需要淘汰的列表中随机选择sample个key，选出闲置时间最长的key移除。</span><br><span class="line"># maxmemory-samples 5</span><br><span class="line"></span><br><span class="line">############################## APPEND ONLY MODE ###############################</span><br><span class="line">#默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line">#aof文件名</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line">#aof持久化策略的配置</span><br><span class="line">#no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。</span><br><span class="line">#always表示每次写入都执行fsync，以保证数据同步到磁盘。</span><br><span class="line">#everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"># 在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line">#aof自动重写配置。当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">#设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line">#aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data&#x3D;ordered选项（redis宕机或者异常终止不会造成尾部不完整现象。）出现这种现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line">################################ LUA SCRIPTING ###############################</span><br><span class="line"># 如果达到最大时间限制（毫秒），redis会记个log，然后返回error。当一个脚本超过了最大时限。只有SCRIPT KILL和SHUTDOWN NOSAVE可以用。第一个可以杀没有调write命令的东西。要是已经调用了write，只能用第二个命令杀。</span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line">################################ REDIS CLUSTER ###############################</span><br><span class="line">#集群开关，默认是不开启集群模式。</span><br><span class="line"># cluster-enabled yes</span><br><span class="line"></span><br><span class="line">#集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要一个单独的配置文件，请确保与实例运行的系统中配置文件名称不冲突</span><br><span class="line"># cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line">#节点互连超时的阀值。集群节点超时毫秒数</span><br><span class="line"># cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line">#在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：</span><br><span class="line">#比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period</span><br><span class="line">#如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移 </span><br><span class="line"># cluster-slave-validity-factor 10</span><br><span class="line"></span><br><span class="line">#master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2 个可工作的从节点时，它的一个从节点会尝试迁移。</span><br><span class="line"># cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line">#默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致。</span><br><span class="line"># cluster-require-full-coverage yes</span><br><span class="line"></span><br><span class="line">################################## SLOW LOG ###################################</span><br><span class="line">###slog log是用来记录redis运行中执行比较慢的命令耗时。当命令的执行超过了指定时间，就记录在slow log中，slog log保存在内存中，所以没有IO操作。</span><br><span class="line">#执行时间比slowlog-log-slower-than大的请求记录到slowlog里面，单位是微秒，所以1000000就是1秒。注意，负数时间会禁用慢查询日志，而0则会强制记录所有命令。</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line">#慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。这个长度没有限制。只要有足够的内存就行。你可以通过 SLOWLOG RESET 来释放内存。</span><br><span class="line">slowlog-max-len 128</span><br><span class="line"></span><br><span class="line">################################ LATENCY MONITOR ##############################</span><br><span class="line">#延迟监控功能是用来监控redis中执行比较缓慢的一些操作，用LATENCY打印redis实例在跑命令时的耗时图表。只记录大于等于下边设置的值的操作。0的话，就是关闭监视。默认延迟监控功能是关闭的，如果你需要打开，也可以通过CONFIG SET命令动态设置。</span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line"></span><br><span class="line">############################# EVENT NOTIFICATION ##############################</span><br><span class="line">#键空间通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件。因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。</span><br><span class="line">#notify-keyspace-events 的参数可以是以下字符的任意组合，它指定了服务器该发送哪些类型的通知：</span><br><span class="line">##K 键空间通知，所有通知以 __keyspace@__ 为前缀</span><br><span class="line">##E 键事件通知，所有通知以 __keyevent@__ 为前缀</span><br><span class="line">##g DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知</span><br><span class="line">##$ 字符串命令的通知</span><br><span class="line">##l 列表命令的通知</span><br><span class="line">##s 集合命令的通知</span><br><span class="line">##h 哈希命令的通知</span><br><span class="line">##z 有序集合命令的通知</span><br><span class="line">##x 过期事件：每当有过期键被删除时发送</span><br><span class="line">##e 驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送</span><br><span class="line">##A 参数 g$lshzxe 的别名</span><br><span class="line">#输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何 通知被分发。详细使用可以参考http:&#x2F;&#x2F;redis.io&#x2F;topics&#x2F;notifications</span><br><span class="line"></span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line"></span><br><span class="line">############################### ADVANCED CONFIG ###############################</span><br><span class="line">#数据量小于等于hash-max-ziplist-entries的用ziplist，大于hash-max-ziplist-entries用hash</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">#value大小小于等于hash-max-ziplist-value的用ziplist，大于hash-max-ziplist-value用hash。</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line">#数据量小于等于list-max-ziplist-entries用ziplist，大于list-max-ziplist-entries用list。</span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line">#value大小小于等于list-max-ziplist-value的用ziplist，大于list-max-ziplist-value用list。</span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line">#数据量小于等于set-max-intset-entries用iniset，大于set-max-intset-entries用set。</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line">#数据量小于等于zset-max-ziplist-entries用ziplist，大于zset-max-ziplist-entries用zset。</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">#value大小小于等于zset-max-ziplist-value用ziplist，大于zset-max-ziplist-value用zset。</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line">#value大小小于等于hll-sparse-max-bytes使用稀疏数据结构（sparse），大于hll-sparse-max-bytes使用稠密的数据结构（dense）。一个比16000大的value是几乎没用的，建议的value大概为3000。如果对CPU要求不高，对空间要求较高的，建议设置到10000左右。</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"></span><br><span class="line">#Redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用。当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存。</span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line">##对客户端输出缓冲进行限制可以强迫那些不从服务器读取数据的客户端断开连接，用来强制关闭传输缓慢的客户端。</span><br><span class="line">#对于normal client，第一个0表示取消hard limit，第二个0和第三个0表示取消soft limit，normal client默认取消限制，因为如果没有寻问，他们是不会接收数据的。</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">#对于slave client和MONITER client，如果client-output-buffer一旦超过256mb，又或者超过64mb持续60秒，那么服务器就会立即断开客户端连接。</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">#对于pubsub client，如果client-output-buffer一旦超过32mb，又或者超过8mb持续60秒，那么服务器就会立即断开客户端连接。</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"></span><br><span class="line">#redis执行任务的频率为1s除以hz。</span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line">#在aof重写的时候，如果打开了aof-rewrite-incremental-fsync开关，系统会每32MB执行一次fsync。这对于把文件写入磁盘是有帮助的，可以避免过大的延迟峰值。</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS原理</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/AQS%E5%8E%9F%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/AQS%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ul><li>Sync queue：同步队列，是一个双向链表。包括head节点和tail节点。head节点主要用作后续的调度。</li><li>Condition queue：非必须，单向链表。当程序中存在cindition的时候才会存在此列表。</li></ul><h2 id="AQS核心思想"><a href="#AQS核心思想" class="headerlink" title="AQS核心思想"></a>AQS核心思想</h2><p>==同步组件的实现者通过使用AQS提供的模板方法实现同步组件语义，AQS则实现了对同步状态的管理，以及对阻塞线程进行排队，等待通知等等一些底层的实现处理==</p><p>可重写的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tryAcquire(int arg)独占获取同步状态，实现该方法需要查询当前状态，并判断同步状态是否符合预期状态，然后再进行CAS设置同步状态。</span><br><span class="line">treRelease(int arg)独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tryAcquireShared(int arg)共享式获取同步状态，返回大于等于0的值，表示获取成功，反之失败</span><br><span class="line">tryReleaseShared(int arg)共享式释放同步状态</span><br><span class="line">isHeldExclusively()当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占</span><br></pre></td></tr></table></figure><p>同步器提供的模板方法： </p><p>（1）独占式锁方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;独占式获取同步状态，如果获取失败则插入同步队列进行等待；</span><br><span class="line">void acquire(int arg);</span><br><span class="line">&#x2F;&#x2F;与acquire方法相同，但在同步队列中进行等待的时候可以检测中断；</span><br><span class="line">void acquireInterruptibly(int arg);</span><br><span class="line">&#x2F;&#x2F;在acquireInterruptibly基础上增加了超时等待功能，在超时时间内没有获得同步状态返回false;</span><br><span class="line">boolean tryAcquireNanos(int arg, long nanosTimeout);</span><br><span class="line">&#x2F;&#x2F;释放同步状态，该方法会唤醒在同步队列中的下一个节点</span><br><span class="line">boolean release(int arg);</span><br></pre></td></tr></table></figure><p>（2）共享式锁方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;：共享式获取同步状态，与独占式的区别在于同一时刻有多个线程获取同步状态；</span><br><span class="line">void acquireShared(int arg);</span><br><span class="line">&#x2F;&#x2F;：在acquireShared方法基础上增加了能响应中断的功能；</span><br><span class="line">void acquireSharedInterruptibly(int arg);</span><br><span class="line">&#x2F;&#x2F;：在acquireSharedInterruptibly基础上增加了超时等待的功能；</span><br><span class="line">boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</span><br><span class="line">&#x2F;&#x2F;：共享式释放同步状态</span><br><span class="line">boolean releaseShared(int arg)</span><br></pre></td></tr></table></figure><p>要想掌握AQS的底层实现，其实也就是对这些模板方法的逻辑进行学习。</p><p>AQS通过持有头尾指针管理同步队列(同步队列是一个双向队列)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile Node head;</span><br><span class="line"></span><br><span class="line">private transient volatile Node tail;</span><br><span class="line"></span><br><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure><p>AQS的静态内部类Node</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">volatile int waitStatus &#x2F;&#x2F;节点状态</span><br><span class="line">volatile Node prev &#x2F;&#x2F;当前节点&#x2F;线程的前驱节点</span><br><span class="line">volatile Node next; &#x2F;&#x2F;当前节点&#x2F;线程的后继节点</span><br><span class="line">volatile Thread thread;&#x2F;&#x2F;加入同步队列的线程引用</span><br><span class="line">Node nextWaiter;&#x2F;&#x2F;等待队列中的下一个节点</span><br></pre></td></tr></table></figure><p>节点的状态有以下这些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int CANCELLED &#x3D;  1&#x2F;&#x2F;节点从同步队列中取消</span><br><span class="line">int SIGNAL    &#x3D; -1&#x2F;&#x2F;后继节点的线程处于等待状态，如果当前节点释放同步状态会通知后继节点，使得后继节点的线程能够运行；</span><br><span class="line">int CONDITION &#x3D; -2&#x2F;&#x2F;当前节点进入等待队列中</span><br><span class="line">int PROPAGATE &#x3D; -3&#x2F;&#x2F;表示下一次共享式同步状态获取将会无条件传播下去</span><br><span class="line">int INITIAL &#x3D; 0;&#x2F;&#x2F;初始状态</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="一：获取独占式锁"><a href="#一：获取独占式锁" class="headerlink" title="一：获取独占式锁"></a>一：获取独占式锁</h1><h3 id="1、开始获取独占式锁："><a href="#1、开始获取独占式锁：" class="headerlink" title="1、开始获取独占式锁："></a>1、开始获取独占式锁：</h3><p>调用lock()方法是获取独占式锁，获取失败就将当前线程加入同步队列，成功则线程执行。而lock()方法实际上会调用AQS的acquire()方法.</p><p>acquire根据当前获得同步状态成功与否做了两件事情：</p><ol><li>成功，则方法结束返回，</li><li>失败，则先调用addWaiter()将线程加入等待队列,然后在调用acquireQueued()方法:排队获取锁。</li></ol><p>==acquire 该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移出。==</p><p>==首先调用自定义同步器实现的tryAcquire(int arg)方法，该方法<br>保证线程安全的获取同步状态，如果同步状态获取失败，则构造同步节点（独占式<br>Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过addWaiter(Node node)<br>方法将该节点加入到同步队列的尾部，最后调用acquireQueued(Node node,int arg)方法，使得该<br>节点以“死循环”的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的<br>唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">&#x2F;&#x2F;先看同步状态是否获取成功，如果成功则方法结束返回</span><br><span class="line">&#x2F;&#x2F;若失败则先调用addWaiter()方法再调用acquireQueued()方法</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、获取独占式锁态失败-做入队操作"><a href="#2、获取独占式锁态失败-做入队操作" class="headerlink" title="2、获取独占式锁态失败:做入队操作"></a>2、获取独占式锁态失败:做入队操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. 将当前线程构建成Node类型</span><br><span class="line">        Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">        &#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure</span><br><span class="line">        &#x2F;&#x2F; 2. 当前尾节点是否为null？</span><br><span class="line">        Node pred &#x3D; tail;</span><br><span class="line">        if (pred !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 2.2 将当前节点尾插入的方式插入同步队列中</span><br><span class="line">            node.prev &#x3D; pred;</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next &#x3D; node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 2.1. 当前同步队列尾节点为null，说明当前线程是第一个加入同步队列进行等待的线程</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自旋的过程（for (;;)）</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t &#x3D; tail;</span><br><span class="line">        if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">            &#x2F;&#x2F;1. 构造头结点</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail &#x3D; head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 2. 尾插入，CAS操作失败自旋尝试</span><br><span class="line">            node.prev &#x3D; t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next &#x3D; node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enq()方法：</p><ol><li>处理当前同步队列（带头双向链表）尾节点为null时进行入队操作；</li><li>compareAndSetTail(t, node)方法会利用CAS操作设置尾节点，CAS操作失败后负责自旋进行尝试会在for (;;)for死循环中不断尝试，直至成功return返回为止。</li></ol><p><img src="https://img-blog.csdn.net/20170819204120318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDYzNDMzOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><p>在同步队列中的节点（线程）会做什么事情了来保证自己能够有机会获得独占式锁了？自旋：acquireQueued</p><h3 id="入队列后，线程排队获取独占式锁的过程：acquireQueued"><a href="#入队列后，线程排队获取独占式锁的过程：acquireQueued" class="headerlink" title="入队列后，线程排队获取独占式锁的过程：acquireQueued"></a>入队列后，线程排队获取独占式锁的过程：acquireQueued</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">        boolean failed &#x3D; true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted &#x3D; false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                &#x2F;&#x2F; 1. 获得当前节点的先驱节点</span><br><span class="line">                final Node p &#x3D; node.predecessor();</span><br><span class="line">                &#x2F;&#x2F; 2. 当前节点能否获取独占式锁                  </span><br><span class="line">                &#x2F;&#x2F; 2.1 如果当前节点的先驱节点是头结点并且成功获取同步状态，即可以获得独占式锁</span><br><span class="line">                if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    &#x2F;&#x2F;获取锁成功，出队操作</span><br><span class="line">                    &#x2F;&#x2F;队列头指针用指向当前节点</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    &#x2F;&#x2F;释放前驱节点</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 2.2 获取锁失败，线程进入等待状态等待获取独占式锁</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;做出队操作：</span><br><span class="line">private void setHead(Node node) &#123;</span><br><span class="line">        head &#x3D; node;</span><br><span class="line">        node.thread &#x3D; null;</span><br><span class="line">        node.prev &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自旋获取锁整体示意图</p><p>只有前驱节点是头节点才能够尝试获取同步状态，因为</p><ul><li>第一，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会<br>唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。</li><li>第二，维护同步队列的FIFO原则。该方法中，节点自旋获取同步状态的行为</li></ul><p><img src="https://img-blog.csdn.net/20180509095351100?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmdoYW4xMjIy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p><h3 id="排队获取独占式获取成功，做出队操作："><a href="#排队获取独占式获取成功，做出队操作：" class="headerlink" title="排队获取独占式获取成功，做出队操作："></a>排队获取独占式获取成功，做出队操作：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;做出队操作：</span><br><span class="line">private void setHead(Node node) &#123;</span><br><span class="line">        head &#x3D; node;</span><br><span class="line">        node.thread &#x3D; null;</span><br><span class="line">        node.prev &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排队获取独占式获取失败"><a href="#排队获取独占式获取失败" class="headerlink" title="排队获取独占式获取失败"></a>排队获取独占式获取失败</h3><p>获取锁失败的时候会调用shouldParkAfterFailedAcquire()方法和parkAndCheckInterrupt()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    int ws &#x3D; pred.waitStatus;</span><br><span class="line">    if (ws &#x3D;&#x3D; Node.SIGNAL)</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * This node has already set status asking a release</span><br><span class="line">         * to signal it, so it can safely park.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        return true;</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">         * indicate retry.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next &#x3D; node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">         * need a signal, but don&#39;t park yet.  Caller will need to</span><br><span class="line">         * retry to make sure it cannot acquire before parking.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二：释放独占式锁：release"><a href="#二：释放独占式锁：release" class="headerlink" title="二：释放独占式锁：release()"></a>二：释放独占式锁：release()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">        if (tryRelease(arg)) &#123;</span><br><span class="line">            Node h &#x3D; head;</span><br><span class="line">            if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line"></span><br><span class="line">    int ws &#x3D; node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;头节点的后继节点</span><br><span class="line">    Node s &#x3D; node.next;</span><br><span class="line">    if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s &#x3D; null;</span><br><span class="line">        for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">            if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                s &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s !&#x3D; null)</span><br><span class="line">        &#x2F;&#x2F;后继节点不为null时唤醒该线程</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同步状态释放成功（tryRelease返回true）则会执行if块中的代码，当head指向的头结点不为null，并且该节点的状态值不为0的话才会执行unparkSuccessor()方法。==每一次锁释放后就会唤醒队列中该节点的后继节点所引用的线程，从而进一步可以佐证获得锁的过程是一个FIFO（先进先出）的过程。==</p><h1 id="三：独占式锁的获取和释放总结-很重要-："><a href="#三：独占式锁的获取和释放总结-很重要-：" class="headerlink" title="三：独占式锁的获取和释放总结(很重要)："></a>三：独占式锁的获取和释放总结(很重要)：</h1><p>==在获取同步状态时，AQS维护一个同步队列，获取同步状态失败的线程会加入到队列中进行自旋；移除队列（或停止自旋）的条件是前驱节点是头结点并且成功获得了同步状态。在释放同步状态时，同步器会调用unparkSuccessor()方法唤醒后继节点。==</p><p><img src="https://img-blog.csdn.net/2018083010402464?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjY3ODE3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p><h1 id="四：共享锁的获取"><a href="#四：共享锁的获取" class="headerlink" title="四：共享锁的获取"></a>四：共享锁的获取</h1><p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状<br>态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                int r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 当该节点的前驱节点是头结点且成功获取同步状态</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是<br>tryAcquireShared(int arg)方法返回值大于等于0。可以看到，在doAcquireShared(int arg)方法的自<br>旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示<br>该次获取同步状态成功并从自旋过程中退出。</p><h3 id="共享锁的释放（releaseShared-方法）"><a href="#共享锁的释放（releaseShared-方法）" class="headerlink" title="共享锁的释放（releaseShared()方法）"></a>共享锁的释放（releaseShared()方法）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>释放同步状态之后，将会唤醒后续处于等待状态的节点。对于能够支持多个线<br>程同时访问的并发组件（比如Semaphore），它和独占式主要区别在于tryReleaseShared(int arg)<br>方法必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证的，因为<br>释放同步状态的操作会同时来自多个线程。</p><h1 id="五：获取超时等待式锁：tryAcquireNanos"><a href="#五：获取超时等待式锁：tryAcquireNanos" class="headerlink" title="五：获取超时等待式锁：tryAcquireNanos()"></a>五：获取超时等待式锁：tryAcquireNanos()</h1><p>lock.tryLock(timeout,TimeUnit)，该方法会调用AQS的方法tryAcquireNanos(),方式达到超时等待获取锁的效果，该方法会在三种情况下才会返回：</p><ul><li>在超时时间内，当前线程成功获取了锁；</li><li>当前线程在超时时间内被中断；</li><li>超时时间结束，仍未获得锁返回false。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public final boolean tryAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    return tryAcquire(arg) ||</span><br><span class="line">        &#x2F;&#x2F;实现超时等待的效果</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean doAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (nanosTimeout &lt;&#x3D; 0L)</span><br><span class="line">        return false;</span><br><span class="line">    &#x2F;&#x2F;1. 根据超时时间和当前时间计算出截止时间</span><br><span class="line">    final long deadline &#x3D; System.nanoTime() + nanosTimeout;</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            &#x2F;&#x2F;2. 当前线程获得锁出队列</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 3.1 重新计算超时时间</span><br><span class="line">            nanosTimeout &#x3D; deadline - System.nanoTime();</span><br><span class="line">            &#x2F;&#x2F; 3.2 已经超时返回false</span><br><span class="line">            if (nanosTimeout &lt;&#x3D; 0L)</span><br><span class="line">                return false;</span><br><span class="line">            &#x2F;&#x2F; 3.3 线程阻塞等待 </span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(this, nanosTimeout);</span><br><span class="line">            &#x2F;&#x2F; 3.4 线程被中断抛出被中断异常</span><br><span class="line">            if (Thread.interrupted())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://upload-images.jianshu.io/upload_images/2615789-a80779d4736afb87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/704/format/webp" alt="image"></li></ul><p>程序逻辑同独占锁可响应中断式获取基本一致，唯一的不同在于获取锁失败后，对超时时间的处理上，在第1步会先计算出按照现在时间和超时时间计算出理论上的截止时间，比如当前时间是8h10min,超时时间是10min，那么根据deadline = System.nanoTime() + nanosTimeout计算出刚好达到超时时间时的系统时间就是8h 10min+10min = 8h 20min。然后根据deadline - System.nanoTime()就可以判断是否已经超时了，比如，当前系统时间是8h 30min很明显已经超过了理论上的系统时间8h 20min，deadline - System.nanoTime()计算出来就是一个负数，自然而然会在3.2步中的If判断之间返回false。如果还没有超时即3.2步中的if判断为true时就会继续执行3.3步通过LockSupport.parkNanos使得当前线程阻塞，同时在3.4步增加了对中断的检测，若检测出被中断直接抛出被中断异常</p>]]></content>
      
      
      <categories>
          
          <category> JUC锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CopyOnWriteArrayList</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/2%E3%80%81CopyOnWriteArrayList/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/2%E3%80%81CopyOnWriteArrayList/</url>
      
        <content type="html"><![CDATA[<p>CopyOnWriteArrayList是一个线程安全的ArrayList,对其进行修改操作和元素迭代操作都是在底层创建一个拷贝数组（快照）上进行的，也就是写时拷贝策略。</p><p>==每个CopyOnWriteArrayList对象里面有一个array数组对象用来存放具体元素，ReentrantLock独占锁对象用来保证同时只有一个线程对array进行修改。==</p><p>JDK8</p><h3 id="类属性："><a href="#类属性：" class="headerlink" title="类属性："></a>类属性：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class CopyOnWriteArrayList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    &#x2F;&#x2F; 版本序列号</span><br><span class="line">    private static final long serialVersionUID &#x3D; 8673264195747942595L;</span><br><span class="line">    &#x2F;&#x2F; 可重入锁</span><br><span class="line">    final transient ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">    &#x2F;&#x2F; 对象数组，用于存放元素</span><br><span class="line">    private transient volatile Object[] array;</span><br><span class="line">    &#x2F;&#x2F; 反射机制</span><br><span class="line">    private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">    &#x2F;&#x2F; lock域的内存偏移量</span><br><span class="line">    private static final long lockOffset;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            UNSAFE &#x3D; sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k &#x3D; CopyOnWriteArrayList.class;</span><br><span class="line">            lockOffset &#x3D; UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;lock&quot;));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public CopyOnWriteArrayList() &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置数组</span><br><span class="line">    setArray(new Object[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    if (c.getClass() &#x3D;&#x3D; CopyOnWriteArrayList.class) &#x2F;&#x2F; 类型相同</span><br><span class="line">        &#x2F;&#x2F; 获取c集合的数组</span><br><span class="line">        elements &#x3D; ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    else &#123; &#x2F;&#x2F; 类型不相同</span><br><span class="line">        &#x2F;&#x2F; 将c集合转化为数组并赋值给elements</span><br><span class="line">        elements &#x3D; c.toArray();</span><br><span class="line">        &#x2F;&#x2F; c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">        if (elements.getClass() !&#x3D; Object[].class) &#x2F;&#x2F; elements类型不为Object[]类型</span><br><span class="line">            &#x2F;&#x2F; 将elements数组转化为Object[]类型的数组</span><br><span class="line">            elements &#x3D; Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 设置数组</span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br><span class="line">  public CopyOnWriteArrayList(E[] toCopyIn) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将toCopyIn转化为Object[]类型数组，然后设置当前数组</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① 判断传入的集合c的类型是否为CopyOnWriteArrayList类型，若是，则获取该集合类型的底层数组（Object[]），并且设置当前CopyOnWriteArrayList的数组（Object[]数组），进入步骤③；否则，进入步骤②</p><p>　　② 将传入的集合转化为数组elements，判断elements的类型是否为Object[]类型（toArray方法可能不会返回Object类型的数组），若不是，则将elements转化为Object类型的数组。进入步骤③</p><p>　　③ 设置当前CopyOnWriteArrayList的Object[]为elements。</p><h3 id="copyOf函数"><a href="#copyOf函数" class="headerlink" title="copyOf函数　　"></a>copyOf函数　　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        &#x2F;&#x2F; 确定copy的类型（将newType转化为Object类型，将Object[].class转化为Object类型，判断两者是否相等，若相等，则生成指定长度的Object数组</span><br><span class="line">        &#x2F;&#x2F; 否则,生成指定长度的新类型的数组）</span><br><span class="line">        T[] copy &#x3D; ((Object)newType &#x3D;&#x3D; (Object)Object[].class)</span><br><span class="line">            ? (T[]) new Object[newLength]</span><br><span class="line">            : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">        &#x2F;&#x2F; 将original数组从下标0开始，复制长度为(original.length和newLength的较小者),复制到copy数组中（也从下标0开始）</span><br><span class="line">        System.arraycopy(original, 0, copy, 0,</span><br><span class="line">                         Math.min(original.length, newLength));</span><br><span class="line">        return copy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        &#x2F;&#x2F; 可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 元素数组</span><br><span class="line">            Object[] elements &#x3D; getArray();</span><br><span class="line">            &#x2F;&#x2F; 数组长度</span><br><span class="line">            int len &#x3D; elements.length;</span><br><span class="line">            &#x2F;&#x2F; 复制数组</span><br><span class="line">            Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);</span><br><span class="line">            &#x2F;&#x2F; 存放元素e</span><br><span class="line">            newElements[len] &#x3D; e;</span><br><span class="line">            &#x2F;&#x2F; 设置数组</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数用于将指定元素添加到此列表的尾部，处理流程如下</p><p>　　① 获取锁（保证多线程的安全访问），获取当前的Object数组，获取Object数组的长度为length，进入步骤②。</p><p>　　② 根据Object数组复制一个长度为length+1的Object数组为newElements（此时，newElements[length]为null），进入步骤③。</p><p>　　③ 将下标为length的数组元素newElements[length]设置为元素e，再设置当前Object[]为newElements，释放锁，返回。这样就完成了元素的添加。　　</p><h3 id="addIfAbsent"><a href="#addIfAbsent" class="headerlink" title="　　addIfAbsent"></a>　　addIfAbsent</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private boolean addIfAbsent(E e, Object[] snapshot) &#123;</span><br><span class="line">        &#x2F;&#x2F; 重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取数组</span><br><span class="line">            Object[] current &#x3D; getArray();</span><br><span class="line">            &#x2F;&#x2F; 数组长度</span><br><span class="line">            int len &#x3D; current.length;</span><br><span class="line">            if (snapshot !&#x3D; current) &#123; &#x2F;&#x2F; 快照不等于当前数组，对数组进行了修改</span><br><span class="line">                &#x2F;&#x2F; Optimize for lost race to another addXXX operation</span><br><span class="line">                &#x2F;&#x2F; 取较小者</span><br><span class="line">                int common &#x3D; Math.min(snapshot.length, len);</span><br><span class="line">                for (int i &#x3D; 0; i &lt; common; i++) &#x2F;&#x2F; 遍历</span><br><span class="line">                    if (current[i] !&#x3D; snapshot[i] &amp;&amp; eq(e, current[i])) &#x2F;&#x2F; 当前数组的元素与快照的元素不相等并且e与当前元素相等</span><br><span class="line">                        &#x2F;&#x2F; 表示在snapshot与current之间修改了数组，并且设置了数组某一元素为e，已经存在</span><br><span class="line">                        &#x2F;&#x2F; 返回</span><br><span class="line">                        return false;</span><br><span class="line">                if (indexOf(e, current, common, len) &gt;&#x3D; 0) &#x2F;&#x2F; 在当前数组中找到e元素</span><br><span class="line">                        &#x2F;&#x2F; 返回</span><br><span class="line">                        return false;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 复制数组</span><br><span class="line">            Object[] newElements &#x3D; Arrays.copyOf(current, len + 1);</span><br><span class="line">            &#x2F;&#x2F; 对数组len索引的元素赋值为e</span><br><span class="line">            newElements[len] &#x3D; e;</span><br><span class="line">            &#x2F;&#x2F; 设置数组</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：该函数用于添加元素（如果数组中不存在，则添加；否则，不添加，直接返回）。可以保证多线程环境下不会重复添加元素，该函数的流程如下</p><p>　　① 获取锁，获取当前数组为current，current长度为len，判断数组之前的快照snapshot是否等于当前数组current，若不相等，则进入步骤②；否则，进入步骤④</p><p>　　② 不相等，表示在snapshot与current之间，对数组进行了修改（如进行了add、set、remove等操作），获取长度（snapshot与current之间的较小者），对current进行遍历操作，若遍历过程发现snapshot与current的元素不相等并且current的元素与指定元素相等（可能进行了set操作），进入步骤⑤，否则，进入步骤③</p><p>　　③ 在当前数组中索引指定元素，若能够找到，进入步骤⑤，否则，进入步骤④</p><p>　　④ 复制当前数组current为newElements，长度为len+1，此时newElements[len]为null。再设置newElements[len]为指定元素e，再设置数组，进入步骤⑤</p><p>　　⑤ 释放锁，返回。　　</p><h3 id="set函数"><a href="#set函数" class="headerlink" title="　　set函数　"></a>　　set函数　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">        &#x2F;&#x2F; 可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取数组</span><br><span class="line">            Object[] elements &#x3D; getArray();</span><br><span class="line">            &#x2F;&#x2F; 获取index索引的元素</span><br><span class="line">            E oldValue &#x3D; get(elements, index);</span><br><span class="line"></span><br><span class="line">            if (oldValue !&#x3D; element) &#123; &#x2F;&#x2F; 旧值等于element</span><br><span class="line">                &#x2F;&#x2F; 数组长度</span><br><span class="line">                int len &#x3D; elements.length;</span><br><span class="line">                &#x2F;&#x2F; 复制数组</span><br><span class="line">                Object[] newElements &#x3D; Arrays.copyOf(elements, len);</span><br><span class="line">                &#x2F;&#x2F; 重新赋值index索引的值</span><br><span class="line">                newElements[index] &#x3D; element;</span><br><span class="line">                &#x2F;&#x2F; 设置数组</span><br><span class="line">                setArray(newElements);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; Not quite a no-op; ensures volatile write semantics</span><br><span class="line">                &#x2F;&#x2F; 设置数组</span><br><span class="line">                setArray(elements);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 返回旧值</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">        &#x2F;&#x2F; 可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取数组</span><br><span class="line">            Object[] elements &#x3D; getArray();</span><br><span class="line">            &#x2F;&#x2F; 数组长度</span><br><span class="line">            int len &#x3D; elements.length;</span><br><span class="line">            &#x2F;&#x2F; 获取旧值</span><br><span class="line">            E oldValue &#x3D; get(elements, index);</span><br><span class="line">            &#x2F;&#x2F; 需要移动的元素个数</span><br><span class="line">            int numMoved &#x3D; len - index - 1;</span><br><span class="line">            if (numMoved &#x3D;&#x3D; 0) &#x2F;&#x2F; 移动个数为0</span><br><span class="line">                &#x2F;&#x2F; 复制后设置数组</span><br><span class="line">                setArray(Arrays.copyOf(elements, len - 1));</span><br><span class="line">            else &#123; &#x2F;&#x2F; 移动个数不为0</span><br><span class="line">                &#x2F;&#x2F; 新生数组</span><br><span class="line">                Object[] newElements &#x3D; new Object[len - 1];</span><br><span class="line">                &#x2F;&#x2F; 复制index索引之前的元素</span><br><span class="line">                System.arraycopy(elements, 0, newElements, 0, index);</span><br><span class="line">                &#x2F;&#x2F; 复制index索引之后的元素</span><br><span class="line">                System.arraycopy(elements, index + 1, newElements, index,</span><br><span class="line">                                 numMoved);</span><br><span class="line">                &#x2F;&#x2F; 设置索引</span><br><span class="line">                setArray(newElements);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 返回旧值</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数用于移除此列表指定位置上的元素。处理流程如下</p><p>　　① 获取锁，获取数组elements，数组长度为length，获取索引的值elements[index]，计算需要移动的元素个数（length - index - 1）,若个数为0，则表示移除的是数组的最后一个元素，复制elements数组，复制长度为length-1，然后设置数组，进入步骤③；否则，进入步骤②</p><p>　　② 先复制index索引前的元素，再复制index索引后的元素，然后设置数组。</p><p>　　③ 释放锁，返回旧值。    </p><h3 id="COWIterator迭代器"><a href="#COWIterator迭代器" class="headerlink" title="COWIterator迭代器"></a>COWIterator迭代器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">        &#x2F;** Snapshot of the array *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 快照</span><br><span class="line">        private final Object[] snapshot;</span><br><span class="line">        &#x2F;** Index of element to be returned by subsequent call to next.  *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 游标</span><br><span class="line">        private int cursor;</span><br><span class="line">        &#x2F;&#x2F; 构造函数</span><br><span class="line">        private COWIterator(Object[] elements, int initialCursor) &#123;</span><br><span class="line">            cursor &#x3D; initialCursor;</span><br><span class="line">            snapshot &#x3D; elements;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 是否还有下一项</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return cursor &lt; snapshot.length;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 是否有上一项</span><br><span class="line">        public boolean hasPrevious() &#123;</span><br><span class="line">            return cursor &gt; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; next项</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public E next() &#123;</span><br><span class="line">            if (! hasNext()) &#x2F;&#x2F; 不存在下一项，抛出异常</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            &#x2F;&#x2F; 返回下一项</span><br><span class="line">            return (E) snapshot[cursor++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public E previous() &#123;</span><br><span class="line">            if (! hasPrevious())</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            return (E) snapshot[--cursor];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 下一项索引</span><br><span class="line">        public int nextIndex() &#123;</span><br><span class="line">            return cursor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 上一项索引</span><br><span class="line">        public int previousIndex() &#123;</span><br><span class="line">            return cursor-1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Not supported. Always throws UnsupportedOperationException.</span><br><span class="line">         * @throws UnsupportedOperationException always; &#123;@code remove&#125;</span><br><span class="line">         *         is not supported by this iterator.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 不支持remove操作</span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            throw new UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Not supported. Always throws UnsupportedOperationException.</span><br><span class="line">         * @throws UnsupportedOperationException always; &#123;@code set&#125;</span><br><span class="line">         *         is not supported by this iterator.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 不支持set操作</span><br><span class="line">        public void set(E e) &#123;</span><br><span class="line">            throw new UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Not supported. Always throws UnsupportedOperationException.</span><br><span class="line">         * @throws UnsupportedOperationException always; &#123;@code add&#125;</span><br><span class="line">         *         is not supported by this iterator.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 不支持add操作</span><br><span class="line">        public void add(E e) &#123;</span><br><span class="line">            throw new UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;</span><br><span class="line">            Objects.requireNonNull(action);</span><br><span class="line">            Object[] elements &#x3D; snapshot;</span><br><span class="line">            final int size &#x3D; elements.length;</span><br><span class="line">            for (int i &#x3D; cursor; i &lt; size; i++) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;) E e &#x3D; (E) elements[i];</span><br><span class="line">                action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">            cursor &#x3D; size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>COWIterator表示迭代器，其也有一个Object类型的数组作为CopyOnWriteArrayList数组的快照，这种快照风格的迭代器方法在创建迭代器时使用了对当时数组状态的引用。此数组在迭代器的生存期内不会更改，因此不可能发生冲突，并且迭代器保证不会抛出 ConcurrentModificationException。创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。在迭代器上进行的元素更改操作（remove、set 和 add）不受支持。这些方法将抛出 UnsupportedOperationException。</p><p>CopyOnWriteArrayList的源码很简单，其主要用到的快照的思路，使得在迭代的过程中，只是Object数组之前的某个快照，而不是最新的Object，这样可以保证在迭代的过程中不会抛出ConcurrentModificationException异常。谢谢各位园友的观看~</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>内存占用问题，有可能造成频繁的垃圾回收。</li><li>数据一致性问题，CopyOnWriteArrayList只能保证数据的最终一致性，不能保证数据的实时一致性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CopyOnWriteArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lucene分词器</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/5%E3%80%81%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/1%E3%80%81Lucene/2%E3%80%81Lucene%E5%88%86%E8%AF%8D%E5%99%A8/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/5%E3%80%81%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/1%E3%80%81Lucene/2%E3%80%81Lucene%E5%88%86%E8%AF%8D%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一：lucene自带分词器："><a href="#一：lucene自带分词器：" class="headerlink" title="一：lucene自带分词器："></a>一：lucene自带分词器：</h1><ol><li>Lucene-分词器API<br>（1）org.apache.lucene.analysi.Analyzer</li></ol><p>分析器，分词器组件的核心API，它的职责：构建真正对文本进行分词处理的TokenStream（分词处理器）。通过调用它的如下两个方法，得到输入文本的分词处理器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final TokenStream tokenStream(String fieldName, Reader reader)</span><br><span class="line"></span><br><span class="line">public final TokenStream tokenStream(String fieldName, String text)</span><br></pre></td></tr></table></figure><p>源码分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final TokenStream tokenStream(final String fieldName,</span><br><span class="line">                                       final Reader reader) &#123;</span><br><span class="line">    TokenStreamComponents components &#x3D; reuseStrategy.getReusableComponents(this, fieldName);</span><br><span class="line">    final Reader r &#x3D; initReader(fieldName, reader);</span><br><span class="line">    if (components &#x3D;&#x3D; null) &#123;</span><br><span class="line">      components &#x3D; createComponents(fieldName);</span><br><span class="line">      reuseStrategy.setReusableComponents(this, fieldName, components);</span><br><span class="line">    &#125;</span><br><span class="line">    components.setReader(r);</span><br><span class="line">    return components.getTokenStream();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Lucene提供的分词器StandardAnalyzer和SmartChineseAnalyzer</p><p>1、引入依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- lucene 核心模块  --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.lucene&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lucene-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;7.3.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Lucene提供的中文分词器模块，lucene-analyzers-smartcn:Lucene  的中文分词器 SmartChineseAnalyzer --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.lucene&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lucene-analyzers-smartcn&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;7.3.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2.1、新建一个标准分词器StandardAnalyzer（英文分词效果好，中文分词效果不好）的测试类LuceneStandardAnalyzerTest</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.luceneanalyzer.use.standardanalyzer;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import org.apache.lucene.analysis.Analyzer;</span><br><span class="line">import org.apache.lucene.analysis.TokenStream;</span><br><span class="line">import org.apache.lucene.analysis.standard.StandardAnalyzer;</span><br><span class="line">import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Lucene core模块中的 StandardAnalyzer英文分词器使用</span><br><span class="line"> * 英文分词效果好，中文分词效果不好</span><br><span class="line"> * @author THINKPAD</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class LuceneStandardAnalyzerTest &#123;</span><br><span class="line"></span><br><span class="line">    private static void doToken(TokenStream ts) throws IOException &#123;</span><br><span class="line">        ts.reset();</span><br><span class="line">        CharTermAttribute cta &#x3D; ts.getAttribute(CharTermAttribute.class);</span><br><span class="line">        while (ts.incrementToken()) &#123;</span><br><span class="line">            System.out.print(cta.toString() + &quot;|&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        ts.end();</span><br><span class="line">        ts.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        String etext &#x3D; &quot;Analysis is one of the main causes of slow indexing. Simply put, the more you analyze the slower analyze the indexing (in most cases).&quot;;</span><br><span class="line">        String chineseText &#x3D; &quot;张三说的确实在理。&quot;;</span><br><span class="line">        &#x2F;&#x2F; Lucene core模块中的 StandardAnalyzer 英文分词器</span><br><span class="line">        try (Analyzer ana &#x3D; new StandardAnalyzer();) &#123;</span><br><span class="line">            TokenStream ts &#x3D; ana.tokenStream(&quot;coent&quot;, etext);</span><br><span class="line">            System.out.println(&quot;标准分词器，英文分词效果：&quot;);</span><br><span class="line">            doToken(ts);</span><br><span class="line">            ts &#x3D; ana.tokenStream(&quot;content&quot;, chineseText);</span><br><span class="line">            System.out.println(&quot;标准分词器，中文分词效果：&quot;);</span><br><span class="line">            doToken(ts);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标准分词器，英文分词效果：</span><br><span class="line">analysis|one|main|causes|slow|indexing|simply|put|more|you|analyze|slower|analyze|indexing|most|cases|</span><br><span class="line">标准分词器，中文分词效果：</span><br><span class="line">张|三|说|的|确|实|在|理|</span><br></pre></td></tr></table></figure><p>2.2、新建一个Lucene提供的中文分词器SmartChineseAnalyzer（中英文分词效果都不好）的测试类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.luceneanalyzer.use.smartchineseanalyzer;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import org.apache.lucene.analysis.Analyzer;</span><br><span class="line">import org.apache.lucene.analysis.TokenStream;</span><br><span class="line">import org.apache.lucene.analysis.cn.smart.SmartChineseAnalyzer;</span><br><span class="line">import org.apache.lucene.analysis.standard.StandardAnalyzer;</span><br><span class="line">import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Lucene提供的中文分词器模块，lucene-analyzers-smartcn:Lucene 的中文分词器 SmartChineseAnalyzer</span><br><span class="line"> * 中英文分词效果都不好</span><br><span class="line"> * </span><br><span class="line"> * @author THINKPAD</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class LuceneSmartChineseAnalyzerTest &#123;</span><br><span class="line"></span><br><span class="line">    private static void doToken(TokenStream ts) throws IOException &#123;</span><br><span class="line">        ts.reset();</span><br><span class="line">        CharTermAttribute cta &#x3D; ts.getAttribute(CharTermAttribute.class);</span><br><span class="line">        while (ts.incrementToken()) &#123;</span><br><span class="line">            System.out.print(cta.toString() + &quot;|&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        ts.end();</span><br><span class="line">        ts.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        String etext &#x3D; &quot;Analysis is one of the main causes of slow indexing. Simply put, the more you analyze the slower analyze the indexing (in most cases).&quot;;</span><br><span class="line">        String chineseText &#x3D; &quot;张三说的确实在理。&quot;;</span><br><span class="line">        &#x2F;&#x2F; Lucene 的中文分词器 SmartChineseAnalyzer</span><br><span class="line">        try (Analyzer smart &#x3D; new SmartChineseAnalyzer()) &#123;</span><br><span class="line">            TokenStream ts &#x3D; smart.tokenStream(&quot;content&quot;, etext);</span><br><span class="line">            System.out.println(&quot;smart中文分词器，英文分词效果：&quot;);</span><br><span class="line">            doToken(ts);</span><br><span class="line">            ts &#x3D; smart.tokenStream(&quot;content&quot;, chineseText);</span><br><span class="line">            System.out.println(&quot;smart中文分词器，中文分词效果：&quot;);</span><br><span class="line">            doToken(ts);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">smart中文分词器，英文分词效果：</span><br><span class="line">analysi|is|on|of|the|main|caus|of|slow|index|simpli|put|the|more|you|analyz|the|slower|analyz|the|index|in|most|case|</span><br><span class="line">smart中文分词器，中文分词效果：</span><br><span class="line">张|三|说|的|确实|在|理|</span><br></pre></td></tr></table></figure><h1 id="二、IKAnalyze中文分词器集成"><a href="#二、IKAnalyze中文分词器集成" class="headerlink" title="二、IKAnalyze中文分词器集成"></a>二、IKAnalyze中文分词器集成</h1><p>1、引入依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- lucene 核心模块  --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.lucene&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lucene-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;7.3.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;   </span><br><span class="line">            </span><br><span class="line">        &lt;!-- ikanalyzer 中文分词器  --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.janeluo&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ikanalyzer&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2012_u6&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;!--排除掉里面旧的lucene包，因为我们要重写里面的分析器和分词器  --&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.apache.lucene&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;lucene-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.apache.lucene&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;lucene-queryparser&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.apache.lucene&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;lucene-analyzers-common&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">            &lt;&#x2F;exclusions&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、 重写分析器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.study.lucene.ikanalyzer.Integrated;</span><br><span class="line"></span><br><span class="line">import org.apache.lucene.analysis.Analyzer;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 因为Analyzer的createComponents方法API改变了需要重新实现分析器</span><br><span class="line"> * @author THINKPAD</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class IKAnalyzer4Lucene7 extends Analyzer &#123;</span><br><span class="line"></span><br><span class="line">    private boolean useSmart &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public IKAnalyzer4Lucene7() &#123;</span><br><span class="line">        this(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IKAnalyzer4Lucene7(boolean useSmart) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.useSmart &#x3D; useSmart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isUseSmart() &#123;</span><br><span class="line">        return useSmart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUseSmart(boolean useSmart) &#123;</span><br><span class="line">        this.useSmart &#x3D; useSmart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected TokenStreamComponents createComponents(String fieldName) &#123;</span><br><span class="line">        IKTokenizer4Lucene7 tk &#x3D; new IKTokenizer4Lucene7(this.useSmart);</span><br><span class="line">        return new TokenStreamComponents(tk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、重写分词器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package com.study.lucene.ikanalyzer.Integrated;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import org.apache.lucene.analysis.Analyzer;</span><br><span class="line">import org.apache.lucene.analysis.TokenStream;</span><br><span class="line">import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * IKAnalyzer分词器集成测试:</span><br><span class="line"> * 细粒度切分：把词分到最细</span><br><span class="line"> * 智能切分：根据词库进行拆分符合我们的语言习惯</span><br><span class="line"> * </span><br><span class="line"> * @author THINKPAD</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class IKAnalyzerTest &#123;</span><br><span class="line">    private static void doToken(TokenStream ts) throws IOException &#123;</span><br><span class="line">        ts.reset();</span><br><span class="line">        CharTermAttribute cta &#x3D; ts.getAttribute(CharTermAttribute.class);</span><br><span class="line">        while (ts.incrementToken()) &#123;</span><br><span class="line">            System.out.print(cta.toString() + &quot;|&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        ts.end();</span><br><span class="line">        ts.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        String etext &#x3D; &quot;Analysis is one of the main causes of slow indexing. Simply put, the more you analyze the slower analyze the indexing (in most cases).&quot;;</span><br><span class="line">        String chineseText &#x3D; &quot;张三说的确实在理。&quot;;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * ikanalyzer 中文分词器 因为Analyzer的createComponents方法API改变了 需要我们自己实现</span><br><span class="line">         * 分析器IKAnalyzer4Lucene7和分词器IKTokenizer4Lucene7</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; IKAnalyzer 细粒度切分</span><br><span class="line">        try (Analyzer ik &#x3D; new IKAnalyzer4Lucene7();) &#123;</span><br><span class="line">            TokenStream ts &#x3D; ik.tokenStream(&quot;content&quot;, etext);</span><br><span class="line">            System.out.println(&quot;IKAnalyzer中文分词器 细粒度切分，英文分词效果：&quot;);</span><br><span class="line">            doToken(ts);</span><br><span class="line">            ts &#x3D; ik.tokenStream(&quot;content&quot;, chineseText);</span><br><span class="line">            System.out.println(&quot;IKAnalyzer中文分词器 细粒度切分，中文分词效果：&quot;);</span><br><span class="line">            doToken(ts);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; IKAnalyzer 智能切分</span><br><span class="line">        try (Analyzer ik &#x3D; new IKAnalyzer4Lucene7(true);) &#123;</span><br><span class="line">            TokenStream ts &#x3D; ik.tokenStream(&quot;content&quot;, etext);</span><br><span class="line">            System.out.println(&quot;IKAnalyzer中文分词器 智能切分，英文分词效果：&quot;);</span><br><span class="line">            doToken(ts);</span><br><span class="line">            ts &#x3D; ik.tokenStream(&quot;content&quot;, chineseText);</span><br><span class="line">            System.out.println(&quot;IKAnalyzer中文分词器 智能切分，中文分词效果：&quot;);</span><br><span class="line">            doToken(ts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、 运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IKAnalyzer中文分词器 细粒度切分，英文分词效果：</span><br><span class="line">analysis|is|one|of|the|main|causes|of|slow|indexing.|indexing|simply|put|the|more|you|analyze|the|slower|analyze|the|indexing|in|most|cases|</span><br><span class="line">IKAnalyzer中文分词器 细粒度切分，中文分词效果：</span><br><span class="line">张三|三|说的|的确|的|确实|实在|在理|</span><br><span class="line">IKAnalyzer中文分词器 智能切分，英文分词效果：</span><br><span class="line">analysis|is|one|of|the|main|causes|of|slow|indexing.|simply|put|the|more|you|analyze|the|slower|analyze|the|indexing|in|most|cases|</span><br><span class="line">IKAnalyzer中文分词器 智能切分，中文分词效果：</span><br><span class="line">张三|说的|确实|在理|</span><br></pre></td></tr></table></figure><h1 id="三、扩展-IKAnalyzer的停用词和新词"><a href="#三、扩展-IKAnalyzer的停用词和新词" class="headerlink" title="三、扩展 IKAnalyzer的停用词和新词"></a>三、扩展 IKAnalyzer的停用词和新词</h1><p>扩展 IKAnalyzer的停用词</p><p>1、在类目录下创建IK的配置文件：IKAnalyzer.cfg.xml</p><p>2、在配置文件中增加配置扩展停用词文件的节点： <entry key=“ext_stopwords”>my_ext_stopword.dic</entry> 如有多个，以“;”间隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE properties SYSTEM &quot;http:&#x2F;&#x2F;java.sun.com&#x2F;dtd&#x2F;properties.dtd&quot;&gt;  </span><br><span class="line">&lt;properties&gt;  </span><br><span class="line">    &lt;comment&gt;IK Analyzer 扩展配置&lt;&#x2F;comment&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span><br><span class="line">    &lt;entry key&#x3D;&quot;ext_stopwords&quot;&gt;my_ext_stopword.dic&lt;&#x2F;entry&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure><p>3、在类目录下创建我们的扩展停用词文件 my_ext_stopword.dic，编辑该文件加入停用词，一行一个<br><img src="https://images2018.cnblogs.com/blog/1227483/201805/1227483-20180508000031889-1983024489.png" alt="image"><br>4、目录结构如下：<br><img src="https://images2018.cnblogs.com/blog/1227483/201805/1227483-20180508000140633-1997720168.png" alt="image"><br>5.新建测试类ExtendedIKAnalyzerDicTest.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package com.study.lucene.ikanalyzer.Integrated.ext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import org.apache.lucene.analysis.Analyzer;</span><br><span class="line">import org.apache.lucene.analysis.TokenStream;</span><br><span class="line">import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;</span><br><span class="line"></span><br><span class="line">import com.study.lucene.ikanalyzer.Integrated.IKAnalyzer4Lucene7;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 扩展 IKAnalyzer的词典测试</span><br><span class="line"> * </span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ExtendedIKAnalyzerDicTest &#123;</span><br><span class="line"></span><br><span class="line">    private static void doToken(TokenStream ts) throws IOException &#123;</span><br><span class="line">        ts.reset();</span><br><span class="line">        CharTermAttribute cta &#x3D; ts.getAttribute(CharTermAttribute.class);</span><br><span class="line">        while (ts.incrementToken()) &#123;</span><br><span class="line">            System.out.print(cta.toString() + &quot;|&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        ts.end();</span><br><span class="line">        ts.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        String chineseText &#x3D; &quot;厉害了我的国一经播出，受到各方好评，强烈激发了国人的爱国之情、自豪感！&quot;;</span><br><span class="line">        &#x2F;&#x2F; IKAnalyzer 细粒度切分</span><br><span class="line">        try (Analyzer ik &#x3D; new IKAnalyzer4Lucene7();) &#123;</span><br><span class="line">            TokenStream ts &#x3D; ik.tokenStream(&quot;content&quot;, chineseText);</span><br><span class="line">            System.out.println(&quot;IKAnalyzer中文分词器 细粒度切分，中文分词效果：&quot;);</span><br><span class="line">            doToken(ts);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; IKAnalyzer 智能切分</span><br><span class="line">        try (Analyzer ik &#x3D; new IKAnalyzer4Lucene7(true);) &#123;</span><br><span class="line">            TokenStream ts &#x3D; ik.tokenStream(&quot;content&quot;, chineseText);</span><br><span class="line">            System.out.println(&quot;IKAnalyzer中文分词器 智能切分，中文分词效果：&quot;);</span><br><span class="line">            doToken(ts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>未加停用词之前：<br><img src="https://images2018.cnblogs.com/blog/1227483/201805/1227483-20180508000522941-1675631753.png" alt="image"><br>加停用词之后：<br><img src="https://images2018.cnblogs.com/blog/1227483/201805/1227483-20180508000610510-2095338490.png" alt="image"></p><h1 id="四：扩展-IKAnalyzer的新词："><a href="#四：扩展-IKAnalyzer的新词：" class="headerlink" title="四：扩展 IKAnalyzer的新词："></a>四：扩展 IKAnalyzer的新词：</h1><p>1、在类目录下IK的配置文件：IKAnalyzer.cfg.xml 中增加配置扩展词文件的节点： <entry key="ext_dict">ext.dic</entry> 如有多个，以“;”间隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE properties SYSTEM &quot;http:&#x2F;&#x2F;java.sun.com&#x2F;dtd&#x2F;properties.dtd&quot;&gt;  </span><br><span class="line">&lt;properties&gt;  </span><br><span class="line">    &lt;comment&gt;IK Analyzer 扩展配置&lt;&#x2F;comment&gt;</span><br><span class="line">    &lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span><br><span class="line">    &lt;entry key&#x3D;&quot;ext_dict&quot;&gt;ext.dic&lt;&#x2F;entry&gt; </span><br><span class="line">    </span><br><span class="line">    &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span><br><span class="line">    &lt;entry key&#x3D;&quot;ext_stopwords&quot;&gt;my_ext_stopword.dic&lt;&#x2F;entry&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure><p>2、在类目录下创建扩展词文件 ext.dic，编辑该文件加入新词，一行一个</p><p><img src="https://images2018.cnblogs.com/blog/1227483/201805/1227483-20180508000821076-1887752381.png" alt="image"></p><p>3、目录结构如下：</p><p><img src="https://images2018.cnblogs.com/blog/1227483/201805/1227483-20180508000926462-1027764993.png" alt="image"><br>4.运行前面的测试类测试类ExtendedIKAnalyzerDicTest.java查看运行效果</p><p>运行结果：</p><p>未加新词之前：<br><img src="https://images2018.cnblogs.com/blog/1227483/201805/1227483-20180508003111276-681217039.png" alt="image"><br>加新词之后：<br><img src="https://images2018.cnblogs.com/blog/1227483/201805/1227483-20180508003226101-1437691226.png" alt="image"><br>附带源码获取地址：</p><p><a href="https://github.com/leeSmall/SearchEngineDemo">https://github.com/leeSmall/SearchEngineDemo</a> </p>]]></content>
      
      
      <categories>
          
          <category> Lucene </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lucene分词器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/10%E3%80%81ThreadLocal/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/10%E3%80%81ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h3 id="1、ThreadLocal"><a href="#1、ThreadLocal" class="headerlink" title="1、ThreadLocal"></a>1、ThreadLocal</h3><p>==每个线程都有独立的数据：每个线程仅需要实例化一次即可。虽然不同的线程执行同一段代码时，访问同一个ThreadLocal变量，但是每个线程只能看到私有的ThreadLocal实例。所以不同的线程在给ThreadLocal对象设置不同的值时，他们也不能看到彼此的修改。==</p><h3 id="ThreadLocal结构"><a href="#ThreadLocal结构" class="headerlink" title="ThreadLocal结构"></a>ThreadLocal结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocal&lt;T&gt; &#123;</span><br><span class="line">&#x2F;&#x2F;ThreadLocal静态内部类ThreadLocalMap</span><br><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line">&#x2F;&#x2F;ThreadLocalMap静态内部类Entry</span><br><span class="line">        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                super(k);</span><br><span class="line">                value &#x3D; v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal的内部维护着一个叫做==ThreadLocalmap的静态类，它由一个环形动态数组组成（默认大小为16），每个数组都是一个Entry对象==，该对象以ThreadLocal对象作为key，以传入的数据作为值</p><p><img src="https://images2018.cnblogs.com/blog/1066538/201802/1066538-20180224142513040-912203924.png" alt="image"></p><h3 id="源码解析："><a href="#源码解析：" class="headerlink" title="源码解析："></a>源码解析：</h3><p>ThreadLocal是对其静态内部类ThreadLocalMap的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocal&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;计算下一个hash码</span><br><span class="line">    private final int threadLocalHashCode &#x3D; nextHashCode();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下一个哈希码初始状态：从零开始。</span><br><span class="line">    private static AtomicInteger nextHashCode &#x3D;</span><br><span class="line">        new AtomicInteger();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;hash增量。存在意义是将隐式顺序线程本地ID转换为近乎最佳的散布（hash的均匀分布）</span><br><span class="line">    private static final int HASH_INCREMENT &#x3D; 0x61c88647;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下一个哈希码原子更新，从零开始。通过hash增量计算hash值</span><br><span class="line">    private static int nextHashCode() &#123;</span><br><span class="line">        return nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化value 为null</span><br><span class="line">    protected T initialValue() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) &#123;</span><br><span class="line">        return new SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构造器</span><br><span class="line">    public ThreadLocal() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取值方法</span><br><span class="line">    public T get() &#123;</span><br><span class="line">        Thread t &#x3D; Thread.currentThread();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据线程获取线程本地map(ThreadLocal的一个静态内部类)</span><br><span class="line">        ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">        if (map !&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F;根据threadlocal对象获取Entry环形数组中的对应下标的一个Entry</span><br><span class="line">            ThreadLocalMap.Entry e &#x3D; map.getEntry(this);</span><br><span class="line">            if (e !&#x3D; null) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                T result &#x3D; (T)e.value;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;若map为空，初始化一个值</span><br><span class="line">        return setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化一个值</span><br><span class="line">    private T setInitialValue() &#123;</span><br><span class="line">        T value &#x3D; initialValue();</span><br><span class="line">        Thread t &#x3D; Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">        if (map !&#x3D; null)</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        else</span><br><span class="line">&#x2F;&#x2F;若map为空，则创建一个map</span><br><span class="line">            createMap(t, value);</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设值方法</span><br><span class="line">    public void set(T value) &#123;</span><br><span class="line">        Thread t &#x3D; Thread.currentThread();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据线程获取线程本地map(ThreadLocal的一个静态内部类)</span><br><span class="line">        ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">        if (map !&#x3D; null)</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        else</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;若map为空，则创建一个map</span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除元素</span><br><span class="line">     public void remove() &#123;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;根据线程获取线程本地map(ThreadLocal的一个静态内部类)</span><br><span class="line">         ThreadLocalMap m &#x3D; getMap(Thread.currentThread());</span><br><span class="line">         if (m !&#x3D; null)</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;删除环形数据中的一个Entry</span><br><span class="line">             m.remove(this);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">        return t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建ThreadLocalMap（环形数组初始长度为16）</span><br><span class="line">    void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">        t.threadLocals &#x3D; new ThreadLocalMap(this, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">        return new ThreadLocalMap(parentMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    T childValue(T parentValue) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static final class SuppliedThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private final Supplier&lt;? extends T&gt; supplier;</span><br><span class="line"></span><br><span class="line">        SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) &#123;</span><br><span class="line">            this.supplier &#x3D; Objects.requireNonNull(supplier);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected T initialValue() &#123;</span><br><span class="line">            return supplier.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br></pre></td><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用虚引用封装的ThreadLocal</span><br><span class="line">        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            </span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                super(k);</span><br><span class="line">                value &#x3D; v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;环形数组初始长度为16</span><br><span class="line">        private static final int INITIAL_CAPACITY &#x3D; 16;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        private Entry[] table;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;数组的实际长度（在涉及数组元素变化时修改）</span><br><span class="line">        private int size &#x3D; 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;类似hashMap的负载因子对应的一个阀值</span><br><span class="line">        private int threshold; </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        private void setThreshold(int len) &#123;</span><br><span class="line">            threshold &#x3D; len * 2 &#x2F; 3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F;环形数组的体现：若i+1 &lt; len，则返回下标为 i+1，否则返回0，也就是回到数组起始位置</span><br><span class="line">        private static int nextIndex(int i, int len) &#123;</span><br><span class="line">            return ((i + 1 &lt; len) ? i + 1 : 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;环形数组的体现：下标没有越界，返回i-1，否则返回len-1，取到了数组末尾</span><br><span class="line">        private static int prevIndex(int i, int len) &#123;</span><br><span class="line">            return ((i - 1 &gt;&#x3D; 0) ? i - 1 : len - 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">&#x2F;&#x2F;创建初始大小为16的数组</span><br><span class="line">            table &#x3D; new Entry[INITIAL_CAPACITY];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取键值的hashCode与数组的长度-1进行与运算,计算对应数组的下标</span><br><span class="line">            int i &#x3D; firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将数据放入新构建的Entry，并放入数组对应位置</span><br><span class="line">            table[i] &#x3D; new Entry(firstKey, firstValue);</span><br><span class="line">            size &#x3D; 1;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从给定的parentMap构造一个包含所有map的新ThreadLocal。由createInheritedMap调用。</span><br><span class="line">        private ThreadLocalMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">            Entry[] parentTable &#x3D; parentMap.table;</span><br><span class="line">            int len &#x3D; parentTable.length;</span><br><span class="line">            setThreshold(len);</span><br><span class="line">            table &#x3D; new Entry[len];</span><br><span class="line"></span><br><span class="line">            for (int j &#x3D; 0; j &lt; len; j++) &#123;</span><br><span class="line">                Entry e &#x3D; parentTable[j];</span><br><span class="line">                if (e !&#x3D; null) &#123;</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    ThreadLocal&lt;Object&gt; key &#x3D; (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                    if (key !&#x3D; null) &#123;</span><br><span class="line">                        Object value &#x3D; key.childValue(e.value);</span><br><span class="line">                        Entry c &#x3D; new Entry(key, value);</span><br><span class="line">                        int h &#x3D; key.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">                        while (table[h] !&#x3D; null)</span><br><span class="line">                            h &#x3D; nextIndex(h, len);</span><br><span class="line">                        table[h] &#x3D; c;</span><br><span class="line">                        size++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取键值的hashCode与数组的长度-1进行与运算,计算对应数组的下标</span><br><span class="line">            int i &#x3D; key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">            Entry e &#x3D; table[i];</span><br><span class="line">&#x2F;&#x2F;取出Entry，且Entry的e.get()等于传入的key</span><br><span class="line">            if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; key)</span><br><span class="line">                return e;</span><br><span class="line">            else</span><br><span class="line">&#x2F;&#x2F;hash冲突的情况，（因为放值得时候，使用的是线性探测解决hash冲突）</span><br><span class="line">                return getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;因为放值得时候，使用的是线性探测解决hash冲突,所以这里需要依次比对</span><br><span class="line">        private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line"></span><br><span class="line">            Entry[] tab &#x3D; table;</span><br><span class="line">int len &#x3D; tab.length;</span><br><span class="line">while (e !&#x3D; null) &#123;&#x2F;&#x2F;循环直到节点Entry对象不为null</span><br><span class="line">ThreadLocal k &#x3D; e.get();&#x2F;&#x2F;获取键值ThreadLocal</span><br><span class="line">if (k &#x3D;&#x3D; key)&#x2F;&#x2F;如果key值相同</span><br><span class="line">return e;&#x2F;&#x2F;返回该节点</span><br><span class="line">if (k &#x3D;&#x3D; null)&#x2F;&#x2F;如果key为null</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里为什么要清除 不太理解</span><br><span class="line">expungeStaleEntry(i);&#x2F;&#x2F;调取exoungeStaleEntry方法</span><br><span class="line">else</span><br><span class="line">i &#x3D; nextIndex(i, len);&#x2F;&#x2F;继续下一个节点</span><br><span class="line">e &#x3D; tab[i];</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Entry[] tab &#x3D; table;</span><br><span class="line">            int len &#x3D; tab.length;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取键值的hashCode与数组的长度-1进行与运算,计算对应数组的下标</span><br><span class="line">            int i &#x3D; key.threadLocalHashCode &amp; (len-1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;若hash冲突则线性探测，将数据放入数组下一个空闲的位置</span><br><span class="line">            for (Entry e &#x3D; tab[i];</span><br><span class="line">                 e !&#x3D; null;</span><br><span class="line">                 e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;若数组对应的位置key与传入的key相同则直接覆盖</span><br><span class="line">                if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">                    e.value &#x3D; value;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果键为null</span><br><span class="line">                if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F;调用replaceStaleEntry方法</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">循环结束为放进去，则数组满了</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构建新的Entry，</span><br><span class="line">            tab[i] &#x3D; new Entry(key, value);</span><br><span class="line">            int sz &#x3D; ++size;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果数组中没有冗余的null值并且如果size大于临界值</span><br><span class="line">            if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;&#x3D; threshold)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;数组扩容</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        private void remove(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">            Entry[] tab &#x3D; table;</span><br><span class="line">            int len &#x3D; tab.length;</span><br><span class="line">            int i &#x3D; key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">            for (Entry e &#x3D; tab[i];</span><br><span class="line">                 e !&#x3D; null;</span><br><span class="line">                 e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123;</span><br><span class="line">                if (e.get() &#x3D;&#x3D; key) &#123;</span><br><span class="line">                    e.clear();</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,</span><br><span class="line">                                       int staleSlot) &#123;</span><br><span class="line">            Entry[] tab &#x3D; table;</span><br><span class="line">            int len &#x3D; tab.length;</span><br><span class="line">            Entry e;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            int slotToExpunge &#x3D; staleSlot;</span><br><span class="line">            for (int i &#x3D; prevIndex(staleSlot, len);</span><br><span class="line">                 (e &#x3D; tab[i]) !&#x3D; null;</span><br><span class="line">                 i &#x3D; prevIndex(i, len))</span><br><span class="line">                if (e.get() &#x3D;&#x3D; null)</span><br><span class="line">                    slotToExpunge &#x3D; i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            for (int i &#x3D; nextIndex(staleSlot, len);</span><br><span class="line">                 (e &#x3D; tab[i]) !&#x3D; null;</span><br><span class="line">                 i &#x3D; nextIndex(i, len)) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line"></span><br><span class="line">                if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">                    e.value &#x3D; value;</span><br><span class="line"></span><br><span class="line">                    tab[i] &#x3D; tab[staleSlot];</span><br><span class="line">                    tab[staleSlot] &#x3D; e;</span><br><span class="line"></span><br><span class="line">                    if (slotToExpunge &#x3D;&#x3D; staleSlot)</span><br><span class="line">                        slotToExpunge &#x3D; i;</span><br><span class="line">                    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (k &#x3D;&#x3D; null &amp;&amp; slotToExpunge &#x3D;&#x3D; staleSlot)</span><br><span class="line">                    slotToExpunge &#x3D; i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If key not found, put new entry in stale slot</span><br><span class="line">            tab[staleSlot].value &#x3D; null;</span><br><span class="line">            tab[staleSlot] &#x3D; new Entry(key, value);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If there are any other stale entries in run, expunge them</span><br><span class="line">            if (slotToExpunge !&#x3D; staleSlot)</span><br><span class="line">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自动释放内存</span><br><span class="line">        private int expungeStaleEntry(int staleSlot) &#123;</span><br><span class="line">Entry[] tab &#x3D; table;</span><br><span class="line">int len &#x3D; tab.length;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tab[staleSlot].value &#x3D; null;&#x2F;&#x2F;数组的对应节点值设为nulll</span><br><span class="line">tab[staleSlot] &#x3D; null;&#x2F;&#x2F;数组对应的节点设为null</span><br><span class="line">size--;&#x2F;&#x2F;数组大小-1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Entry e;</span><br><span class="line">int i;</span><br><span class="line">for (i &#x3D; nextIndex(staleSlot, len);</span><br><span class="line"> (e &#x3D; tab[i]) !&#x3D; null;</span><br><span class="line"> i &#x3D; nextIndex(i, len)) &#123; &#x2F;&#x2F;移动到下一节点</span><br><span class="line">ThreadLocal k &#x3D; e.get();</span><br><span class="line">if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">e.value &#x3D; null;</span><br><span class="line">tab[i] &#x3D; null;</span><br><span class="line">size--;&#x2F;&#x2F;size-1</span><br><span class="line">&#125; else &#123;</span><br><span class="line">int h &#x3D; k.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">if (h !&#x3D; i) &#123;&#x2F;&#x2F;如果该位置不是下一节点</span><br><span class="line">tab[i] &#x3D; null;&#x2F;&#x2F;数组的元素设为null</span><br><span class="line">while (tab[h] !&#x3D; null)&#x2F;&#x2F;</span><br><span class="line">h &#x3D; nextIndex(h, len);</span><br><span class="line">tab[h] &#x3D; e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        private boolean cleanSomeSlots(int i, int n) &#123;</span><br><span class="line">            boolean removed &#x3D; false;</span><br><span class="line">            Entry[] tab &#x3D; table;</span><br><span class="line">            int len &#x3D; tab.length;</span><br><span class="line">            do &#123;</span><br><span class="line">                i &#x3D; nextIndex(i, len);</span><br><span class="line">                Entry e &#x3D; tab[i];</span><br><span class="line">                if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    n &#x3D; len;</span><br><span class="line">                    removed &#x3D; true;</span><br><span class="line">                    i &#x3D; expungeStaleEntry(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; while ( (n &gt;&gt;&gt;&#x3D; 1) !&#x3D; 0);</span><br><span class="line">            return removed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Re-pack and&#x2F;or re-size the table. First scan the entire</span><br><span class="line">         * table removing stale entries. If this doesn&#39;t sufficiently</span><br><span class="line">         * shrink the size of the table, double the table size.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        private void rehash() &#123;</span><br><span class="line">            expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Use lower threshold for doubling to avoid hysteresis</span><br><span class="line">            if (size &gt;&#x3D; threshold - threshold &#x2F; 4)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void resize() &#123;</span><br><span class="line">Entry[] oldTab &#x3D; table;</span><br><span class="line">int oldLen &#x3D; oldTab.length;</span><br><span class="line">int newLen &#x3D; oldLen * 2;</span><br><span class="line">Entry[] newTab &#x3D; new Entry[newLen];</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for (int j &#x3D; 0; j &lt; oldLen; ++j) &#123;&#x2F;&#x2F;循环遍历旧数组</span><br><span class="line">Entry e &#x3D; oldTab[j];</span><br><span class="line">if (e !&#x3D; null) &#123;</span><br><span class="line">ThreadLocal k &#x3D; e.get();</span><br><span class="line">if (k &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;如果键为bull</span><br><span class="line">e.value &#x3D; null; &#x2F;&#x2F; 值也设为null</span><br><span class="line">&#125; else &#123;</span><br><span class="line">int h &#x3D; k.threadLocalHashCode &amp; (newLen - 1);&#x2F;&#x2F;通过hashcode值计算键位</span><br><span class="line">while (newTab[h] !&#x3D; null)</span><br><span class="line">h &#x3D; nextIndex(h, newLen);</span><br><span class="line">newTab[h] &#x3D; e;&#x2F;&#x2F;给数据元素设值</span><br><span class="line">count++;&#x2F;&#x2F;count进行+1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置下次数组扩容的阀值</span><br><span class="line">setThreshold(newLen);</span><br><span class="line">size &#x3D; count;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将新数组替换过去的旧数组</span><br><span class="line">table &#x3D; newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;移除不用的entry从而达到自动释放内存的目的</span><br><span class="line">        private void expungeStaleEntries() &#123; </span><br><span class="line">            Entry[] tab &#x3D; table;</span><br><span class="line">            int len &#x3D; tab.length; </span><br><span class="line">            for (int j &#x3D; 0; j &lt; len; j++) &#123;</span><br><span class="line">                Entry e &#x3D; tab[j];</span><br><span class="line">&#x2F;&#x2F;如果元素不为null并且获取的键为null</span><br><span class="line">                if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; null)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用expungeStaleEntry方法</span><br><span class="line">                    expungeStaleEntry(j);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p>Spring的事务管理器底层获取连接时候，应用ThreadLocal</p><p>为什么要放在ThreadLocal里面呢？由于Spring在AOP后并不能向应用程序传递參数。应用程序的每一个业务代码是事先定义好的，Spring并不会要求在业务代码的入口參数中必须编写Connection的入口參数。此时Spring选择了ThreadLocal，通过它保证连接对象始终在线程内部，不论什么时候都能拿到，此时Spring很清楚什么时候回收这个连接，也就是很清楚什么时候从ThreadLocal中删除这个元素</p><p>用ThreadLocal解决SimpleDateFormat的线程不安全的问题。</p><h4 id="内存泄露，缺点以及线程池复用的值传递问题。"><a href="#内存泄露，缺点以及线程池复用的值传递问题。" class="headerlink" title="内存泄露，缺点以及线程池复用的值传递问题。"></a>内存泄露，缺点以及线程池复用的值传递问题。</h4>]]></content>
      
      
      <categories>
          
          <category> 常用方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solrj api的操作</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/5%E3%80%81%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/2%E3%80%81solr/6%E3%80%81solrj%20api%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/5%E3%80%81%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/2%E3%80%81solr/6%E3%80%81solrj%20api%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>1、引入相关依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.solr&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;solr-solrj&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.3.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.11&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.7&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-logging&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-logging&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="1、HttpSolrClient"><a href="#1、HttpSolrClient" class="headerlink" title="1、HttpSolrClient"></a>1、HttpSolrClient</h2><p>创建与 schema.xml文件相对应的javabean，这里命名为Notice。并添加@Field注解，生成getter和setter方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Notice &#123;</span><br><span class="line">  @Field(&quot;id&quot;)</span><br><span class="line">  private String id;</span><br><span class="line">  @Field</span><br><span class="line">  private String title;</span><br><span class="line">  @Field</span><br><span class="line">  private String subject;</span><br><span class="line">  @Field</span><br><span class="line">  private String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">public class SolrjTest &#123;</span><br><span class="line"></span><br><span class="line">  private HttpSolrClient httpSolrClient;</span><br><span class="line">  </span><br><span class="line">  &#x2F;**</span><br><span class="line">  *solrj6.5之前的初始化SolrClient方式</span><br><span class="line">  *&#x2F;</span><br><span class="line">  @Before</span><br><span class="line">  public void initConnect() throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F; 在url中指定core名称：notice</span><br><span class="line">    String url &#x3D; &quot;http:&#x2F;&#x2F;localhost:777&#x2F;solr&#x2F;notice&#x2F;&quot;;</span><br><span class="line">    HttpSolrClient httpSolrClient &#x3D; new HttpSolrClient(url);</span><br><span class="line">    httpSolrClient.setParser(new XMLResponseParser()); &#x2F;&#x2F; 设置响应解析器</span><br><span class="line">    httpSolrClient.setConnectionTimeout(500); &#x2F;&#x2F; 建立连接的最长时间</span><br><span class="line">    this.httpSolrClient &#x3D; httpSolrClient;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取SolrClient</span><br><span class="line">     * solrj 6.5及以后版本获取方式</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static HttpSolrClient getSolrClient()&#123;</span><br><span class="line">    &#x2F;&#x2F; solr url</span><br><span class="line">    private final static String BASE_URL &#x3D; &quot;http:&#x2F;&#x2F;localhost:8081&#x2F;solr&quot;;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 设置超时时间</span><br><span class="line">         * .withConnectionTimeout(10000)</span><br><span class="line">         * .withSocketTimeout(60000)</span><br><span class="line">         *&#x2F;</span><br><span class="line">        return new HttpSolrClient.Builder(BASE_URL)</span><br><span class="line">                .withConnectionTimeout(10000)</span><br><span class="line">                .withSocketTimeout(60000)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">   &#x2F;*</span><br><span class="line">     * 测试向索引库中添加文档</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">  public void testAdd() throws IOException, SolrServerException &#123;</span><br><span class="line">    Notice notice &#x3D; new Notice();</span><br><span class="line">    String desc &#x3D; &quot;该应用场景为AdMaster DMP缓存存储需求，DMP需要管理非常多的第三方id数据，其中包括各媒体cookie与自身cookie（以下统称admckid）的mapping关系，还包括了admckid的人口标签、移动端id（主要是idfa和imei）的人口标签，以及一些黑名单id、ip等数据。&quot;;</span><br><span class="line">    notice.setId(UUID.randomUUID().toString());</span><br><span class="line">    notice.setTitle(&quot;Redis百亿级Key存储方案&quot;);</span><br><span class="line">    notice.setSubject(&quot;该应用场景为AdMaster DMP缓存存储需求&quot;);</span><br><span class="line">    notice.setDescription(desc);</span><br><span class="line">    this.httpSolrClient.addBean(notice);</span><br><span class="line">    this.httpSolrClient.commit();</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;*</span><br><span class="line">     * 测试查询文档</span><br><span class="line">     *&#x2F;</span><br><span class="line">  @Test</span><br><span class="line">  public void testQuery() throws SolrServerException, IOException&#123;</span><br><span class="line">    String keywords &#x3D; &quot;应用&quot;;</span><br><span class="line">    int page &#x3D; 1;</span><br><span class="line">    int rows &#x3D; 10;</span><br><span class="line">    </span><br><span class="line">    SolrQuery solrQuery &#x3D; new SolrQuery(); &#x2F;&#x2F; 构造搜索条件</span><br><span class="line">    solrQuery.setQuery(&quot;text:&quot; + keywords); &#x2F;&#x2F; 搜索关键词</span><br><span class="line">    &#x2F;&#x2F; 设置分页 </span><br><span class="line">    solrQuery.setStart((Math.max(page, 1) - 1) * rows);</span><br><span class="line">    solrQuery.setRows(rows);</span><br><span class="line">    </span><br><span class="line">    QueryResponse queryResponse &#x3D; this.httpSolrClient.query(solrQuery);</span><br><span class="line">    List&lt;Notice&gt; notices &#x3D; queryResponse.getBeans(Notice.class);</span><br><span class="line">    for (Notice notice : notices) &#123;</span><br><span class="line">      System.out.println(notice.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 测试删除文档</span><br><span class="line">     *&#x2F;</span><br><span class="line">  @Test</span><br><span class="line">  public void testDelete() throws SolrServerException, IOException&#123;</span><br><span class="line">    String id &#x3D; &quot;30a6d598-9762-455a-94f7-21fa011640d1&quot;;</span><br><span class="line">    this.httpSolrClient.deleteById(id);</span><br><span class="line">    this.httpSolrClient.commit();</span><br><span class="line">  &#125;</span><br><span class="line">     &#x2F;*</span><br><span class="line">     * 测试高亮显示关键字</span><br><span class="line">     *&#x2F;</span><br><span class="line">  @Test</span><br><span class="line">  public void testHighlighting() throws SolrServerException, IOException&#123;</span><br><span class="line">    String keywords &#x3D; &quot;应用&quot;;</span><br><span class="line">    int page &#x3D; 1;</span><br><span class="line">    int rows &#x3D; 10;</span><br><span class="line">    </span><br><span class="line">    SolrQuery solrQuery &#x3D; new SolrQuery(); &#x2F;&#x2F; 构造搜索条件</span><br><span class="line">    solrQuery.setQuery(&quot;text:&quot; + keywords); &#x2F;&#x2F; 搜索关键词</span><br><span class="line">    &#x2F;&#x2F; 设置分页 </span><br><span class="line">    solrQuery.setStart((Math.max(page, 1) - 1) * rows);</span><br><span class="line">    solrQuery.setRows(rows);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 是否需要高亮</span><br><span class="line">    boolean isHighlighting &#x3D; !StringUtils.equals(&quot;*&quot;, keywords) &amp;&amp; StringUtils.isNotEmpty(keywords);</span><br><span class="line">    if (isHighlighting) &#123;</span><br><span class="line">      &#x2F;&#x2F; 设置高亮</span><br><span class="line">      solrQuery.setHighlight(true); &#x2F;&#x2F; 开启高亮组件</span><br><span class="line">      solrQuery.addHighlightField(&quot;title&quot;);&#x2F;&#x2F; 高亮字段</span><br><span class="line">      solrQuery.addHighlightField(&quot;subject&quot;);</span><br><span class="line">      solrQuery.setHighlightSimplePre(&quot;&lt;span style&#x3D;&#39;color:red;&#39;&gt;&quot;);&#x2F;&#x2F; 标记，高亮关键字前缀</span><br><span class="line">      solrQuery.setHighlightSimplePost(&quot;&lt;&#x2F;span&gt;&quot;);&#x2F;&#x2F; 后缀</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    QueryResponse queryResponse &#x3D; this.httpSolrClient.query(solrQuery);</span><br><span class="line">    List&lt;Notice&gt; notices &#x3D; queryResponse.getBeans(Notice.class);</span><br><span class="line">    </span><br><span class="line">    if (isHighlighting) &#123;</span><br><span class="line">      &#x2F;&#x2F; 将高亮的标题数据写回到数据对象中</span><br><span class="line">      Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; map &#x3D; queryResponse.getHighlighting();</span><br><span class="line">      for (Map.Entry&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting : map.entrySet()) &#123;</span><br><span class="line">        for (Notice notice : notices) &#123;</span><br><span class="line">          if (!highlighting.getKey().equals(notice.getId().toString())) &#123;</span><br><span class="line">            continue;</span><br><span class="line">          &#125;</span><br><span class="line">          if(highlighting.getValue().get(&quot;title&quot;) !&#x3D; null)&#123;</span><br><span class="line">            notice.setTitle(StringUtils.join(highlighting.getValue().get(&quot;title&quot;), &quot;&quot;));</span><br><span class="line">          &#125;</span><br><span class="line">          if(highlighting.getValue().get(&quot;subject&quot;) !&#x3D; null)&#123;</span><br><span class="line">            notice.setSubject(StringUtils.join(highlighting.getValue().get(&quot;subject&quot;),&quot;&quot;));</span><br><span class="line">          &#125;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (Notice notice : notices) &#123;</span><br><span class="line">      System.out.println(notice.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、solrServer"><a href="#2、solrServer" class="headerlink" title="2、solrServer"></a>2、solrServer</h2><p>可以直接配置到spring或者直接在代码中创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;</span><br><span class="line">xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot; xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-4.0.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context-4.0.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop-4.0.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx-4.0.xsd</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&#x2F;spring-util-4.0.xsd&quot;&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!-- 配置SolrServer对象 --&gt;</span><br><span class="line">&lt;!-- 单机版 --&gt;</span><br><span class="line"> &lt;bean id&#x3D;&quot;httpSolrServer&quot; class&#x3D;&quot;org.apache.solr.client.solrj.impl.HttpSolrServer&quot;&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;baseURL&quot; value&#x3D;&quot;$&#123;SOLR.SERVER.URL&#125;&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;&#x2F;bean&gt; </span><br><span class="line">&lt;!-- 集群版 --&gt;</span><br><span class="line">&lt;!--&lt;bean id&#x3D;&quot;cloudSolrServer&quot; class&#x3D;&quot;org.apache.solr.client.solrj.impl.CloudSolrServer&quot;&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;zkHost&quot; value&#x3D;&quot;192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;defaultCollection&quot; value&#x3D;&quot;collection2&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;--&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">package com.april.lucene.solr;</span><br><span class="line"> </span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.util.List;</span><br><span class="line">import org.apache.solr.client.solrj.SolrQuery;</span><br><span class="line">import org.apache.solr.client.solrj.SolrQuery.ORDER;</span><br><span class="line">import org.apache.solr.client.solrj.SolrServerException;</span><br><span class="line">import org.apache.solr.client.solrj.impl.HttpSolrServer;</span><br><span class="line">import org.apache.solr.client.solrj.response.QueryResponse;</span><br><span class="line">import org.apache.solr.client.solrj.response.UpdateResponse;</span><br><span class="line">import org.apache.solr.common.SolrDocument;</span><br><span class="line">import org.apache.solr.common.SolrDocumentList;</span><br><span class="line">import org.apache.solr.common.SolrInputDocument;</span><br><span class="line">import org.junit.After;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import com.april.lucene.model.JavaBean;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author: April</span><br><span class="line"> * @version Solr 4.10.0</span><br><span class="line"> * @Date: 2014年10月14日</span><br><span class="line"> * @参考：http:&#x2F;&#x2F;blog.csdn.net&#x2F;liuweitoo&#x2F;article&#x2F;details&#x2F;8137023</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ServerTest &#123;</span><br><span class="line">private HttpSolrServer server &#x3D; null;</span><br><span class="line">&#x2F;**</span><br><span class="line">   * 注：URL这里 !</span><br><span class="line">   * 这是错误的：URL &#x3D; &quot;http:&#x2F;&#x2F;localhost:8080&#x2F;solr&#x2F;home&#x2F;april&quot;;</span><br><span class="line">   * 在安装solr配置solr.home环境变量整合tomcat时，已经配置了solr&#x2F;home</span><br><span class="line">   * 所以URL直接到&#x2F;solr&#x2F;code~ 就可以了，当时被个问题纠结了半天</span><br><span class="line">   *&#x2F;</span><br><span class="line"> private static final String URL &#x3D; &quot;http:&#x2F;&#x2F;localhost:8080&#x2F;solr&#x2F;april&quot;; &#x2F;&#x2F;april索引库URL</span><br><span class="line">@Before</span><br><span class="line">public void init() &#123;</span><br><span class="line">server &#x3D; new HttpSolrServer(URL);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> *@Function: 添加索引 Document文档</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void addDoc() &#123;</span><br><span class="line">&#x2F;&#x2F;创建doc文档</span><br><span class="line">SolrInputDocument doc &#x3D; new SolrInputDocument();</span><br><span class="line">doc.addField(&quot;id&quot;, 1);</span><br><span class="line">doc.addField(&quot;name&quot;, &quot;Add Solr Index&quot;);&#x2F;&#x2F;schema.xml中首先应该配置了名称为name的field</span><br><span class="line">doc.addField(&quot;manu&quot;, &quot;Solr test file&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">UpdateResponse response &#x3D; server.add(doc);&#x2F;&#x2F;可以添加一个doc文档</span><br><span class="line">&#x2F;&#x2F;server.add(Collection&lt;SolrInputDocument&gt; docs);&#x2F;&#x2F;也可以直接添加一个文档集合</span><br><span class="line">server.commit();&#x2F;&#x2F;commit后才保存到索引库</span><br><span class="line">System.out.println(response);</span><br><span class="line">System.out.println(&quot;query time：&quot; + response.getQTime());</span><br><span class="line">System.out.println(&quot;Elapsed Time：&quot; + response.getElapsedTime());</span><br><span class="line">System.out.println(&quot;status：&quot; + response.getStatus());</span><br><span class="line">&#125; catch (SolrServerException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> *@Function: 直接添加JavaBean</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void addBean() throws IOException, SolrServerException &#123;</span><br><span class="line">&#x2F;&#x2F;Bean需要添加Annotation注解，以便告诉solr哪些属性参与到index中</span><br><span class="line">JavaBean bean &#x3D; new JavaBean();</span><br><span class="line">bean.setId(&quot;2&quot;);</span><br><span class="line">bean.setName(&quot;Add bean index&quot;);</span><br><span class="line">bean.setMenu(&quot;index bean menu&quot;);</span><br><span class="line">server.addBean(bean);&#x2F;&#x2F;添加Bean到索引库</span><br><span class="line">&#x2F;&#x2F;server.addBeans(Collection&lt;?&gt; beans);&#x2F;&#x2F;同样有addBeans方法</span><br><span class="line">server.commit();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Function: 删除索引</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void remove() throws SolrServerException, IOException &#123;</span><br><span class="line">server.deleteById(&quot;1&quot;);&#x2F;&#x2F;删除id为1的索引</span><br><span class="line">server.commit();</span><br><span class="line">&#x2F;&#x2F;server.deleteById(List&lt;String&gt; ids);&#x2F;&#x2F;删除id集合</span><br><span class="line">server.commit(true, true);</span><br><span class="line">&#x2F;&#x2F;删除查询到的索引信息</span><br><span class="line">server.deleteByQuery(&quot;id:4 id:6&quot;);</span><br><span class="line">server.commit(true, true);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> *@Function: 查询索引</span><br><span class="line"> *@Date: 2014年10月28日</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void search() throws SolrServerException &#123;</span><br><span class="line">SolrQuery query &#x3D; new SolrQuery();</span><br><span class="line">query.set(&quot;name&quot;, &quot;Solr&quot;);&#x2F;&#x2F;</span><br><span class="line">query.setStart(0);  &#x2F;&#x2F;分页： 从零开始  </span><br><span class="line">query.setRows(10);&#x2F;&#x2F;分页：返回10条记录，第二页start:10开始</span><br><span class="line">query.setSort(&quot;name&quot;, ORDER.desc);&#x2F;&#x2F;排序：名称倒序</span><br><span class="line">&#x2F;&#x2F;查询</span><br><span class="line">QueryResponse resp &#x3D; server.query(query);</span><br><span class="line">SolrDocumentList sdl &#x3D; resp.getResults();&#x2F;&#x2F;查询结果</span><br><span class="line">System.out.println(&quot;总数：&quot;+sdl.getNumFound());&#x2F;&#x2F;查询总数</span><br><span class="line">for(SolrDocument sd:sdl) &#123;</span><br><span class="line">System.out.println(sd.getFieldValue(&quot;id&quot;));             </span><br><span class="line">System.out.println(sd.getFieldValue(&quot;name&quot;));</span><br><span class="line">System.out.println(sd.getFieldValue(&quot;manu&quot;));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Function: 直接使用bean查询</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test  </span><br><span class="line">public void search2() throws MalformedURLException, SolrServerException&#123;  </span><br><span class="line">SolrQuery query &#x3D; new SolrQuery();  </span><br><span class="line">query.set(&quot;name&quot;, &quot;Solr&quot;);</span><br><span class="line">query.setStart(0).setRows(10).setSort(&quot;name&quot;, ORDER.desc);</span><br><span class="line">QueryResponse res &#x3D; server.query(query);  </span><br><span class="line">&#x2F;&#x2F;可以直接查询相应的bean对象，但是不是很常用 .且这种方式无法获取总数量  </span><br><span class="line">List&lt;JavaBean&gt; list &#x3D; res.getBeans(JavaBean.class);  </span><br><span class="line">System.out.println(&quot;当前总数：&quot;+list.size());  </span><br><span class="line">for(JavaBean bean : list)&#123;  </span><br><span class="line">System.out.println(bean.toString());</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Function: 高亮 </span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test  </span><br><span class="line">public void test6() throws SolrServerException, MalformedURLException&#123;  </span><br><span class="line">SolrQuery query &#x3D; new SolrQuery(&quot;*&quot;);  &#x2F;&#x2F;*:*代表所有属性、所有值</span><br><span class="line">query.setHighlight(true).setHighlightSimplePre(&quot;&lt;span class&#x3D;&#39;red&#39;&gt;&quot;).setHighlightSimplePost(&quot;&lt;&#x2F;span&gt;&quot;).setStart(0).setRows(10);  </span><br><span class="line">&#x2F;&#x2F;hl.fl表示高亮的field，也就是高亮的区域  </span><br><span class="line">query.setParam(&quot;hl.fl&quot;, &quot;name,menu&quot;);  </span><br><span class="line">QueryResponse res &#x3D; server.query(query);  </span><br><span class="line"> </span><br><span class="line">SolrDocumentList sdl &#x3D; res.getResults();  </span><br><span class="line">for(SolrDocument sd : sdl)&#123;  </span><br><span class="line">System.out.println(sd.get(&quot;id&quot;)+&quot;#&quot;+sd.get(&quot;quesRemark&quot;)+&quot;#&quot;+sd.get(&quot;createEmpName&quot;));  </span><br><span class="line">String id &#x3D; (String) sd.get(&quot;id&quot;);  </span><br><span class="line">&#x2F;&#x2F;在solr这里对需要加高亮的字段必须要在索引中store&#x3D;true</span><br><span class="line">System.out.println(id+&quot;#&quot;+res.getHighlighting().get(id).get(&quot;quesRemark&quot;));;  </span><br><span class="line"> </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;**</span><br><span class="line"> * gc在大部分状况下会将没有任何指向的引用的内存释放掉,除非在特殊情况下,最好不要干涉gc!</span><br><span class="line"> * runFinalization()方法在调用时它会尽量去调用这个对象的finalize方法!</span><br><span class="line"> * 都是强制gc去回收内存,其它大部分相似</span><br><span class="line"> *&#x2F;</span><br><span class="line">@After</span><br><span class="line">public void destory() &#123;</span><br><span class="line">server &#x3D; null;</span><br><span class="line">System.runFinalization();</span><br><span class="line">System.gc();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Solr 索引分片(Sharding Index)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @Author: April</span><br><span class="line"> * @version Solr 4.10.0</span><br><span class="line"> * @Date: 2014年11月7日</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ServerTest2 &#123;</span><br><span class="line">private HttpSolrServer server &#x3D; new HttpSolrServer(URL);</span><br><span class="line">private static final String URL &#x3D; &quot;http:&#x2F;&#x2F;localhost:8080&#x2F;solr&#x2F;core0&quot;;</span><br><span class="line">@Before</span><br><span class="line">public void init() &#123;</span><br><span class="line">server &#x3D; new HttpSolrServer(URL);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Function: Solr多核索引分片(Sharding index)查询(代码基于实际项目，这里未做测试)</span><br><span class="line"> *  参数“shards”能够使请求被分发到shards所指定的小索引上。 </span><br><span class="line"> *  shards 的格式  ：host:port&#x2F;base_url[,host:port&#x2F;base_url]* </span><br><span class="line"> *  @description: 多核(例如core1、core2..)中添加索引field :coreFlag</span><br><span class="line"> *  用于标识shards指定的小索引</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void search3 () throws SolrServerException&#123;</span><br><span class="line">String SHARDS_URL &#x3D; &quot;http:&#x2F;&#x2F;localhost:8080&#x2F;solr&#x2F;core0,http:&#x2F;&#x2F;localhost:8080&#x2F;solr&#x2F;core2&quot;;</span><br><span class="line">String queryValue &#x3D; &quot;((coreFlag:0 AND ..core1上的其他条件) OR (coreFlag:1 AND  ..core2 上的条件)) AND 其他条件 &quot;;</span><br><span class="line">SolrQuery query &#x3D; new SolrQuery(queryValue);</span><br><span class="line">query.setStart(0).setRows(10).setSort(&quot;name&quot;, ORDER.desc);</span><br><span class="line">if(StringUtils.isNotBlank(SHARDS_URL))&#123;</span><br><span class="line">query.set(&quot;shards&quot;,SHARDS_URL);</span><br><span class="line">&#125;</span><br><span class="line">QueryResponse resp &#x3D; server.query(query);</span><br><span class="line">SolrDocumentList sdList &#x3D; resp.getResults();</span><br><span class="line">List&lt;JavaBean&gt; searchList &#x3D; server.getBinder().getBeans(JavaBean.class,sdList); </span><br><span class="line">Long totalRecord &#x3D; new Long(sdList.getNumFound());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> solr </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solrj api的操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList的原理</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/2%E3%80%81ArrayList%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/2%E3%80%81ArrayList%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="1、ArrayList特点"><a href="#1、ArrayList特点" class="headerlink" title="1、ArrayList特点"></a>1、ArrayList特点</h3><p>ArrayList是一个有序的动态数组，它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行==扩容操作：底层调用grow方法，创建一个与原数组1.5倍大的新数组，将原数组数据复制过去==。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。</p><h3 id="2-ArrayList的实现（JDK1-8）："><a href="#2-ArrayList的实现（JDK1-8）：" class="headerlink" title="2. ArrayList的实现（JDK1.8）："></a>2. ArrayList的实现（JDK1.8）：</h3><p>   对于ArrayList而言，它实现List接口、==底层使用数组保存所有元素。其操作基本上是对数组的操作==。<br>   分析ArrayList的源代码：</p><h3 id="（1）ArrayList提供了三种方式的构造器："><a href="#（1）ArrayList提供了三种方式的构造器：" class="headerlink" title="（1）ArrayList提供了三种方式的构造器："></a>（1）ArrayList提供了三种方式的构造器：</h3><ul><li>1、可以构造一个默认初始容量为0的空列表（JDK7默认大小直接就是10）</li></ul><p>ArrayList的无参构造方法中初始容量为0（初次调用add()会更新为10）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;</span><br><span class="line">   </span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">       this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><p>2、构造一个指定初始容量的空列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity &gt; 0) &#123;</span><br><span class="line">            this.elementData &#x3D; new Object[initialCapacity];</span><br><span class="line">        &#125; else if (initialCapacity &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            this.elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>3、构造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">   elementData &#x3D; c.toArray();</span><br><span class="line">   size &#x3D; elementData.length;</span><br><span class="line">  </span><br><span class="line">   if (elementData.getClass() !&#x3D; Object[].class)</span><br><span class="line">   &#x2F;&#x2F;将传入的集合 c.toArray();转数组 在复制到自己的数组中</span><br><span class="line">       elementData &#x3D; Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）-存储-修改："><a href="#（2）-存储-修改：" class="headerlink" title="（2） 存储/修改："></a>（2） 存储/修改：</h3><p>   ArrayList提供了set(int index, E element)、add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。</span><br><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">   RangeCheck(index);</span><br><span class="line"></span><br><span class="line">   E oldValue &#x3D; (E) elementData[index];</span><br><span class="line">   elementData[index] &#x3D; element;</span><br><span class="line">   return oldValue;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 将指定的元素添加到此列表的尾部。</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">   ensureCapacity(size + 1);  &#x2F;&#x2F;  Increments modCount!!记录修改次数；快速失败机制 </span><br><span class="line">   elementData[size++] &#x3D; e;</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 将指定的元素插入此列表中的指定位置。</span><br><span class="line">&#x2F;&#x2F; 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">   if (index &gt; size || index &lt; 0)</span><br><span class="line">       throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+&quot;, Size: &quot;+size);</span><br><span class="line">   &#x2F;&#x2F; 如果数组长度不足，将进行扩容。</span><br><span class="line">   ensureCapacity(size+1);  &#x2F;&#x2F; Increments modCount!!记录修改次数；快速失败机制 </span><br><span class="line">   &#x2F;&#x2F; 将 elementData中从Index位置开始、长度为size-index的元素，</span><br><span class="line">   &#x2F;&#x2F; 拷贝到从下标为index+1位置开始的新的elementData数组中。</span><br><span class="line">   &#x2F;&#x2F; 即将当前位于该位置的元素以及所有后续元素右移一个位置。</span><br><span class="line">   System.arraycopy(elementData, index, elementData, index + 1, size - index);</span><br><span class="line">   elementData[index] &#x3D; element;</span><br><span class="line">   size++;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。</span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">   Object[] a &#x3D; c.toArray();</span><br><span class="line">   int numNew &#x3D; a.length;</span><br><span class="line">   ensureCapacity(size + numNew);  &#x2F;&#x2F;  Increments modCount!!记录修改次数；快速失败机制 </span><br><span class="line">   System.arraycopy(a, 0, elementData, size, numNew);</span><br><span class="line">   size +&#x3D; numNew;</span><br><span class="line">   return numNew !&#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 从指定的位置开始，将指定collection中的所有元素插入到此列表中。</span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">   if (index &gt; size || index &lt; 0)</span><br><span class="line">       throw new IndexOutOfBoundsException(</span><br><span class="line">           &quot;Index: &quot; + index + &quot;, Size: &quot; + size);</span><br><span class="line"></span><br><span class="line">   Object[] a &#x3D; c.toArray();</span><br><span class="line">   int numNew &#x3D; a.length;</span><br><span class="line">   ensureCapacity(size + numNew);  &#x2F;&#x2F; Increments modCount</span><br><span class="line"></span><br><span class="line">   int numMoved &#x3D; size - index;</span><br><span class="line">   if (numMoved &gt; 0)</span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + numNew, numMoved);</span><br><span class="line"></span><br><span class="line">   System.arraycopy(a, 0, elementData, index, numNew);</span><br><span class="line">   size +&#x3D; numNew;</span><br><span class="line">   return numNew !&#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）-读取："><a href="#（3）-读取：" class="headerlink" title="（3） 读取："></a>（3） 读取：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    &#x2F;&#x2F;检查角标是否越界</span><br><span class="line">   rangeCheck(index);</span><br><span class="line"></span><br><span class="line">   return (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）-删除："><a href="#（4）-删除：" class="headerlink" title="（4） 删除："></a>（4） 删除：</h3><p>ArrayList提供了根据下标或者指定对象两种方式的删除功能。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 移除此列表中指定位置上的元素。</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">   RangeCheck(index);</span><br><span class="line"></span><br><span class="line">   modCount++;&#x2F;&#x2F; Increments modCount!!记录修改次数；快速失败机制 </span><br><span class="line">   E oldValue &#x3D; (E) elementData[index];</span><br><span class="line"></span><br><span class="line">   int numMoved &#x3D; size - index - 1;</span><br><span class="line">   if (numMoved &gt; 0)</span><br><span class="line">       System.arraycopy(elementData, index+1, elementData, index, numMoved);</span><br><span class="line">   elementData[--size] &#x3D; null; &#x2F;&#x2F; Let gc do its work</span><br><span class="line"></span><br><span class="line">   return oldValue;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 移除此列表中首次出现的指定元素（如果存在）。这是应为ArrayList中允许存放重复的元素。</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">   &#x2F;&#x2F; 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。</span><br><span class="line">   if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">       for (int index &#x3D; 0; index &lt; size; index++)</span><br><span class="line">           if (elementData[index] &#x3D;&#x3D; null) &#123;</span><br><span class="line">               &#x2F;&#x2F; 类似remove(int index)，移除列表中指定位置上的元素。</span><br><span class="line">               fastRemove(index);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   for (int index &#x3D; 0; index &lt; size; index++)</span><br><span class="line">       if (o.equals(elementData[index])) &#123;</span><br><span class="line">           fastRemove(index);</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br><span class="line">    注意：从数组中移除元素的操作，也会导致被移除的元素以后的所有元素的向左移动一个位置。</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h3 id="（5）-调整数组容量："><a href="#（5）-调整数组容量：" class="headerlink" title="（5） 调整数组容量："></a>（5） 调整数组容量：</h3><p>   从上面介绍的向ArrayList中存储元素的代码中，我们看到，每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现</p><p>   ==在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。提高容器性能==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">       modCount++; &#x2F;&#x2F;Increments modCount!!记录修改次数；快速失败机制 </span><br><span class="line">       &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">       if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;扩容操作</span><br><span class="line">    private void grow(int minCapacity) &#123;</span><br><span class="line">       &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">       int oldCapacity &#x3D; elementData.length;</span><br><span class="line">       int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">       if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">           newCapacity &#x3D; minCapacity;</span><br><span class="line">       if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">           newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">       &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:</span><br><span class="line">       elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   从上述代码中可以看出，数组进行扩容时，==会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的==，因此在实际使用时。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。</p><p>   ==ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize方法来实现==<br>   代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void trimToSize() &#123;</span><br><span class="line">   modCount++;</span><br><span class="line">   int oldCapacity &#x3D; elementData.length;</span><br><span class="line">   if (size &lt; oldCapacity) &#123;</span><br><span class="line">       elementData &#x3D; Arrays.copyOf(elementData, size);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（6）-Fail-Fast机制："><a href="#（6）-Fail-Fast机制：" class="headerlink" title="（6） Fail-Fast机制："></a>（6） Fail-Fast机制：</h3><p>ArrayList也采用了快速失败的机制，是通过记录modCount参数来实现。<br>add()、remove()，还是clear()，只要涉及到==修改集合中的元素个数==时，都会改变modCount的值。(这里不包含set 因为不涉及集合元素个数修改)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123;</span><br><span class="line">     &#x2F;&#x2F;修改次数</span><br><span class="line">     protected transient int modCount    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当多个线程对同一个集合进行操作的时候，某线程访问集合的过程中，该集合的内容被其他线程所改变(即其它线程通过add、remove、clear等方法，改变了modCount的值)；这时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;迭代器源码</span><br><span class="line">  private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        int cursor &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        int lastRet &#x3D; -1;</span><br><span class="line">&#x2F;&#x2F;创建迭代器的时候，将AbstractList的修改次数modCount 赋值给迭代器的预期修改值expectedModCount</span><br><span class="line">        int expectedModCount &#x3D; modCount;</span><br><span class="line"></span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return cursor !&#x3D; size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public E next() &#123;</span><br><span class="line">&#x2F;&#x2F;每次遍历的时候，都会检查 若modCount !&#x3D; expectedModCount则抛出ConcurrentModificationException</span><br><span class="line">            checkForComodification();</span><br><span class="line">            try &#123;</span><br><span class="line">                int i &#x3D; cursor;</span><br><span class="line">                E next &#x3D; get(i);</span><br><span class="line">                lastRet &#x3D; i;</span><br><span class="line">                cursor &#x3D; i + 1;</span><br><span class="line">                return next;</span><br><span class="line">            &#125; catch (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;迭代器的删除集合元素时，会将expectedModCount 重新赋值</span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            if (lastRet &lt; 0)</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                AbstractList.this.remove(lastRet);</span><br><span class="line">                if (lastRet &lt; cursor)</span><br><span class="line">                    cursor--;</span><br><span class="line">                lastRet &#x3D; -1;</span><br><span class="line">&#x2F;&#x2F;重新赋值</span><br><span class="line">                expectedModCount &#x3D; modCount;</span><br><span class="line">            &#125; catch (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;检查expectedModCount 和 modCount是否相等</span><br><span class="line">        final void checkForComodification() &#123;</span><br><span class="line">            if (modCount !&#x3D; expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>当多个线程对同一个集合进行操作的时候，线程A访问集合的过程中，该集合的内容被其他线程所改变(即其它线程通过add、remove、clear等方法，改变了modCount的值)；线程A使用迭代器取值时，next()会检查  if (modCount != expectedModCount)<br>这时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p><p>在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p><h3 id="（7）如何解决fail-fast的原理："><a href="#（7）如何解决fail-fast的原理：" class="headerlink" title="（7）如何解决fail-fast的原理："></a>（7）如何解决fail-fast的原理：</h3><p>java.util.concurrent包中是如何解决fail-fast事件的。<br>还是以和ArrayList对应的CopyOnWriteArrayList对比</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class CopyOnWriteArrayList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 返回集合对应的迭代器</span><br><span class="line">    public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return new COWIterator&lt;E&gt;(getArray(), 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">   </span><br><span class="line">    private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">        private final Object[] snapshot;</span><br><span class="line"></span><br><span class="line">        private int cursor;</span><br><span class="line"></span><br><span class="line">        private COWIterator(Object[] elements, int initialCursor) &#123;</span><br><span class="line">            cursor &#x3D; initialCursor;</span><br><span class="line">            &#x2F;&#x2F; 新建COWIterator时，将集合中的元素保存到一个新的拷贝数组中。</span><br><span class="line">            &#x2F;&#x2F; 这样，当原始集合的数据改变，拷贝数据中的值也不会变化。</span><br><span class="line">            snapshot &#x3D; elements;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ArrayList和CopyOnWriteArrayList的区别"><a href="#ArrayList和CopyOnWriteArrayList的区别" class="headerlink" title="ArrayList和CopyOnWriteArrayList的区别"></a>ArrayList和CopyOnWriteArrayList的区别</h4><ul><li>(01) 和ArrayList继承于AbstractList不同，CopyOnWriteArrayList没有继承于AbstractList，它仅仅只是实现了List接口。</li><li>(02) ArrayList的iterator()函数返回的Iterator是在AbstractList中实现的；而CopyOnWriteArrayList是自己实现Iterator。</li><li>(03) ArrayList的Iterator实现类中调用next()时，会“调用checkForComodification()比较‘expectedModCount’和‘modCount’的大小”；但是，CopyOnWriteArrayList的Iterator实现类中，没有所谓的checkForComodification()，更不会抛出ConcurrentModificationException异常！</li></ul>]]></content>
      
      
      <categories>
          
          <category> java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayList的原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ActiveMQ+zookeeper集群配置</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/1%E3%80%81ActiveMQ/4%E3%80%81ActiveMQ+zookeeper%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/1%E3%80%81ActiveMQ/4%E3%80%81ActiveMQ+zookeeper%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="1、首先，选三台服务器。"><a href="#1、首先，选三台服务器。" class="headerlink" title="1、首先，选三台服务器。"></a>1、首先，选三台服务器。</h3><p>之所以选三台，是因为zookeeper推荐最低三台配置，这样可以保持最大的可用服务器数，ip地址分别为：192.168.120.241,192.168.120.242,192.168.120.171</p><h3 id="2、下载zookeeper"><a href="#2、下载zookeeper" class="headerlink" title="2、下载zookeeper"></a>2、下载zookeeper</h3><p>wget <a href="http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.3.6/zookeeper-3.3.6.tar.gz">http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.3.6/zookeeper-3.3.6.tar.gz</a></p><p>解压tar -xvf  zookeeper-3.3.6.tar.gz</p><p>修改配置，mv zoo_sample.cfg zoo.cfg 实现zookeeper的集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> 1 # The number of milliseconds of each tick</span><br><span class="line"> 2 tickTime&#x3D;2000</span><br><span class="line"> 3 # The number of ticks that the initial </span><br><span class="line"> 4 # synchronization phase can take</span><br><span class="line"> 5 initLimit&#x3D;10</span><br><span class="line"> 6 # The number of ticks that can pass between </span><br><span class="line"> 7 # sending a request and getting an acknowledgement</span><br><span class="line"> 8 syncLimit&#x3D;5</span><br><span class="line"> 9 # the directory where the snapshot is stored.</span><br><span class="line">10 # do not use &#x2F;tmp for storage, &#x2F;tmp here is just </span><br><span class="line">11 # example sakes.</span><br><span class="line">12 </span><br><span class="line">13 dataDir&#x3D;&#x2F;home&#x2F;amqbroker&#x2F;zkdir&#x2F;data</span><br><span class="line">14 dataLogDir&#x3D;&#x2F;home&#x2F;amqbroker&#x2F;zkdir&#x2F;log</span><br><span class="line">15 # the port at which the clients will connect</span><br><span class="line">16 clientPort&#x3D;2181</span><br><span class="line">17 # the maximum number of client connections.</span><br><span class="line">18 # increase this if you need to handle more clients</span><br><span class="line">19 #maxClientCnxns&#x3D;60</span><br><span class="line">20 #</span><br><span class="line">21 # Be sure to read the maintenance section of the </span><br><span class="line">22 # administrator guide before turning on autopurge.</span><br><span class="line">23 #</span><br><span class="line">24 # http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance</span><br><span class="line">25 #</span><br><span class="line">26 # The number of snapshots to retain in dataDir</span><br><span class="line">27 #autopurge.snapRetainCount&#x3D;3</span><br><span class="line">28 # Purge task interval in hours</span><br><span class="line">29 # Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">30 #autopurge.purgeInterval&#x3D;1</span><br><span class="line">31 </span><br><span class="line">32 </span><br><span class="line">33 ##three servers of this cluster</span><br><span class="line">34 server.1&#x3D;192.168.120.241:2888:3888</span><br><span class="line">35 server.2&#x3D;192.168.120.242:2888:3888</span><br><span class="line">36 server.3&#x3D;192.168.120.171:2888:3888</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、配置activemq"><a href="#3、配置activemq" class="headerlink" title="3、配置activemq"></a>3、配置activemq</h3><p>下载activemq-5.10<br>wget  <a href="http://archive.apache.org/dist/activemq/5.10.1/apache-activemq-5.10.1-bin.tar.gz">http://archive.apache.org/dist/activemq/5.10.1/apache-activemq-5.10.1-bin.tar.gz</a></p><p>解压：tar -xvf apache-activemq-5.10.1-bin.tar.gz</p><p>修改配置文件：vi apache-activemq-5.10.1/conf/activemq.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre name&#x3D;&quot;code&quot; class&#x3D;&quot;java&quot;&gt;  1 &lt;!--</span><br><span class="line">  2     Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class="line">  3     contributor license agreements.  See the NOTICE file distributed with</span><br><span class="line">  4     this work for additional information regarding copyright ownership.</span><br><span class="line">  5     The ASF licenses this file to You under the Apache License, Version 2.0</span><br><span class="line">  6     (the &quot;License&quot;); you may not use this file except in compliance with</span><br><span class="line">  7     the License.  You may obtain a copy of the License at</span><br><span class="line">  8 </span><br><span class="line">  9     http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0</span><br><span class="line"> 10 </span><br><span class="line"> 11     Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> 12     distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"> 13     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> 14     See the License for the specific language governing permissions and</span><br><span class="line"> 15     limitations under the License.</span><br><span class="line"> 16 --&gt;</span><br><span class="line"> 17 &lt;!-- START SNIPPET: example --&gt;</span><br><span class="line"> 18 &lt;beans</span><br><span class="line"> 19   xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line"> 20   xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line"> 21   xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line"> 22   http:&#x2F;&#x2F;activemq.apache.org&#x2F;schema&#x2F;core http:&#x2F;&#x2F;activemq.apache.org&#x2F;schema&#x2F;core&#x2F;activemq-core.xsd&quot;&gt;</span><br><span class="line"> 23 </span><br><span class="line"> 24     &lt;!-- Allows us to use system properties as variables in this configuration file --&gt;</span><br><span class="line"> 25     &lt;bean class&#x3D;&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;</span><br><span class="line"> 26         &lt;property name&#x3D;&quot;locations&quot;&gt;</span><br><span class="line"> 27             &lt;value&gt;file:$&#123;activemq.conf&#125;&#x2F;credentials.properties&lt;&#x2F;value&gt;</span><br><span class="line"> 28         &lt;&#x2F;property&gt;</span><br><span class="line"> 29     &lt;&#x2F;bean&gt;</span><br><span class="line"> 30 </span><br><span class="line"> 31    &lt;!-- Allows accessing the server log --&gt;</span><br><span class="line"> 32     &lt;!--</span><br><span class="line"> 33     &lt;bean id&#x3D;&quot;logQuery&quot; class&#x3D;&quot;org.fusesource.insight.log.log4j.Log4jLogQuery&quot;</span><br><span class="line"> 34           lazy-init&#x3D;&quot;false&quot; scope&#x3D;&quot;singleton&quot;</span><br><span class="line"> 35           init-method&#x3D;&quot;start&quot; destroy-method&#x3D;&quot;stop&quot;&gt;</span><br><span class="line"> 36     &lt;&#x2F;bean&gt;</span><br><span class="line"> 37     --&gt;</span><br><span class="line"> 38     &lt;!--</span><br><span class="line"> 39         The &lt;broker&gt; element is used to configure the ActiveMQ broker.</span><br><span class="line"> 40     --&gt;</span><br><span class="line"> 41     &lt;broker xmlns&#x3D;&quot;http:&#x2F;&#x2F;activemq.apache.org&#x2F;schema&#x2F;core&quot; brokerName&#x3D;&quot;job-broker&quot; dataDirectory&#x3D;&quot;$&#123;activemq.data&#125;&quot;&gt;</span><br><span class="line"> 42 </span><br><span class="line"> 43         &lt;destinationPolicy&gt;</span><br><span class="line"> 44             &lt;policyMap&gt;</span><br><span class="line"> 45               &lt;policyEntries&gt;</span><br><span class="line"> 46              &lt;!-- Set the following policy on all queues using the &#39;&gt;&#39; wildcard --&gt;</span><br><span class="line"> 47                 &lt;policyEntry queue&#x3D;&quot;QUEUE.SH.LTE.IMPORT&quot;&gt;</span><br><span class="line"> 48                     &lt;deadLetterStrategy&gt;</span><br><span class="line"> 49                             &lt;!--Use the prefix &#39;DLQ.&#39; for the destination name, and make the DLQ a queue rather than a topic --&gt;</span><br><span class="line"> 50                         &lt;individualDeadLetterStrategy queuePrefix&#x3D;&quot;SH.LTE.DLQ.&quot; useQueueForQueueMessages&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line"> 51                     &lt;&#x2F;deadLetterStrategy&gt;</span><br><span class="line"> 52                 &lt;&#x2F;policyEntry&gt;</span><br><span class="line"> 53                 &lt;policyEntry queue&#x3D;&quot;QUEUE.STTTTT&quot;&gt;</span><br><span class="line"> 54                     &lt;deadLetterStrategy&gt;</span><br><span class="line"> 55                          &lt;!--Use the prefix &#39;DLQ.&#39; for the destination name, and make the DLQ a queue rather than a topic --&gt;</span><br><span class="line"> 56                           &lt;individualDeadLetterStrategy queuePrefix&#x3D;&quot;TTT.LTE.SH.DLQ.&quot; useQueueForQueueMessages&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line"> 57                       &lt;&#x2F;deadLetterStrategy&gt;</span><br><span class="line"> 58                   &lt;&#x2F;policyEntry&gt;</span><br><span class="line"> 59                 &lt;policyEntry topic&#x3D;&quot;&gt;&quot; &gt;</span><br><span class="line"> 60                     &lt;!-- The constantPendingMessageLimitStrategy is used to prevent</span><br><span class="line"> 61                          slow topic consumers to block producers and affect other consumers</span><br><span class="line"> 62                          by limiting the number of messages that are retained</span><br><span class="line"> 63                          For more information, see:</span><br><span class="line"> 64 </span><br><span class="line"> 65                          http:&#x2F;&#x2F;activemq.apache.org&#x2F;slow-consumer-handling.html</span><br><span class="line"> 66 </span><br><span class="line"> 67                     --&gt;</span><br><span class="line"> 68                   &lt;pendingMessageLimitStrategy&gt;</span><br><span class="line"> 69                     &lt;constantPendingMessageLimitStrategy limit&#x3D;&quot;1000&quot;&#x2F;&gt;</span><br><span class="line"> 70                   &lt;&#x2F;pendingMessageLimitStrategy&gt;</span><br><span class="line"> 71                 &lt;&#x2F;policyEntry&gt;</span><br><span class="line"> 72               &lt;&#x2F;policyEntries&gt;</span><br><span class="line"> 73             &lt;&#x2F;policyMap&gt;</span><br><span class="line"> 74         &lt;&#x2F;destinationPolicy&gt;</span><br><span class="line"> 75 </span><br><span class="line"> 76 </span><br><span class="line"> 77         &lt;!--</span><br><span class="line"> 78             The managementContext is used to configure how ActiveMQ is exposed in</span><br><span class="line"> 79             JMX. By default, ActiveMQ uses the MBean server that is started by</span><br><span class="line"> 80             the JVM. For more information, see:</span><br><span class="line"> 81 </span><br><span class="line"> 82             http:&#x2F;&#x2F;activemq.apache.org&#x2F;jmx.html</span><br><span class="line"> 83         --&gt;</span><br><span class="line"> 84         &lt;managementContext&gt;</span><br><span class="line"> 85             &lt;managementContext createConnector&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line"> 86         &lt;&#x2F;managementContext&gt;</span><br><span class="line"> 87 </span><br><span class="line"> 88         &lt;!--</span><br><span class="line"> 89             Configure message persistence for the broker. The default persistence</span><br><span class="line"> 89             Configure message persistence for the broker. The default persistence</span><br><span class="line"> 90             mechanism is the KahaDB store (identified by the kahaDB tag).</span><br><span class="line"> 91             For more information, see:</span><br><span class="line"> 92 </span><br><span class="line"> 93             http:&#x2F;&#x2F;activemq.apache.org&#x2F;persistence.html</span><br><span class="line"> 94         --&gt;</span><br><span class="line"> 95 </span><br><span class="line"> 96      &lt;!-- 数据存储为kahadb</span><br><span class="line"> 97      &lt;persistenceAdapter&gt;</span><br><span class="line"> 98          &lt;kahaDB directory&#x3D;&quot;$&#123;activemq.data&#125;&#x2F;kahadb&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!-- 配置注册中心为zookeeper--&gt;</span><br><span class="line"> 99          &lt;&#x2F;persistenceAdapter&gt;</span><br><span class="line">100      --&gt;</span><br><span class="line">101      &lt;persistenceAdapter&gt;</span><br><span class="line">102         &lt;replicatedLevelDB </span><br><span class="line">103              directory&#x3D;&quot;$&#123;activemq.data&#125;&#x2F;leveldb&quot;</span><br><span class="line">104              replicas&#x3D;&quot;3&quot;</span><br><span class="line">105              bind&#x3D;&quot;tcp:&#x2F;&#x2F;0.0.0.0:0&quot;</span><br><span class="line">106              zkAddress&#x3D;&quot;192.168.120.171:2181,192.168.120.241:2181,192.168.120.242:2181&quot;</span><br><span class="line">107              zkPassword&#x3D;&quot;&quot;</span><br><span class="line">108              hostname&#x3D;&quot;192.168.120.241&quot;</span><br><span class="line">109              sync&#x3D;&quot;local_disk&quot;</span><br><span class="line">110              zkPath&#x3D;&quot;&#x2F;activemq&#x2F;leveldb-stores&quot;&#x2F;&gt;</span><br><span class="line">111      &lt;&#x2F;persistenceAdapter&gt;</span><br><span class="line">112 </span><br><span class="line">113           &lt;!--</span><br><span class="line">114             The systemUsage controls the maximum amount of space the broker will</span><br><span class="line">115             use before disabling caching and&#x2F;or slowing down producers. For more information, see:</span><br><span class="line">116             http:&#x2F;&#x2F;activemq.apache.org&#x2F;producer-flow-control.html</span><br><span class="line">117           --&gt;</span><br><span class="line">118           &lt;systemUsage&gt;</span><br><span class="line">119             &lt;systemUsage&gt;</span><br><span class="line">120                 &lt;memoryUsage&gt;</span><br><span class="line">121                     &lt;memoryUsage percentOfJvmHeap&#x3D;&quot;70&quot; &#x2F;&gt;</span><br><span class="line">122                 &lt;&#x2F;memoryUsage&gt;</span><br><span class="line">123                 &lt;storeUsage&gt;</span><br><span class="line">124                     &lt;storeUsage limit&#x3D;&quot;100 gb&quot;&#x2F;&gt;</span><br><span class="line">125                 &lt;&#x2F;storeUsage&gt;</span><br><span class="line">126                 &lt;tempUsage&gt;</span><br><span class="line">127                     &lt;tempUsage limit&#x3D;&quot;50 gb&quot;&#x2F;&gt;</span><br><span class="line">128                 &lt;&#x2F;tempUsage&gt;</span><br><span class="line">129             &lt;&#x2F;systemUsage&gt;</span><br><span class="line">130         &lt;&#x2F;systemUsage&gt;</span><br><span class="line">131 </span><br><span class="line">132         &lt;!--</span><br><span class="line">133             The transport connectors expose ActiveMQ over a given protocol to</span><br><span class="line">134             clients and other brokers. For more information, see:</span><br><span class="line">135 </span><br><span class="line">136             http:&#x2F;&#x2F;activemq.apache.org&#x2F;configuring-transports.html</span><br><span class="line">137         --&gt;</span><br><span class="line">138         &lt;transportConnectors&gt;</span><br><span class="line">139             &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt;</span><br><span class="line">140             &lt;transportConnector name&#x3D;&quot;openwire&quot; uri&#x3D;&quot;tcp:&#x2F;&#x2F;0.0.0.0:61616?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;104    857600&quot;&#x2F;&gt;</span><br><span class="line">141             &lt;transportConnector name&#x3D;&quot;amqp&quot; uri&#x3D;&quot;amqp:&#x2F;&#x2F;0.0.0.0:5672?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;1048576    00&quot;&#x2F;&gt;</span><br><span class="line">142             &lt;transportConnector name&#x3D;&quot;stomp&quot; uri&#x3D;&quot;stomp:&#x2F;&#x2F;0.0.0.0:61613?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;1048    57600&quot;&#x2F;&gt;</span><br><span class="line">143             &lt;transportConnector name&#x3D;&quot;mqtt&quot; uri&#x3D;&quot;mqtt:&#x2F;&#x2F;0.0.0.0:1883?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;1048576    00&quot;&#x2F;&gt;</span><br><span class="line">144             &lt;transportConnector name&#x3D;&quot;ws&quot; uri&#x3D;&quot;ws:&#x2F;&#x2F;0.0.0.0:61614?maximumConnections&#x3D;1000&amp;wireFormat.maxFrameSize&#x3D;104857600&quot;    &#x2F;&gt;</span><br><span class="line">145         &lt;&#x2F;transportConnectors&gt;</span><br><span class="line">146 </span><br><span class="line">147         &lt;!-- destroy the spring context on shutdown to stop jetty --&gt;</span><br><span class="line">148         &lt;shutdownHooks&gt;</span><br><span class="line">149             &lt;bean xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; class&#x3D;&quot;org.apache.activemq.hooks.SpringContextHook&quot; &#x2F;&gt;</span><br><span class="line">150         &lt;&#x2F;shutdownHooks&gt;</span><br><span class="line">151 </span><br><span class="line">152     &lt;&#x2F;broker&gt;</span><br><span class="line">153 </span><br><span class="line">154     &lt;!--</span><br><span class="line">155         Enable web consoles, REST and Ajax APIs and demos</span><br><span class="line">156         The web consoles requires by default login, you can disable this in the jetty.xml file</span><br><span class="line">157 </span><br><span class="line">158         Take a look at $&#123;ACTIVEMQ_HOME&#125;&#x2F;conf&#x2F;jetty.xml for more details</span><br><span class="line">159     --&gt;</span><br><span class="line">160     &lt;import resource&#x3D;&quot;jetty.xml&quot;&#x2F;&gt;</span><br><span class="line">161 </span><br><span class="line">162 &lt;&#x2F;beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="另外两台服务器的配置与该文档相似，唯一不同就是-hostname-”192-168-120-241”这里，需要写入各自的ip地址"><a href="#另外两台服务器的配置与该文档相似，唯一不同就是-hostname-”192-168-120-241”这里，需要写入各自的ip地址" class="headerlink" title="另外两台服务器的配置与该文档相似，唯一不同就是    hostname=”192.168.120.241”这里，需要写入各自的ip地址"></a>另外两台服务器的配置与该文档相似，唯一不同就是    hostname=”192.168.120.241”这里，需要写入各自的ip地址</h3>]]></content>
      
      
      <categories>
          
          <category> ActiveMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ActiveMQ+zookeeper集群配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合Shiro</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/6%E3%80%81%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/shiro/SSM%E6%95%B4%E5%90%88Shiro/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/6%E3%80%81%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/shiro/SSM%E6%95%B4%E5%90%88Shiro/</url>
      
        <content type="html"><![CDATA[<p>1、引入shiro相关依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;shiro-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.3.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;type&gt;jar&lt;&#x2F;type&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;shiro-spring&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.3.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;type&gt;jar&lt;&#x2F;type&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;shiro-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.3.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;type&gt;jar&lt;&#x2F;type&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;shiro-ehcache&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.3.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;type&gt;jar&lt;&#x2F;type&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;shiro-all&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.3.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;type&gt;jar&lt;&#x2F;type&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;shiro-quartz&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2、在spring的核心配置文件中，引入shiro的配置文件"><a href="#2、在spring的核心配置文件中，引入shiro的配置文件" class="headerlink" title="2、在spring的核心配置文件中，引入shiro的配置文件"></a>2、在spring的核心配置文件中，引入shiro的配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Shiro Core </span><br><span class="line">Components - Not Spring Specific &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; --&gt;</span><br><span class="line">&lt;!-- 配置securityManager --&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;securityManager&quot; class&#x3D;&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;cacheManager&quot; ref&#x3D;&quot;cacheManager&quot; &#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;realm&quot; ref&#x3D;&quot;jdbcRealm&quot; &#x2F;&gt;</span><br><span class="line">&lt;!-- 多relam时，配置多relam认证器 ，在认证器中配置认证策略 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 定义要使用的session管理器 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;sessionManager&quot; ref&#x3D;&quot;sessionManager&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- &lt;property name&#x3D;&quot;rememberMeManager&quot; ref&#x3D;&quot;rememberMeManager&quot; &#x2F;&gt; --&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缓存配置 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;cacheManager&quot; class&#x3D;&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 授权&#x2F;认证 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;jdbcRealm&quot; class&#x3D;&quot;com.lxtd.cca.relam.ShiroRealm&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;credentialsMatcher&quot;&gt;</span><br><span class="line">&lt;bean class&#x3D;&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;hashAlgorithmName&quot; value&#x3D;&quot;MD5&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;hashIterations&quot; value&#x3D;&quot;10&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!-- MD5盐值加密 加密10次 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;storedCredentialsHexEncoded&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 此三个bean顺序不能变 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;lifecycleBeanPostProcessor&quot; class&#x3D;&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot; &#x2F;&gt;</span><br><span class="line">&lt;bean</span><br><span class="line">class&#x3D;&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;</span><br><span class="line">depends-on&#x3D;&quot;lifecycleBeanPostProcessor&quot; &#x2F;&gt;</span><br><span class="line">&lt;bean</span><br><span class="line">class&#x3D;&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;securityManager&quot; ref&#x3D;&quot;securityManager&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置哪些页面受保护，以及访问这些页面所需要的权限 anon可以被匿名访问 authc必须在认证登录之后才能被访问 logout 退出 </span><br><span class="line">roles[admin]需相关角色认证 需要角色访问 &#x2F;index2.jsp&#x3D;roles[admin] --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- lxtdShiroFilter必须和web.xml文件中的filter的name一致 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;lxtdShiroFilter&quot; class&#x3D;&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;securityManager&quot; ref&#x3D;&quot;securityManager&quot; &#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;loginUrl&quot; value&#x3D;&quot;&#x2F;showStytm.html&quot; &#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;successUrl&quot; value&#x3D;&quot;&#x2F;showStytm.html&quot; &#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;unauthorizedUrl&quot; value&#x3D;&quot;&#x2F;index.html&quot; &#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;filterChainDefinitionMap&quot; ref&#x3D;&quot;filterChainDefinitionMap&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!-- url权限采用第一次匹配优先原则 目前不涉及权限管理 所有路径均可以匿名访问 &#x2F;** &#x3D; anon --&gt;</span><br><span class="line">&lt;!-- &lt;property name&#x3D;&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; &#x2F;login.jsp&#x3D;anon &#x2F;test&#x2F;login**&#x3D;anon </span><br><span class="line">&#x2F;admin.jsp&#x3D;roles[admin] &#x2F;user.jsp&#x3D;roles[user] &#x2F;** &#x3D; authc &#x2F;** &#x3D; anon &lt;&#x2F;value&gt; </span><br><span class="line">&lt;&#x2F;property&gt; --&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;filterChainDefinitionMap&quot; factory-bean&#x3D;&quot;filterChainDefinitionMapBuilder&quot;</span><br><span class="line">factory-method&#x3D;&quot;builderFilterChainDefinitionMapBuilder&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;filterChainDefinitionMapBuilder&quot; class&#x3D;&quot;com.lxtd.cca.relam.FilterChainDefinitionMapBuilder&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Shiro Session &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;sessionIdGenerator&quot;</span><br><span class="line">class&#x3D;&quot;org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 配置Session DAO的操作处理 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;sessionDAO&quot;</span><br><span class="line">class&#x3D;&quot;org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO&quot;&gt;</span><br><span class="line">&lt;!-- 设置session缓存的名字，这个名字可以任意 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;activeSessionsCacheName&quot; value&#x3D;&quot;shiro-activeSessionCache&quot; &#x2F;&gt;</span><br><span class="line">&lt;!-- 定义该Session DAO操作中所使用的ID生成器 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;sessionIdGenerator&quot; ref&#x3D;&quot;sessionIdGenerator&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 配置需要向Cookie中保存数据的配置模版 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;sessionIdCookie&quot; class&#x3D;&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt;</span><br><span class="line">&lt;!-- 在Tomcat运行下默认使用的Cookie的名字为JSESSIONID --&gt;</span><br><span class="line">&lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;mldn-session-id&quot; &#x2F;&gt;</span><br><span class="line">&lt;!-- 保证该系统不会受到跨域的脚本操作供给 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;httpOnly&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 定义Cookie的过期时间，单位为秒，如果设置为-1表示浏览器关闭，则Cookie消失 --&gt;</span><br><span class="line">&lt;!-- &lt;property name&#x3D;&quot;maxAge&quot; value&#x3D;&quot;-1&quot; &#x2F;&gt; --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;maxAge&quot; value&#x3D;&quot;1800&quot; &#x2F;&gt;&lt;!-- cookie过期时间为30分钟 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 定义会话管理器的操作 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;sessionManager&quot;</span><br><span class="line">class&#x3D;&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt;</span><br><span class="line">&lt;!-- 定义的是全局的session会话超时时间，此操作会覆盖web.xml文件中的超时时间配置 session一小时过期 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;globalSessionTimeout&quot; value&#x3D;&quot;3600000&quot; &#x2F;&gt;</span><br><span class="line">&lt;!-- 删除所有无效的Session对象，此时的session被保存在了内存里面 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;deleteInvalidSessions&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">&lt;!-- 定义要使用的无效的Session定时调度器 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;sessionValidationScheduler&quot; ref&#x3D;&quot;sessionValidationScheduler&quot; &#x2F;&gt;</span><br><span class="line">&lt;!-- 需要让此session可以使用该定时调度器进行检测 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;sessionValidationSchedulerEnabled&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">&lt;!-- 定义Session可以进行序列化的工具类 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;sessionDAO&quot; ref&#x3D;&quot;sessionDAO&quot; &#x2F;&gt;</span><br><span class="line">&lt;!-- 所有的session一定要将id设置到Cookie之中，需要提供有Cookie的操作模版 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;sessionIdCookie&quot; ref&#x3D;&quot;sessionIdCookie&quot; &#x2F;&gt;</span><br><span class="line">&lt;!-- 定义sessionIdCookie模版可以进行操作的启用 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;sessionIdCookieEnabled&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;!-- &lt;bean id&#x3D;&quot;sessionManager&quot; class&#x3D;&quot;com.lxtd.cca.relam.SimpleWebSessionManager&quot;&gt; </span><br><span class="line">&lt;property name&#x3D;&quot;globalSessionTimeout&quot; value&#x3D;&quot;3600000&quot; &#x2F;&gt; &lt;property name&#x3D;&quot;sessionValidationInterval&quot; </span><br><span class="line">value&#x3D;&quot;30000&quot; &#x2F;&gt; &lt;property name&#x3D;&quot;sessionValidationSchedulerEnabled&quot; value&#x3D;&quot;true&quot; </span><br><span class="line">&#x2F;&gt; &lt;&#x2F;bean&gt; --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置session的定时验证检测程序类，以让无效的session释放 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;sessionValidationScheduler&quot;</span><br><span class="line">class&#x3D;&quot;org.apache.shiro.session.mgt.quartz.QuartzSessionValidationScheduler&quot;&gt;</span><br><span class="line">&lt;!-- 设置session的失效扫描间隔，单位为毫秒 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;sessionValidationInterval&quot; value&#x3D;&quot;15000&quot; &#x2F;&gt;</span><br><span class="line">&lt;!-- 随后还需要定义有一个会话管理器的程序类的引用 --&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;sessionManager&quot; ref&#x3D;&quot;sessionManager&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><h3 id="3、ShiroRealm-java"><a href="#3、ShiroRealm-java" class="headerlink" title="3、ShiroRealm.java"></a>3、ShiroRealm.java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">public class ShiroRealm extends AuthorizingRealm &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">UserAuthMapper userAuthMapper;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">EmplManageMapper emplManageMapper;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">DeveloperManageMapper developerManageMapper;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private SessionDAO sessionDAO;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 授权</span><br><span class="line">@Override</span><br><span class="line">protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;</span><br><span class="line"></span><br><span class="line">System.err.println(&quot;授权角色通道。。。&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1、从principals中获取用户的信息，</span><br><span class="line">Object principal &#x3D; principals.getPrimaryPrincipal();</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; roles &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line">roles.add(&quot;user&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 权限名的集合</span><br><span class="line">Set&lt;String&gt; permissions &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">if (&quot;admin&quot;.equals(principal)) &#123;</span><br><span class="line">roles.add(&quot;admin&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SimpleAuthorizationInfo info &#x3D; new SimpleAuthorizationInfo();</span><br><span class="line"></span><br><span class="line">info.addRoles(roles);</span><br><span class="line">info.addStringPermissions(permissions);</span><br><span class="line"></span><br><span class="line">return info;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 认证 shiro maven</span><br><span class="line">@Override</span><br><span class="line">protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</span><br><span class="line">UsernamePasswordToken usernamePasswordToken &#x3D; (UsernamePasswordToken) token;</span><br><span class="line">&#x2F;&#x2F; 获取封装在UsernamePasswordToken的userName</span><br><span class="line">String username &#x3D; usernamePasswordToken.getUsername();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 唯一登录认证start</span><br><span class="line">String loginIp &#x3D; null;</span><br><span class="line">String loginTime &#x3D; null;</span><br><span class="line">&#x2F;&#x2F; 获取到所有在线session</span><br><span class="line">Collection&lt;Session&gt; sessions &#x3D; this.sessionDAO.getActiveSessions();</span><br><span class="line">boolean expired &#x3D; false;</span><br><span class="line">&#x2F;&#x2F;for (Session session : sessions) &#123;</span><br><span class="line">&#x2F;&#x2F;if(session instanceof SimpleSession) &#123;</span><br><span class="line">&#x2F;&#x2F;expired &#x3D; ((SimpleSession) session).isExpired();</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F; 在session域中获取用户对象</span><br><span class="line">&#x2F;&#x2F;Object user &#x3D; session.getAttribute(session.getId().toString().replaceAll(&quot;-&quot;, &quot;&quot;));</span><br><span class="line">&#x2F;&#x2F;UserInfo userInfo &#x3D; null;</span><br><span class="line">&#x2F;&#x2F;if (!expired &amp;&amp; user !&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F;userInfo &#x3D; (UserInfo) user;</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F; 判断如果该用户已经登录</span><br><span class="line">&#x2F;&#x2F;if (username.equals(userInfo.getName())) &#123;</span><br><span class="line">&#x2F;&#x2F;loginIp &#x3D; session.getHost();&#x2F;&#x2F; 登录ip</span><br><span class="line">&#x2F;&#x2F;Date lastAccessTime &#x3D; session.getStartTimestamp();</span><br><span class="line">&#x2F;&#x2F;if (lastAccessTime !&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F;loginTime &#x3D; DateUtil.dateToStr(lastAccessTime);&#x2F;&#x2F; 最后登录时间</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line">&#x2F;&#x2F;throw new ConcurrentAccessException(&quot;登录失败!该用户已于&quot; + loginTime + &quot; 在ip为:&quot; + loginIp + &quot; 的设备上登录!&quot;);</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line">&#x2F;&#x2F; 唯一登录认证end</span><br><span class="line">UserInfo userInfo &#x3D; null;</span><br><span class="line"></span><br><span class="line">if (&quot;sadmin&quot;.equals(username)) &#123;</span><br><span class="line">userInfo &#x3D; developerManageMapper.getEmplByName(username);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">userInfo &#x3D; emplManageMapper.getEmplByName(username);</span><br><span class="line">&#125;</span><br><span class="line">if (userInfo &#x3D;&#x3D; null) &#123;</span><br><span class="line">throw new UnknownAccountException(&quot;未知账户&quot;);</span><br><span class="line">&#125;</span><br><span class="line">String password &#x3D; null;</span><br><span class="line">if (&quot;sadmin&quot;.equals(username)) &#123;</span><br><span class="line">password &#x3D; developerManageMapper.getPasswordByName(username);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">password &#x3D; userAuthMapper.getPasswordByName(username);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以下的参数信息是从数据库中获得</span><br><span class="line">&#x2F;&#x2F; 1、principal可以是用户名username 也可以是数据表对应的实体类信息 如user对象</span><br><span class="line">&#x2F;&#x2F; 2、credentials 数据库中的密码</span><br><span class="line">&#x2F;&#x2F; 3、当前realm对象的name 调用父类的getName即可</span><br><span class="line">Object principal &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">Object credentials &#x3D; password &#x3D;&#x3D; null ? &quot;&quot; : password;&#x2F;&#x2F; 数据库中查询的密码</span><br><span class="line"></span><br><span class="line">String realmName &#x3D; getName();</span><br><span class="line"></span><br><span class="line">ByteSource salt &#x3D; null;</span><br><span class="line"></span><br><span class="line">salt &#x3D; ByteSource.Util.bytes(&quot;pwd&quot;);</span><br><span class="line"></span><br><span class="line">SimpleAuthenticationInfo info &#x3D; new SimpleAuthenticationInfo(principal, credentials, salt, realmName);</span><br><span class="line"></span><br><span class="line">return info;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">String hashAlgorithm &#x3D; &quot;MD5&quot;;</span><br><span class="line"></span><br><span class="line">Object credentials &#x3D; &quot;lxtd_pwd_2018&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 123456+小张 10次M5盐值加密的结果 String md5Result &#x3D;</span><br><span class="line">&#x2F;&#x2F; &quot;cf2f84b6b83710fd7442ede509c95012&quot;;</span><br><span class="line"></span><br><span class="line">Object salt &#x3D; null;</span><br><span class="line"></span><br><span class="line">salt &#x3D; ByteSource.Util.bytes(&quot;pwd&quot;);</span><br><span class="line"></span><br><span class="line">int hashIterations &#x3D; 10;</span><br><span class="line"></span><br><span class="line">Object result &#x3D; new SimpleHash(hashAlgorithm, credentials, salt, hashIterations);</span><br><span class="line"></span><br><span class="line">System.err.println(result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、FilterChainDefinitionMapBuilder-java"><a href="#4、FilterChainDefinitionMapBuilder-java" class="headerlink" title="4、FilterChainDefinitionMapBuilder.java"></a>4、FilterChainDefinitionMapBuilder.java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class FilterChainDefinitionMapBuilder &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public LinkedHashMap&lt;String, String&gt; builderFilterChainDefinitionMapBuilder()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;url权限采用第一次匹配优先原则 </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;roles[user]</span><br><span class="line">&#x2F;&#x2F;&#x2F;** &#x3D; authc</span><br><span class="line">&#x2F;&#x2F;perms[permssion:look] </span><br><span class="line"></span><br><span class="line">LinkedHashMap&lt;String, String&gt; map&#x3D;new LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;map.put(&quot;&#x2F;index.html&quot;, &quot;anon&quot;);</span><br><span class="line">&#x2F;&#x2F;map.put(&quot;&#x2F;auth&#x2F;login&quot;, &quot;anon&quot;);</span><br><span class="line">&#x2F;&#x2F;map.put(&quot;&#x2F;js**&quot;, &quot;anon&quot;);</span><br><span class="line">&#x2F;&#x2F;map.put(&quot;&#x2F;svg**&quot;, &quot;anon&quot;);</span><br><span class="line">&#x2F;&#x2F;map.put(&quot;&#x2F;css**&quot;, &quot;anon&quot;);</span><br><span class="line">&#x2F;&#x2F;map.put(&quot;&#x2F;images**&quot;, &quot;anon&quot;);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">map.put(&quot;&#x2F;showStytm.html**&quot;, &quot;authc&quot;);</span><br><span class="line">map.put(&quot;&#x2F;**&quot;, &quot;anon&quot;);</span><br><span class="line">return map;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、编写前段控制器"><a href="#5、编写前段控制器" class="headerlink" title="5、编写前段控制器"></a>5、编写前段控制器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value &#x3D; &quot;login&quot;, method &#x3D; RequestMethod.POST)</span><br><span class="line">public void login(User user,HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line"></span><br><span class="line">Subject currentUser &#x3D; SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">if (!currentUser.isAuthenticated()) &#123;&#x2F;&#x2F; 若未认证，将用户名密码封装到UsernamePasswordToken</span><br><span class="line">UsernamePasswordToken token &#x3D; new UsernamePasswordToken(user.getName(), user.getPassword());</span><br><span class="line">token.setRememberMe(true);</span><br><span class="line">&#x2F;&#x2F;定义一个用户信息对象</span><br><span class="line">UserInfo userInfo&#x3D;new UserInfo();</span><br><span class="line">try &#123;</span><br><span class="line">currentUser.login(token);&#x2F;&#x2F; 执行登录</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过名称获取员工信息</span><br><span class="line">userInfo &#x3D; emplManageServiceImpl.getEmplByName(user.getName());</span><br><span class="line">&#x2F;&#x2F; 获取session</span><br><span class="line">Session session &#x3D; SecurityUtils.getSubject().getSession();</span><br><span class="line">String sessionId &#x3D; session.getId().toString().replace(&quot;-&quot;, &quot;&quot;);</span><br><span class="line">if (userInfo !&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F; 缓存用户信息到session</span><br><span class="line">session.setAttribute(sessionId, userInfo);</span><br><span class="line">writeResult(response, userInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (UnknownAccountException uae) &#123;</span><br><span class="line"></span><br><span class="line">writeError400(response, &quot;未知账户&quot;);</span><br><span class="line">&#125; catch (IncorrectCredentialsException ice) &#123;</span><br><span class="line"></span><br><span class="line">writeError400(response, &quot;错误密码&quot;);</span><br><span class="line">&#125; catch (LockedAccountException lae) &#123;</span><br><span class="line"></span><br><span class="line">writeError400(response, &quot;用户被锁定&quot;);</span><br><span class="line">&#125; catch (ConcurrentAccessException cust) &#123;</span><br><span class="line">writeError400(response, cust.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">writeError400(response, &quot;重复登录&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> shiro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM整合Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型，即“参数化类型”</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/9%E3%80%81%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%EF%BC%8C%E5%8D%B3%E2%80%9C%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B%E2%80%9D/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/9%E3%80%81%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%EF%BC%8C%E5%8D%B3%E2%80%9C%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<p>泛型，即“参数化类型”。</p><p>顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），</p><p>然后在使用/调用时传入具体的类型（类型实参）。</p><p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，</p><p>操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List arrayList &#x3D; new ArrayList();</span><br><span class="line">arrayList.add(&quot;aaaa&quot;);</span><br><span class="line">arrayList.add(100);</span><br><span class="line"></span><br><span class="line">for(int i &#x3D; 0; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">    String item &#x3D; (String)arrayList.get(i);</span><br><span class="line">    Log.d(&quot;泛型测试&quot;,&quot;item &#x3D; &quot; + item);</span><br><span class="line">    &#x2F;&#x2F;报错：java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-特性"><a href="#3-特性" class="headerlink" title="3. 特性"></a>3. 特性</h2><p>泛型只在编译阶段有效。看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList &#x3D; stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList &#x3D; integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line">if(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    Log.d(&quot;泛型测试&quot;,&quot;类型相同&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。"><a href="#也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。" class="headerlink" title="也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。"></a><strong>也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</strong></h4><h2 id="4-泛型类"><a href="#4-泛型类" class="headerlink" title="4 泛型类"></a>4 泛型类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class="line">&#x2F;&#x2F;在实例化泛型类时，必须指定T的具体类型</span><br><span class="line">public class Generic&lt;T&gt;&#123; </span><br><span class="line">    &#x2F;&#x2F;key这个成员变量的类型为T,T的类型由外部指定  </span><br><span class="line">    private T key;</span><br><span class="line"></span><br><span class="line">    public Generic(T key) &#123; &#x2F;&#x2F;泛型构造方法形参key的类型也为T，T的类型由外部指定</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getKey()&#123; &#x2F;&#x2F;泛型方法getKey的返回值类型为T，T的类型由外部指定</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span><br><span class="line">&#x2F;&#x2F;传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span><br><span class="line">Generic&lt;Integer&gt; genericInteger &#x3D; new Generic&lt;Integer&gt;(123456);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;传入的实参类型需与泛型的类型参数类型相同，即为String.</span><br><span class="line">Generic&lt;String&gt; genericString &#x3D; new Generic&lt;String&gt;(&quot;key_vlaue&quot;);</span><br><span class="line">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericInteger.getKey());</span><br><span class="line">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericString.getKey());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;12-27 09:20:04.432 13063-13063&#x2F;? D&#x2F;泛型测试: key is 123456</span><br><span class="line">&#x2F;&#x2F;12-27 09:20:04.432 13063-13063&#x2F;? D&#x2F;泛型测试: key is key_vlaue</span><br></pre></td></tr></table></figure><p>在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Generic generic &#x3D; new Generic(&quot;111111&quot;);</span><br><span class="line">Generic generic1 &#x3D; new Generic(4444);</span><br><span class="line">Generic generic2 &#x3D; new Generic(55.55);</span><br><span class="line">Generic generic3 &#x3D; new Generic(false);</span><br><span class="line"></span><br><span class="line">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic.getKey());&#x2F;&#x2F;111111</span><br><span class="line">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic1.getKey());&#x2F;&#x2F;4444</span><br><span class="line">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic2.getKey());&#x2F;&#x2F;55.55</span><br><span class="line">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic3.getKey()); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure><p>注意：</p><p>泛型的类型参数只能是类类型，不能是简单类型。<br>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(ex_num instanceof Generic&lt;Number&gt;)&#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="5、泛型接口"><a href="#5、泛型接口" class="headerlink" title="5、泛型接口"></a>5、泛型接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span><br><span class="line"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class="line"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public T next() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、泛型通配符"><a href="#6、泛型通配符" class="headerlink" title="6、泛型通配符"></a>6、泛型通配符</h2><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void showKeyValue1(Generic&lt;Number&gt; obj)&#123;</span><br><span class="line">    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; gInteger &#x3D; new Generic&lt;Integer&gt;(123);</span><br><span class="line">Generic&lt;Number&gt; gNumber &#x3D; new Generic&lt;Number&gt;(456);</span><br><span class="line"></span><br><span class="line">showKeyValue(gNumber);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; </span><br><span class="line">&#x2F;&#x2F; cannot be applied to Generic&lt;java.lang.Number&gt;</span><br><span class="line">&#x2F;&#x2F; showKeyValue(gInteger);</span><br></pre></td></tr></table></figure><p>结论：</p><p>我们知道Ingeter是Number的一个子类</p><p>Generic<Integer>不能被看作为`Generic<Number>的子类</p><p>如何解决上面的问题？总不能为了定义一个新的方法来处理Generic<Integer>类型的类，这显然与java中的多台理念相违背</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void showKeyValue1(Generic&lt;?&gt; obj)&#123;</span><br><span class="line">    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参 。重要说三遍！此处’？’是类型实参，而不是类型形参 ！ 此处’？’是类型实参，而不是类型形参 ！再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。</p><p>可以解决当具体类型不确定的时候，这个通配符就是 ?  ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。</p><h2 id="7、泛型方法"><a href="#7、泛型方法" class="headerlink" title="7、泛型方法"></a>7、泛型方法</h2><p>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。</p><p>示例1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 泛型方法的基本介绍</span><br><span class="line"> * @param tClass 传入的泛型实参</span><br><span class="line"> * @return T 返回值为T类型</span><br><span class="line"> * 说明：</span><br><span class="line"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span><br><span class="line"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span><br><span class="line"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span><br><span class="line"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException ,</span><br><span class="line">  IllegalAccessException&#123;</span><br><span class="line">        T instance &#x3D; tClass.newInstance();</span><br><span class="line">        return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj &#x3D; genericMethod(Class.forName(&quot;com.test.test&quot;));</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line">   &#x2F;&#x2F;这个类是个泛型类，在上面已经介绍过</span><br><span class="line">   public class Generic&lt;T&gt;&#123;     </span><br><span class="line">        private T key;</span><br><span class="line"></span><br><span class="line">        public Generic(T key) &#123;</span><br><span class="line">            this.key &#x3D; key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span><br><span class="line">        &#x2F;&#x2F;这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span><br><span class="line">        &#x2F;&#x2F;所以在这个方法中才可以继续使用 T 这个泛型。</span><br><span class="line">        public T getKey()&#123;</span><br><span class="line">            return key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot;</span><br><span class="line">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span><br><span class="line">        public E setKey(E key)&#123;</span><br><span class="line">             this.key &#x3D; keu</span><br><span class="line">        &#125;</span><br><span class="line">        *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** </span><br><span class="line">     * 这才是一个真正的泛型方法。</span><br><span class="line">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span><br><span class="line">     * 这个T可以出现在这个泛型方法的任意位置.</span><br><span class="line">     * 泛型的数量也可以为任意多个 </span><br><span class="line">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span><br><span class="line">     *        ...</span><br><span class="line">     *        &#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123;</span><br><span class="line">        System.out.println(&quot;container key :&quot; + container.getKey());</span><br><span class="line">        &#x2F;&#x2F;当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span><br><span class="line">        T test &#x3D; container.getKey();</span><br><span class="line">        return test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span><br><span class="line">    public void showKeyValue1(Generic&lt;Number&gt; obj)&#123;</span><br><span class="line">        Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span><br><span class="line">    &#x2F;&#x2F;同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span><br><span class="line">    public void showKeyValue2(Generic&lt;?&gt; obj)&#123;</span><br><span class="line">        Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;**</span><br><span class="line">     * 这个方法是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#39;E&#39; &quot;</span><br><span class="line">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span><br><span class="line">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span><br><span class="line">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;  </span><br><span class="line">    *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 这个方法也是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#39;T&#39; &quot;</span><br><span class="line">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span><br><span class="line">     * 所以这也不是一个正确的泛型方法声明。</span><br><span class="line">    public void showkey(T genericObj)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 泛型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛型，即“参数化类型” </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>00_AQS</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/00_AQS/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/00_AQS/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC中的AQS"><a href="#JUC中的AQS" class="headerlink" title="JUC中的AQS"></a>JUC中的AQS</h1><h2 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h2><ul><li>java.util.concurrent中有许多可阻塞的类，如ReentrantLock、Semaphore、ReentrantReadWriteLock、CountDownLatch、SynchronousQueue和FutureTask等，这些阻塞类有一个共同点就是都是基于AQS构建的。</li><li>AQS(AbstractQueuedSynchronizer)即队列同步器。是用来构建锁或者其他同步组件的基础框架，是JUC并发包中的核心基础组件。</li><li>AQS解决了实现同步器是涉及到的大量细节问题，如：获取同步状态、FIFO同步队列等。在基于AQS构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提供了吞吐量。</li><li>AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态。</li><li>AQS使用一个int类型的成员变量state来表示同步状态，当state&gt;0时表示已经获取锁，当state=0时表示释放了锁。AQS提供了三个方法来对同步状态state进行操作。</li><li>AQS通过内置的FIFO同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态失败时，AQS会将当前线程以及等待状态等信息构造成一个Node并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。</li></ul><h2 id="AQS结构"><a href="#AQS结构" class="headerlink" title="AQS结构"></a>AQS结构</h2><pre><code>见代码</code></pre><h2 id="AQS提供的主要方法"><a href="#AQS提供的主要方法" class="headerlink" title="AQS提供的主要方法"></a>AQS提供的主要方法</h2><ul><li><strong>getState()</strong>:返回同步状态的当前值</li><li><strong>setState(int newState)</strong>:设置当前同步状态</li><li><strong>compareAndSetState(int expect, int update)</strong>:使用CAS设置当前状态，该方法能够保证状态设置的原子性</li><li><strong>isHeldExclusively()</strong>:当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程独占</li><li><strong>acquire(int arg)</strong>:独占式获取同步状态，如果当前线程获取同步状态成功，则由改方法返回，否则，将会进入同步队列等待，该方法将会调用可重写的tryAcquire(int arg)方法</li><li><strong>acquireInterruptibly(int arg)</strong>:与acquire(int arg)相同，但是该方法响应中断，当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法抛出InterruptedException异常并返回</li><li>**acquireShared(int arg)**：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态</li><li>**acquireSharedInterruptibly(int arg)**：共享式获取同步状态，响应中断</li><li>**release(int arg)**：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒</li><li>**releaseShared(int arg)**：共享式释放同步状态</li></ul><hr><ul><li><strong>tryAcquire(int arg)</strong>:独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态</li><li><strong>tryRelease(int arg)</strong>:独占式释放同步状态</li><li><strong>tryAcquireNanos(int arg, long nanos)</strong>:超时获取同步状态，如果当前线程在nanos时间内没有获取到同步状态，那么将会返回false，已经获取则返回true</li><li><strong>tryAcquireShared(int arg)</strong>:共享式获取同步状态，返回值大于等于0表示获取成功，否则获取失败</li><li><strong>tryReleaseShared(int arg)</strong>:共享式释放同步状态</li><li>**tryAcquireSharedNanos(int arg, long nanosTimeout)**：共享式获取同步状态，增加超时限制</li></ul><h2 id="CLH同步队列"><a href="#CLH同步队列" class="headerlink" title="CLH同步队列"></a>CLH同步队列</h2><ul><li>CLH同步队列是一个FIFO双向队列，AQS依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</li><li>在CLH同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next）<br> CLH同步队列结构<br><img src="./image/CLH%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97.jpg" alt="image"></li></ul><h2 id="同步状态的获取与释放"><a href="#同步状态的获取与释放" class="headerlink" title="同步状态的获取与释放"></a>同步状态的获取与释放</h2><ul><li>AQS的设计模式采用了模板方法，子类通过继承的方式，实现AQS的抽象方法来管理同步状态，AQS提供了大量的模板方法来事项同步，主要分三类：独占式获取和释放同步状态、共享式获取和释放同步状态、查询同步队列中的等待线程情况。</li></ul><h2 id="ReentrantLock结构"><a href="#ReentrantLock结构" class="headerlink" title="ReentrantLock结构"></a>ReentrantLock结构</h2><p><img src="./image/ReentrantLock.jpg" alt="image"></p><h3 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h3><ul><li>独占式指同一时刻仅有一个线程持有同步状态</li><li>独占式同步状态获取：acquire(int arg)方法为AQS提供的模板方法，改方法为独占式获取同步状态，但是该方法对中断不敏感，也就是说由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。</li><li>各个方法的定义：</li><li><strong>tryAcquire</strong>：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。该方法自定义同步组件自己实现，该方法必须要保证线程安全的获取同步状态。</li><li><strong>addWaiter</strong>：如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。</li><li><strong>acquireQueued</strong>：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。</li><li><strong>selfInterrupt</strong>：产生一个中断。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ReentrantLock的lock代码</span><br><span class="line">public void lock() &#123;</span><br><span class="line">       sync.lock();</span><br><span class="line">   &#125;</span><br><span class="line">&#x2F;&#x2F;NonfairSync的lock代码</span><br><span class="line">final void lock() &#123;</span><br><span class="line">if (compareAndSetState(0, 1))</span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">else</span><br><span class="line">acquire(1);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;AQS中的acquire</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">       if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br><span class="line">改写为</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">       if (tryAcquire(arg)) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       Node newNode &#x3D; addWaiter(Node.EXCLUSIVE);</span><br><span class="line">       boolean interrupted &#x3D; acquireQueued(newNode, arg);</span><br><span class="line">       if (interrupted) &#123;</span><br><span class="line">           selfInterrupt();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>acquire(int arg)方法流程图 </code></pre><p><img src="./image/acquire()%E6%96%B9%E6%B3%95.jpg" alt="image"></p><ul><li><p>独占式获取响应中断：AQS提供了acquire(int arg)方法以供独占式获取同步状态，但是该方法对中断不响应，对线程进行中断操作后，该线程会依然位于CLH同步队列中等待获取同步状态，为了响应中断，AQS提供了acquireInterruptibly(int arg)方法，该方法在等待获取同步状态时，如果当前线程被中断了，会立即响应中断并抛出InterruptedException。</p><blockquote><p>首先校验该线程是否已经中断了，如果是则抛出InterruptedException，否则执行tryAcquire(int arg)方法获取同步状态，如果获取成功，则直接返回，否则执行doAcquireInterruptibly(int arg)。</p></blockquote><blockquote><p>doAcquireInterruptibly(int arg)方法与acquire(int arg)方法仅有两个差别。</p></blockquote><blockquote><blockquote><p>1.方法声明抛出InterruptedException异常。</p></blockquote></blockquote><blockquote><blockquote><p>2.在中断方法处不再是使用interrupted标志，而是直接抛出InterruptedException异常。</p></blockquote></blockquote></li></ul><ul><li><p>独占式超时获取    </p><blockquote><blockquote><p>AQS除了提供上面两个方法外，还提供了一个增强版的方法：tryAcquireNanos(int arg,long nanos)。该方法为acquireInterruptibly方法的进一步增强，它除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回false，否则返回true。<br><img src="./image/acquireNano%E6%96%B9%E6%B3%95.jpg" alt="image"></p></blockquote></blockquote></li><li><p>独占式同步状态释放</p><blockquote><blockquote><p>当线程获取同步状态后，执行完相应逻辑后就需要释放同步状态。AQS提供了release(int arg)方法释放同步状态。该方法同样是先调用自定义同步器自定义的tryRelease(int arg)方法来释放同步状态，释放成功后，会调用unparkSuccessor(Node node)方法唤醒后继节点。<br>** 在AQS中维护着一个FIFO的同步队列，当线程获取同步状态失败后，则会加入到这个CLH同步队列的对尾并一直保持着自旋。在CLH同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态，获取成功则退出CLH同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。**</p></blockquote></blockquote></li></ul><h3 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h3><ul><li>共享式与独占式的最主要区别在于同一时刻独占式只能有一个线程获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。例如读操作可以有多个线程同时进行，而写操作同一时刻只能有一个线程进行写操作，其他操作都会被阻塞。</li><li>共享式同步状态获取    AQS提供acquireShared(int arg)方法共享式获取同步状态：</li><li>方法首先是调用tryAcquireShared(int arg)方法尝试获取同步状态，如果获取失败则调用doAcquireShared(int arg)自旋方式获取同步状态，共享式获取同步状态的标志是返回 &gt;= 0 的值表示获取成功。</li><li>tryAcquireShared(int arg)方法尝试获取同步状态，返回值为int，当其 &gt;= 0 时，表示能够获取到同步状态，这个时候就可以从自旋过程中退出。</li><li>acquireShared(int arg)方法不响应中断，与独占式相似，AQS也提供了响应中断、超时的方法，分别是：acquireSharedInterruptibly(int arg)、tryAcquireSharedNanos(int arg,long nanos)。</li><li>共享式同步状态释放    获取同步状态后，需要调用release(int arg)方法释放同步状态</li><li>因为可能会存在多个线程同时行释放同步状态资源，所以需要确保同步状态安全地成功释放，一般都是通过CAS和循环来完成的。</li></ul><h2 id="阻塞和唤醒线程"><a href="#阻塞和唤醒线程" class="headerlink" title="阻塞和唤醒线程"></a>阻塞和唤醒线程</h2><ul><li>在线程获取同步状态时如果获取失败，则加入CLH同步队列，通过通过自旋的方式不断获取同步状态，但是在自旋的过程中则需要判断当前线程是否需要阻塞，其主要方法在acquireQueued()</li><li>在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态，检查状态的方法为 shouldParkAfterFailedAcquire(Node pred, Node node) 方法，该方法主要靠前驱节点判断当前线程是否应该被阻塞</li></ul>]]></content>
      
      
      <categories>
          
          <category> JUC锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 00_AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Condition</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/Condition/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/Condition/</url>
      
        <content type="html"><![CDATA[<p>在Java程序中，任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object类上），主要包括wait()、wait(long)、notify()、notifyAll()方法，这些方法与synchronized关键字配合。实现等待/通知模式。==Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">   Condition condition &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">   public void conditionWait() throws InterruptedException &#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       try &#123;</span><br><span class="line">           condition.await();</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void conditionSignal() throws InterruptedException &#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       try &#123;</span><br><span class="line">           condition.signal();</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>一般都会将Condition对象作为成员变量。当调用await()方法后，当前线程会<br>释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程<br>才从await()方法返回，并且在返回前已经获取了锁</p><p>Condition接口定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public interface Condition &#123;</span><br><span class="line">    &#x2F;&#x2F;当前线程进入等待状态直到被通知（signal）或中断。</span><br><span class="line">    void await() throws InterruptedException;</span><br><span class="line">    &#x2F;&#x2F;当前线程进入等待状态直到被通知，该方法不响应中断。</span><br><span class="line">    void awaitUninterruptibly();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;当前线程进入等待状态直到被通知、中断或者超时，返回值表示剩余超时时间。</span><br><span class="line">    long awaitNanos(long nanosTimeout) throws InterruptedException;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    boolean await(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; &#x2F;&#x2F;当前线程进入等待状态直到被通知、中断或者到某个时间。如果没有到指定时间就被通知，方法返回true，否则，表示到了指定时间，返回false。</span><br><span class="line">    boolean awaitUntil(Date deadline) throws InterruptedException;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">唤醒一个等待在Condition上的线程，该线程从等待方法返回前必须获得与Condition相关联的锁。</span><br><span class="line">    void signal();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;唤醒所有等待在Condition上的线程，能够从等待方法返回的线程必须获得与Condition相关联的锁。</span><br><span class="line">    void signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Condition的实现。创建一个condition对象是通过lock.newCondition()，会new出一个ConditionObject对象（AQS的一个内部类）。AQS内部维护了一个同步队列，如果是独占式锁的话，所有获取锁失败的线程的尾插入到==同步队列(带头结点的双向队列)==，同样的，==condition内部也是使用同样的方式，内部维护了一个 等待队列(不带头结点的单向队列)==，所有调用condition.await方法的线程会加入到等待队列中，并且线程状态转换为等待状态</p><p>如果一个线程调用了Condition.await()方法，那么该线程将会<br>释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步器中节点<br>的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** First node of condition queue. *&#x2F;</span><br><span class="line">private transient Node firstWaiter;</span><br><span class="line">&#x2F;** Last node of condition queue. *&#x2F;</span><br><span class="line">private transient Node lastWaiter;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/2615789-5aa1ee1ae8cb7f5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/796/format/webp" alt="image"></p><p>我们可以多次调用lock.newCondition()方法创建多个condition对象，也就是一个lock可以持有多个等待队列。而在之前利用Object的方式实际上是指在对象Object对象监视器上只能拥有一个同步队列和一个等待队列，而并发包中的Lock拥有一个同步队列和多个等待队列。<br><img src="https://img-blog.csdnimg.cn/20190329234207496.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dzX2FsYmI=,size_16,color_FFFFFF,t_70" alt="image"></p><p>Condition的实现是同步器的内部类，因此每个Condition实例都能够访问同步器<br>提供的方法，相当于每个Condition都拥有所属同步器的引用</p><h3 id="await实现原理"><a href="#await实现原理" class="headerlink" title="await实现原理"></a>await实现原理</h3><h4 id="等待队列入队操作："><a href="#等待队列入队操作：" class="headerlink" title="等待队列入队操作："></a>等待队列入队操作：</h4><p>当调用condition.await()方法后会使得当前获取lock的线程进入到等待队列，如果该线程能够从await()方法返回的话一定是该线程获取了与condition相关联的lock</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    &#x2F;&#x2F; 1. 将当前线程包装成Node，尾插入到等待队列中</span><br><span class="line">    Node node &#x3D; addConditionWaiter();</span><br><span class="line">    &#x2F;&#x2F; 2. 释放当前线程所占用的lock，在释放的过程中会唤醒同步队列中的下一个节点</span><br><span class="line">    int savedState &#x3D; fullyRelease(node);</span><br><span class="line">    int interruptMode &#x3D; 0;</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 3. 当前线程进入到等待状态</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        if ((interruptMode &#x3D; checkInterruptWhileWaiting(node)) !&#x3D; 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 4. 自旋等待获取到同步状态（即获取到lock）</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode !&#x3D; THROW_IE)</span><br><span class="line">        interruptMode &#x3D; REINTERRUPT;</span><br><span class="line">    if (node.nextWaiter !&#x3D; null) &#x2F;&#x2F; clean up if cancelled</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    &#x2F;&#x2F; 5. 处理被中断的情况</span><br><span class="line">    if (interruptMode !&#x3D; 0)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==当前线程调用condition.await()方法后，会使得当前线程释放lock然后加入到等待队列中，直至被signal/signalAll后会使得当前线程从等待队列中移至到同步队列中去，直到获得了lock后才会从await方法返回，或者在等待时被中断会做中断处理。==</p><p>addConditionWaiter将当前线程添加到等待队列中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private Node addConditionWaiter() &#123;</span><br><span class="line">    Node t &#x3D; lastWaiter;</span><br><span class="line">    &#x2F;&#x2F; If lastWaiter is cancelled, clean out.</span><br><span class="line">    if (t !&#x3D; null &amp;&amp; t.waitStatus !&#x3D; Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t &#x3D; lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;将当前线程包装成Node</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    if (t &#x3D;&#x3D; null)</span><br><span class="line">        firstWaiter &#x3D; node;</span><br><span class="line">    else</span><br><span class="line">        &#x2F;&#x2F;尾插入</span><br><span class="line">        t.nextWaiter &#x3D; node;</span><br><span class="line">    &#x2F;&#x2F;更新lastWaiter</span><br><span class="line">    lastWaiter &#x3D; node;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="释放锁："><a href="#释放锁：" class="headerlink" title="释放锁："></a>释放锁：</h4><p>将当前节点插入到等待对列之后，会使当前线程释放lock，由fullyRelease方法实现:调用AQS的模板方法release方法释放AQS的同步状态并且唤醒在同步队列中头结点的后继节点引用的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final int fullyRelease(Node node) &#123;</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        int savedState &#x3D; getState();</span><br><span class="line">        if (release(savedState)) &#123;</span><br><span class="line">            &#x2F;&#x2F;成功释放同步状态</span><br><span class="line">            failed &#x3D; false;</span><br><span class="line">            return savedState;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;不成功释放同步状态抛出异常</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            node.waitStatus &#x3D; Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从await方法退出"><a href="#从await方法退出" class="headerlink" title="从await方法退出"></a>从await方法退出</h3><p>await方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 3. 当前线程进入到等待状态</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    if ((interruptMode &#x3D; checkInterruptWhileWaiting(node)) !&#x3D; 0)</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当前等待的线程被中断后代码会走到break退出</li><li>当前节点被移动到了同步队列中（即另外线程调用的condition的signal或者signalAll方法），while中逻辑判断为false后结束while循环。</li><li><img src="https://upload-images.jianshu.io/upload_images/2615789-1cb1c2fe3c1ddf38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/889/format/webp" alt="image"><br>调用condition.await方法的线程必须是已经获得了lock，也就是当前线程是同步队列中的头结点。调用该方法后会使得当前线程所封装的Node尾插入到等待队列中。</li></ul><h3 id="signal-signalAll实现原理"><a href="#signal-signalAll实现原理" class="headerlink" title="signal/signalAll实现原理"></a>signal/signalAll实现原理</h3><p>调用condition的signal或者signalAll方法可以将等待队列中等待时间最长的节点移动到同步队列中，使得该节点能够有机会获得lock。按照等待队列是先进先出（FIFO）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是==本质上调用condition的signal方法是将等待队列的头节点移动到同步队列中==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">    &#x2F;&#x2F;1. 先检测当前线程是否已经获取lock</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    &#x2F;&#x2F;2. 获取等待队列中第一个节点，之后的操作都是针对这个节点</span><br><span class="line">    Node first &#x3D; firstWaiter;</span><br><span class="line">    if (first !&#x3D; null)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        if ( (firstWaiter &#x3D; first.nextWaiter) &#x3D;&#x3D; null)</span><br><span class="line">            lastWaiter &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;1. 将头结点从等待队列中移除</span><br><span class="line">        first.nextWaiter &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;2. while中transferForSignal方法对头结点做真正的处理</span><br><span class="line">    &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first &#x3D; firstWaiter) !&#x3D; null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;1. 更新状态为0</span><br><span class="line">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2.将该节点移入到同步队列中去</span><br><span class="line">    Node p &#x3D; enq(node);</span><br><span class="line">    int ws &#x3D; p.waitStatus;</span><br><span class="line">    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/2615789-3750f5baf7995623.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/855/format/webp" alt="image"></p><p> await与signal/signalAll的结合<br> <img src="https://upload-images.jianshu.io/upload_images/2615789-02449dc316fe1de6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/837/format/webp" alt="image"><br> 线程awaitThread先通过lock.lock()方法获取锁成功后调用了condition.await方法进入等待队列，而另一个线程signalThread通过lock.lock()方法获取锁成功后调用了condition.signal或者signalAll方法，使得线程awaitThread能够有机会移入到同步队列中，当其他线程释放lock后使得线程awaitThread能够有机会获取lock，从而使得线程awaitThread能够从await方法中退出执行后续操作。如果awaitThread获取lock失败会直接进入到同步队列。</p>]]></content>
      
      
      <categories>
          
          <category> JUC锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Condition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行sql</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/%E6%BA%90%E7%A0%81/6%E3%80%81%E6%89%A7%E8%A1%8Csql/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/%E6%BA%90%E7%A0%81/6%E3%80%81%E6%89%A7%E8%A1%8Csql/</url>
      
        <content type="html"><![CDATA[<h2 id="1、获取SqlSeesion"><a href="#1、获取SqlSeesion" class="headerlink" title="1、获取SqlSeesion"></a>1、获取SqlSeesion</h2><p>前面通过配置文件产生SqlSessionFactory，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(Configuration config) &#123;</span><br><span class="line">  return new DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到 SqlSessionFactory 之后，就可以通过 SqlSessionFactory 去获取 SqlSession 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;sqlSessionFactory.openSession()</span><br><span class="line">@Override</span><br><span class="line">public SqlSession openSession() &#123;</span><br><span class="line">    return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123;</span><br><span class="line">    Transaction tx &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;Environment对象封装了配置文件中对于数据源和事务的配置</span><br><span class="line">        final Environment environment &#x3D; configuration.getEnvironment();</span><br><span class="line">        final TransactionFactory transactionFactory &#x3D; getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">        tx &#x3D; transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">        &#x2F;&#x2F;获取Executor对象，用来执行sql语句</span><br><span class="line">        final Executor executor &#x3D; configuration.newExecutor(tx, execType);</span><br><span class="line">        return new DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        closeTransaction(tx); &#x2F;&#x2F; may have fetched a connection so lets call close()</span><br><span class="line">        throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取Executor对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Executor newExecutor(Transaction transaction, ExecutorType executorType) &#123;</span><br><span class="line">    executorType &#x3D; executorType &#x3D;&#x3D; null ? defaultExecutorType : executorType;</span><br><span class="line">    executorType &#x3D; executorType &#x3D;&#x3D; null ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    if (ExecutorType.BATCH &#x3D;&#x3D; executorType) &#123;</span><br><span class="line">      executor &#x3D; new BatchExecutor(this, transaction);</span><br><span class="line">    &#125; else if (ExecutorType.REUSE &#x3D;&#x3D; executorType) &#123;</span><br><span class="line">      executor &#x3D; new ReuseExecutor(this, transaction);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      executor &#x3D; new SimpleExecutor(this, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;cacheEnabled &#x3D; true（这里是一级缓存，默认是开启的）,使用了装饰器模式，在原有的 Executor 上装饰了缓存功能。</span><br><span class="line">    if (cacheEnabled) &#123;</span><br><span class="line">      executor &#x3D; new CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor &#x3D; (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    return executor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum ExecutorType &#123;</span><br><span class="line">  SIMPLE, REUSE, BATCH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SimpleExecutor："><a href="#SimpleExecutor：" class="headerlink" title="SimpleExecutor："></a>SimpleExecutor：</h4><p>每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象：closeStatement(stmt);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;每次新开启一个Statement</span><br><span class="line">  private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection &#x3D; getConnection(statementLog);</span><br><span class="line">    stmt &#x3D; handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    return stmt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="ReuseExecutor："><a href="#ReuseExecutor：" class="headerlink" title="ReuseExecutor："></a>ReuseExecutor：</h4><p>执行update或select，以sql作为key从statementMap查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。就是重复使用Statement对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ReuseExecutor获取Statement</span><br><span class="line">  private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    BoundSql boundSql &#x3D; handler.getBoundSql();</span><br><span class="line">    String sql &#x3D; boundSql.getSql();</span><br><span class="line">    &#x2F;&#x2F;判断statementMap是否包含key为sql的Statement对象</span><br><span class="line">    if (hasStatementFor(sql)) &#123;</span><br><span class="line">      &#x2F;&#x2F;如果包含则直接statementMap.get(s);</span><br><span class="line">      stmt &#x3D; getStatement(sql);</span><br><span class="line">      applyTransactionTimeout(stmt);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;如果不包含新开启一个Statement，并放入statementMap</span><br><span class="line">      Connection connection &#x3D; getConnection(statementLog);</span><br><span class="line">      stmt &#x3D; handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">      putStatement(sql, stmt);</span><br><span class="line">    &#125;</span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    return stmt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="BatchExecutor："><a href="#BatchExecutor：" class="headerlink" title="BatchExecutor："></a>BatchExecutor：</h4><p>执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p><p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p><h2 id="2、接口动态代理执行调用sqlsession的crud"><a href="#2、接口动态代理执行调用sqlsession的crud" class="headerlink" title="2、接口动态代理执行调用sqlsession的crud"></a>2、接口动态代理执行调用sqlsession的crud</h2><p>不管是单独使用还是和Spring集成，我们都是使用接口定义的方式声明数据库的增删改查方法。那么我们只声明一个接口，MyBatis是如何帮我们来实现SQL？</p><p>调用sqlSession.getMapper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserMapper mapper &#x3D; session.getMapper(UserMapper.class);</span><br></pre></td></tr></table></figure><p>SqlSession本身不做任何事情，直接把任务甩给Configuration。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">   return configuration.getMapper(type, this);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Configuration又把任务甩给MapperRegistry。MapperRegistry 用来注册接口和生成代理类实例的工具类 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">     return this.mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MapperRegistry.getMapper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">  final MapperProxyFactory&lt;T&gt; mapperProxyFactory &#x3D; (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;如果未空则抛异常。然后继续调用mapperProxyFactory.newInstance()。</span><br><span class="line">  if (mapperProxyFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">    throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    return mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapperProxyFactory.newInstance(sqlSession);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public T newInstance(SqlSession sqlSession) &#123;</span><br><span class="line">    final MapperProxy&lt;T&gt; mapperProxy &#x3D; new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    return newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;</span><br><span class="line">    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>　MapperProxy这个类实现了jdk动态代理接口InvocationHandler。在invoke方法中实现代理方法调用的细节。</p><p>MapperMethod类是整个代理机制的核心类,对SqlSession中的操作进行了封装。 该类里有两个内部类SqlCommand和MethodSignature。 SqlCommand用来封装增删改查操作，也就是我们在xml中配置的select、update、delete、insert节点。每个节点都会生成一个MappedStatement类。MethodSignature用来封装方法的参数，返回类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">    Object result;</span><br><span class="line">    switch (command.getType()) &#123;</span><br><span class="line">      case INSERT: &#123;</span><br><span class="line">      &#x2F;&#x2F;调用sqlSession.insert</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case UPDATE: &#123;</span><br><span class="line">       &#x2F;&#x2F;调用sqlSession.UPDATE</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case DELETE: &#123;</span><br><span class="line">       &#x2F;&#x2F;调用sqlSession.DELETE</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case SELECT:</span><br><span class="line">       &#x2F;&#x2F;调用sqlSession.SELECT</span><br><span class="line">        if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result &#x3D; null;</span><br><span class="line">        &#125; else if (method.returnsMany()) &#123;</span><br><span class="line">          result &#x3D; executeForMany(sqlSession, args);</span><br><span class="line">        &#125; else if (method.returnsMap()) &#123;</span><br><span class="line">          result &#x3D; executeForMap(sqlSession, args);</span><br><span class="line">        &#125; else if (method.returnsCursor()) &#123;</span><br><span class="line">          result &#x3D; executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result &#x3D; sqlSession.selectOne(command.getName(), param);</span><br><span class="line">          if (method.returnsOptional()</span><br><span class="line">              &amp;&amp; (result &#x3D;&#x3D; null || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">            result &#x3D; Optional.ofNullable(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      case FLUSH:</span><br><span class="line">        result &#x3D; sqlSession.flushStatements();</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    if (result &#x3D;&#x3D; null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      throw new BindingException(&quot;Mapper method &#39;&quot; + command.getName()</span><br><span class="line">          + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="3、sqlSession的操作"><a href="#3、sqlSession的操作" class="headerlink" title="3、sqlSession的操作"></a>3、sqlSession的操作</h2><p>最终调用执行器executor的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int update(String statement, Object parameter) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      dirty &#x3D; true;</span><br><span class="line">      MappedStatement ms &#x3D; configuration.getMappedStatement(statement);</span><br><span class="line">      return executor.update(ms, wrapCollection(parameter));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error updating database.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>调用对应执行器executor的doUpdate</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int doUpdate(MappedStatement ms, Object parameter) throws SQLException &#123;</span><br><span class="line">  Statement stmt &#x3D; null;</span><br><span class="line">  try &#123;</span><br><span class="line">    Configuration configuration &#x3D; ms.getConfiguration();</span><br><span class="line">    StatementHandler handler &#x3D; configuration.newStatementHandler(this, ms, parameter, RowBounds.DEFAULT, null, null);</span><br><span class="line">    stmt &#x3D; prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    return handler.update(stmt);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>executor调用原始的JDBC操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public int update(Statement statement) throws SQLException &#123;</span><br><span class="line">    String sql &#x3D; boundSql.getSql();</span><br><span class="line">    Object parameterObject &#x3D; boundSql.getParameterObject();</span><br><span class="line">    KeyGenerator keyGenerator &#x3D; mappedStatement.getKeyGenerator();</span><br><span class="line">    int rows;</span><br><span class="line">    if (keyGenerator instanceof Jdbc3KeyGenerator) &#123;</span><br><span class="line">      statement.execute(sql, Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">      rows &#x3D; statement.getUpdateCount();</span><br><span class="line">      keyGenerator.processAfter(executor, mappedStatement, statement, parameterObject);</span><br><span class="line">    &#125; else if (keyGenerator instanceof SelectKeyGenerator) &#123;</span><br><span class="line">      statement.execute(sql);</span><br><span class="line">      rows &#x3D; statement.getUpdateCount();</span><br><span class="line">      keyGenerator.processAfter(executor, mappedStatement, statement, parameterObject);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      statement.execute(sql);</span><br><span class="line">      rows &#x3D; statement.getUpdateCount();</span><br><span class="line">    &#125;</span><br><span class="line">    return rows;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 执行sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前中后缀表达式</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E3%80%81%E6%A0%88/3%E3%80%81%E5%89%8D%E4%B8%AD%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E3%80%81%E6%A0%88/3%E3%80%81%E5%89%8D%E4%B8%AD%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>前缀记法、中缀记法和后缀记法。它们之间的区别在于运算符相对与操作数的位置不同</p><ul><li>(3 + 4) × 5 - 6 就是中缀表达式</li><li>一 * + 3 4 5 6 前缀表达式（波兰式）</li><li>3 4 + 5 × 6 - 后缀表达式（逆波兰式）</li></ul><p>虽然人的大脑很容易理解与分析中缀表达式，但对计算机来说中缀表达式却是很复杂的，因此计算表达式的值时，通常需要先将中缀表达式转换为前缀或后缀表达式，然后再进行求值。对计算机来说，计算前缀或后缀表达式的值非常简单。</p><h3 id="前缀表达式求值："><a href="#前缀表达式求值：" class="headerlink" title="前缀表达式求值："></a>前缀表达式求值：</h3><p>从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果。</p><p>例如前缀表达式“- × + 3 4 5 6”：</p><ul><li>(1) 从右至左扫描，将6、5、4、3压入堆栈；</li><li>(2) 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素，注意与后缀表达式做比较），计算出3+4的值，得7，再将7入栈；</li><li>(3) 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈；</li><li>(4) 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。</li></ul><h3 id="后缀表达式求值："><a href="#后缀表达式求值：" class="headerlink" title="后缀表达式求值："></a>后缀表达式求值：</h3><p>与前缀表达式类似，只是顺序是从左至右</p><p>例如后缀表达式“3 4 + 5 × 6 -”：</p><ul><li>(1) 从左至右扫描，将3和4压入堆栈；</li><li>(2) 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素，注意与前缀表达式做比较），计算出3+4的值，得7，再将7入栈；</li><li>(3) 将5入栈；</li><li>(4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</li><li>(5) 将6入栈；</li><li>(6) 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。</li></ul><h3 id="中缀表达式转后缀表达式："><a href="#中缀表达式转后缀表达式：" class="headerlink" title="中缀表达式转后缀表达式："></a>中缀表达式转后缀表达式：</h3><p>中缀表达式1 + (( 2 + 3)* 4 ) –5，请将它转化为后缀表达式。</p><p>首先将中缀表达式转换为表达式树，然后后序遍历表达式树，所得结果就是后缀表达式。</p><p>将中缀表达式转化为表达式树方法：表达式树的树叶是操作数，而其他的节点为操作符，根节点为优先级最低且靠右的操作符（如上述表达式优先级最低的是- 和+，但 + 更靠右，所以根为+），圆括号不包括。如上述中缀表达式转换后的表达式树如下：</p><p><img src="https://img-blog.csdn.net/20140402144303578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2Fsa2Vya2Fscg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><p>经过后序遍历表达式树后得到的后缀表达式为：12 3 + 4 * + 5 –</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line">public class PolandNotation &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;完成将一个中缀表达式转成后缀表达式的功能</span><br><span class="line">&#x2F;&#x2F;说明</span><br><span class="line">&#x2F;&#x2F;1. 1+((2+3)×4)-5 &#x3D;&gt; 转成  1 2 3 + 4 × + 5 –</span><br><span class="line">&#x2F;&#x2F;2. 因为直接对str 进行操作，不方便，因此 先将  &quot;1+((2+3)×4)-5&quot; &#x3D;》 中缀的表达式对应的List</span><br><span class="line">&#x2F;&#x2F;   即 &quot;1+((2+3)×4)-5&quot; &#x3D;&gt; ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span><br><span class="line">&#x2F;&#x2F;3. 将得到的中缀表达式对应的List &#x3D;&gt; 后缀表达式对应的List</span><br><span class="line">&#x2F;&#x2F;   即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  &#x3D;》 ArrayList [1,2,3,+,4,*,+,5,–]</span><br><span class="line"></span><br><span class="line">String expression &#x3D; &quot;1+((2+3)*4)-5&quot;;&#x2F;&#x2F;注意表达式 </span><br><span class="line">List&lt;String&gt; infixExpressionList &#x3D; toInfixExpressionList(expression);</span><br><span class="line">System.out.println(&quot;中缀表达式对应的List&#x3D;&quot; + infixExpressionList); &#x2F;&#x2F; ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span><br><span class="line">List&lt;String&gt; suffixExpreesionList &#x3D; parseSuffixExpreesionList(infixExpressionList);</span><br><span class="line">System.out.println(&quot;后缀表达式对应的List&quot; + suffixExpreesionList); &#x2F;&#x2F;ArrayList [1,2,3,+,4,*,+,5,–] </span><br><span class="line"></span><br><span class="line">System.out.printf(&quot;expression&#x3D;%d&quot;, calculate(suffixExpreesionList)); &#x2F;&#x2F; ?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;先定义给逆波兰表达式</span><br><span class="line">&#x2F;&#x2F;(30+4)×5-6  &#x3D;&gt; 30 4 + 5 × 6 - &#x3D;&gt; 164</span><br><span class="line">&#x2F;&#x2F; 4 * 5 - 8 + 60 + 8 &#x2F; 2 &#x3D;&gt; 4 5 * 8 - 60 + 8 2 &#x2F; + </span><br><span class="line">&#x2F;&#x2F;测试 </span><br><span class="line">&#x2F;&#x2F;说明为了方便，逆波兰表达式 的数字和符号使用空格隔开</span><br><span class="line">&#x2F;&#x2F;String suffixExpression &#x3D; &quot;30 4 + 5 * 6 -&quot;;</span><br><span class="line">String suffixExpression &#x3D; &quot;4 5 * 8 - 60 + 8 2 &#x2F; +&quot;; &#x2F;&#x2F; 76</span><br><span class="line">&#x2F;&#x2F;思路</span><br><span class="line">&#x2F;&#x2F;1. 先将 &quot;3 4 + 5 × 6 - &quot; &#x3D;&gt; 放到ArrayList中</span><br><span class="line">&#x2F;&#x2F;2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list &#x3D; getListString(suffixExpression);</span><br><span class="line">System.out.println(&quot;rpnList&#x3D;&quot; + list);</span><br><span class="line">int res &#x3D; calculate(list);</span><br><span class="line">System.out.println(&quot;计算的结果是&#x3D;&quot; + res);</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  &#x3D;》 ArrayList [1,2,3,+,4,*,+,5,–]</span><br><span class="line">&#x2F;&#x2F;方法：将得到的中缀表达式对应的List &#x3D;&gt; 后缀表达式对应的List</span><br><span class="line">public static List&lt;String&gt; parseSuffixExpreesionList(List&lt;String&gt; ls) &#123;</span><br><span class="line">&#x2F;&#x2F;定义两个栈</span><br><span class="line">Stack&lt;String&gt; s1 &#x3D; new Stack&lt;String&gt;(); &#x2F;&#x2F; 符号栈</span><br><span class="line">&#x2F;&#x2F;说明：因为s2 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出</span><br><span class="line">&#x2F;&#x2F;因此比较麻烦，这里我们就不用 Stack&lt;String&gt; 直接使用 List&lt;String&gt; s2</span><br><span class="line">&#x2F;&#x2F;Stack&lt;String&gt; s2 &#x3D; new Stack&lt;String&gt;(); &#x2F;&#x2F; 储存中间结果的栈s2</span><br><span class="line">List&lt;String&gt; s2 &#x3D; new ArrayList&lt;String&gt;(); &#x2F;&#x2F; 储存中间结果的Lists2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;遍历ls</span><br><span class="line">for(String item: ls) &#123;</span><br><span class="line">&#x2F;&#x2F;如果是一个数，加入s2</span><br><span class="line">if(item.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">s2.add(item);</span><br><span class="line">&#125; else if (item.equals(&quot;(&quot;)) &#123;</span><br><span class="line">s1.push(item);</span><br><span class="line">&#125; else if (item.equals(&quot;)&quot;)) &#123;</span><br><span class="line">&#x2F;&#x2F;如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span><br><span class="line">while(!s1.peek().equals(&quot;(&quot;)) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line">s1.pop();&#x2F;&#x2F;!!! 将 ( 弹出 s1栈， 消除小括号</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;当item的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较</span><br><span class="line">&#x2F;&#x2F;问题：我们缺少一个比较优先级高低的方法</span><br><span class="line">while(s1.size() !&#x3D; 0 &amp;&amp; Operation.getValue(s1.peek()) &gt;&#x3D; Operation.getValue(item) ) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;还需要将item压入栈</span><br><span class="line">s1.push(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将s1中剩余的运算符依次弹出并加入s2</span><br><span class="line">while(s1.size() !&#x3D; 0) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return s2; &#x2F;&#x2F;注意因为是存放到List, 因此按顺序输出就是对应的后缀表达式对应的List</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法：将 中缀表达式转成对应的List</span><br><span class="line">&#x2F;&#x2F;  s&#x3D;&quot;1+((2+3)×4)-5&quot;;</span><br><span class="line">public static List&lt;String&gt; toInfixExpressionList(String s) &#123;</span><br><span class="line">&#x2F;&#x2F;定义一个List,存放中缀表达式 对应的内容</span><br><span class="line">List&lt;String&gt; ls &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">int i &#x3D; 0; &#x2F;&#x2F;这时是一个指针，用于遍历 中缀表达式字符串</span><br><span class="line">String str; &#x2F;&#x2F; 对多位数的拼接</span><br><span class="line">char c; &#x2F;&#x2F; 每遍历到一个字符，就放入到c</span><br><span class="line">do &#123;</span><br><span class="line">&#x2F;&#x2F;如果c是一个非数字，我需要加入到ls</span><br><span class="line">if((c&#x3D;s.charAt(i)) &lt; 48 ||  (c&#x3D;s.charAt(i)) &gt; 57) &#123;</span><br><span class="line">ls.add(&quot;&quot; + c);</span><br><span class="line">i++; &#x2F;&#x2F;i需要后移</span><br><span class="line">&#125; else &#123; &#x2F;&#x2F;如果是一个数，需要考虑多位数</span><br><span class="line">str &#x3D; &quot;&quot;; &#x2F;&#x2F;先将str 置成&quot;&quot; &#39;0&#39;[48]-&gt;&#39;9&#39;[57]</span><br><span class="line">while(i &lt; s.length() &amp;&amp; (c&#x3D;s.charAt(i)) &gt;&#x3D; 48 &amp;&amp; (c&#x3D;s.charAt(i)) &lt;&#x3D; 57) &#123;</span><br><span class="line">str +&#x3D; c;&#x2F;&#x2F;拼接</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">ls.add(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;while(i &lt; s.length());</span><br><span class="line">return ls;&#x2F;&#x2F;返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList中</span><br><span class="line">public static List&lt;String&gt; getListString(String suffixExpression) &#123;</span><br><span class="line">&#x2F;&#x2F;将 suffixExpression 分割</span><br><span class="line">String[] split &#x3D; suffixExpression.split(&quot; &quot;);</span><br><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">for(String ele: split) &#123;</span><br><span class="line">list.add(ele);</span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;完成对逆波兰表达式的运算</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 1)从左至右扫描，将3和4压入堆栈；</span><br><span class="line">2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；</span><br><span class="line">3)将5入栈；</span><br><span class="line">4)接下来是×运算符，因此弹出5和7，计算出7×5&#x3D;35，将35入栈；</span><br><span class="line">5)将6入栈；</span><br><span class="line">6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public static int calculate(List&lt;String&gt; ls) &#123;</span><br><span class="line">&#x2F;&#x2F; 创建给栈, 只需要一个栈即可</span><br><span class="line">Stack&lt;String&gt; stack &#x3D; new Stack&lt;String&gt;();</span><br><span class="line">&#x2F;&#x2F; 遍历 ls</span><br><span class="line">for (String item : ls) &#123;</span><br><span class="line">&#x2F;&#x2F; 这里使用正则表达式来取出数</span><br><span class="line">if (item.matches(&quot;\\d+&quot;)) &#123; &#x2F;&#x2F; 匹配的是多位数</span><br><span class="line">&#x2F;&#x2F; 入栈</span><br><span class="line">stack.push(item);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; pop出两个数，并运算， 再入栈</span><br><span class="line">int num2 &#x3D; Integer.parseInt(stack.pop());</span><br><span class="line">int num1 &#x3D; Integer.parseInt(stack.pop());</span><br><span class="line">int res &#x3D; 0;</span><br><span class="line">if (item.equals(&quot;+&quot;)) &#123;</span><br><span class="line">res &#x3D; num1 + num2;</span><br><span class="line">&#125; else if (item.equals(&quot;-&quot;)) &#123;</span><br><span class="line">res &#x3D; num1 - num2;</span><br><span class="line">&#125; else if (item.equals(&quot;*&quot;)) &#123;</span><br><span class="line">res &#x3D; num1 * num2;</span><br><span class="line">&#125; else if (item.equals(&quot;&#x2F;&quot;)) &#123;</span><br><span class="line">res &#x3D; num1 &#x2F; num2;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">throw new RuntimeException(&quot;运算符有误&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;把res 入栈</span><br><span class="line">stack.push(&quot;&quot; + res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;最后留在stack中的数据是运算结果</span><br><span class="line">return Integer.parseInt(stack.pop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编写一个类 Operation 可以返回一个运算符 对应的优先级</span><br><span class="line">class Operation &#123;</span><br><span class="line">private static int ADD &#x3D; 1;</span><br><span class="line">private static int SUB &#x3D; 1;</span><br><span class="line">private static int MUL &#x3D; 2;</span><br><span class="line">private static int DIV &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;写一个方法，返回对应的优先级数字</span><br><span class="line">public static int getValue(String operation) &#123;</span><br><span class="line">int result &#x3D; 0;</span><br><span class="line">switch (operation) &#123;</span><br><span class="line">case &quot;+&quot;:</span><br><span class="line">result &#x3D; ADD;</span><br><span class="line">break;</span><br><span class="line">case &quot;-&quot;:</span><br><span class="line">result &#x3D; SUB;</span><br><span class="line">break;</span><br><span class="line">case &quot;*&quot;:</span><br><span class="line">result &#x3D; MUL;</span><br><span class="line">break;</span><br><span class="line">case &quot;&#x2F;&quot;:</span><br><span class="line">result &#x3D; DIV;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">System.out.println(&quot;不存在该运算符&quot; + operation);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前中后缀表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis的缓存</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/6%E3%80%81mybatis%E7%9A%84%E7%BC%93%E5%AD%98/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/6%E3%80%81mybatis%E7%9A%84%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-一级缓存"><a href="#1-一级缓存" class="headerlink" title="1. 一级缓存:"></a>1. 一级缓存:</h2><p>  基于PerpetualCache 的 HashMap本地缓存，其存储==作用域为 Session==，当 Session flush 或 close 之后，该Session中的所有 Cache 就将清空。</p><p>对于一二级缓存数据更新机制，当某一个作用域(一级缓存Session/二级缓存Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被clear。</p><h3 id="1-1、Mybatis一级缓存测试"><a href="#1-1、Mybatis一级缓存测试" class="headerlink" title="1.1、Mybatis一级缓存测试"></a>1.1、Mybatis一级缓存测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package me.gacl.test;</span><br><span class="line"></span><br><span class="line">import me.gacl.domain.User;</span><br><span class="line">import me.gacl.util.MyBatisUtil;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author gacl</span><br><span class="line"> * 测试一级缓存</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TestOneLevelCache &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 一级缓存: 也就Session级的缓存(默认开启)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testCache1() &#123;</span><br><span class="line">        SqlSession session &#x3D; MyBatisUtil.getSqlSession();</span><br><span class="line">        String statement &#x3D; &quot;me.gacl.mapping.userMapper.getUser&quot;;</span><br><span class="line">        User user &#x3D; session.selectOne(statement, 1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        </span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 一级缓存默认就会被使用</span><br><span class="line">         *&#x2F;</span><br><span class="line">        user &#x3D; session.selectOne(statement, 1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        session.close();</span><br><span class="line">        &#x2F;*</span><br><span class="line">         1. 必须是同一个Session,如果session对象已经close()过了就不可能用了 </span><br><span class="line">         *&#x2F;</span><br><span class="line">        session &#x3D; MyBatisUtil.getSqlSession();</span><br><span class="line">        user &#x3D; session.selectOne(statement, 1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        </span><br><span class="line">        &#x2F;*</span><br><span class="line">         2. 查询条件是一样的</span><br><span class="line">         *&#x2F;</span><br><span class="line">        user &#x3D; session.selectOne(statement, 2);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        </span><br><span class="line">        &#x2F;*</span><br><span class="line">         3. 没有执行过session.clearCache()清理缓存</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F;session.clearCache(); </span><br><span class="line">        user &#x3D; session.selectOne(statement, 2);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        </span><br><span class="line">        &#x2F;*</span><br><span class="line">         4. 没有执行过增删改的操作(这些操作都会清理缓存)</span><br><span class="line">         *&#x2F;</span><br><span class="line">        session.update(&quot;me.gacl.mapping.userMapper.updateUser&quot;,</span><br><span class="line">                new User(2, &quot;user&quot;, 23));</span><br><span class="line">        user &#x3D; session.selectOne(statement, 2);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mybatis的一级缓存默认是开启的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public Executor newExecutor(Transaction transaction, ExecutorType executorType) &#123;</span><br><span class="line">    executorType &#x3D; executorType &#x3D;&#x3D; null ? defaultExecutorType : executorType;</span><br><span class="line">    executorType &#x3D; executorType &#x3D;&#x3D; null ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    if (ExecutorType.BATCH &#x3D;&#x3D; executorType) &#123;</span><br><span class="line">      executor &#x3D; new BatchExecutor(this, transaction);</span><br><span class="line">    &#125; else if (ExecutorType.REUSE &#x3D;&#x3D; executorType) &#123;</span><br><span class="line">      executor &#x3D; new ReuseExecutor(this, transaction);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      executor &#x3D; new SimpleExecutor(this, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;缓存执行器</span><br><span class="line">    &#x2F;&#x2F;  protected boolean cacheEnabled &#x3D; true;</span><br><span class="line">    if (cacheEnabled) &#123;</span><br><span class="line">      executor &#x3D; new CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor &#x3D; (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    return executor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="2-二级缓存："><a href="#2-二级缓存：" class="headerlink" title="　　2. 二级缓存："></a>　　2. 二级缓存：</h2><p>　　<br>　　二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap存储，存在于 Sq lSessionFactory 的生命周期中，当存在多个 SqlSessioηFactory<br>们的缓存都是绑定在各自对象上的，缓存数据在 般情况下是不相通的。只有在使用如 Red is<br>这样的缓存数据库时，才可 以共享缓存。可自定义存储源，如 Ehcache。</p><h4 id="1-2、Mybatis二级缓存开启步骤"><a href="#1-2、Mybatis二级缓存开启步骤" class="headerlink" title="1.2、Mybatis二级缓存开启步骤"></a>1.2、Mybatis二级缓存开启步骤</h4><p>1、修改配置文件mybatis-config.xml加入&lt;setting name=”cacheEnabled”value=”true”/&gt;，全局配置参数</p><p>2、开启二级缓存，在userMapper.xml文件中添加如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace&#x3D;&quot;me.gacl.mapping.userMapper&quot;&gt;</span><br><span class="line">&lt;!-- 开启二级缓存 --&gt;</span><br><span class="line">&lt;cache </span><br><span class="line">&lt;!--收回策略--&gt;</span><br><span class="line">eviction＝ FIFO</span><br><span class="line">&lt;!--刷新间隔--&gt;</span><br><span class="line">flushlnterval&#x3D;” 60000 ” </span><br><span class="line">&lt;!--引用数--&gt;</span><br><span class="line">size&#x3D;” 512 ” </span><br><span class="line">readOnly&#x3D;” true &quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h4 id="eviction-（收回策略）"><a href="#eviction-（收回策略）" class="headerlink" title="eviction （收回策略）"></a>eviction （收回策略）</h4><ul><li>LRU （最近最少使用的） 移除最长时间不被使用的对象，这是默认值</li><li>FIFO （先进先出〉 按对象进入缓存的顺序来移除它们</li><li>SOFT （软引用） 移除基于垃圾回收器状态和软引用规则的对象</li><li>WEAK （弱引用） 更积极地移除基于垃圾收集器状态和弱引用规则的对象</li></ul><h4 id="flushinterval-（刷新间隔〉。"><a href="#flushinterval-（刷新间隔〉。" class="headerlink" title="flushinterval （刷新间隔〉。"></a>flushinterval （刷新间隔〉。</h4><p>可以被设置为任意 正整数 而且它 代表 个合理的<br>毫秒形式的时间段 默认情况不设置，即没有刷新间隔 缓存仅仅在调用语句时刷新。</p><h4 id="size-（引用数目）"><a href="#size-（引用数目）" class="headerlink" title="size （引用数目）"></a>size （引用数目）</h4><p>可以被设置为任意正整数，要记住缓存的对象数目和运行环境的可<br>用内存资源数目。默认值是 1024</p><h4 id="readOnly-（只读）"><a href="#readOnly-（只读）" class="headerlink" title="readOnly （只读）"></a>readOnly （只读）</h4><p>属性可以被设置为 true false 。只读的缓存会给所有调用者<br>返回缓存对象的相同实例，因此这些对象不能被修改 这提供了很重要的性能优势<br>读写的缓存会通过序列化返回缓存对象的拷贝 这种方式会慢 些，但是安全 因此默认 false</p><p>注意：开启缓存的弊端是数据没有实时性，当数据库中的数据一旦修改，查询的数据还是缓存中的数据没有实时性，对于某些需要实时性显示数据的接口我们可以设置useCache=”false”,设置该属性后，该接口每次查询出来都是去执行sql查询出实时性数据。</p><p>针对每次查询都需要最新的数据sql，要设置成useCache=false，禁用二级缓存。</p><ul><li>（1）当为select语句时：<br>flushCache默认为false，表示任何时候语句被调用，都不会去清空本地缓存和二级缓存。<br>useCache默认为true，表示会将本条语句的结果进行二级缓存。</li><li>（2）当为insert、update、delete语句时：<br>flushCache默认为true，表示任何时候语句被调用，都会导致本地缓存和二级缓存被清空。<br>useCache属性在该情况下没有。</li></ul><p>　2、测试二级缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package me.gacl.test;</span><br><span class="line"></span><br><span class="line">import me.gacl.domain.User;</span><br><span class="line">import me.gacl.util.MyBatisUtil;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author gacl</span><br><span class="line"> * 测试二级缓存</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TestTwoLevelCache &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 测试二级缓存</span><br><span class="line">     * 使用两个不同的SqlSession对象去执行相同查询条件的查询，第二次查询时不会再发送SQL语句，而是直接从缓存中取出数据</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testCache2() &#123;</span><br><span class="line">        String statement &#x3D; &quot;me.gacl.mapping.userMapper.getUser&quot;;</span><br><span class="line">        SqlSessionFactory factory &#x3D; MyBatisUtil.getSqlSessionFactory();</span><br><span class="line">        &#x2F;&#x2F;开启两个不同的SqlSession</span><br><span class="line">        SqlSession session1 &#x3D; factory.openSession();</span><br><span class="line">        SqlSession session2 &#x3D; factory.openSession();</span><br><span class="line">        &#x2F;&#x2F;使用二级缓存时，User类必须实现一个Serializable接口&#x3D;&#x3D;&#x3D;&gt; User implements Serializable</span><br><span class="line">        User user &#x3D; session1.selectOne(statement, 1);</span><br><span class="line">        session1.commit();&#x2F;&#x2F;不懂为啥，这个地方一定要提交事务之后二级缓存才会起作用</span><br><span class="line">        System.out.println(&quot;user&#x3D;&quot;+user);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;由于使用的是两个不同的SqlSession对象，所以即使查询条件相同，一级缓存也不会开启使用</span><br><span class="line">        user &#x3D; session2.selectOne(statement, 1);</span><br><span class="line">        &#x2F;&#x2F;session2.commit();</span><br><span class="line">        System.out.println(&quot;user2&#x3D;&quot;+user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h2><p>集成 EhCache 缓存</p><p>1、添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupid&gt;org .mybatis . caches&lt;&#x2F;groupid&gt; </span><br><span class="line">&lt;artifactid&gt;mybat 工 s - ehcache&lt;&#x2F;artifactid&gt; </span><br><span class="line">&lt;version&gt;l . 0 . 3&lt;&#x2F;version&gt; </span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、添加ehcache.xml 文件<br>src/main/resources 目录下新增 ehcache.xml 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version 1. encoding UTF ？〉</span><br><span class="line">&lt;ehcache xmlns : xsi&#x3D;” http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance ” </span><br><span class="line">xsi : noNamespaceSchemaLocation&#x3D;” ehcache . xsd” </span><br><span class="line">updateCheck&#x3D;” false ” monitoring&#x3D;” autodetect” </span><br><span class="line">dynam cConf g＝ true</span><br><span class="line">&lt;diskStore path&#x3D;” D:&#x2F;cache ” &#x2F;&gt;</span><br><span class="line">&lt;defaultCache </span><br><span class="line">maxElementsinMemory&#x3D;” 3000</span><br><span class="line">eternal&#x3D;” false ” </span><br><span class="line">copyOnRead&#x3D;” true ” </span><br><span class="line">copyOnWrite&#x3D;” true ” </span><br><span class="line">timeToidleSeconds&#x3D;” 3600</span><br><span class="line">timeToLiveSeconds&#x3D;” 3600</span><br><span class="line">overf lowToDisk&#x3D;” true ” </span><br><span class="line">diskPersistent&#x3D;” true ” &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;ehcache&gt;</span><br></pre></td></tr></table></figure><ul><li>copyOnRead 的含义是，判断从缓存中读取数据时是返回对象的引用还是复制 个对象返<br>回。默认情况下是 false ，即返回数据的引用，这种情况下返回的都是相同的对象，和 MyBatis<br>默认缓存中的只读对象是相同的。如果设置为 true ，那就是可读写缓存，每次读取缓存时都<br>会复制 个新的实例</li><li>copyOnWrite 的含义是 ，判断写入缓存时是直接缓存对象的引用还是复制 个对象然后<br>缓存，默认也是 false 如果想使用可读写缓存，就需要将这两个属性配置为 true ，如果使<br>用只读缓存，可以不配置这两个属性，使用默认值 false 即可<br>3、在UserMapper.xml文件添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace tk.mybat s.simple mapper RoleMapper</span><br><span class="line">&lt;cache type org.mybatis caches ehcache.EhcacheCache ／〉</span><br><span class="line">&lt;&#x2F;mapper &gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis的缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList实现原理</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/3%E3%80%81LinkedList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/3%E3%80%81LinkedList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="1、LinkedList特点："><a href="#1、LinkedList特点：" class="headerlink" title="1、LinkedList特点："></a>1、LinkedList特点：</h3><ul><li><p>数据存储是基于双向链表实现的。（fast-fail机制与arrayList一致，因为都是AbstractList子类）</p></li><li><p>插入数据很快。先是在双向链表中找到要插入节点的位置index，找到之后，再插入一个新节点。</p></li><li><p>双向链表查找index位置的节点时，有一个加速动作：若index &lt; 双向链表长度的1/2，则从前向后查找; 否则，从后向前查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        return node(index).item;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">        &#x2F;&#x2F; assert isElementIndex(index);</span><br><span class="line"></span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">            x &#x3D; x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">        for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">            x &#x3D; x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除数据很快。先是在双向链表中找到要插入节点的位置index，找到之后，进行如下操作：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.previous.next &#x3D; node.next;node.next.previous &#x3D; node.previous;node &#x3D; null</span><br></pre></td></tr></table></figure></li></ul><p>具体源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">        &#x2F;&#x2F; assert x !&#x3D; null;</span><br><span class="line">    final E element &#x3D; x.item;</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; x.prev;</span><br><span class="line">    </span><br><span class="line">    if (prev &#x3D;&#x3D; null) &#123;</span><br><span class="line">        first &#x3D; next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev.next &#x3D; next;</span><br><span class="line">        x.prev &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">        last &#x3D; prev;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next.prev &#x3D; prev;</span><br><span class="line">        x.next &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    x.item &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 。查找节点过程和插入一样。</p><ul><li><p>获取数据很慢，需要从Head节点进行查找。</p></li><li><p>遍历数据很慢，每次获取数据都需要从头开始。</p></li></ul><p>2、实现原理（JDK.8）源码分析</p><h4 id="成员变量和构造方法"><a href="#成员变量和构造方法" class="headerlink" title="成员变量和构造方法"></a>成员变量和构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;当前存储的元素个数</span><br><span class="line">transient int size &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;首节点</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;末节点</span><br><span class="line">transient Node&lt;E&gt; last;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;空构造器</span><br><span class="line">public LinkedList() &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;传入集合参数的构造器</span><br><span class="line">&#x2F;&#x2F;该集合里面的所有元素插入到LinkedList中，</span><br><span class="line">注意这里是“插入”而不是说“初始化添加”，</span><br><span class="line">因为LinkedList并非线程安全，可能在this（）调用之后，已经有其他的线程向里面插入数据了。</span><br><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    this();&#x2F;&#x2F;调用当前类的构造函数</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="addAll添加元素"><a href="#addAll添加元素" class="headerlink" title="addAll添加元素"></a>addAll添加元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *在链表的尾端追加指定集合的所有元素，按指定的迭代器的集合顺序返回，在这个操作执行总是如果指定的集合被修改了</span><br><span class="line"> *，那么该行为操作将提示未定义</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    return addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">&#x2F;&#x2F; 检查index是否越界，index&#x3D;size+1</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    &#x2F;&#x2F;将集合参数转化为数组</span><br><span class="line">    Object[] a &#x3D; c.toArray();</span><br><span class="line">    int numNew &#x3D; a.length;&#x2F;&#x2F;要插入的集合长度</span><br><span class="line">    if (numNew &#x3D;&#x3D; 0)</span><br><span class="line">        return false;</span><br><span class="line">    &#x2F;&#x2F;定义pred和succ两个Node对象，用于标识要插入元素的前置节点和后置节点</span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 这里为什么要写if..else？</span><br><span class="line">     * 因为该方法不一定是从上层方法addAll(size, c)过来的，还有可能是直接调用了addAll(int index, Collection&lt;? extends E&gt; c)</span><br><span class="line">     * 方法，从上层addAll(size, c)跳转过来的，size&#x3D;index也就从尾部插入，但是直接调用的该方法，则从传进来的参数index这个位置（肯能是任何位置）插入</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (index &#x3D;&#x3D; size) &#123;&#x2F;&#x2F;表明是从尾部插入</span><br><span class="line">        succ &#x3D; null;&#x2F;&#x2F;从尾部插入，后置节点为null</span><br><span class="line">        pred &#x3D; last;&#x2F;&#x2F;从尾部插入，前置节点为当前LinkedList中的最后一个节点</span><br><span class="line">    &#125; else &#123;&#x2F;&#x2F;表明不是从尾部插入</span><br><span class="line">        succ &#x3D; node(index);&#x2F;&#x2F;查到当前LinkedList中位置为index的节点并把它赋给要插入元素的后置节点</span><br><span class="line">        pred &#x3D; succ.prev;&#x2F;&#x2F;把上一步得到的节点的前置节点赋值给要插入元素的后置节点</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    for (Object o : a) &#123;&#x2F;&#x2F;变量集合参数</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;) E e &#x3D; (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, null);</span><br><span class="line">        if (pred &#x3D;&#x3D; null)&#x2F;&#x2F;说明插入之前当前链表是空链表</span><br><span class="line">            first &#x3D; newNode;&#x2F;&#x2F;新节点是第一个节点</span><br><span class="line">        else</span><br><span class="line">            pred.next &#x3D; newNode;&#x2F;&#x2F;设置插入元素的的前置节点的后置节点为新节点</span><br><span class="line">        pred &#x3D; newNode;&#x2F;&#x2F;更改指向后将新节点对象赋给pred作为下次循环中新插入节点的前一个对象节点，依次循环</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;&#x2F;此时pred代表集合元素的插入完后的最后一个节点对象</span><br><span class="line">    if (succ &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;结尾添加的话在添加完集合元素后将最后一个集合的节点对象pred作为last</span><br><span class="line">        last &#x3D; pred;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        pred.next &#x3D; succ;&#x2F;&#x2F;将集合元素的最后一个节点对象的next指针指向原index位置上的Node对象</span><br><span class="line">        succ.prev &#x3D; pred;&#x2F;&#x2F;将原index位置上的pred指针对象指向集合的最后一个对象</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    size +&#x3D; numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Returns the (non-null) Node at the specified element index.</span><br><span class="line"> * 返回index位置的非空节点</span><br><span class="line"> * 折半查询 </span><br><span class="line"> *&#x2F;</span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 如果index小于当前元素个数的一半，则从前向后遍历查询 ，否则从后向前遍历查询</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">            x &#x3D; x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">        for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">            x &#x3D; x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="add方法："><a href="#add方法：" class="headerlink" title="add方法："></a>add方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 获取当前链表的最后一个节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建一个以当前最后一个节点为之前节点的节点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last &#x3D; newNode;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 空表，首次插入</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next &#x3D; newNode;&#x2F;&#x2F;不是首次插入，则最后一个节点的后置节点地址赋值给新节点</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法:"></a>remove方法:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *从第一个节点循环指针查找</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    &#x2F;&#x2F;如果移除的数据为Null</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;遍历找到第一个为null的节点，然后移除掉</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F;遍历找到第一条不为null与参数相等的数据，然后移除掉</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert x !&#x3D; null;</span><br><span class="line">&#x2F;&#x2F;移除的数据</span><br><span class="line">    final E element &#x3D; x.item;</span><br><span class="line">    &#x2F;&#x2F;移除节点的后置节点</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">  &#x2F;&#x2F;移除节点的前置节点</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; x.prev;</span><br><span class="line">    </span><br><span class="line">    if (prev &#x3D;&#x3D; null) &#123;</span><br><span class="line">        first &#x3D; next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev.next &#x3D; next;</span><br><span class="line">        x.prev &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">        last &#x3D; prev;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next.prev &#x3D; prev;</span><br><span class="line">        x.next &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    x.item &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="清除clear"><a href="#清除clear" class="headerlink" title="清除clear"></a>清除clear</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">    &#x2F;&#x2F;遍历所以的数据，置为null,方便垃圾回收</span><br><span class="line">    for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; ) &#123;</span><br><span class="line">        Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">        x.item &#x3D; null;</span><br><span class="line">        x.next &#x3D; null;</span><br><span class="line">        x.prev &#x3D; null;</span><br><span class="line">        x &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line">    first &#x3D; last &#x3D; null;</span><br><span class="line">    size &#x3D; 0;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="细节：add和offer的区别："><a href="#细节：add和offer的区别：" class="headerlink" title="细节：add和offer的区别："></a>细节：add和offer的区别：</h4><p>linkendList的offer都是调用的add方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">        return add(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>add是list的</p><p>offer是queue的</p><p>add：<br>将指定的元素插入到list中指定的的位置。</p><p>offer：<br>如果在不违反容量限制的情况下，尽可能快的将指定的元素插入到queue中去</p>]]></content>
      
      
      <categories>
          
          <category> java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList实现原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双向链表</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2%E3%80%81%E9%93%BE%E8%A1%A8/4%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2%E3%80%81%E9%93%BE%E8%A1%A8/4%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>双链表具有以下优点：</p><p>如果要找上一个节点的数据，</p><p>1、删除单链表中的某个结点时，一定要得到待删除结点的前驱，得到该前驱有两种方法，第一种方法是在定位待删除结点的同时一路保存当前结点的前驱。第二种方法是在定位到待删除结点之后，重新从单链表表头开始来定位前驱。尽管通常会采用方法一。但其实这两种方法的效率是一样的，指针的总的移动操作都会有2*i次。而如果用双向链表，则不需要定位前驱结点。因此指针总的移动操作为i次。</p><p>2、可以借用二分法的思路，从head（首节点）向后查找操作和last（尾节点）向前查找操作同步进行，这样双链表的效率可以提高一倍。</p><h4 id="可是为什么市场上单链表的使用多余双链表呢？"><a href="#可是为什么市场上单链表的使用多余双链表呢？" class="headerlink" title="可是为什么市场上单链表的使用多余双链表呢？"></a>可是为什么市场上单链表的使用多余双链表呢？</h4><ul><li>从存储结构来看，每个双链表的节点要比单链表的节点多一个指针，而长度为n就需要 n*length（这个指针的length在32位系统中是4字节，在64位系统中是8个字节） 的空间，这在一些追求时间效率不高应用下并不适应，因为它占用空间大于单链表所占用的空间；这时设计者就会采用以时间换空间的做法，这时一种工程总体上的衡量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 双向链表</span><br><span class="line"> * </span><br><span class="line"> * @author Dylan</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class DuLinkList&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 定义一个内部类Node，Node实例代表链表的节点</span><br><span class="line">    private class Node &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 保存节点的数据</span><br><span class="line">        private T data;</span><br><span class="line">        &#x2F;&#x2F; 保存上个节点的引用</span><br><span class="line">        private Node prev;</span><br><span class="line">        &#x2F;&#x2F; 指向下一个节点的引用</span><br><span class="line">        private Node next;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 无参构造器</span><br><span class="line">        public Node() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 初始化全部属性的构造器</span><br><span class="line">        public Node(T data, Node prev, Node next) &#123;</span><br><span class="line"></span><br><span class="line">            this.data &#x3D; data;</span><br><span class="line">            this.prev &#x3D; prev;</span><br><span class="line">            this.next &#x3D; next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 保存该链表的头节点</span><br><span class="line">    private Node header;</span><br><span class="line">    &#x2F;&#x2F; 保存该链表的尾节点</span><br><span class="line">    private Node tail;</span><br><span class="line">    &#x2F;&#x2F; 保存该链表中已包含的节点数</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建空链表</span><br><span class="line">    public DuLinkList() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 空链表，header和tail都是null</span><br><span class="line">        header &#x3D; null;</span><br><span class="line">        tail &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 以指定数据元素来创建链表，该链表只有一个元素</span><br><span class="line">    public DuLinkList(T element) &#123;</span><br><span class="line"></span><br><span class="line">        header &#x3D; new Node(element, null, null);</span><br><span class="line">        &#x2F;&#x2F; 只有一个节点，header、tail都指向该节点</span><br><span class="line">        tail &#x3D; header;</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 返回链表的长度</span><br><span class="line">    public int length() &#123;</span><br><span class="line"></span><br><span class="line">        return size;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取链式线性表中索引为index处的元素</span><br><span class="line">    public T get(int index) &#123;</span><br><span class="line"></span><br><span class="line">        return getNodeByIndex(index).data;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据索引index获取指定位置的节点</span><br><span class="line">    public Node getNodeByIndex(int index) &#123;</span><br><span class="line"></span><br><span class="line">        if (index &lt; 0 || index &gt; size - 1) &#123;</span><br><span class="line"></span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;线性表索引越界&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if (index &lt;&#x3D; size &#x2F; 2) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 从header节点开始</span><br><span class="line">            Node current &#x3D; header;</span><br><span class="line">            for (int i &#x3D; 0; i &lt;&#x3D; size &#x2F; 2 &amp;&amp; current !&#x3D; null; i++, current &#x3D; current.next) &#123;</span><br><span class="line">                if (i &#x3D;&#x3D; index) &#123;</span><br><span class="line"></span><br><span class="line">                    return current;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 从tail节点开始搜索</span><br><span class="line">            Node current &#x3D; tail;</span><br><span class="line">            for (int i &#x3D; size - 1; i &gt; size &#x2F; 2 &amp;&amp; current !&#x3D; null; i++, current &#x3D; current.prev) &#123;</span><br><span class="line">                if (i &#x3D;&#x3D; index) &#123;</span><br><span class="line"></span><br><span class="line">                    return current;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 查找链式线性表中指定元素的索引</span><br><span class="line">    public int locate(T element) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 从头结点开始搜索</span><br><span class="line">        Node current &#x3D; header;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; size &amp;&amp; current !&#x3D; null; i++, current &#x3D; current.next) &#123;</span><br><span class="line"></span><br><span class="line">            if (current.data.equals(element)) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 向线性链表的指定位置插入一个元素</span><br><span class="line">    public void insert(T element, int index) &#123;</span><br><span class="line"></span><br><span class="line">        if (index &lt; 0 || index &gt; size) &#123;</span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;线性表索引越界&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果还是空链表</span><br><span class="line">        if (header &#x3D;&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">            add(element);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 当index为0时，也就是在链表头处插入</span><br><span class="line">            if (index &#x3D;&#x3D; 0) &#123;</span><br><span class="line"></span><br><span class="line">                addAtHeader(element);</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 获取插入点的前一个节点</span><br><span class="line">                Node prev &#x3D; getNodeByIndex(index - 1);</span><br><span class="line">                &#x2F;&#x2F; 获取插入点的节点</span><br><span class="line">                Node next &#x3D; prev.next;</span><br><span class="line">                &#x2F;&#x2F; 让新节点的next引用指向next节点，prev引用指向prev节点</span><br><span class="line">                Node newNode &#x3D; new Node(element, prev, next);</span><br><span class="line">                &#x2F;&#x2F; 让prev的next节点指向新节点</span><br><span class="line">                prev.next &#x3D; newNode;</span><br><span class="line">                &#x2F;&#x2F; 让prev的下一个节点的prev指向新节点</span><br><span class="line">                next.prev &#x3D; newNode;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 采用尾插法为链表添加新节点</span><br><span class="line">    public void add(T element) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果该链表还是空链表</span><br><span class="line">        if (header &#x3D;&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">            header &#x3D; new Node(element, null, null);</span><br><span class="line">            &#x2F;&#x2F; 只有一个节点，header、tail都指向该节点</span><br><span class="line">            tail &#x3D; header;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 创建新节点，新节点的pre指向原tail节点</span><br><span class="line">            Node newNode &#x3D; new Node(element, tail, null);</span><br><span class="line">            &#x2F;&#x2F; 让尾节点的next指向新增的节点</span><br><span class="line">            tail.next &#x3D; newNode;</span><br><span class="line">            &#x2F;&#x2F; 以新节点作为新的尾节点</span><br><span class="line">            tail &#x3D; newNode;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 采用头插法为链表添加新节点</span><br><span class="line">    public void addAtHeader(T element) &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建新节点，让新节点的next指向原来的header</span><br><span class="line">        &#x2F;&#x2F; 并以新节点作为新的header</span><br><span class="line">        header &#x3D; new Node(element, null, header);</span><br><span class="line">        &#x2F;&#x2F; 如果插入之前是空链表</span><br><span class="line">        if (tail &#x3D;&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">            tail &#x3D; header;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 删除链式线性表中指定索引处的元素</span><br><span class="line">    public T delete(int index) &#123;</span><br><span class="line"></span><br><span class="line">        if (index &lt; 0 || index &gt; size - 1) &#123;</span><br><span class="line"></span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;线性表索引越界&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Node del &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 如果被删除的是header节点</span><br><span class="line">        if (index &#x3D;&#x3D; 0) &#123;</span><br><span class="line"></span><br><span class="line">            del &#x3D; header;</span><br><span class="line">            header &#x3D; header.next;</span><br><span class="line">            &#x2F;&#x2F; 释放新的header节点的prev引用</span><br><span class="line">            header.prev &#x3D; null;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 获取删除节点的前一个节点</span><br><span class="line">            Node prev &#x3D; getNodeByIndex(index - 1);</span><br><span class="line">            &#x2F;&#x2F; 获取将要被删除的节点</span><br><span class="line">            del &#x3D; prev.next;</span><br><span class="line">            &#x2F;&#x2F; 让被删除节点的next指向被删除节点的下一个节点</span><br><span class="line">            prev.next &#x3D; del.next;</span><br><span class="line">            &#x2F;&#x2F; 让被删除节点的下一个节点的prev指向prev节点</span><br><span class="line">            if (del.next !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">                del.next.prev &#x3D; prev;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 将被删除节点的prev、next引用赋为null</span><br><span class="line">            del.prev &#x3D; null;</span><br><span class="line">            del.next &#x3D; null;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        return del.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 删除链式线性表中最后一个元素</span><br><span class="line">    public T remove() &#123;</span><br><span class="line"></span><br><span class="line">        return delete(size - 1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 判断链式线性表是否为空表</span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line"></span><br><span class="line">        return size &#x3D;&#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 清空线性表</span><br><span class="line">    public void clear() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 将底层数组所有元素赋为null</span><br><span class="line">        header &#x3D; null;</span><br><span class="line">        tail &#x3D; null;</span><br><span class="line">        size &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 链表为空链表</span><br><span class="line">        if (empty()) &#123;</span><br><span class="line"></span><br><span class="line">            return &quot;[]&quot;;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            StringBuilder sb &#x3D; new StringBuilder(&quot;[&quot;);</span><br><span class="line">            for (Node current &#x3D; header; current !&#x3D; null; current &#x3D; current.next) &#123;</span><br><span class="line"></span><br><span class="line">                sb.append(current.data.toString() + &quot;, &quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            int len &#x3D; sb.length();</span><br><span class="line">            return sb.delete(len - 2, len).append(&quot;]&quot;).toString();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 倒序toString</span><br><span class="line">    public String reverseToString() &#123;</span><br><span class="line"></span><br><span class="line">        if (empty()) &#123;</span><br><span class="line"></span><br><span class="line">            return &quot;[]&quot;;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            StringBuilder sb &#x3D; new StringBuilder(&quot;[&quot;);</span><br><span class="line">            for (Node current &#x3D; tail; current !&#x3D; null; current &#x3D; current.prev) &#123;</span><br><span class="line"></span><br><span class="line">                sb.append(current.data.toString() + &quot;, &quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            int len &#x3D; sb.length();</span><br><span class="line">            return sb.delete(len - 2, len).append(&quot;]&quot;).toString();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双向链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈对表达式求值的应用</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E3%80%81%E6%A0%88/2%E3%80%81%E6%A0%88%E5%AF%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E3%80%81%E6%A0%88/2%E3%80%81%E6%A0%88%E5%AF%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="中缀表达式求值："><a href="#中缀表达式求值：" class="headerlink" title="中缀表达式求值："></a>中缀表达式求值：</h3><ul><li>开始遍历表达式</li><li>—-是否为数字</li><li>———是：压入数字栈</li><li>———否：判断符号栈是否为空</li><li>—————-是：压入符号栈</li><li>—————-否：判断当前操作符与栈中的操作符优先级</li><li>————————大于：压入符号栈</li><li>————————小于等于：从数字栈pop出两个数字，从符号栈中pop出一个符号，做运算。并将结果压入数字栈</li><li>遍历表达式结束:顺序从数字栈和符号栈中pop出数字和符号进行运算，最后栈中只剩一个数字（最终结果）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">public class Calculator &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String expression &#x3D; &quot;7*2*2-5+1-5+3-4&quot;; &#x2F;&#x2F; 15&#x2F;&#x2F;如何处理多位数的问题？</span><br><span class="line">        &#x2F;&#x2F;创建两个栈，数栈，一个符号栈</span><br><span class="line">        ArrayStack2 numStack &#x3D; new ArrayStack2(10);</span><br><span class="line">        ArrayStack2 operStack &#x3D; new ArrayStack2(10);</span><br><span class="line">        &#x2F;&#x2F;定义需要的相关变量</span><br><span class="line">        int index &#x3D; 0;&#x2F;&#x2F;用于扫描</span><br><span class="line">        int num1 &#x3D; 0;</span><br><span class="line">        int num2 &#x3D; 0;</span><br><span class="line">        int oper &#x3D; 0;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        char ch &#x3D; &#39; &#39;; &#x2F;&#x2F;将每次扫描得到char保存到ch</span><br><span class="line">        String keepNum &#x3D; &quot;&quot;; &#x2F;&#x2F;用于拼接 多位数</span><br><span class="line">        &#x2F;&#x2F;开始while循环的扫描expression</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            &#x2F;&#x2F;依次得到expression 的每一个字符</span><br><span class="line">            ch &#x3D; expression.substring(index, index + 1).charAt(0);</span><br><span class="line">            &#x2F;&#x2F;判断ch是什么，然后做相应的处理</span><br><span class="line">            if (operStack.isOper(ch)) &#123;&#x2F;&#x2F;如果是运算符</span><br><span class="line">                &#x2F;&#x2F;判断当前的符号栈是否为空</span><br><span class="line">                if (!operStack.isEmpty()) &#123;</span><br><span class="line">                    &#x2F;&#x2F;如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符,就需要从数栈中pop出两个数,</span><br><span class="line">                    &#x2F;&#x2F;在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈</span><br><span class="line">                    if (operStack.priority(ch) &lt;&#x3D; operStack.priority(operStack.peek())) &#123;</span><br><span class="line">                        num1 &#x3D; numStack.pop();</span><br><span class="line">                        num2 &#x3D; numStack.pop();</span><br><span class="line">                        oper &#x3D; operStack.pop();</span><br><span class="line">                        res &#x3D; numStack.cal(num1, num2, oper);</span><br><span class="line">                        &#x2F;&#x2F;把运算的结果如数栈</span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        &#x2F;&#x2F;然后将当前的操作符入符号栈</span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        &#x2F;&#x2F;如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.</span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F;如果为空直接入符号栈..</span><br><span class="line">                    operStack.push(ch); &#x2F;&#x2F; 1 + 3</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F;如果是数，则直接入数栈</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;numStack.push(ch - 48); &#x2F;&#x2F;? &quot;1+3&quot; &#39;1&#39; &#x3D;&gt; 1</span><br><span class="line">                &#x2F;&#x2F;分析思路</span><br><span class="line">                &#x2F;&#x2F;1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数</span><br><span class="line">                &#x2F;&#x2F;2. 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈</span><br><span class="line">                &#x2F;&#x2F;3. 因此我们需要定义一个变量 字符串，用于拼接</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;处理多位数</span><br><span class="line">                keepNum +&#x3D; ch;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;如果ch已经是expression的最后一位，就直接入栈</span><br><span class="line">                if (index &#x3D;&#x3D; expression.length() - 1) &#123;</span><br><span class="line">                    numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈</span><br><span class="line">                    &#x2F;&#x2F;注意是看后一位，不是index++</span><br><span class="line">                    if (operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) &#123;</span><br><span class="line">                        &#x2F;&#x2F;如果后一位是运算符，则入栈 keepNum &#x3D; &quot;1&quot; 或者 &quot;123&quot;</span><br><span class="line">                        numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                        &#x2F;&#x2F;重要的!!!!!!, keepNum清空</span><br><span class="line">                        keepNum &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;让index + 1, 并判断是否扫描到expression最后.</span><br><span class="line">            index++;</span><br><span class="line">            if (index &gt;&#x3D; expression.length()) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果符号栈为空，则计算到最后的结果, 数栈中只有一个数字【结果】</span><br><span class="line">            if (operStack.isEmpty()) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            num1 &#x3D; numStack.pop();</span><br><span class="line">            num2 &#x3D; numStack.pop();</span><br><span class="line">            oper &#x3D; operStack.pop();</span><br><span class="line">            res &#x3D; numStack.cal(num1, num2, oper);</span><br><span class="line">            numStack.push(res);&#x2F;&#x2F;入栈</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将数栈的最后数，pop出，就是结果</span><br><span class="line">        int res2 &#x3D; numStack.pop();</span><br><span class="line">        System.out.printf(&quot;表达式 %s &#x3D; %d&quot;, expression, res2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;先创建一个栈,直接使用前面创建好</span><br><span class="line">&#x2F;&#x2F;定义一个 ArrayStack2 表示栈, 需要扩展功能</span><br><span class="line">class ArrayStack2 &#123;</span><br><span class="line">    private int maxSize; &#x2F;&#x2F; 栈的大小</span><br><span class="line">    private int[] stack; &#x2F;&#x2F; 数组，数组模拟栈，数据就放在该数组</span><br><span class="line">    private int top &#x3D; -1;&#x2F;&#x2F; top表示栈顶，初始化为-1</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造器</span><br><span class="line">    public ArrayStack2(int maxSize) &#123;</span><br><span class="line">        this.maxSize &#x3D; maxSize;</span><br><span class="line">        stack &#x3D; new int[this.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;增加一个方法，可以返回当前栈顶的值, 但是不是真正的pop</span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        return stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;栈满</span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        return top &#x3D;&#x3D; maxSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;栈空</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return top &#x3D;&#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;入栈-push</span><br><span class="line">    public void push(int value) &#123;</span><br><span class="line">        &#x2F;&#x2F;先判断栈是否满</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;栈满&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;出栈-pop, 将栈顶的数据返回</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        &#x2F;&#x2F;先判断栈是否空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            &#x2F;&#x2F;抛出异常</span><br><span class="line">            throw new RuntimeException(&quot;栈空，没有数据~&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int value &#x3D; stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;栈空，没有数据~~&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;需要从栈顶开始显示数据</span><br><span class="line">        for (int i &#x3D; top; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            System.out.printf(&quot;stack[%d]&#x3D;%d\n&quot;, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回运算符的优先级，优先级是程序员来确定, 优先级使用数字表示</span><br><span class="line">    &#x2F;&#x2F;数字越大，则优先级就越高.</span><br><span class="line">    public int priority(int oper) &#123;</span><br><span class="line">        if (oper &#x3D;&#x3D; &#39;*&#39; || oper &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else if (oper &#x3D;&#x3D; &#39;+&#39; || oper &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return -1; &#x2F;&#x2F; 假定目前的表达式只有 +, - , * , &#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断是不是一个运算符</span><br><span class="line">    public boolean isOper(char val) &#123;</span><br><span class="line">        return val &#x3D;&#x3D; &#39;+&#39; || val &#x3D;&#x3D; &#39;-&#39; || val &#x3D;&#x3D; &#39;*&#39; || val &#x3D;&#x3D; &#39;&#x2F;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;计算方法</span><br><span class="line">    public int cal(int num1, int num2, int oper) &#123;</span><br><span class="line">        int res &#x3D; 0; &#x2F;&#x2F; res 用于存放计算的结果</span><br><span class="line">        switch (oper) &#123;</span><br><span class="line">            case &#39;+&#39;:</span><br><span class="line">                res &#x3D; num1 + num2;</span><br><span class="line">                break;</span><br><span class="line">            case &#39;-&#39;:</span><br><span class="line">                res &#x3D; num2 - num1;&#x2F;&#x2F; 注意顺序</span><br><span class="line">                break;</span><br><span class="line">            case &#39;*&#39;:</span><br><span class="line">                res &#x3D; num1 * num2;</span><br><span class="line">                break;</span><br><span class="line">            case &#39;&#x2F;&#39;:</span><br><span class="line">                res &#x3D; num2 &#x2F; num1;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈对表达式求值的应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多环境打包部署</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-boot/%E5%A4%9A%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-boot/%E5%A4%9A%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="1、在src-main-resources下的添加多环境的配置文件"><a href="#1、在src-main-resources下的添加多环境的配置文件" class="headerlink" title="1、在src/main/resources下的添加多环境的配置文件"></a>1、在src/main/resources下的添加多环境的配置文件</h3><p>application.yml</p><p>application-dev.yml</p><p>application-test.yml</p><p>application-prod.yml</p><h3 id="2、application-yml："><a href="#2、application-yml：" class="headerlink" title="2、application.yml："></a>2、application.yml：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9002</span><br><span class="line">  tomcat:</span><br><span class="line">      uri-encoding: UTF-8</span><br><span class="line">#多数据源配置</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">#      active: test</span><br><span class="line">      active: @environment@</span><br><span class="line">  datasource:</span><br><span class="line">      master:</span><br><span class="line">        username: rmld</span><br><span class="line">        password: 3iKth9TCG6Nx</span><br><span class="line">        url: jdbc:mysql:&#x2F;&#x2F;47.104.142.127:3306&#x2F;rmld?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;zeroDateTimeBehavior&#x3D;convertToNull</span><br><span class="line">        driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">        type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">      slave:</span><br><span class="line">          username: 209Reader</span><br><span class="line">          password: iDiroVEOzG</span><br><span class="line">          url: jdbc:mysql:&#x2F;&#x2F;114.112.88.244:3309&#x2F;qianlima?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;zeroDateTimeBehavior&#x3D;convertToNull</span><br><span class="line">          driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">          type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">#mvc响应超时</span><br><span class="line">  mvc:</span><br><span class="line">    async:</span><br><span class="line">      request-timeout: 300000</span><br><span class="line">  jpa:</span><br><span class="line">    show-sql: true</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: none</span><br><span class="line">#格式化输出的json字符串</span><br><span class="line">  jackson:</span><br><span class="line">    serialization: true</span><br><span class="line"></span><br><span class="line">  http:</span><br><span class="line">    encoding:</span><br><span class="line">      charset: UTF-8</span><br><span class="line">      force: true</span><br><span class="line">      enabled: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    org.springframework.web: DEBUG</span><br><span class="line">    com.qianlima.rmld: DEBUG</span><br><span class="line">    com.qianlima.rmld.mapper: DEBUG</span><br><span class="line"></span><br><span class="line">#人脉雷达微信服务号--测试号--配置信息</span><br><span class="line">wechat:</span><br><span class="line">  mp:</span><br><span class="line">    appId: wx7c478dcfe2500253</span><br><span class="line">    secret: a22d176f4e6de9c0d689e95231a8c522</span><br><span class="line">    token: rmldwp12</span><br><span class="line">    aesKey: 7sT76DRJUTpiEVsZGPuJHX48iCNCsKUyDQQghwWcOh5</span><br><span class="line">mybatis:</span><br><span class="line">#添加mybatis的映射文件</span><br><span class="line">  mapper-locations: classpath:mybatis&#x2F;mapper&#x2F;*.xml</span><br><span class="line">  #添加mybatis的配置文件</span><br><span class="line">  config-location: classpath:mybatis&#x2F;mybatis-config.xml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、pom文件（未瘦身，将外部lib包也打包进项目包）"><a href="#3、pom文件（未瘦身，将外部lib包也打包进项目包）" class="headerlink" title="3、pom文件（未瘦身，将外部lib包也打包进项目包）"></a>3、pom文件（未瘦身，将外部lib包也打包进项目包）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;rmld&lt;&#x2F;finalName&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;src&#x2F;main&#x2F;lib&lt;&#x2F;directory&gt;</span><br><span class="line">                &lt;targetPath&gt;BOOT-INF&#x2F;lib&#x2F;&lt;&#x2F;targetPath&gt;</span><br><span class="line">                &lt;includes&gt;</span><br><span class="line">                    &lt;include&gt;**&#x2F;*.jar&lt;&#x2F;include&gt;</span><br><span class="line">                &lt;&#x2F;includes&gt;</span><br><span class="line">            &lt;&#x2F;resource&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;filtering&gt;true&lt;&#x2F;filtering&gt;</span><br><span class="line">                &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;</span><br><span class="line">                &lt;excludes&gt;</span><br><span class="line">                    &lt;exclude&gt;application-dev.yml&lt;&#x2F;exclude&gt;</span><br><span class="line">                    &lt;exclude&gt;application-test.yml&lt;&#x2F;exclude&gt;</span><br><span class="line">                    &lt;exclude&gt;application-prod.yml&lt;&#x2F;exclude&gt;</span><br><span class="line">                &lt;&#x2F;excludes&gt;</span><br><span class="line">            &lt;&#x2F;resource&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;filtering&gt;true&lt;&#x2F;filtering&gt;</span><br><span class="line">                &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;</span><br><span class="line">                &lt;includes&gt;</span><br><span class="line">                    &lt;include&gt;application-$&#123;environment&#125;.yml&lt;&#x2F;include&gt;</span><br><span class="line">                    &lt;include&gt;application.yml&lt;&#x2F;include&gt;</span><br><span class="line">                &lt;&#x2F;includes&gt;</span><br><span class="line">            &lt;&#x2F;resource&gt;</span><br><span class="line">        &lt;&#x2F;resources&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line"></span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;repackage&lt;&#x2F;goal&gt;&lt;!--可以把依赖的包都打包到生成的Jar包中 --&gt;</span><br><span class="line">                        &lt;&#x2F;goals&gt;</span><br><span class="line">                    &lt;&#x2F;execution&gt;</span><br><span class="line">                &lt;&#x2F;executions&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-jar-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;maven-jar-plugin.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;archive&gt;</span><br><span class="line">                        &lt;manifest&gt;</span><br><span class="line">                            &lt;addClasspath&gt;true&lt;&#x2F;addClasspath&gt;</span><br><span class="line">                            &lt;classpathPrefix&gt;lib&#x2F;&lt;&#x2F;classpathPrefix&gt;</span><br><span class="line">                            &lt;mainClass&gt;com.qianlima.rmld.RmldApplication&lt;&#x2F;mainClass&gt;</span><br><span class="line">                        &lt;&#x2F;manifest&gt;</span><br><span class="line">                    &lt;&#x2F;archive&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line"></span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--多环境配置*****************************************************--&gt;</span><br><span class="line">    &lt;profiles&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;dev&lt;&#x2F;id&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;environment&gt;dev&lt;&#x2F;environment&gt;</span><br><span class="line">            &lt;&#x2F;properties&gt;</span><br><span class="line">            &lt;activation&gt;</span><br><span class="line">                &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt;</span><br><span class="line">            &lt;&#x2F;activation&gt;</span><br><span class="line">        &lt;&#x2F;profile&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;test&lt;&#x2F;id&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;environment&gt;test&lt;&#x2F;environment&gt;</span><br><span class="line">            &lt;&#x2F;properties&gt;</span><br><span class="line">        &lt;&#x2F;profile&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;prod&lt;&#x2F;id&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;environment&gt;prod&lt;&#x2F;environment&gt;</span><br><span class="line">            &lt;&#x2F;properties&gt;</span><br><span class="line">        &lt;&#x2F;profile&gt;</span><br><span class="line">    &lt;&#x2F;profiles&gt;</span><br></pre></td></tr></table></figure><p>打包命令：<br>clean install -Ptest -f pom.xml</p><h3 id="3、pom文件（项目包瘦身，外部lib包分开）"><a href="#3、pom文件（项目包瘦身，外部lib包分开）" class="headerlink" title="3、pom文件（项目包瘦身，外部lib包分开）"></a>3、pom文件（项目包瘦身，外部lib包分开）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;rmld&lt;&#x2F;finalName&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;</span><br><span class="line">                &lt;includes&gt;</span><br><span class="line">                    &lt;include&gt;**&#x2F;**&lt;&#x2F;include&gt;</span><br><span class="line">                &lt;&#x2F;includes&gt;</span><br><span class="line">                &lt;filtering&gt;true&lt;&#x2F;filtering&gt;</span><br><span class="line">            &lt;&#x2F;resource&gt;</span><br><span class="line">        &lt;&#x2F;resources&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-jar-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;maven-jar-plugin.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;archive&gt;</span><br><span class="line">                        &lt;manifest&gt;</span><br><span class="line">                            &lt;mainClass&gt;com.qianlima.rmld.RmldApplication&lt;&#x2F;mainClass&gt; &lt;!--指定Springboot程序启动类--&gt;</span><br><span class="line">                            &lt;addClasspath&gt;true&lt;&#x2F;addClasspath&gt;</span><br><span class="line">                            &lt;classpathPrefix&gt;lib&#x2F;&lt;&#x2F;classpathPrefix&gt; &lt;!--指定依赖的jar包相对于本程序jar的位置--&gt;</span><br><span class="line">                        &lt;&#x2F;manifest&gt;</span><br><span class="line">                        &lt;manifestEntries&gt;</span><br><span class="line">                            &lt;Class-Path&gt;.&#x2F;&lt;&#x2F;Class-Path&gt;</span><br><span class="line">                        &lt;&#x2F;manifestEntries&gt;</span><br><span class="line">                    &lt;&#x2F;archive&gt;</span><br><span class="line">                    &lt;!--    &lt;excludes&gt;</span><br><span class="line">                            &lt;exclude&gt;application*.yml&lt;&#x2F;exclude&gt; &lt;!&amp;ndash;指定打包时要排除的文件,支持正则&amp;ndash;&gt;</span><br><span class="line">                        &lt;&#x2F;excludes&gt;--&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line"></span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--多环境配置*****************************************************--&gt;</span><br><span class="line">    &lt;profiles&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;dev&lt;&#x2F;id&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;environment&gt;dev&lt;&#x2F;environment&gt;</span><br><span class="line">            &lt;&#x2F;properties&gt;</span><br><span class="line">            &lt;activation&gt;</span><br><span class="line">                &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt;</span><br><span class="line">            &lt;&#x2F;activation&gt;</span><br><span class="line">        &lt;&#x2F;profile&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;test&lt;&#x2F;id&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;environment&gt;test&lt;&#x2F;environment&gt;</span><br><span class="line">            &lt;&#x2F;properties&gt;</span><br><span class="line">        &lt;&#x2F;profile&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;prod&lt;&#x2F;id&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;environment&gt;prod&lt;&#x2F;environment&gt;</span><br><span class="line">            &lt;&#x2F;properties&gt;</span><br><span class="line">        &lt;&#x2F;profile&gt;</span><br><span class="line">    &lt;&#x2F;profiles&gt;</span><br></pre></td></tr></table></figure><p>最后在启动脚本中指定项目加载外部lib的路径： java -Dloader.path=/runtime/rmld/lib -jar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup &#x2F;usr&#x2F;local&#x2F;jdk1.8.0_144&#x2F;bin&#x2F;java -Xmx256m -Xms256m -XX:MetaspaceSize&#x3D;64m -XX:MaxMetaspaceSize&#x3D;128m -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC -Dloader.path&#x3D;&#x2F;runtime&#x2F;rmld&#x2F;lib -jar &#x2F;runtime&#x2F;rmld&#x2F;rmld.jar --server.port&#x3D;9005 &gt;&gt; &#x2F;runtime&#x2F;rmld&#x2F;logs&#x2F;rmld.out &amp;</span><br></pre></td></tr></table></figure><p>clean install -Pprod -f pom.xml</p>]]></content>
      
      
      <categories>
          
          <category> spring-boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多环境打包部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整合JmsTemplate</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/1%E3%80%81ActiveMQ/3%E3%80%81%E6%95%B4%E5%90%88JmsTemplate/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/1%E3%80%81ActiveMQ/3%E3%80%81%E6%95%B4%E5%90%88JmsTemplate/</url>
      
        <content type="html"><![CDATA[<h2 id="1、生产者接口："><a href="#1、生产者接口：" class="headerlink" title="1、生产者接口："></a>1、生产者接口：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface ProducerService &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 向指定队列发送消息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void sendMessage(Destination destination, final String msg);</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 向默认队列发送消息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void sendMessage(final String msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2、生产者实现："><a href="#2、生产者实现：" class="headerlink" title="2、生产者实现："></a>2、生产者实现：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;producerService&quot;)</span><br><span class="line">public class ProducerServiceImpl implements ProducerService &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 向指定队列发送消息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void sendMessage(Destination destination, final String msg) &#123;</span><br><span class="line">        System.out.println(&quot;向队列&quot; + destination.toString() + &quot;发送了消息------------&quot; + msg);</span><br><span class="line">        jmsTemplate.send(destination, new MessageCreator() &#123;</span><br><span class="line">            public Message createMessage(Session session) throws JMSException &#123;</span><br><span class="line">                return session.createTextMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 向默认队列发送消息（默认队列在配置类中配置）</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void sendMessage(final String msg) &#123;</span><br><span class="line">        String destination &#x3D;  jmsTemplate.getDefaultDestination().toString();</span><br><span class="line">        System.out.println(&quot;向队列&quot; +destination+ &quot;发送了消息------------&quot; + msg);</span><br><span class="line">        jmsTemplate.send(new MessageCreator() &#123;</span><br><span class="line">            public Message createMessage(Session session) throws JMSException &#123;</span><br><span class="line">                return session.createTextMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、消费者接口："><a href="#3、消费者接口：" class="headerlink" title="3、消费者接口："></a>3、消费者接口：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ConsumerService &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 接受消息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void receive(Destination destination);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、消费者实现："><a href="#4、消费者实现：" class="headerlink" title="4、消费者实现："></a>4、消费者实现：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;consumerService&quot;)</span><br><span class="line">public class ConsumerServiceImpl implements ConsumerService &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 接受消息</span><br><span class="line">     JmsTemplate会尝试从ActiveMQ中获取一个消息。如果没有可用的消息，receive()方法会一直等待，</span><br><span class="line">     直到获得消息为止。也就是说该方法时同步的。</span><br><span class="line">     这意味着接收者必须耐心等待消息的到来，</span><br><span class="line">     因此receive()方法会一直被阻塞，直到有可用消息（或者消息超时）</span><br><span class="line">     </span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void receive(Destination destination) &#123;</span><br><span class="line">        TextMessage tm &#x3D; (TextMessage) jmsTemplate.receive(destination);</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;从队列&quot; + destination.toString() + &quot;收到了消息：\t&quot;</span><br><span class="line">                    + tm.getText());</span><br><span class="line">        &#125; catch (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、spring配置文件（可专为配置类）："><a href="#5、spring配置文件（可专为配置类）：" class="headerlink" title="5、spring配置文件（可专为配置类）："></a>5、spring配置文件（可专为配置类）：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context-4.1.xsd&quot;&gt;</span><br><span class="line">    &lt;!-- spring 注解支持 --&gt;</span><br><span class="line">    &lt;context:annotation-config &#x2F;&gt;</span><br><span class="line">    &lt;context:component-scan base-package&#x3D;&quot;com.activemq.service&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- 配置JMS连接工厂 --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;connectionFactory&quot; class&#x3D;&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;brokerURL&quot; value&#x3D;&quot;failover:(tcp:&#x2F;&#x2F;localhost:61616)&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义消息队列（Queue） --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;queueDestination&quot; class&#x3D;&quot;org.apache.activemq.command.ActiveMQQueue&quot;&gt;</span><br><span class="line">        &lt;!-- 设置消息队列的名字 --&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;value&gt;queue1&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;constructor-arg&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置JMS模板（Queue），Spring提供的JMS工具类，它发送、接收消息。 --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;jmsTemplate&quot; class&#x3D;&quot;org.springframework.jms.core.JmsTemplate&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;connectionFactory&quot; ref&#x3D;&quot;connectionFactory&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;defaultDestination&quot; ref&#x3D;&quot;queueDestination&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;receiveTimeout&quot; value&#x3D;&quot;10000&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><h3 id="6、注意：以上实现的消息同步收发，如何实现异步？"><a href="#6、注意：以上实现的消息同步收发，如何实现异步？" class="headerlink" title="6、注意：以上实现的消息同步收发，如何实现异步？"></a>6、注意：以上实现的消息同步收发，如何实现异步？</h3><p>同步和异步的区别在于： </p><p>同步：使用Message message = consumer.receive()接收消息 </p><p>异步：实现接口MessageListener，注册监听器 consumer.setMessageListener(this); //(异步接收) ，实现 onMessage方法</p><p>异步方式一：（推荐使用，可以用JmsTemplate改造）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">import javax.jms.Connection;</span><br><span class="line">import javax.jms.ConnectionFactory;</span><br><span class="line">import javax.jms.Destination;</span><br><span class="line">import javax.jms.JMSException;</span><br><span class="line">import javax.jms.Message;</span><br><span class="line">import javax.jms.MessageConsumer;</span><br><span class="line">import javax.jms.MessageListener;</span><br><span class="line">import javax.jms.Session;</span><br><span class="line">import javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line">import org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * &lt;p&gt;Title:ActivemqQueueConsumerAsyn&lt;&#x2F;p&gt;</span><br><span class="line"> * &lt;p&gt;Description: 异步接收信息&lt;&#x2F;p&gt;   </span><br><span class="line"> * @author yuanxj</span><br><span class="line"> * @date 2016-1-20</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ActivemqQueueConsumerAsyn implements MessageListener&#123;</span><br><span class="line">    private String name &#x3D; &quot;&quot;;</span><br><span class="line">    private Connection connection &#x3D; null;        </span><br><span class="line">    private Session session &#x3D; null;       </span><br><span class="line">    private MessageConsumer consumer &#x3D; null; </span><br><span class="line">    ActivemqQueueConsumerAsyn(String name)&#123;</span><br><span class="line">        this.name&#x3D;name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  void initialize() throws JMSException</span><br><span class="line">    &#123;ConnectionFactory connectFactory &#x3D; new ActiveMQConnectionFactory(</span><br><span class="line">&quot;tcp:&#x2F;&#x2F;localhost:61616&quot;);</span><br><span class="line">        Connection connection &#x3D; connectFactory.createConnection();</span><br><span class="line">        session &#x3D; connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        Destination destination &#x3D;  session.createQueue(&quot;queue1&quot;);</span><br><span class="line">        consumer &#x3D; session.createConsumer(destination);</span><br><span class="line">        connection.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void recive()</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            initialize();</span><br><span class="line">            System.out.println(&quot;Consumer(&quot;+name+&quot;):-&gt;Begin listening...&quot;);     </span><br><span class="line">            &#x2F;&#x2F; 开始监听     </span><br><span class="line">            consumer.setMessageListener(this);  &#x2F;&#x2F;(异步接收)   </span><br><span class="line"></span><br><span class="line">            &#125; catch (JMSException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(Message arg0) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        try&#123;</span><br><span class="line">            if(arg0 instanceof TextMessage)</span><br><span class="line">            &#123;   </span><br><span class="line">                TextMessage txtMsg &#x3D; (TextMessage) arg0; </span><br><span class="line">                System.out.println(&quot;consumer(&quot;+name+&quot;)异步 recive:&quot;+txtMsg.getText());</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void submit() throws JMSException</span><br><span class="line">    &#123;</span><br><span class="line">        session.commit();</span><br><span class="line">    &#125;</span><br><span class="line">     &#x2F;&#x2F; 关闭连接     </span><br><span class="line">    public void close() throws JMSException &#123;     </span><br><span class="line">        System.out.println(&quot;Consumer:-&gt;Closing connection&quot;);     </span><br><span class="line">        if (consumer !&#x3D; null)     </span><br><span class="line">            consumer.close();     </span><br><span class="line">        if (session !&#x3D; null)     </span><br><span class="line">            session.close();     </span><br><span class="line">        if (connection !&#x3D; null)     </span><br><span class="line">            connection.close();     </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步方式二：</p><p>1、发送消息的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * 使用JmsTemplate发送序列化消息 </span><br><span class="line"> * @param user </span><br><span class="line"> *&#x2F;  </span><br><span class="line">public void send(final User user)&#123;  </span><br><span class="line">    jmsTemplate.send(new MessageCreator() &#123;  </span><br><span class="line">        @Override  </span><br><span class="line">        public ObjectMessage createMessage(Session session) throws JMSException &#123;  </span><br><span class="line">            ObjectMessage msg &#x3D; session.createObjectMessage();  </span><br><span class="line">            msg.setObject(user);  </span><br><span class="line">            return msg;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>2、消息异步接收代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class UserHandler&#123;  </span><br><span class="line">  </span><br><span class="line">    public void handler(User user)&#123;  </span><br><span class="line">        System.out.println(&quot;异步接收消息：&quot;+user);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>3、配置消息接收监听器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userHandler&quot; class&#x3D;&quot;com.gosun.jms.pojo.UserHandler&quot;&gt;&lt;&#x2F;bean&gt;  </span><br><span class="line">      </span><br><span class="line">&lt;jms:listener-container connection-factory&#x3D;&quot;connectionFactory&quot;&gt;  </span><br><span class="line">    &lt;!-- 可以有多个 --&gt;  </span><br><span class="line">    &lt;jms:listener destination&#x3D;&quot;queue.destination&quot; ref&#x3D;&quot;userHandler&quot; method&#x3D;&quot;handler&quot;&#x2F;&gt;  </span><br><span class="line">&lt;&#x2F;jms:listener-container&gt; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ActiveMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整合JmsTemplate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashSet</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/9%E3%80%81HashSet/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/9%E3%80%81HashSet/</url>
      
        <content type="html"><![CDATA[<ol><li>HashSet概述：<br>HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。</li><li>HashSet的实现：<br>对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，因此HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成，</li></ol><p>往HashSet添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值 ，<br>　　然后通过元素 的哈希值经过移位等运算，就可以算出该元素在哈希表中 的存储位置。</p><p>情况1： 如果算出元素存储的位置目前没有任何元素存储，那么该元素可以直接存储到该位置上。</p><p>情况2： 如果算出该元素的存储位置目前已经存在有其他的元素了，那么会调用该元素的equals方法与该位置的元素再比较一次，如果equals返回的是true，那么该元素与这个位置上的元素就视为重复元素，不允许添加，如果equals方法返回的是false，那么该元素运行添加。</p><p>HashSet的源代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt;</span><br><span class="line">   extends AbstractSet&lt;E&gt;</span><br><span class="line">   implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">   static final long serialVersionUID &#x3D; -5024744406713321676L;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 底层使用HashMap来保存HashSet中所有元素。</span><br><span class="line">   private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。</span><br><span class="line">   private static final Object PRESENT &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 默认的无参构造器，构造一个空的HashSet。</span><br><span class="line">    * </span><br><span class="line">    * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public HashSet() &#123;</span><br><span class="line"> map &#x3D; new HashMap&lt;E,Object&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 构造一个包含指定collection中的元素的新set。</span><br><span class="line">    *</span><br><span class="line">    * 实际底层使用默认的加载因子0.75和足以包含指定</span><br><span class="line">    * collection中所有元素的初始容量来创建一个HashMap。</span><br><span class="line">    * @param c 其中的元素将存放在此set中的collection。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line"> map &#x3D; new HashMap&lt;E,Object&gt;(Math.max((int) (c.size()&#x2F;.75f) + 1, 16));</span><br><span class="line"> addAll(c);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 以指定的initialCapacity和loadFactor构造一个空的HashSet。</span><br><span class="line">    *</span><br><span class="line">    * 实际底层以相应的参数构造一个空的HashMap。</span><br><span class="line">    * @param initialCapacity 初始容量。</span><br><span class="line">    * @param loadFactor 加载因子。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public HashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line"> map &#x3D; new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 以指定的initialCapacity构造一个空的HashSet。</span><br><span class="line">    *</span><br><span class="line">    * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。</span><br><span class="line">    * @param initialCapacity 初始容量。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public HashSet(int initialCapacity) &#123;</span><br><span class="line"> map &#x3D; new HashMap&lt;E,Object&gt;(initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。</span><br><span class="line">    * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。</span><br><span class="line">    *</span><br><span class="line">    * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。</span><br><span class="line">    * @param initialCapacity 初始容量。</span><br><span class="line">    * @param loadFactor 加载因子。</span><br><span class="line">    * @param dummy 标记。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line"> map &#x3D; new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。</span><br><span class="line">    * </span><br><span class="line">    * 底层实际调用底层HashMap的keySet来返回所有的key。</span><br><span class="line">    * 可见HashSet中的元素，只是存放在了底层HashMap的key上，</span><br><span class="line">    * value使用一个static final的Object对象标识。</span><br><span class="line">    * @return 对此set中元素进行迭代的Iterator。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line"> return map.keySet().iterator();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 返回此set中的元素的数量（set的容量）。</span><br><span class="line">    *</span><br><span class="line">    * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。</span><br><span class="line">    * @return 此set中的元素的数量（set的容量）。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public int size() &#123;</span><br><span class="line"> return map.size();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 如果此set不包含任何元素，则返回true。</span><br><span class="line">    *</span><br><span class="line">    * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。</span><br><span class="line">    * @return 如果此set不包含任何元素，则返回true。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public boolean isEmpty() &#123;</span><br><span class="line"> return map.isEmpty();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 如果此set包含指定元素，则返回true。</span><br><span class="line">    * 更确切地讲，当且仅当此set包含一个满足(o&#x3D;&#x3D;null ? e&#x3D;&#x3D;null : o.equals(e))</span><br><span class="line">    * 的e元素时，返回true。</span><br><span class="line">    *</span><br><span class="line">    * 底层实际调用HashMap的containsKey判断是否包含指定key。</span><br><span class="line">    * @param o 在此set中的存在已得到测试的元素。</span><br><span class="line">    * @return 如果此set包含指定元素，则返回true。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public boolean contains(Object o) &#123;</span><br><span class="line"> return map.containsKey(o);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 如果此set中尚未包含指定元素，则添加指定元素。</span><br><span class="line">    * 更确切地讲，如果此 set 没有包含满足(e&#x3D;&#x3D;null ? e2&#x3D;&#x3D;null : e.equals(e2))</span><br><span class="line">    * 的元素e2，则向此set 添加指定的元素e。</span><br><span class="line">    * 如果此set已包含该元素，则该调用不更改set并返回false。</span><br><span class="line">    *</span><br><span class="line">    * 底层实际将将该元素作为key放入HashMap。</span><br><span class="line">    * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key</span><br><span class="line">    * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true），</span><br><span class="line">    * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变，</span><br><span class="line">    * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中，</span><br><span class="line">    * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。</span><br><span class="line">    * @param e 将添加到此set中的元素。</span><br><span class="line">    * @return 如果此set尚未包含指定元素，则返回true。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public boolean add(E e) &#123;</span><br><span class="line"> return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 如果指定元素存在于此set中，则将其移除。</span><br><span class="line">    * 更确切地讲，如果此set包含一个满足(o&#x3D;&#x3D;null ? e&#x3D;&#x3D;null : o.equals(e))的元素e，</span><br><span class="line">    * 则将其移除。如果此set已包含该元素，则返回true</span><br><span class="line">    * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。</span><br><span class="line">    *</span><br><span class="line">    * 底层实际调用HashMap的remove方法删除指定Entry。</span><br><span class="line">    * @param o 如果存在于此set中则需要将其移除的对象。</span><br><span class="line">    * @return 如果set包含指定元素，则返回true。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public boolean remove(Object o) &#123;</span><br><span class="line"> return map.remove(o)&#x3D;&#x3D;PRESENT;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 从此set中移除所有元素。此调用返回后，该set将为空。</span><br><span class="line">    *</span><br><span class="line">    * 底层实际调用HashMap的clear方法清空Entry中所有元素。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public void clear() &#123;</span><br><span class="line"> map.clear();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。</span><br><span class="line">    *</span><br><span class="line">    * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public Object clone() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           HashSet&lt;E&gt; newSet &#x3D; (HashSet&lt;E&gt;) super.clone();</span><br><span class="line">           newSet.map &#x3D; (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">           return newSet;</span><br><span class="line">       &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">           throw new InternalError();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashSet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀疏数组 SparseArray</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1%E3%80%81%E6%95%B0%E7%BB%84/2%E3%80%81%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%20SparseArray/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1%E3%80%81%E6%95%B0%E7%BB%84/2%E3%80%81%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%20SparseArray/</url>
      
        <content type="html"><![CDATA[<p>稀疏数组：Android提供的一个工具类。</p><p> Android 开发中，我们可以使用 SparseArray 来实现更高效的实现 Map</p><p>SparseArray指的是稀疏数组，是Android中对HashMap的性能优化。所谓稀疏数组就是数组中的大部分的内容值都未被使用或者都为0，在数组中仅有少部分的空间使用。因此造成了内存空间的浪费，为了节省内存空间，并且不影响数组中原有的内容值，我们可以采用一种压缩的方式来表示稀疏数组的内容。</p><p>稀疏数组如何记录数据：</p><ul><li>记录数组一共有几行几列，有多少个不同的值</li><li>把具有不同值的元素的行列及值记录在一个小规模的数组(稀疏数组)中，从而缩小程序的规模</li></ul><p>如图将二维数组 转为稀疏数组（见笔记4）</p><p>源码实现：</p><h4 id="一、成员变量"><a href="#一、成员变量" class="headerlink" title="一、成员变量"></a>一、成员变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 删除操作时替换对应位置 value 的默认值</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static final Object DELETED &#x3D; new Object();</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 是否需要回收</span><br><span class="line"> *&#x2F;</span><br><span class="line">private boolean mGarbage &#x3D; false;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 存储 key 的数组</span><br><span class="line"> *&#x2F;</span><br><span class="line">private int[] mKeys;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 存储 value 的数组</span><br><span class="line"> *&#x2F;</span><br><span class="line">private Object[] mValues;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 当前存储的键值对数量</span><br><span class="line"> *&#x2F;</span><br><span class="line">private int mSize;</span><br></pre></td></tr></table></figure><h4 id="二、构造函数"><a href="#二、构造函数" class="headerlink" title="二、构造函数"></a>二、构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 创建一个空 map 初始容量为 10</span><br><span class="line"> *&#x2F;</span><br><span class="line">public SparseArray() &#123; this(10); &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 根据指定初始容量创建键值对为空的稀疏数组，并且不会申请额外内存；指定初始容量为 0 时会创建一个轻量级的不需要任何内存分配的稀疏数组</span><br><span class="line"> * capacity 容量</span><br><span class="line"> *&#x2F;</span><br><span class="line">public SparseArray(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        mKeys &#x3D; EmptyArray.INT; &#x2F;&#x2F; 长度为 0 的 int 类型数组</span><br><span class="line">        mValues &#x3D; EmptyArray.OBJECT; &#x2F;&#x2F; 长度为 0 的 Object 类型数组</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mValues &#x3D; ArrayUtils.newUnpaddedObjectArray(initialCapacity);</span><br><span class="line">        mKeys &#x3D; new int[mValues.length];</span><br><span class="line">    &#125;</span><br><span class="line">    mSize &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、添加-修改-操作"><a href="#三、添加-修改-操作" class="headerlink" title="三、添加/修改 操作"></a>三、添加/修改 操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">public void put(int key, E value) &#123;</span><br><span class="line">    int i &#x3D; ContainerHelpers.binarySearch(mKeys, mSize, key); &#x2F;&#x2F; 使用二分法查找对应的 key 在数组中的下标</span><br><span class="line"></span><br><span class="line">    if (i &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 索引大于等于 0 说明原数组中有对应 key</span><br><span class="line">        mValues[i] &#x3D; value; &#x2F;&#x2F; 则直接 Value 数组中的 value 值为最新的 value</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; 索引小于 0 说明原数组中不存在对应的 key</span><br><span class="line">        i &#x3D; ~i; &#x2F;&#x2F; 取反后得到当前 key 应该在的位置</span><br><span class="line"></span><br><span class="line">        if (i &lt; mSize &amp;&amp; mValues[i] &#x3D;&#x3D; DELETED) &#123; &#x2F;&#x2F; 如果数组长度够，并且当前位置已被回收则直接对该位置赋值</span><br><span class="line">            mKeys[i] &#x3D; key;</span><br><span class="line">            mValues[i] &#x3D; value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mGarbage &amp;&amp; mSize &gt;&#x3D; mKeys.length) &#123; &#x2F;&#x2F; 回收状态为 true 并且内容长度大于等于 key 数组长度</span><br><span class="line">            gc(); &#x2F;&#x2F; 回收，整理数组</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Search again because indices may have changed.</span><br><span class="line">            i &#x3D; ~ContainerHelpers.binarySearch(mKeys, mSize, key); &#x2F;&#x2F; 再次使用二分法查找位置</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mKeys &#x3D; GrowingArrayUtils.insert(mKeys, mSize, i, key); &#x2F;&#x2F; 执行 key 插入到 key 数组对应位置</span><br><span class="line">        mValues &#x3D; GrowingArrayUtils.insert(mValues, mSize, i, value); &#x2F;&#x2F; 执行 value 插入到 value 数组对应位置</span><br><span class="line">        mSize++; &#x2F;&#x2F; 键值对数量加 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ContainerHelpers </span><br><span class="line">static int binarySearch(int[] array, int size, int value) &#123;</span><br><span class="line">        int lo &#x3D; 0;</span><br><span class="line">        int hi &#x3D; size - 1;</span><br><span class="line"></span><br><span class="line">        while (lo &lt;&#x3D; hi) &#123;</span><br><span class="line">            final int mid &#x3D; (lo + hi) &gt;&gt;&gt; 1; &#x2F;&#x2F; 带符号右移，也就是做除以 2，这里是找到中间位置索引的操作</span><br><span class="line">            final int midVal &#x3D; array[mid]; </span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 下面是正常的二分法操作</span><br><span class="line">            if (midVal &lt; value) &#123;</span><br><span class="line">                lo &#x3D; mid + 1;</span><br><span class="line">            &#125; else if (midVal &gt; value) &#123;</span><br><span class="line">                hi &#x3D; mid - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return mid;  &#x2F;&#x2F; value found</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ~lo;  &#x2F;&#x2F; 当数组中不存在对应 value 的时候，这里是将如果数组中存在 value 时应该在的位置取反后返回</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">private void gc() &#123;</span><br><span class="line">    int n &#x3D; mSize; &#x2F;&#x2F; 键值对数量</span><br><span class="line">    int o &#x3D; 0;</span><br><span class="line">    int[] keys &#x3D; mKeys;</span><br><span class="line">    Object[] values &#x3D; mValues;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123; &#x2F;&#x2F; 通过循环将 value 数组中的 DELETED 值移除，并且 DELETED 以后的键跟值都往前补</span><br><span class="line">        Object val &#x3D; values[i];</span><br><span class="line"></span><br><span class="line">        if (val !&#x3D; DELETED) &#123;</span><br><span class="line">            if (i !&#x3D; o) &#123; &#x2F;&#x2F; 循环第一次执行时 i 和 o 都是 0 ，这种情况不需要处理</span><br><span class="line">                keys[o] &#x3D; keys[i];</span><br><span class="line">                values[o] &#x3D; val;</span><br><span class="line">                values[i] &#x3D; null; &#x2F;&#x2F; 原位置置空</span><br><span class="line">            &#125;</span><br><span class="line">            o++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mGarbage &#x3D; false; &#x2F;&#x2F; 回收状态置为 false</span><br><span class="line">    mSize &#x3D; o; &#x2F;&#x2F; 将键值对的值更新为实际的键值对数量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * GrowingArrayUtils 中定义了 泛型&#x2F;int&#x2F;long&#x2F;boolean 等类型数组在指定位置插入数据的方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static int[] insert(int[] array, int currentSize, int index, int element) &#123;</span><br><span class="line">    assert currentSize &lt;&#x3D; array.length;</span><br><span class="line"></span><br><span class="line">    if (currentSize + 1 &lt;&#x3D; array.length) &#123; &#x2F;&#x2F; 不需要扩容</span><br><span class="line">        System.arraycopy(array, index, array, index + 1, currentSize - index); &#x2F;&#x2F; 将对应位置后的内容右移</span><br><span class="line">        array[index] &#x3D; element;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 需要扩容，</span><br><span class="line">    int[] newArray &#x3D; new int[growSize(currentSize)];</span><br><span class="line">    System.arraycopy(array, 0, newArray, 0, index); &#x2F;&#x2F; 将对应位置前的内容插入</span><br><span class="line">    newArray[index] &#x3D; element; &#x2F;&#x2F; 将对应位置内容插入</span><br><span class="line">    System.arraycopy(array, index, newArray, index + 1, array.length - index); &#x2F;&#x2F; 将对应位置后的内容插入</span><br><span class="line">    return newArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * GrowingArrayUtils 中定义了 泛型&#x2F;int&#x2F;long&#x2F;boolean 等类型数组在指定位置插入数据的方法，这个方法的作用为，在位置超出数组大小时，计算扩容后数组的新长度</span><br><span class="line"> * 旧数组长度小于 4 则设置为 8，否则都是在当前长度基础上扩容一被</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static int growSize(int currentSize) &#123;</span><br><span class="line">    return currentSize &lt;&#x3D; 4 ? 8 : currentSize * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="查找方法-get-int-key"><a href="#查找方法-get-int-key" class="headerlink" title="查找方法 get(int key)"></a>查找方法 get(int key)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public E get(int key) &#123;</span><br><span class="line">    return get(key, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 根据 key 查找 value ，如果 key 不存在则返回指定的默认值</span><br><span class="line"> *&#x2F;</span><br><span class="line">public E get(int key, E valueIfKeyNotFound) &#123;</span><br><span class="line">    int i &#x3D; ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    if (i &lt; 0 || mValues[i] &#x3D;&#x3D; DELETED) &#123;</span><br><span class="line">        return valueIfKeyNotFound;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (E) mValues[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="五、删除方法-delete-int-key"><a href="#五、删除方法-delete-int-key" class="headerlink" title="五、删除方法 delete(int key)"></a>五、删除方法 delete(int key)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 删除操作</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void delete(int key) &#123;</span><br><span class="line">    int i &#x3D; ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    if (i &gt;&#x3D; 0) &#123;</span><br><span class="line">        if (mValues[i] !&#x3D; DELETED) &#123;</span><br><span class="line">            mValues[i] &#x3D; DELETED;</span><br><span class="line">            mGarbage &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E removeReturnOld(int key) &#123;</span><br><span class="line">    int i &#x3D; ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    if (i &gt;&#x3D; 0) &#123;</span><br><span class="line">        if (mValues[i] !&#x3D; DELETED) &#123;</span><br><span class="line">            final E old &#x3D; (E) mValues[i];</span><br><span class="line">            mValues[i] &#x3D; DELETED;</span><br><span class="line">            mGarbage &#x3D; true;</span><br><span class="line">            return old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 删除指定位置的值</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void removeAt(int index) &#123;</span><br><span class="line">    if (mValues[index] !&#x3D; DELETED) &#123;</span><br><span class="line">        mValues[index] &#x3D; DELETED;</span><br><span class="line">        mGarbage &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 以 index 开始，删除之后 size 个值，包含 index 位置，不包含 index + size</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void removeAtRange(int index, int size) &#123;</span><br><span class="line">    final int end &#x3D; Math.min(mSize, index + size);</span><br><span class="line">    for (int i &#x3D; index; i &lt; end; i++) &#123;</span><br><span class="line">        removeAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他方法略</p><p>总结：</p><p>SparseArray 的代码非常少，只有 450 行左右，并且特别易于理解。但 SparseArray 要比 HashMap 更加高效，在 Android 手机中，如果 key 为 int 类型的 Map 数据，最好使用 SparseArray 来实现。</p>]]></content>
      
      
      <categories>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 稀疏数组 SparseArray </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存模型(JDK7)</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/4%E3%80%81JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B(JDK7)/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/4%E3%80%81JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B(JDK7)/</url>
      
        <content type="html"><![CDATA[<h2 id="JDK7的jvm数据区内存结构图："><a href="#JDK7的jvm数据区内存结构图：" class="headerlink" title="JDK7的jvm数据区内存结构图："></a>JDK7的jvm数据区内存结构图：</h2><p>方法区，堆，java栈，PC寄存器，本地方法栈</p><p><img src="https://images2015.cnblogs.com/blog/539365/201511/539365-20151119103724608-1752144990.png" alt="image"></p><h1 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h1><h4 id="程序计数作用："><a href="#程序计数作用：" class="headerlink" title="程序计数作用："></a>程序计数作用：</h4><p>程序计数器是一块 较小 的内存空间，它可以看做是==当前线程所执行的字节码的 行号指示器==，字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳准、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成，程序计数器保证了程序的正常执行</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul><li><p>CPU在切换线程的时候，程序计数器里面保存的是 当前线程执行的字节码的行号（看着像行号，其实是指令地址）所以当线程重新获得CPU执行权的时候，知道从那个位置继续执行程序</p></li><li><p>当线程执行的是本地方法的时候，程序计数器中保存的值是空（undefined）；原因很简单：本地方法是C++/C 写的，由系统调用，根本不会产生字节码文件，因此，程序计数器也就不会做任何记录 ；</p></li></ul><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li>1、线程私有的</li><li>2、是java虚拟机规范里面,唯一一个没有规定任何 OutOfMemoryError情况的区域</li><li>3、生命周期随着线程，线程启动而产生，线程结束而消亡</li></ul><h1 id="2、java虚拟机栈"><a href="#2、java虚拟机栈" class="headerlink" title="2、java虚拟机栈"></a>2、java虚拟机栈</h1><ul><li>保存的数据：</li></ul><p>（2）java基本数据类型</p><p>（2）自定义对象的引用(包含常量池的引用)</p><ul><li>数据保存的格式：<br>栈中的数据都是以==栈帧==（Stack Frame）的格式存在，栈帧是一个内存区块，用于存储局部变量表(slot)、操作数栈、动态连接、方法出口等信息,==当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈==。<br><img src="https://images2015.cnblogs.com/blog/539365/201511/539365-20151119105009030-922518460.png" alt="image"></li></ul><h5 id="局部变量表："><a href="#局部变量表：" class="headerlink" title="局部变量表："></a>局部变量表：</h5><p>64为长度的long、double以高位对齐的占用2个连续的局部变量表slot,其余基本类型占用1个，因为是线程私有的基本类型，所以无论读写两个连续的slot是否原子性，都是线程安全的<br>操作数栈：</p><p>虚拟机栈规定了两种异常情况：</p><ul><li>1、如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。</li><li>2、如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li><li>注意：在单线程的操作中，无论是由于栈帧太大，还是虚拟机栈空间太小，当栈空间无法分配时，虚拟机抛出的都是StackOverflowError异常，而不会得到OutOfMemoryError异常。<br>而在多线程环境下，则会抛出OutOfMemoryError异常。</li></ul><h1 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h1><p>　本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法而服务的，而本地方法栈则是为执行本地方法（Native Method）而服务的（常用的HotSpot虚拟机选择合并了虚拟机栈和本地方法栈。），与虚拟机栈一样会抛出StackOverflowError，OutOfMemoryErro异常</p><p>什么是Native Method：一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C</p><h1 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h1><p>　Java中的堆是用来存储对象本身（包含成员变量：作为对象的一部分）、以及数组对象（数组引用是存放在Java栈中的）。堆是被所有线程共享的，在JVM中只有一个堆。（堆可以处在物理上不连续的内存空间，只要逻辑上连续即可），Java堆分为新生代和老年代</p><h3 id="4-1：新生代"><a href="#4-1：新生代" class="headerlink" title="4.1：新生代"></a>4.1：新生代</h3><p>新生代和老年代的比例时1：3</p><p>新生代再细致一点的分有：Eden区、survivor0、survivor1（内存大小比例是 8:1:1）</p><p>1、Eden区:Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC（回收方式：采用复制算法)</p><p>2、ServivorTo空间：保留了一次MinorGC过程中的幸存者（每熬过一次MinorGC的对象age+1 默认当age大于15，移动到老年代，该值不同垃圾回收器是不一样的 CMS是6岁，该可调整）</p><p>3、ServivorFrom:上一次GC的幸存者，作为这一次GC的被扫描者。</p><p><strong>新生代MinorGC（YGC）回收步骤</strong>：</p><p>MinorGC发生频率比较高，不一定等 Eden区满了才触发。</p><ul><li>第一次gc先将eden区存活对象复制到survivor0区，然后清空eden区</li><li>第2次gc 将eden区(虽然第一次清空了eden，但还会有新对象产生进入eden)和survivor0区存活对象复制到survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，</li><li>第3次gc,将eden区和survivor1复制到survivor0区</li><li>依次循环</li><li>如此往复当age&gt;15移动到老年代。特别地，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。</li><li>如果老年代也满了，就会触发一次全量垃圾回收majorGC(FullGC)，也就是整个堆内存（新生代、老年代）都进行回收。JVM调优的目标时尽量减少FullGC。因为全量回收会产生STW现象。</li></ul><h4 id="4-2：老年代"><a href="#4-2：老年代" class="headerlink" title="4.2：老年代"></a>4.2：老年代</h4><p>老年代的对象比较稳定，所以MajorGC不会频繁执行。在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。</p><p>MajorGC清除-标记回收算法：</p><p>首先扫描一次所有老年代，标记出==存活的对象==然后回收没有标记的对象。</p><p><img src="https://images2015.cnblogs.com/blog/908514/201607/908514-20160728195713028-1922699910.jpg" alt="image"></p><h1 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h1><p>线程共享的区域。在方法区中，存储==了每个类==的信息（包括类的名称、方法信息、字段信息）、静态变量、常量（常量池）以及编译器编译后的代码等。因此方法区的大小决定了系统可以保存多少个类。</p><p>方法区又被称为“永久代”，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。但是并非数据进入方法区，就如永久代名字一样，永久存在了，而是该内存区域回收目标主要针对废弃常量和无用的类的卸载。（JDK8已经用元数据区替代了永久代，且元数据区不在存放jvm中，而是本地内存中）</p><ul><li>废弃的常量判断标准：<br>若字符串“abc”已经进入常量池中，但当前系统没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用该字面量，若发生内存回收，且必要的话，该“abc”就会被系统清理出常量池。常量池中其他的类（接口）、方法、字段的符号引用与此类似。</li><li>无用的类判断标准：</li></ul><p>（1）该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例； </p><p>（2）加载该类的ClassLoader已经被回收； </p><p>（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p><p>虚拟机可以对满足上述3个条件的无用类进行回收，此处仅仅是“可以”，而并不是和对象一样（不使用了就必然回收）</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM内存模型(JDK7) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%9E%B6%E6%9E%84/4%E3%80%81%E9%94%81/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%9E%B6%E6%9E%84/4%E3%80%81%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>查看事务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from  INFORMATION_SCHEMA.INNODB_TRX;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TRX_ID事务Id</span><br><span class="line">TRX_WEIGHT事务的权重，反映（但不一定是确切的计数）更改的行数和事务锁定的行数。要解决死锁，请 InnoDB选择权重最小的事务作为回滚的“ 受害者 ”。无论更改和锁定行的数量如何，已更改非事务表的事务都被认为比其他事务更重。</span><br><span class="line">TRX_STATE事务执行状态。允许值是 RUNNING，LOCK WAIT， ROLLING BACK，和 COMMITTING。</span><br><span class="line">TRX_STARTED交易开始时间。</span><br><span class="line">TRX_REQUESTED_LOCK_ID事务当前正在等待的锁的ID，如果TRX_STATE是LOCK WAIT; 否则NULL。</span><br><span class="line">TRX_WAIT_STARTED交易开始等待锁定的时间，如果 TRX_STATE是LOCK WAIT; 否则NULL。</span><br><span class="line">TRX_MYSQL_THREAD_IDMySQL线程ID，与show processlist中的ID值相对应</span><br><span class="line">TRX_QUERY事务正在执行的SQL语句</span><br></pre></td></tr></table></figure><p>查看锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from  INFORMATION_SCHEMA.INNODB_LOCKS;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LOCK_ID一个唯一的锁ID号，内部为 InnoDB。</span><br><span class="line">LOCK_TRX_ID持有锁的交易的ID</span><br><span class="line">LOCK_MODE如何请求锁定。允许锁定模式描述符 S，X， IS，IX， GAP，AUTO_INC，和 UNKNOWN。锁定模式描述符可以组合使用以识别特定的锁定模式。</span><br><span class="line">LOCK_TYPE锁的类型</span><br><span class="line">LOCK_TABLE已锁定或包含锁定记录的表的名称</span><br><span class="line">LOCK_INDEX索引的名称，如果LOCK_TYPE是 RECORD; 否则NULL</span><br><span class="line">LOCK_SPACE锁定记录的表空间ID，如果 LOCK_TYPE是RECORD; 否则NULL</span><br><span class="line">LOCK_PAGE锁定记录的页码，如果 LOCK_TYPE是RECORD; 否则NULL。</span><br><span class="line">LOCK_REC页面内锁定记录的堆号，如果 LOCK_TYPE是RECORD; 否则NULL。</span><br><span class="line">LOCK_DATA与锁相关的数据（如果有）。如果 LOCK_TYPE是RECORD，是锁定的记录的主键值，否则NULL。此列包含锁定行中主键列的值，格式为有效的SQL字符串。如果没有主键，LOCK_DATA则是唯一的InnoDB内部行ID号。如果对键值或范围高于索引中的最大值的间隙锁定，则LOCK_DATA 报告supremum pseudo-record。当包含锁定记录的页面不在缓冲池中时（如果在保持锁定时将其分页到磁盘），InnoDB不从磁盘获取页面，以避免不必要的磁盘操作。相反， LOCK_DATA设置为 NULL。</span><br></pre></td></tr></table></figure><p>查看锁等待</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from  INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REQUESTING_TRX_ID请求（阻止）事务的ID。</span><br><span class="line">REQUESTED_LOCK_ID事务正在等待的锁的ID。</span><br><span class="line">BLOCKING_TRX_ID阻止事务的ID。</span><br><span class="line">BLOCKING_LOCK_ID由阻止另一个事务继续进行的事务所持有的锁的ID</span><br></pre></td></tr></table></figure><h3 id="InnoDB存储引擎的行锁是通过锁住主键索引实现的，而不是记录。这是理解很多数据库锁问题的关键。"><a href="#InnoDB存储引擎的行锁是通过锁住主键索引实现的，而不是记录。这是理解很多数据库锁问题的关键。" class="headerlink" title="==InnoDB存储引擎的行锁是通过锁住主键索引实现的，而不是记录。这是理解很多数据库锁问题的关键。=="></a>==InnoDB存储引擎的行锁是通过锁住主键索引实现的，而不是记录。这是理解很多数据库锁问题的关键。==</h3><p>InnoDB特殊的索引机制，数据库操作使用主键索引时，InnoDB会锁住主键索引；使用非主键索引时，InnoDB会先锁住非主键索引，再锁定主键索引。如果操作不通过索引条件检索数据，InnoDB 则对表中的所有记录加锁，实际效果就和表锁一样。</p><p>InnoDB存储引擎有3种行锁的算法，分别是：</p><ul><li>Record Lock: 单个记录上的锁</li></ul><p>Record Lock总是会锁住索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。</p><ul><li>Gap Lock: 间隙锁，锁定一个范围，但不包括记录本上</li></ul><p>解决Phantom Problem（幻象/幻读），利用这种锁技术，锁定的不是单个值，而是一个范围。</p><ul><li>Next-Key Lock: Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身</li></ul><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁:"></a>乐观锁:</h3><p>乐观锁不是锁，通过版本号判断数据是否更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">下单操作包括3步骤：</span><br><span class="line">1.查询出商品信息</span><br><span class="line">select (status,status,version) from t_goods where id&#x3D;#&#123;id&#125;</span><br><span class="line">2.根据商品信息生成订单</span><br><span class="line">3.修改商品status为2</span><br><span class="line">update t_goods </span><br><span class="line">set status&#x3D;2,version&#x3D;version+1</span><br><span class="line">where id&#x3D;#&#123;id&#125; and version&#x3D;#&#123;version&#125;;</span><br></pre></td></tr></table></figure><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁是对整个数据库实例加锁。典型使用场景是，做全库逻辑备份。只允许读的操作。写的操作会被阻塞。</p><h3 id="表级锁："><a href="#表级锁：" class="headerlink" title="表级锁："></a>表级锁：</h3><p> MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁</p><h3 id="行锁："><a href="#行锁：" class="headerlink" title="行锁："></a>行锁：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">事务A--begin;</span><br><span class="line">update t set k&#x3D;k+1 where id&#x3D;1</span><br><span class="line">update t set k&#x3D;k+1 where id&#x3D;2</span><br><span class="line"></span><br><span class="line">事务B</span><br><span class="line">事务B--begin;</span><br><span class="line">update t set k&#x3D;k+2 where id&#x3D;1</span><br><span class="line"></span><br><span class="line">事务A--commit</span><br></pre></td></tr></table></figure><p>事务 B 的 update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行。</p><p>事务 A 持有的两个记录的行锁，都是在 commit 的时候才释放的。</p><p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</p><h5 id="行锁在开发中的技巧："><a href="#行锁在开发中的技巧：" class="headerlink" title="行锁在开发中的技巧："></a>行锁在开发中的技巧：</h5><p>一个事务中两台update 一条insert.合理安排语句执行顺序，可提高并发度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从顾客 A 账户余额中扣除电影票价；</span><br><span class="line">给影院 B 的账户余额增加这张电影票价；</span><br><span class="line">记录一条交易日志。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">另外一个顾客 C 要在影院 B 买票</span><br><span class="line">给影院 B 的账户余额增加这张电影票价；</span><br></pre></td></tr></table></figure><p>那么这两个事务冲突的部分就是语句 2 了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。</p><p>==开发中如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放那么影院账户余额这一行的锁时间就最少==。这就最大程度地减少了事务之间的锁等待，提升了并发度。但是调整语句顺序，并不能完全避免死锁问题。</p><h3 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a>死锁：</h3><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>begin</td><td>begin</td></tr><tr><td>update t set k=k+1 where id=1</td><td>/</td></tr><tr><td>/</td><td>update t set k=k+1 where id=2</td></tr><tr><td>update t set k=k+1 where id=2</td><td>/</td></tr><tr><td>/</td><td>update t set k=k+1 where id=1</td></tr></tbody></table><p>事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1 的行锁。 事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态</p><h5 id="死锁的两种解决策略："><a href="#死锁的两种解决策略：" class="headerlink" title="死锁的两种解决策略："></a>死锁的两种解决策略：</h5><ul><li><p>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。<br>innodb_lock_wait_timeout设置太长，服务等待时间不允许。<br>设置太短，出现死锁的时候，很快就可以解开，但如果不是死锁，而是简单的锁等待，就会出现误伤</p></li><li><p>另一种策略是，将参数 innodb_deadlock_detect 设置为 on，主动发起死锁检测。发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。</p></li></ul><p>每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待（死锁）。时间复杂度为O（n）,假设1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的消耗CPU资源。</p><h5 id="降低死锁检测成本策略："><a href="#降低死锁检测成本策略：" class="headerlink" title="降低死锁检测成本策略："></a>降低死锁检测成本策略：</h5><ul><li>（1）修改Mysql源码：对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了</li></ul><ul><li>（2）==业务代码控制并发度==：利用中间件，控制并发数据。如同一行同时最多只有 10 个线程在更新，那么死锁检测的成本降得很低。</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hystrix介绍</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/4%E3%80%81hystrix%20%E6%96%AD%E8%B7%AF%E5%99%A8/1%E3%80%81hystrix%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/4%E3%80%81hystrix%20%E6%96%AD%E8%B7%AF%E5%99%A8/1%E3%80%81hystrix%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>hystrix断路器：</p><p><a href="https://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_clients">https://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_clients</a></p><p>就是一句话，保证单个服务调用出错，不会导致系统宕机。</p><p>在系统中 微服务A调用微服务B  微服务B调用微服务C 微服务C调用微服务D 。。。就是所谓的扇出<br>若微服务C连接超时或不可用时怎么办？</p><p>hystrix 是一个用于处理分布式系统的延迟和容错的开源库。Hystrix断路器 本身是一种开关装置（保险丝）。当一个微服务发生故障时，通过Hystrix的故障监控，会向调用方返回一个可预期，可处理的备选响应（fallBack）。而不是长时间的的等待或者抛出异常。保证服务调用方的线程不会长时间占用，从而避免故障在系统中的蔓延，乃至宕机。</p><h4 id="1、在服务提供者中添加hystrix的依赖"><a href="#1、在服务提供者中添加hystrix的依赖" class="headerlink" title="1、在服务提供者中添加hystrix的依赖"></a>1、在服务提供者中添加hystrix的依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.cloud&#x2F;spring-cloud-starter-hystrix --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4.5.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="2、再微服务中添加注解："><a href="#2、再微服务中添加注解：" class="headerlink" title="2、再微服务中添加注解："></a>2、再微服务中添加注解：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(fallbackMethod&#x3D;&quot;exceptionHandler&quot;)</span><br></pre></td></tr></table></figure><p>一旦微服务发生异常，就会调用fallbackMethod指定的方法</p><ul><li>fallbackMethod：指定服务降级处理方法；</li><li>ignoreExceptions：忽略某些异常，不发生服务降级；</li><li>commandKey：命令名称，用于区分不同的命令；</li><li>groupKey：分组名称，Hystrix会根据不同的分组来统计命令的告警及仪表盘信息；</li><li>threadPoolKey：线程池名称，用于划分线程池。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(fallbackMethod &#x3D; &quot;exceptionHandler&quot;)</span><br><span class="line">public CommonResult getUser(Long id) &#123;</span><br><span class="line">    return restTemplate.getForObject(userServiceUrl + &quot;&#x2F;user&#x2F;&#123;1&#125;&quot;, CommonResult.class, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public CommonResult exceptionHandler(@PathVariable Long id) &#123;</span><br><span class="line">    User defaultUser &#x3D; new User(-1L, &quot;defaultUser&quot;, &quot;123456&quot;);</span><br><span class="line">    return new CommonResult&lt;&gt;(defaultUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="3、在启动类中开启hystrix熔断器"><a href="#3、在启动类中开启hystrix熔断器" class="headerlink" title="3、在启动类中开启hystrix熔断器"></a>3、在启动类中开启hystrix熔断器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@EnableCircuitBreaker &#x2F;&#x2F;开启hysrtix熔断器</span><br><span class="line">@EnableDiscoveryClient &#x2F;&#x2F;服务发现</span><br></pre></td></tr></table></figure><h3 id="4、说明：上述方式的缺点："><a href="#4、说明：上述方式的缺点：" class="headerlink" title="4、说明：上述方式的缺点："></a>4、说明：上述方式的缺点：</h3><p>每个方法都添加上@HystrixCommand(fallbackMethod=”exceptionHandler”)造成代码的耦合性太高，和代码的冗余<br>可以将针对方法的注解，提取到针对类。原理就是AOP面向切面编程的异常通知。</p><p>4.1 在api moudle中针对service添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class DeptClientFallFactory implements FallbackFactory&lt;DeptService&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public DeptService create(Throwable throwable) &#123;</span><br><span class="line">        return new DeptService()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Dept getData() &#123;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;发送服务熔断时候的处理</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.2 再service中指定该DeptClientFallFactory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value &#x3D;&quot;CLOUD-SERVICE-PROVIDER-01&#x2F;cloud-service-provider-01&quot;)</span><br><span class="line">public interface DeptService &#123;</span><br><span class="line">    Dept getData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hystrix的请求缓存"><a href="#Hystrix的请求缓存" class="headerlink" title="Hystrix的请求缓存"></a>Hystrix的请求缓存</h3><p>当系统并发量越来越大时，我们需要使用缓存来优化系统，达到减轻并发请求线程数，提供响应速度的效果。</p><p>相关注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@CacheResult：开启缓存，默认所有参数作为缓存的key，cacheKeyMethod可以通过返回String类型的方法指定key；</span><br><span class="line">@CacheKey：指定缓存的key，可以指定参数或指定参数中的属性值为缓存key，cacheKeyMethod还可以通过返回String类型的方法指定；</span><br><span class="line">@CacheRemove：移除缓存，需要指定commandKey。</span><br></pre></td></tr></table></figure><p>注意：需要在每次使用缓存的请求前后对HystrixRequestContext进行初始化和关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: Request caching is not available. Maybe you need to initialize the HystrixRequestContext?</span><br></pre></td></tr></table></figure><p>使用过滤器，在每个请求前后初始化和关闭HystrixRequestContext来解决该问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by macro on 2019&#x2F;9&#x2F;4.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">@WebFilter(urlPatterns &#x3D; &quot;&#x2F;*&quot;,asyncSupported &#x3D; true)</span><br><span class="line">public class HystrixRequestContextFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        HystrixRequestContext context &#x3D; HystrixRequestContext.initializeContext();</span><br><span class="line">        try &#123;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            context.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Hystrix的常用配置"><a href="#Hystrix的常用配置" class="headerlink" title="Hystrix的常用配置"></a>Hystrix的常用配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">hystrix:</span><br><span class="line">  command: #用于控制HystrixCommand的行为</span><br><span class="line">    default:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          strategy: THREAD #控制HystrixCommand的隔离策略，THREAD-&gt;线程池隔离策略(默认)，SEMAPHORE-&gt;信号量隔离策略</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: 1000 #配置HystrixCommand执行的超时时间，执行超过该时间会进行服务降级处理</span><br><span class="line">            interruptOnTimeout: true #配置HystrixCommand执行超时的时候是否要中断</span><br><span class="line">            interruptOnCancel: true #配置HystrixCommand执行被取消的时候是否要中断</span><br><span class="line">          timeout:</span><br><span class="line">            enabled: true #配置HystrixCommand的执行是否启用超时时间</span><br><span class="line">          semaphore:</span><br><span class="line">            maxConcurrentRequests: 10 #当使用信号量隔离策略时，用来控制并发量的大小，超过该并发量的请求会被拒绝</span><br><span class="line">      fallback:</span><br><span class="line">        enabled: true #用于控制是否启用服务降级</span><br><span class="line">      circuitBreaker: #用于控制HystrixCircuitBreaker的行为</span><br><span class="line">        enabled: true #用于控制断路器是否跟踪健康状况以及熔断请求</span><br><span class="line">        requestVolumeThreshold: 20 #超过该请求数的请求会被拒绝</span><br><span class="line">        forceOpen: false #强制打开断路器，拒绝所有请求</span><br><span class="line">        forceClosed: false #强制关闭断路器，接收所有请求</span><br><span class="line">      requestCache:</span><br><span class="line">        enabled: true #用于控制是否开启请求缓存</span><br><span class="line">  collapser: #用于控制HystrixCollapser的执行行为</span><br><span class="line">    default:</span><br><span class="line">      maxRequestsInBatch: 100 #控制一次合并请求合并的最大请求数</span><br><span class="line">      timerDelayinMilliseconds: 10 #控制多少毫秒内的请求会被合并成一个</span><br><span class="line">      requestCache:</span><br><span class="line">        enabled: true #控制合并请求是否开启缓存</span><br><span class="line">  threadpool: #用于控制HystrixCommand执行所在线程池的行为</span><br><span class="line">    default:</span><br><span class="line">      coreSize: 10 #线程池的核心线程数</span><br><span class="line">      maximumSize: 10 #线程池的最大线程数，超过该线程数的请求会被拒绝</span><br><span class="line">      maxQueueSize: -1 #用于设置线程池的最大队列大小，-1采用SynchronousQueue，其他正数采用LinkedBlockingQueue</span><br><span class="line">      queueSizeRejectionThreshold: 5 #用于设置线程池队列的拒绝阀值，由于LinkedBlockingQueue不能动态改版大小，使用时需要用该参数来控制线程数</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hystrix 断路器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hystrix介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/1%E3%80%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/1%E3%80%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>==复杂度分析是整个算法学习的精髓==</p><p>为什么需要复杂度分析？<br>把代码跑一遍，通过统计、监控，得到的算法执行的时间和占用的内存大小结果会很依赖测试环境（硬件处理器不同），数据规模的影响也很大。</p><p>所以，我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。就是时间、空间复杂度分析</p><h1 id="1、时间复杂度表示方法"><a href="#1、时间复杂度表示方法" class="headerlink" title="1、时间复杂度表示方法"></a>1、时间复杂度表示方法</h1><p>假设每行代码执行的时间都一样，下面这段代码总的执行时间就是 (2n+2)*unit_time。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">  int sum &#x3D; 0;&#x2F;&#x2F;1*unit_time</span><br><span class="line">  int i &#x3D; 1;&#x2F;&#x2F;1*unit_time</span><br><span class="line">  for (; i &lt;&#x3D; n; ++i) &#123;&#x2F;&#x2F;n*unit_time</span><br><span class="line">    sum &#x3D; sum + i;&#x2F;&#x2F;n*unit_time</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这段代码总的执行时间 T(n) = (2*n²+2n+3)*unit_time。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">  int sum &#x3D; 0;&#x2F;&#x2F;1*unit_time</span><br><span class="line">  int i &#x3D; 1;&#x2F;&#x2F;1*unit_time</span><br><span class="line">  int j &#x3D; 1;&#x2F;&#x2F;1*unit_time</span><br><span class="line">  for (; i &lt;&#x3D; n; ++i) &#123;&#x2F;&#x2F;n*unit_time</span><br><span class="line">    j &#x3D; 1;&#x2F;&#x2F;n*unit_time</span><br><span class="line">    for (; j &lt;&#x3D; n; ++j) &#123;&#x2F;&#x2F;n² * unit_time</span><br><span class="line">      sum &#x3D; sum +  i * j;&#x2F;&#x2F;n² * unit_time</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正,我们可以把这个规律总结成一个公式，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(n)&#x3D;O(f(n))</span><br></pre></td></tr></table></figure><ul><li>n表示数据规模，</li><li>f(n) 表示每行代码执行的次数总和</li></ul><p>时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，==低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略==。我们只需要记录一个最大量级就可以了,，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，T(n) = O(n)； T(n) = O(n²)</p><h1 id="2、如何分析一段代码的时间复杂度"><a href="#2、如何分析一段代码的时间复杂度" class="headerlink" title="2、如何分析一段代码的时间复杂度"></a>2、如何分析一段代码的时间复杂度</h1><ul><li>1、只关注循环执行次数最多的一段代码。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">  int sum &#x3D; 0;</span><br><span class="line">  int i &#x3D; 1;</span><br><span class="line">  for (; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">    sum &#x3D; sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码被执行了 n 次，所以总的时间复杂度就是 O(n)</p><ul><li><p>2、加法法则：总复杂度等于量级最大的那段代码的复杂度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">   int sum_1 &#x3D; 0;</span><br><span class="line">   int p &#x3D; 1;</span><br><span class="line">   for (; p &lt; 100; ++p) &#123;&#x2F;&#x2F;即便这段代码循环 10000 次、100000 次,当n无限大时，只要是一个已知的数都可以忽略执行时间</span><br><span class="line">     sum_1 &#x3D; sum_1 + p;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   int sum_2 &#x3D; 0;</span><br><span class="line">   int q &#x3D; 1;</span><br><span class="line">   for (; q &lt; n; ++q) &#123;</span><br><span class="line">     sum_2 &#x3D; sum_2 + q;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   int sum_3 &#x3D; 0;</span><br><span class="line">   int i &#x3D; 1;</span><br><span class="line">   int j &#x3D; 1;</span><br><span class="line">   for (; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">     j &#x3D; 1; </span><br><span class="line">     for (; j &lt;&#x3D; n; ++j) &#123;</span><br><span class="line">       sum_3 &#x3D; sum_3 +  i * j;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   return sum_1 + sum_2 + sum_3;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>那第二段代码和第三段代码的时间复杂度O(n) 和 O(n²),我们取其中最大的量级.O(n²)</p></li><li><p>3、乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">   int ret &#x3D; 0; </span><br><span class="line">   int i &#x3D; 1;</span><br><span class="line">   for (; i &lt; n; ++i) &#123;</span><br><span class="line">     ret &#x3D; ret + f(i);</span><br><span class="line">   &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> int f(int n) &#123;</span><br><span class="line">  int sum &#x3D; 0;</span><br><span class="line">  int i &#x3D; 1;</span><br><span class="line">  for (; i &lt; n; ++i) &#123;</span><br><span class="line">    sum &#x3D; sum + i;</span><br><span class="line">  &#125; </span><br><span class="line">  return sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>cal() 函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n²)。</p></li></ul><h1 id="3、常见的多项式时间复杂度。"><a href="#3、常见的多项式时间复杂度。" class="headerlink" title="3、常见的多项式时间复杂度。"></a>3、常见的多项式时间复杂度。</h1><h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h3><p>O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 8;</span><br><span class="line">int j &#x3D; 6;</span><br><span class="line">int sum &#x3D; i + j;</span><br></pre></td></tr></table></figure><p>只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1),或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p><h3 id="O-logn-、O-nlogn"><a href="#O-logn-、O-nlogn" class="headerlink" title="O(logn)、O(nlogn)"></a>O(logn)、O(nlogn)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">i&#x3D;1;</span><br><span class="line">while (i &lt;&#x3D; n)  &#123;</span><br><span class="line">  i &#x3D; i * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环次数为x=log2n，代码的时间复杂度就是 O(log2n)。<br>，不管i*几，我们可以把所有对数阶的时间复杂度都记为 O(logn)，</p><p>如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn)</p><p>O(logn) 这种对数时间复杂度。这是一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级 O(1) 的算法还要高效。为什么这么说呢？</p><p>因为 logn 是一个非常“恐怖”的数量级，即便 n 非常非常大，对应的 logn 也很小。比如 n 等于 2 的 32 次方，这个数很大了吧？大约是 42 亿。也就是说，如果我们在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次。</p><p>我们前面讲过，用大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1) 有可能表示的是一个非常大的常量值，比如 O(1000)、O(10000)。所以，常量级时间复杂度的算法有时候可能还没有 O(logn) 的算法执行效率高。</p><h3 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m+n)、O(m*n)"></a>O(m+n)、O(m*n)</h3><p>时间复杂度，代码的复杂度由两个数据的规模来决定的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int cal(int m, int n) &#123;</span><br><span class="line">  int sum_1 &#x3D; 0;</span><br><span class="line">  int i &#x3D; 1;</span><br><span class="line">  for (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 &#x3D; sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  int sum_2 &#x3D; 0;</span><br><span class="line">  int j &#x3D; 1;</span><br><span class="line">  for (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 &#x3D; sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  return sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。</p><p>最好、最坏情况时间复杂度：</p><p>如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; n 表示数组 array 的长度</span><br><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">  int i &#x3D; 0;</span><br><span class="line">  int pos &#x3D; -1;</span><br><span class="line">  for (; i &lt; n; ++i) &#123;</span><br><span class="line">    if (array[i] &#x3D;&#x3D; x) &#123;</span><br><span class="line">       pos &#x3D; i;</span><br><span class="line">       break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>平均情况复杂度：</p><p>要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中</p><p>把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，即：<br><img src="https://static001.geekbang.org/resource/image/d8/2f/d889a358b8eccc5bbb90fc16e327a22f.jpg" alt="image"><br>时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以，咱们把刚刚这个公式简化之后，得到的平均时间复杂度就是 O(n)。</p><h1 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void print(int n) &#123;</span><br><span class="line">  int i &#x3D; 0;</span><br><span class="line">  int[] a &#x3D; new int[n];</span><br><span class="line">  for (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] &#x3D; i * i;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  for (i &#x3D; n-1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81String/String/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81String/String/</url>
      
        <content type="html"><![CDATA[<p>==在String中，其实最底层的实现就是通过一个final char value[] 来保存String字符串的，所有的方法操作都是对char[]的操作==</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line"></span><br><span class="line">    private final char value[];</span><br><span class="line"></span><br><span class="line">    private int hash; </span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; -6849794470754667710L;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><ul><li><p>java.io.Serializable这个序列化接口没有任何方法和域，仅用于标识序列化的语意。</p></li><li><p>Comparable<String>这个接口只有一个compareTo(T 0)接口，用于对两个实例化对象比较大小。</p></li><li><p>CharSequence这个接口是一个只读的字符序列。包括length(), charAt(int index), subSequence(int start, int end)这几个API接口，值得一提的是，StringBuffer和StringBuild也是实现了改接口。</p></li></ul><ul><li><p>value[]是存储String的内容的，即当使用String str = “abc”;的时候，本质上，”abc”是存储在一个char类型的数组中的。</p></li><li><p>hash是String实例化的hashcode的一个缓存。因为String经常被用于比较，比如在HashMap中。如果每次进行比较都重新计算hashcode的值的话，那无疑是比较麻烦的，而保存一个hashcode的缓存无疑能优化这样的操作。</p></li></ul><h2 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public String() &#123;</span><br><span class="line">    this.value &#x3D; &quot;&quot;.value;</span><br><span class="line">&#125;</span><br><span class="line">public String(String original) &#123;</span><br><span class="line">    this.value &#x3D; original.value;</span><br><span class="line">    this.hash &#x3D; original.hash;</span><br><span class="line">&#125;</span><br><span class="line">public String(char value[]) &#123;</span><br><span class="line">    this.value &#x3D; Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br><span class="line">public String(char value[], int offset, int count) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public String(int[] codePoints, int offset, int count) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">@Deprecated</span><br><span class="line">public String(byte ascii[], int hibyte, int offset, int count) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">public String(byte ascii[], int hibyte) &#123;</span><br><span class="line">    this(ascii, hibyte, 0, ascii.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因此String s=new String();创建的一个空 “”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String() &#123;</span><br><span class="line">    this.value &#x3D; &quot;&quot;.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String支持多种初始化方法，包括接收String，char[],byte[],StringBuffer等多种参数类型的初始化方法。但本质上，其实就是将接收到的参数传递给全局变量value[]。</p><h2 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int length() &#123;</span><br><span class="line">        return value.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return value.length &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public char charAt(int index) &#123;</span><br><span class="line">        if ((index &lt; 0) || (index &gt;&#x3D; value.length)) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(index);</span><br><span class="line">        &#125;</span><br><span class="line">        return value[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>知道了String其实内部是通过char[]实现的，那么就不难发现length()，isEmpty()，charAt()这些方法其实就是在内部调用数组的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取当前字符串的二进制</span><br><span class="line">    public void getBytes(int srcBegin, int srcEnd, byte dst[], int dstBegin) &#123;</span><br><span class="line">        if (srcBegin &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">        &#125;</span><br><span class="line">        if (srcEnd &gt; value.length) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        if (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">        &#125;</span><br><span class="line">        Objects.requireNonNull(dst);</span><br><span class="line"></span><br><span class="line">        int j &#x3D; dstBegin;</span><br><span class="line">        int n &#x3D; srcEnd;</span><br><span class="line">        int i &#x3D; srcBegin;</span><br><span class="line">        char[] val &#x3D; value;   &#x2F;* avoid getfield opcode *&#x2F;</span><br><span class="line"></span><br><span class="line">        while (i &lt; n) &#123;</span><br><span class="line">            dst[j++] &#x3D; (byte)val[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public byte[] getBytes(String charsetName)</span><br><span class="line">            throws UnsupportedEncodingException &#123;</span><br><span class="line">        if (charsetName &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        return StringCoding.encode(charsetName, value, 0, value.length);</span><br><span class="line">    &#125;</span><br><span class="line">　　</span><br><span class="line">　　public byte[] getBytes() &#123;</span><br><span class="line">    　　return StringCoding.encode(value, 0, value.length);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>将String字符串转成二进制的几种方式，可以指定byte数组，也能让其返回一个byte数组。本质上，其实都是调用了StringCoding.encode()这个静态方法</p><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p> hashCode()和equals()两个方法比较重要且有所关系就放一起了，equals()是string能成为广泛用于Map[key,value]中key的关键所在。</p><p>==equals逻辑==：</p><ul><li>1、先判断是否是当前对象，</li><li>2、判断字符串（char数组）长度是否相等</li><li>3、遍历char[],判断每个char字符是否相等</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">        if (this &#x3D;&#x3D; anObject) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (anObject instanceof String) &#123;</span><br><span class="line">            String anotherString &#x3D; (String)anObject;</span><br><span class="line">            int n &#x3D; value.length;</span><br><span class="line">            if (n &#x3D;&#x3D; anotherString.value.length) &#123;</span><br><span class="line">                char v1[] &#x3D; value;</span><br><span class="line">                char v2[] &#x3D; anotherString.value;</span><br><span class="line">                int i &#x3D; 0;</span><br><span class="line">                while (n-- !&#x3D; 0) &#123;</span><br><span class="line">                    if (v1[i] !&#x3D; v2[i])</span><br><span class="line">                        return false;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">        int h &#x3D; hash;</span><br><span class="line">        if (h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">            char val[] &#x3D; value;</span><br><span class="line"></span><br><span class="line">            for (int i &#x3D; 0; i &lt; value.length; i++) &#123;</span><br><span class="line">                h &#x3D; 31 * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash &#x3D; h;</span><br><span class="line">        &#125;</span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在String中，其实最底层的实现就是通过一个final char value[] 来保存String字符串的，所有的方法操作都是对char[]的操作，抓住这一点，其实很多设计方法，方法的实现方式就显而易见了。</p><p>==细节==：<br>string.intern</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">判断这个常量是否存在于常量池。</span><br><span class="line">  如果存在</span><br><span class="line">   判断存在内容是引用还是常量，</span><br><span class="line">    如果是引用，</span><br><span class="line">     返回引用地址指向堆空间对象，</span><br><span class="line">    如果是常量，</span><br><span class="line">     直接返回常量池常量</span><br><span class="line">  如果不存在，</span><br><span class="line">   将当前对象引用复制到常量池,并且返回的是当前对象的引用</span><br></pre></td></tr></table></figure><p>jdk1.7之前，字符串常量存储在方法区的PermGen Space</p><p>在jdk1.7之后，字符串常量重新被移到了堆中。</p><h3 id="字符串拼接-和concat的区别"><a href="#字符串拼接-和concat的区别" class="headerlink" title="字符串拼接+和concat的区别"></a>字符串拼接+和concat的区别</h3><ul><li>+可以是字符串或者数字及其他基本类型数据，而concat只能接收字符串。<br>如果拼接空字符串，concat会稍快，在速度上两者可以忽略不计，如果拼接更多字符串建议用StringBuilder</li><li>从字节码来看+号编译后就是使用了StringBuiler来拼接，所以一行+++的语句就会创建一个StringBuilder，多条+++语句就会创建多个，所以为什么建议用StringBuilder的原因。</li><li>+左右可以为null，concat为会空指针。</li><li>申明赋值的String与new String();的区别：<br>String a=”aa”;是再常量池中创建一个aa的字符串<br>String a=new String(“aa”);是创建一个String的应用类型等式右半边存放与堆区。在栈区中的a指向堆区的引用地址。</li></ul>]]></content>
      
      
      <categories>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发三大利器：限流</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84%E7%AD%96%E7%95%A5/2%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%89%E5%A4%A7%E5%88%A9%E5%99%A8%EF%BC%9A%E9%99%90%E6%B5%81/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84%E7%AD%96%E7%95%A5/2%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%89%E5%A4%A7%E5%88%A9%E5%99%A8%EF%BC%9A%E9%99%90%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>有些时候，缓存和降级是解决不了问题的，比如，电商的双十一，用户的购买，下单等行为，是涉及到大量写操作，而且是核心链路，无法降级的。</p><ul><li>缓存:将数据缓存起来，减少数据库压力，保护DB和磁盘IO</li><li>降级:保护核心系统/服务，降低非核心系统业务请求响应，防止请求积压过多引发系统崩溃</li><li>限流:在某一时间段内或者某常规时间对请求进行限制访问，保护系统</li></ul><h4 id="一、在哪些节点做访问限流"><a href="#一、在哪些节点做访问限流" class="headerlink" title="一、在哪些节点做访问限流"></a>一、在哪些节点做访问限流</h4><p>网关、接口</p><h4 id="二、限流的方式【两窗两桶】"><a href="#二、限流的方式【两窗两桶】" class="headerlink" title="二、限流的方式【两窗两桶】"></a>二、限流的方式【两窗两桶】</h4><h5 id="1、固定时间窗口-计数器算法"><a href="#1、固定时间窗口-计数器算法" class="headerlink" title="1、固定时间窗口-计数器算法"></a>1、固定时间窗口-计数器算法</h5><p>计数器算法是限流算法里最简单也是最容易实现的一种算法。计数器算法是使用计数器在周期内累加访问次数，当达到设定的限流值时，触发限流策略。下一个周期开始时，进行清零，重新计数。【redis的incr原子自增性和线程安全即可轻松实现。】</p><p>计数器算法是限流算法里最简单也是最容易实现的一种算法。比如我们规定，对于A接口来说，我们1分钟的访问次数不能超过100个。那么我们可以这么做：在一开 始的时候，我们可以设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个 请求的间隔时间还在1分钟之内，那么说明请求数过多；如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置 counter</p><p>致命的临界问题</p><p>假设有一个恶意用户，他在0:59时，瞬间发送了100个请求，并且1:00又瞬间发送了100个请求，那么其实这个用户在 1秒里面，瞬间发送了200个请求。我们刚才规定的是1分钟最多100个请求，也就是每秒钟最多1.7个请求，用户通过在时间窗口的重置节点处突发请求， 可以瞬间超过我们的速率限制。用户有可能通过算法的这个漏洞，瞬间压垮我们的应用</p><h5 id="2、滑动时间窗口-计数器算法"><a href="#2、滑动时间窗口-计数器算法" class="headerlink" title="2、滑动时间窗口-计数器算法"></a>2、滑动时间窗口-计数器算法</h5><p>固定窗口就像是滑动窗口的一个特例。滑动窗口将固定窗口再等分为多个小的窗口，每一次对一个小的窗口进行流量控制。这种方法可以很好的解决之前的临界问题。</p><p>假设我们将1s划分为4个窗口，则每个窗口对应250ms。假设恶意用户还是在上一秒的最后一刻和下一秒的第一刻冲击服务，按照滑动窗口的原理，此时统计上一秒的最后750毫秒和下一秒的前250毫秒，这种方式能够判断出用户的访问依旧超过了1s的访问数量，因此依然会阻拦用户的访问。</p><h5 id="2、漏桶算法"><a href="#2、漏桶算法" class="headerlink" title="2、漏桶算法"></a>2、漏桶算法</h5><p>当请求到达时，就是往漏桶里“加水”，而当请求被处理掉，就是水从漏桶的底部漏出。水漏出的速度是固定的，当“加水”太快，桶就会溢出，也就是“拒绝请求”。从而使得桶里的水的体积不可能超出桶的容量。</p><p>该算法存在三个变量：桶的容量capacity，水漏出的速度rate，以及当前的水量water。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">long timeStamp&#x3D;getNowTime();</span><br><span class="line">int capacity; &#x2F;&#x2F; 桶的容量</span><br><span class="line">int rate ; &#x2F;&#x2F;水漏出的速度</span><br><span class="line">int water; &#x2F;&#x2F;当前水量</span><br><span class="line"></span><br><span class="line">bool limitFlow() &#123;</span><br><span class="line">  &#x2F;&#x2F;先执行漏水，因为rate是固定的，所以可以认为“时间间隔*rate”即为漏出的水量</span><br><span class="line">  long now &#x3D; getNowTime();</span><br><span class="line">  water &#x3D; max(0, water- (now - timeStamp)*rate);</span><br><span class="line">  timeStamp &#x3D; now;</span><br><span class="line"></span><br><span class="line">  if (water &lt; capacity) &#123; &#x2F;&#x2F; 水还未满，加水</span><br><span class="line">    water ++;</span><br><span class="line">    return true;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return false;&#x2F;&#x2F;水满，拒绝加水</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、令牌桶算法"><a href="#3、令牌桶算法" class="headerlink" title="3、令牌桶算法"></a>3、令牌桶算法</h5><p>令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。从原理上看，令牌桶算法和漏桶算法是相反的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">long timeStamp&#x3D;getNowTime();</span><br><span class="line">int capacity; &#x2F;&#x2F; 桶的容量</span><br><span class="line">int rate ; &#x2F;&#x2F;令牌放入速度</span><br><span class="line">int tokens; &#x2F;&#x2F;当前水量</span><br><span class="line"></span><br><span class="line">bool limitFlow() &#123;</span><br><span class="line">  &#x2F;&#x2F;先执行添加令牌的操作</span><br><span class="line">  long now &#x3D; getNowTime();</span><br><span class="line">  tokens &#x3D; max(capacity, tokens+ (now - timeStamp)*rate);</span><br><span class="line">  timeStamp &#x3D; now;</span><br><span class="line">  &#x2F;&#x2F;令牌已用完，拒绝访问</span><br><span class="line">  if(tokens&lt;1)&#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;else&#123;&#x2F;&#x2F;还有令牌，领取令牌</span><br><span class="line">    tokens--;</span><br><span class="line">    retun true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Google开源工具包Guava提供了限流工具类RateLimiter，该类基于令牌桶算法来完成限流，非常易于使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;26.0-jre&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;预估数据库能承受并发10，超过了可能会造成故障，我们就可以对该请求接口进行限流。</span><br><span class="line">RateLimiter rateLimiter &#x3D; RateLimiter.create(10);  </span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;&#x2F;test&quot;)  </span><br><span class="line">public Object test() &#123;  </span><br><span class="line">    &#x2F;&#x2F;rateLimiter.acquire()该方法会阻塞线程，直到令牌桶中能取到令牌为止才继续向下执行，并返回等待的时间。</span><br><span class="line">     System.out.println(&quot;等待时间&quot; + rateLimiter.acquire());  </span><br><span class="line">&#x2F;&#x2F;处理购买逻辑 ...</span><br><span class="line"></span><br><span class="line">return &quot;购买成功&quot;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">acquire()</span><br><span class="line">从RateLimiter获取一个许可，该方法会被阻塞直到获取到请求</span><br><span class="line"></span><br><span class="line">acquire(int permits)</span><br><span class="line">从RateLimiter获取指定许可数，该方法会被阻塞直到获取到请求</span><br><span class="line"></span><br><span class="line">create(double permitsPerSecond)</span><br><span class="line">根据指定的稳定吞吐率创建RateLimiter，这里的吞吐率是指每秒多少许可数（通常是指QPS，每秒多少查询）</span><br><span class="line"></span><br><span class="line">create(double permitsPerSecond, long warmupPeriod, TimeUnit unit)</span><br><span class="line">根据指定的稳定吞吐率和预热期来创建RateLimiter，这里的吞吐率是指每秒多少许可数（通常是指QPS，每秒多少个请求量），在这段预热时间内，RateLimiter每秒分配的许可数会平稳地增长直到预热期结束时达到其最大速率。（只要存在足够请求数来使其饱和）</span><br><span class="line"></span><br><span class="line">getRate()</span><br><span class="line">返回RateLimiter 配置中的稳定速率，该速率单位是每秒多少许可数</span><br><span class="line"></span><br><span class="line">setRate(double permitsPerSecond)</span><br><span class="line">更新RateLimite的稳定速率，参数permitsPerSecond 由构造RateLimiter的工厂方法提供。</span><br><span class="line"></span><br><span class="line">tryAcquire()</span><br><span class="line">从RateLimiter 获取许可，如果该许可可以在无延迟下的情况下立即获取得到的话</span><br><span class="line"></span><br><span class="line">tryAcquire(int permits)</span><br><span class="line">从RateLimiter 获取许可数，如果该许可数可以在无延迟下的情况下立即获取得到的话</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tryAcquire(int permits, long timeout, TimeUnit unit)</span><br><span class="line">从RateLimiter 获取指定许可数如果该许可数可以在不超过timeout的时间内获取得到的话，或者如果无法在timeout 过期之前获取得到许可数的话，那么立即返回false （无需等待）</span><br><span class="line"></span><br><span class="line">tryAcquire(long timeout, TimeUnit unit)</span><br><span class="line">从RateLimiter 获取许可如果该许可可以在不超过timeout的时间内获取得到的话，或者如果无法在timeout 过期之前获取得到许可的话，那么立即返回false（无需等待）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 高并发架构策略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发三大利器：限流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jedis原理</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/7%E3%80%81jedis%E5%8E%9F%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/7%E3%80%81jedis%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>由于redis是C语言写的，java语言要与C语言交互的方式JNI或网络通信。java 提供的Jedis客户端，操作redis。</p><p>6379端口为发明者喜欢的女明星的首字母。</p><p><a href="https://github.com/xetorthio/jedis">https://github.com/xetorthio/jedis</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis &#x3D; new Jedis(&quot;localhost&quot;);</span><br><span class="line">jedis.set(&quot;mykey&quot;, &quot;Hello&quot;);</span><br><span class="line">String value &#x3D; jedis.get(&quot;mykey&quot;);</span><br></pre></td></tr></table></figure><p>jedis是连接redis的客户端，既然是客户端就有服务端，就是典型的cs架构。既然是cs就会涉及到网络通信/通信协议。java就是socket，协议为redis的RESP协议</p><h2 id="redis请求协议："><a href="#redis请求协议：" class="headerlink" title="redis请求协议："></a>redis请求协议：</h2><ul><li>客户端和服务器通过 TCP 连接来进行数据交互， 服务器默认的端口号为 6379 。</li><li>客户端和服务器发送的命令或数据一律以 \r\n （CRLF）结尾。</li><li>在这个协议中， 所有发送至 Redis 服务器的参数都是二进制安全（binary safe）的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*&lt;参数数量&gt; CR LF</span><br><span class="line">$&lt;参数 1 的字节数量&gt; CR LF</span><br><span class="line">&lt;参数 1 的数据&gt; CR LF</span><br><span class="line">...</span><br><span class="line">$&lt;参数 N 的字节数量&gt; CR LF</span><br><span class="line">&lt;参数 N 的数据&gt; CR LF</span><br></pre></td></tr></table></figure>用SET命令来举例说明RESP协议的格式。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）redis客户端：</span><br><span class="line">redis&gt; SET mykey &quot;Hello&quot;</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">（2）redis客户端：</span><br><span class="line">jedis.set(&quot;mykey&quot;, &quot;Hello&quot;);</span><br></pre></td></tr></table></figure><p>实际本质发送的请求数据为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$5\r\nHello\r\n</span><br><span class="line"></span><br><span class="line">#格式化：</span><br><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">SET</span><br><span class="line">$5</span><br><span class="line">mykey</span><br><span class="line">$5</span><br><span class="line">Hello</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2、返回协议："><a href="#2、返回协议：" class="headerlink" title="2、返回协议："></a>2、返回协议：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#RESP有五种最小的单元类型，单元结束时统一加上回车换行符号\r\n。</span><br><span class="line">For Simple Strings the first byte of the reply is &quot;+&quot;</span><br><span class="line">For Errors the first byte of the reply is &quot;-&quot;</span><br><span class="line">For Integers the first byte of the reply is &quot;:&quot;</span><br><span class="line">For Bulk Strings the first byte of the reply is &quot;$&quot;</span><br><span class="line">For Arrays the first byte of the reply is &quot;*&quot;</span><br><span class="line"></span><br><span class="line">#翻译为：</span><br><span class="line">单行字符串 以 + 符号开头。</span><br><span class="line">多行字符串 以 $ 符号开头，后跟字符串长度。</span><br><span class="line">整数值 以 : 符号开头，后跟整数的字符串形式。</span><br><span class="line">错误消息 以 - 符号开头。</span><br><span class="line">数组 以 * 号开头，后跟数组的长度。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际收到的响应数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+OK\r\n</span><br><span class="line"></span><br><span class="line">#其他回复</span><br><span class="line">状态回复（status reply）的第一个字节是 “+”</span><br><span class="line">错误回复（error reply）的第一个字节是 “-“</span><br><span class="line">整数回复（integer reply）的第一个字节是 “:”</span><br><span class="line">批量回复（bulk reply）的第一个字节是 “$”</span><br><span class="line">多条批量回复（multi bulk reply）的第一个字节是 “*”</span><br></pre></td></tr></table></figure><h2 id="3、jedis原理"><a href="#3、jedis原理" class="headerlink" title="3、jedis原理"></a>3、jedis原理</h2><p>jedis等客户端就是按照resp协议，拼接数据，发送给redis.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  提供api服务</span><br><span class="line"> * *&#x2F;</span><br><span class="line">public class Client &#123;</span><br><span class="line">    private Connection connection;</span><br><span class="line"></span><br><span class="line">    public Client(String host, int port) &#123;</span><br><span class="line">        connection &#x3D; new Connection(host, port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String set(String key, String value) &#123;</span><br><span class="line">        set(SafeEncoder.encode(key), SafeEncoder.encode(value));</span><br><span class="line">        return connection.getStatusReply();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(byte[] key, byte[] value) &#123;</span><br><span class="line">        this.connection.sendCommand(Protocol.Command.SET,new byte[][]&#123;key,value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String get(String key) &#123;</span><br><span class="line">        this.connection.sendCommand(Protocol.Command.GET,SafeEncoder.encode(key));</span><br><span class="line">        return connection.getStatusReply();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  编码</span><br><span class="line"> * *&#x2F;</span><br><span class="line">public class SafeEncoder &#123;</span><br><span class="line"></span><br><span class="line">    public static byte[] encode(String str) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (str &#x3D;&#x3D; null) &#123;</span><br><span class="line">                throw new JedisDataException(&quot;value sent to redis cannot be null&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return str.getBytes(&quot;UTF-8&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (UnsupportedEncodingException var2) &#123;</span><br><span class="line">            throw new JedisException(var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 建立连接</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Connection &#123;</span><br><span class="line">    private Socket socket;</span><br><span class="line">    private String host;</span><br><span class="line">    private int port;</span><br><span class="line">    private OutputStream outputStream;</span><br><span class="line">    private InputStream inputStream;</span><br><span class="line"></span><br><span class="line">    public Connection(String host, int port) &#123;</span><br><span class="line">        this.host &#x3D; host;</span><br><span class="line">        this.port &#x3D; port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送命令</span><br><span class="line">    public Connection sendCommand(Protocol.Command cmd, byte[]... args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.connect();</span><br><span class="line">            Protocol.sendCommand(this.outputStream, cmd, args);</span><br><span class="line">            &#x2F;&#x2F;++this.pipelinedCommands;</span><br><span class="line">            return this;</span><br><span class="line">        &#125; catch (JedisConnectionException var6) &#123;</span><br><span class="line">            throw var6;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果未建立连接，则scoket 连接</span><br><span class="line">    public void connect() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!isConnected()) &#123;</span><br><span class="line">                socket &#x3D; new Socket(host, port);</span><br><span class="line">                inputStream &#x3D; socket.getInputStream();</span><br><span class="line">                outputStream &#x3D; socket.getOutputStream();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断是否已建立连接</span><br><span class="line">    public boolean isConnected() &#123;</span><br><span class="line">        return socket !&#x3D; null &amp;&amp; socket.isBound() &amp;&amp; !socket.isClosed() &amp;&amp; socket.isConnected()</span><br><span class="line">                &amp;&amp; !socket.isInputShutdown() &amp;&amp; !socket.isOutputShutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取返回信息</span><br><span class="line">    public String getStatusReply() &#123;</span><br><span class="line">        byte b[] &#x3D; new byte[1024];</span><br><span class="line">        try &#123;</span><br><span class="line">            socket.getInputStream().read(b);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  进行协议编码</span><br><span class="line"> * *&#x2F;</span><br><span class="line">public class Protocol &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * *    &lt;参数数量&gt; CR LF</span><br><span class="line">     * $    &lt;参数 1 的字节数量&gt; CR LF</span><br><span class="line">     *      &lt;参数 1 的数据&gt; CR LF</span><br><span class="line">     *      ...</span><br><span class="line">     * $    &lt;参数 N 的字节数量&gt; CR LF</span><br><span class="line">     *      &lt;参数 N 的数据&gt; CR LF</span><br><span class="line">     * *&#x2F;</span><br><span class="line"></span><br><span class="line">    public static final String PARAM_BYTE_NUM  &#x3D; &quot;$&quot;;</span><br><span class="line">    public static final String PARAM_NUM       &#x3D; &quot;*&quot;;</span><br><span class="line">    public static final String TERMINATION     &#x3D; &quot;\r\n&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void sendCommand(OutputStream outputStream, Command command, byte[]... b) &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">            照着 SET mykey myvalue 的格式进行编码：</span><br><span class="line">            *3</span><br><span class="line">            $3</span><br><span class="line">                SET</span><br><span class="line">            $5</span><br><span class="line">                mykey</span><br><span class="line">            $7</span><br><span class="line">                myvalue</span><br><span class="line">            最终如下：</span><br><span class="line">            &quot;*3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$7\r\nmyvalue\r\n&quot;</span><br><span class="line">        *&#x2F;</span><br><span class="line">        StringBuffer stringBuffer &#x3D; new StringBuffer();</span><br><span class="line">        stringBuffer.append(PARAM_NUM).append(b.length + 1).append(TERMINATION);</span><br><span class="line">        stringBuffer.append(PARAM_BYTE_NUM).append(command.name().length()).append(TERMINATION);</span><br><span class="line">        stringBuffer.append(command).append(TERMINATION);</span><br><span class="line">        for (byte[] arg : b) &#123;</span><br><span class="line">            stringBuffer.append(PARAM_BYTE_NUM).append(arg.length).append(TERMINATION);</span><br><span class="line">            stringBuffer.append(new String(arg)).append(TERMINATION);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            outputStream.write(stringBuffer.toString().getBytes());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static enum Command &#123;</span><br><span class="line">        SET,</span><br><span class="line">        GET;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Jedis &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Client client &#x3D; new Client(&quot;192.168.5.100&quot;,6379);</span><br><span class="line">        System.out.println(client.set(&quot;name&quot;,&quot;xxxx&quot;));</span><br><span class="line">        System.out.println(client.get(&quot;name&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jedis原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/10%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/10%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>我们在字符串 A 中查找字符串 B，那字符串 A 就是主串，字符串 B 就是模式串。我们把主串的长度记作 n，模式串的长度记作 m。因为我们是在主串中查找模式串，所以 n&gt;m。</p><h2 id="BF（暴力匹配算法、朴素算法）O-n-m"><a href="#BF（暴力匹配算法、朴素算法）O-n-m" class="headerlink" title="BF（暴力匹配算法、朴素算法）O(n*m)"></a>BF（暴力匹配算法、朴素算法）O(n*m)</h2><p>在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class ViolenceMatch &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">&#x2F;&#x2F;测试暴力匹配算法</span><br><span class="line">String str1 &#x3D; &quot;aaabbaaaccssdd&quot;;</span><br><span class="line">String str2 &#x3D; &quot;acc&quot;;</span><br><span class="line">int index &#x3D; violenceMatch(str1, str2);</span><br><span class="line">System.out.println(&quot;index&#x3D;&quot; + index);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 暴力匹配算法实现</span><br><span class="line">public static int violenceMatch(String str1, String str2) &#123;</span><br><span class="line">char[] s1 &#x3D; str1.toCharArray();</span><br><span class="line">char[] s2 &#x3D; str2.toCharArray();</span><br><span class="line"></span><br><span class="line">int s1Len &#x3D; s1.length;</span><br><span class="line">int s2Len &#x3D; s2.length;</span><br><span class="line"></span><br><span class="line">int i &#x3D; 0; &#x2F;&#x2F; i索引指向s1</span><br><span class="line">int j &#x3D; 0; &#x2F;&#x2F; j索引指向s2</span><br><span class="line">while (i &lt; s1Len &amp;&amp; j &lt; s2Len) &#123;&#x2F;&#x2F; 保证匹配时，不越界</span><br><span class="line"></span><br><span class="line">if(s1[i] &#x3D;&#x3D; s2[j]) &#123;&#x2F;&#x2F;匹配ok</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125; else &#123; &#x2F;&#x2F;没有匹配成功</span><br><span class="line">&#x2F;&#x2F;如果失配（即str1[i]! &#x3D; str2[j]），令i &#x3D; i - (j - 1)，j &#x3D; 0。</span><br><span class="line">i &#x3D; i - (j - 1);</span><br><span class="line">j &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断是否匹配成功</span><br><span class="line">if(j &#x3D;&#x3D; s2Len) &#123;</span><br><span class="line">return i - j;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="RK算法-O-n-：-是BF算法的升级版引入hash算法用于字符串的比较"><a href="#RK算法-O-n-：-是BF算法的升级版引入hash算法用于字符串的比较" class="headerlink" title="RK算法 O(n)： 是BF算法的升级版引入hash算法用于字符串的比较"></a>RK算法 O(n)： 是BF算法的升级版引入hash算法用于字符串的比较</h2><p>在BF算法中，如果模式串长度为 m，主串长度为 n，那在主串中，就会有 n-m+1 个长度为 m 的子串，我们只需要暴力地对比这 n-m+1 个子串与模式串，就可以找出主串与模式串匹配的子串。但是，每次检查主串与子串是否匹配，需要依次比对每个字符，时间复杂较高O(n*m )</p><p>我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值是否相等（数字比较效率优于字符串的比较）只是比较的效率提高 整体的效率还是一样。</p><p>hash算法的设计就很重要:==假设要匹配的字符串的字符集中只包含 K 个字符，我们可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。==</p><h2 id="BM算法："><a href="#BM算法：" class="headerlink" title="BM算法："></a>BM算法：</h2><p>我们把模式串和主串的匹配过程，看作模式串在主串中不停地往后滑动。当遇到不匹配的字符时，BF 算法和 RK 算法的做法是，模式串往后滑动一位，然后从模式串的第一个字符开始重新匹配。<br><img src="https://static001.geekbang.org/resource/image/43/f9/4316dd98eac500a01a0fd632bb5e77f9.jpg" alt="image"></p><p>主串中的 c，在模式串中是不存在的，所以，模式串向后滑动的时候，只要 c 与模式串有重合，肯定无法匹配。所以，我们可以一次性把模式串往后多滑动几位，把模式串移动到 c 的后面。到底将模式串往后多滑动几位呢， BM算法的本质就是寻找这个规律。</p><p>模式串的末尾往前倒着匹配，当我们发现某个字符没法匹配的时候。我们把这个没有匹配的字符叫作坏字符（主串中的字符）。</p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p><a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html">https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class KMPAlgorithm &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">String str1 &#x3D; &quot;BBC ABCDAB ABCDABCDABDE&quot;;</span><br><span class="line">String str2 &#x3D; &quot;ABCDABD&quot;;</span><br><span class="line">&#x2F;&#x2F;String str2 &#x3D; &quot;BBC&quot;;</span><br><span class="line"></span><br><span class="line">int[] next &#x3D; kmpNext(&quot;ABCDABD&quot;); &#x2F;&#x2F;[0, 1, 2, 0]</span><br><span class="line">System.out.println(&quot;next&#x3D;&quot; + Arrays.toString(next));</span><br><span class="line"></span><br><span class="line">int index &#x3D; kmpSearch(str1, str2, next);</span><br><span class="line">System.out.println(&quot;index&#x3D;&quot; + index); &#x2F;&#x2F; 15了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;写出我们的kmp搜索算法</span><br><span class="line">&#x2F;**</span><br><span class="line"> * </span><br><span class="line"> * @param str1 源字符串</span><br><span class="line"> * @param str2 子串</span><br><span class="line"> * @param next 部分匹配表, 是子串对应的部分匹配表</span><br><span class="line"> * @return 如果是-1就是没有匹配到，否则返回第一个匹配的位置</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static int kmpSearch(String str1, String str2, int[] next) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;遍历 </span><br><span class="line">for(int i &#x3D; 0, j &#x3D; 0; i &lt; str1.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;需要处理 str1.charAt(i) ！&#x3D; str2.charAt(j), 去调整j的大小</span><br><span class="line">&#x2F;&#x2F;KMP算法核心点, 可以验证...</span><br><span class="line">while( j &gt; 0 &amp;&amp; str1.charAt(i) !&#x3D; str2.charAt(j)) &#123;</span><br><span class="line">j &#x3D; next[j-1]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(str1.charAt(i) &#x3D;&#x3D; str2.charAt(j)) &#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">if(j &#x3D;&#x3D; str2.length()) &#123;&#x2F;&#x2F;找到了 &#x2F;&#x2F; j &#x3D; 3 i </span><br><span class="line">return i - j + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return  -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取到一个字符串(子串) 的部分匹配值表</span><br><span class="line">public static  int[] kmpNext(String dest) &#123;</span><br><span class="line">&#x2F;&#x2F;创建一个next 数组保存部分匹配值</span><br><span class="line">int[] next &#x3D; new int[dest.length()];</span><br><span class="line">next[0] &#x3D; 0; &#x2F;&#x2F;如果字符串是长度为1 部分匹配值就是0</span><br><span class="line">for(int i &#x3D; 1, j &#x3D; 0; i &lt; dest.length(); i++) &#123;</span><br><span class="line">&#x2F;&#x2F;当dest.charAt(i) !&#x3D; dest.charAt(j) ，我们需要从next[j-1]获取新的j</span><br><span class="line">&#x2F;&#x2F;直到我们发现 有  dest.charAt(i) &#x3D;&#x3D; dest.charAt(j)成立才退出</span><br><span class="line">&#x2F;&#x2F;这时kmp算法的核心点</span><br><span class="line">while(j &gt; 0 &amp;&amp; dest.charAt(i) !&#x3D; dest.charAt(j)) &#123;</span><br><span class="line">j &#x3D; next[j-1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当dest.charAt(i) &#x3D;&#x3D; dest.charAt(j) 满足时，部分匹配值就是+1</span><br><span class="line">if(dest.charAt(i) &#x3D;&#x3D; dest.charAt(j)) &#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">next[i] &#x3D; j;</span><br><span class="line">&#125;</span><br><span class="line">return next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多模式串匹配：AC自动机"><a href="#多模式串匹配：AC自动机" class="headerlink" title="多模式串匹配：AC自动机"></a>多模式串匹配：AC自动机</h2><p>BF 算法、RK 算法、BM 算法、KMP 算法，还有 Trie 树。前面四种算法都是单模式串匹配算法，只有 Trie 树是多模式串匹配算法。</p><p>多个模式串和一个主串之间做匹配。</p><p>将模式串作为主串，从第一个字符（假设是字符 C）开始，在 Trie 树中匹配。当匹配到 Trie 树的叶子节点，或者中途遇到不匹配字符的时候，我们将主串的开始匹配位置后移一位，也就是从字符 C 的下一个字符开始，重新在 Trie 树中匹配。</p><p>基于 Trie 树的这种处理方法，有点类似单模式串匹配的 BF 算法。我们知道，单模式串匹配算法中，KMP 算法对 BF 算法进行改进，引入了 next 数组，让匹配失败时，尽可能将模式串往后多滑动几位。借鉴单模式串的优化改进方法，能否对多模式串 Trie 树进行改进，进一步提高 Trie 树的效率呢？这就要用到 AC 自动机算法了。</p><p>==AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class AcNode &#123;</span><br><span class="line">  public char data; </span><br><span class="line">  public AcNode[] children &#x3D; new AcNode[26]; &#x2F;&#x2F; 字符集只包含 a~z 这 26 个字符</span><br><span class="line">  public boolean isEndingChar &#x3D; false; &#x2F;&#x2F; 结尾字符为 true</span><br><span class="line">  public int length &#x3D; -1; &#x2F;&#x2F; 当 isEndingChar&#x3D;true 时，记录模式串长度</span><br><span class="line">  public AcNode fail; &#x2F;&#x2F; 失败指针</span><br><span class="line">  public AcNode(char data) &#123;</span><br><span class="line">    this.data &#x3D; data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>AC 自动机的构建，包含两个操作：</p><ul><li>将多个模式串构建成 Trie 树；</li><li>在 Trie 树上构建失败指针（相当于 KMP 中的失效函数 next 数组）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于HTTP的RPC实现</title>
      <link href="2020/06/21/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RPC/3%E3%80%81%E5%9F%BA%E4%BA%8EHTTP%E7%9A%84RPC%E5%AE%9E%E7%8E%B0/"/>
      <url>2020/06/21/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RPC/3%E3%80%81%E5%9F%BA%E4%BA%8EHTTP%E7%9A%84RPC%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-新建springboot工程"><a href="#1-新建springboot工程" class="headerlink" title="1.新建springboot工程"></a>1.新建springboot工程</h2><p>使用springBeanfactory获取容器中所有bean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.yyl.rpc.common;</span><br><span class="line"> </span><br><span class="line">import javafx.fxml.Initializable;</span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.factory.InitializingBean;</span><br><span class="line">import org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContextAware;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class SpringBeanFactory implements ApplicationContextAware,InitializingBean,BeanPostProcessor &#123;</span><br><span class="line">    &#x2F;** ApplicationContext 对象 *&#x2F;</span><br><span class="line">    private ApplicationContext applicationContext;</span><br><span class="line"> </span><br><span class="line">    &#x2F;** 单子 *&#x2F;</span><br><span class="line">    private static SpringBeanFactory instance &#x3D; new SpringBeanFactory();</span><br><span class="line"> </span><br><span class="line">    public static void setInstance(SpringBeanFactory instance) &#123;</span><br><span class="line">        SpringBeanFactory.instance &#x3D; instance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static SpringBeanFactory getInstance() &#123;</span><br><span class="line">        return SpringBeanFactory.instance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; type) &#123;</span><br><span class="line">        return instance.getInnerBean(type);</span><br><span class="line">    &#125;</span><br><span class="line">    private &lt;T&gt; T getInnerBean(Class&lt;T&gt; type) &#123;</span><br><span class="line">        String[] names &#x3D; this.applicationContext.getBeanNamesForType(type);</span><br><span class="line">        if (names &#x3D;&#x3D; null || names.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return (T) this.applicationContext.getBean(names[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        SpringBeanFactory.setInstance(this);</span><br><span class="line">        String[] names &#x3D; this.applicationContext.getBeanDefinitionNames();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; names.length; i++) &#123;</span><br><span class="line">            System.out.println(&quot; &#x3D;&#x3D; names[&quot; + i + &quot;]:&quot; + names[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext &#x3D; applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="建rpccontroller接收远程调用"><a href="#建rpccontroller接收远程调用" class="headerlink" title="建rpccontroller接收远程调用"></a>建rpccontroller接收远程调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package com.yyl.rpc.controller;</span><br><span class="line"> </span><br><span class="line">import com.yyl.rpc.common.SpringBeanFactory;</span><br><span class="line">import com.yyl.rpc.domain.RpcRequestData;</span><br><span class="line">import com.yyl.rpc.domain.RpcResponseData;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"> </span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;&#x2F;rpc&quot;)</span><br><span class="line">public class RpcController &#123;</span><br><span class="line">    private final Logger logger &#x3D; LoggerFactory.getLogger(this.getClass());</span><br><span class="line">    private final Map&lt;String, Class&lt;?&gt;&gt; primitiveClassMap &#x3D; new HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        primitiveClassMap.put(Integer.TYPE.getName(), Integer.TYPE);</span><br><span class="line">        primitiveClassMap.put(Short.TYPE.getName(), Short.TYPE);</span><br><span class="line">        primitiveClassMap.put(Long.TYPE.getName(), Long.TYPE);</span><br><span class="line">        primitiveClassMap.put(Float.TYPE.getName(), Float.TYPE);</span><br><span class="line">        primitiveClassMap.put(Boolean.TYPE.getName(), Boolean.TYPE);</span><br><span class="line">        primitiveClassMap.put(Byte.TYPE.getName(), Byte.TYPE);</span><br><span class="line">        primitiveClassMap.put(Double.TYPE.getName(), Double.TYPE);</span><br><span class="line">        primitiveClassMap.put(Character.TYPE.getName(), Character.TYPE);</span><br><span class="line">        primitiveClassMap.put(Character.TYPE.getName(), Character.TYPE);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private Class&lt;?&gt; getClass(String className) throws ClassNotFoundException&#123;</span><br><span class="line">        Class&lt;?&gt; clazz &#x3D; primitiveClassMap.get(className);</span><br><span class="line">        return clazz &#x3D;&#x3D; null ? Class.forName(className) : clazz;</span><br><span class="line">    &#125;</span><br><span class="line">    @RequestMapping(&quot;&#x2F;invoke&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public RpcResponseData&lt;Object&gt; invoke(@RequestBody RpcRequestData request, HttpServletRequest httpServletRequest)&#123;</span><br><span class="line">        if(request&#x3D;&#x3D;null)&#123;</span><br><span class="line">            logger.debug(&quot;请求参数不能为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(request.getInterfaceType().isEmpty()|| request.getMethodName().isEmpty())&#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;参数有误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        RpcResponseData&lt;Object&gt; responseData&#x3D;new RpcResponseData&lt;&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            Class&lt;?&gt; clazz &#x3D; this.getClass(request.getInterfaceType());</span><br><span class="line">            Object serviceImpl&#x3D;SpringBeanFactory.getBean(clazz);</span><br><span class="line">            if(serviceImpl&#x3D;&#x3D;null)&#123;</span><br><span class="line">                throw new ClassNotFoundException(&quot;没发现服务类&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">            for (String paramTypeName:request.getParameterTypes()) &#123;</span><br><span class="line">                list.add(this.getClass(paramTypeName));</span><br><span class="line">            &#125;</span><br><span class="line">            final Method method &#x3D;clazz.getMethod(request.getMethodName(),list.toArray(new Class[0]));</span><br><span class="line">            Object object&#x3D;method.invoke(serviceImpl,request.getArgs());</span><br><span class="line">            responseData.setSuccess(true);</span><br><span class="line">            responseData.setResult(object);</span><br><span class="line"> </span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            responseData.setSuccess(false);</span><br><span class="line">            responseData.setErrorMessage(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return responseData;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="封装请求对象和返回对象"><a href="#封装请求对象和返回对象" class="headerlink" title="封装请求对象和返回对象"></a>封装请求对象和返回对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.yyl.rpc.domain;</span><br><span class="line"> </span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">@Data</span><br><span class="line"> @NoArgsConstructor</span><br><span class="line"> @AllArgsConstructor</span><br><span class="line">public class RpcRequestData &#123;</span><br><span class="line">    private String clientID;</span><br><span class="line">    private String interfaceType;</span><br><span class="line">    private String serviceName;</span><br><span class="line">    private String methodName;</span><br><span class="line">    private String args[];</span><br><span class="line">    private List&lt;String&gt; parameterTypes;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="返回对象"><a href="#返回对象" class="headerlink" title="返回对象"></a>返回对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.yyl.rpc.domain;</span><br><span class="line"> </span><br><span class="line"> @Data</span><br><span class="line"> @NoArgsConstructor</span><br><span class="line"> @AllArgsConstructor</span><br><span class="line">public class RpcResponseData&lt;T&gt; &#123;</span><br><span class="line">    private T result;</span><br><span class="line">    private boolean success;</span><br><span class="line">    private String errorMessage;</span><br><span class="line">    private String cause;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="服务接口"><a href="#服务接口" class="headerlink" title="服务接口"></a>服务接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.yyl.rpc.service;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">public interface DemoService &#123;</span><br><span class="line">    String add(String a,String b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="服务实现类"><a href="#服务实现类" class="headerlink" title="服务实现类"></a>服务实现类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.yyl.rpc.service.impl;</span><br><span class="line"> </span><br><span class="line">import com.yyl.rpc.service.DemoService;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class DemoServiceImpl implements DemoService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String add(String a, String b) &#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># rpc</span><br><span class="line">#使用http实现rpc远程调用</span><br><span class="line"> </span><br><span class="line">步骤</span><br><span class="line">1.启动项目</span><br><span class="line">2.post请求模拟</span><br><span class="line">localhost:8080&#x2F;rpc&#x2F;invoke</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">   &quot;clientID&quot;:&quot;1222&quot;,</span><br><span class="line">   &quot;interfaceType&quot;:&quot;com.yyl.rpc.service.DemoService&quot;,</span><br><span class="line">   &quot;serviceName&quot;:&quot;com.yyl.rpc.service.impl.DemoServiceImpl&quot;,</span><br><span class="line">   &quot;methodName&quot;:&quot;add&quot;,</span><br><span class="line">   &quot;args&quot;:[&quot;1&quot;,&quot;22222&quot;],</span><br><span class="line">   &quot;parameterTypes&quot;:[&quot;java.lang.String&quot;,&quot;java.lang.String&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基于HTTP的RPC实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/10%E3%80%81%E5%8F%8D%E5%B0%84/1%E3%80%81%E5%8F%8D%E5%B0%84/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/10%E3%80%81%E5%8F%8D%E5%B0%84/1%E3%80%81%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>Java反射机制可以在运行期(Runtime)检查类，接口，变量以及方法的信息。反射还可以在运行期实例化对象，调用方法，通过调用get/set方法获取变量的值。</p><h3 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h3><p>检查一个类的信息之前，你首先需要获取类的Class对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class myObjectClass &#x3D; MyObject.class;</span><br><span class="line">&#x2F;&#x2F;在运行期获取的类名字符串</span><br><span class="line">String className &#x3D; ... ;</span><br><span class="line">Class class &#x3D; Class.forName(className);</span><br></pre></td></tr></table></figure><h3 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h3><p>获取全类名（含包名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass &#x3D; ... </span><br><span class="line">String className &#x3D; aClass.getName();</span><br></pre></td></tr></table></figure><p>获取类名（不含包名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass &#x3D; ...</span><br><span class="line">String simpleClassName &#x3D; aClass.getSimpleName();</span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class  aClass &#x3D; ... </span><br><span class="line">int modifiers &#x3D; aClass.getModifiers();</span><br></pre></td></tr></table></figure><p>一个类的修饰符，即public,private,static等等的关键字，每个修饰符都是一个位标识(flag bit)，可以使用java.lang.reflect.Modifier类中的方法来检查修饰符的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Modifier.isAbstract(int modifiers);</span><br><span class="line">Modifier.isFinal(int modifiers);</span><br><span class="line">Modifier.isInterface(int modifiers);</span><br><span class="line">Modifier.isNative(int modifiers);</span><br><span class="line">Modifier.isPrivate(int modifiers);</span><br><span class="line">Modifier.isProtected(int modifiers);</span><br><span class="line">Modifier.isPublic(int modifiers);</span><br><span class="line">Modifier.isStatic(int modifiers);</span><br><span class="line">Modifier.isStrict(int modifiers);</span><br><span class="line">Modifier.isSynchronized(int modifiers);</span><br><span class="line">Modifier.isTransient(int modifiers);</span><br><span class="line">Modifier.isVolatile(int modifiers);</span><br></pre></td></tr></table></figure><h3 id="包信息"><a href="#包信息" class="headerlink" title="包信息"></a>包信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Package package &#x3D; aClass.getPackage();</span><br></pre></td></tr></table></figure><h3 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h3><p>可以继续在父类对象上进行反射操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class superclass &#x3D; aClass.getSuperclass();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现的接口"><a href="#实现的接口" class="headerlink" title="实现的接口"></a>实现的接口</h3><p>由于一个类可以实现多个接口，因此getInterfaces();方法返回一个Class数组，在Java中接口同样有对应的Class对象。（当前类的父类如果实现了接口，这些接口是不会在返回的Class集合中的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class[] interfaces &#x3D; aClass.getInterfaces();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>Constructor数组包含每一个声明为公有的（Public）构造方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] constructors &#x3D; aClass.getConstructors();</span><br></pre></td></tr></table></figure><p>返回参数为String类型的构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class aClass &#x3D; ...&#x2F;&#x2F;获取Class对象</span><br><span class="line">Constructor constructor &#x3D;</span><br><span class="line">      aClass.getConstructor(new Class[]&#123;String.class&#125;);</span><br></pre></td></tr></table></figure><p>Constructor对象实例化一个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor &#x3D; MyObject.class.getConstructor(String.class);</span><br><span class="line">MyObject myObject &#x3D; (MyObject)</span><br><span class="line">       constructor.newInstance(&quot;constructor-arg1&quot;);</span><br></pre></td></tr></table></figure><p>constructor.newInstance()方法的方法参数是一个==可变参数==列表，但是当你调用构造方法的时候你必须提供精确的参数，即形参与实参必须一一对应。在这个例子中构造方法需要一个String类型的参数，那我们在调用newInstance方法的时候就必须传入一个String类型的参数。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Field对象数组包含了指定类中声明为公有的(public)的所有变量集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field[] method &#x3D; aClass.getFields();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">获取指定的变量：</span><br><span class="line">Class  aClass &#x3D; MyObject.class</span><br><span class="line">Field field &#x3D; aClass.getField(&quot;someField&quot;); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量名称</span><br><span class="line">String fieldName &#x3D; field.getName();</span><br><span class="line">&#x2F;&#x2F;变量类型</span><br><span class="line">Field field &#x3D; aClass.getField(&quot;someField&quot;);</span><br><span class="line">Object fieldType &#x3D; field.getType();</span><br><span class="line">&#x2F;&#x2F;获取或设置（get&#x2F;set）变量值</span><br><span class="line">Class  aClass &#x3D; MyObject.class</span><br><span class="line">Field field &#x3D; aClass.getField(&quot;someField&quot;);</span><br><span class="line"></span><br><span class="line">MyObject objectInstance &#x3D; new MyObject();</span><br><span class="line"></span><br><span class="line">Object value &#x3D; field.get(objectInstance);</span><br><span class="line"></span><br><span class="line">field.set(objetInstance, value);</span><br></pre></td></tr></table></figure><ul><li>==访问私有变量==<br>Class.getDeclaredField(String name)<br>Class.getDeclaredFields()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class PrivateObject &#123;</span><br><span class="line">  private String privateString &#x3D; null;</span><br><span class="line">  public PrivateObject(String privateString) &#123;</span><br><span class="line">    this.privateString &#x3D; privateString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PrivateObject privateObject &#x3D; new PrivateObject(&quot;The Private Value&quot;);</span><br><span class="line"></span><br><span class="line">Field privateStringField &#x3D; PrivateObject.class.</span><br><span class="line">            getDeclaredField(&quot;privateString&quot;);</span><br><span class="line">&#x2F;&#x2F;关闭指定类Field实例的反射访问检查(暴力反射)</span><br><span class="line">&#x2F;&#x2F;不论是私有的、受保护的以及包访问的作用域和不在他的访问权限作用域之内，可以在任何地方访问</span><br><span class="line">privateStringField.setAccessible(true);</span><br><span class="line"></span><br><span class="line">String fieldValue &#x3D; (String) privateStringField.get(privateObject);</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Method对象数组包含了指定类中声明为公有的(public)的所有变量集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class aClass &#x3D; ...&#x2F;&#x2F;获取Class对象</span><br><span class="line">Method[] method &#x3D; aClass.getMethods();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过参数类型来获取指定的方法  </span><br><span class="line">Method method &#x3D; aClass.getMethod(&quot;doSomething&quot;, new Class[]&#123;String.class&#125;);</span><br><span class="line">&#x2F;&#x2F;无参方法第二个参数传入null即可</span><br><span class="line">Method method &#x3D; aClass.getMethod(&quot;doSomething&quot;, null);</span><br><span class="line">&#x2F;&#x2F;获取指定方法的方法参数是哪些：</span><br><span class="line">Class[] parameterTypes &#x3D; method.getParameterTypes();</span><br><span class="line">&#x2F;&#x2F;获取指定方法的返回类型</span><br><span class="line">Class returnType &#x3D; method.getReturnType();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Getters and Setters不能直接寻找getters和setters，需要通过get set方法特性获取</p><ul><li>Getter方法的名字以get开头，没有方法参数，返回一个值。   </li><li>Setter方法的名字以set开头，有一个方法参数。<br>setters方法有可能会有返回值也有可能没有，一些Setter方法返回void，一些用来设置值，有一些对象的setter方法在方法链中被调用（译者注：这类的setter方法必须要有返回值），因此你不应该妄自假设setter方法的返回值，一切应该视情况而定。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void printGettersSetters(Class aClass)&#123;</span><br><span class="line">  Method[] methods &#x3D; aClass.getMethods();</span><br><span class="line"></span><br><span class="line">  for(Method method : methods)&#123;</span><br><span class="line">    if(isGetter(method)) System.out.println(&quot;getter: &quot; + method);</span><br><span class="line">    if(isSetter(method)) System.out.println(&quot;setter: &quot; + method);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean isGetter(Method method)&#123;</span><br><span class="line">  if(!method.getName().startsWith(&quot;get&quot;))      return false;</span><br><span class="line">  if(method.getParameterTypes().length !&#x3D; 0)   return false;</span><br><span class="line">  if(void.class.equals(method.getReturnType()) return false;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean isSetter(Method method)&#123;</span><br><span class="line">  if(!method.getName().startsWith(&quot;set&quot;)) return false;</span><br><span class="line">  if(method.getParameterTypes().length !&#x3D; 1) return false;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Method对象调用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取一个方法名为doSomesthing，参数类型为String的方法</span><br><span class="line">Method method &#x3D; MyObject.class.getMethod(&quot;doSomething&quot;, String.class);</span><br><span class="line">Object returnValue &#x3D; method.invoke(null, &quot;parameter-value1&quot;);</span><br></pre></td></tr></table></figure><ul><li>invoke第一个参数是调用方法的对象</li></ul><p>如果是一个静态方法调用的话则可以用null代替</p><ul><li>invoke第二个参数是一个可变参数列表</li></ul><p>==访问私有方法。==</p><p>Class.getDeclaredMethod(String name, Class[] parameterTypes)或者Class.getDeclaredMethods() </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PrivateObject privateObject &#x3D; new PrivateObject(&quot;The Private Value&quot;);</span><br><span class="line"></span><br><span class="line">Method privateStringMethod &#x3D; PrivateObject.class.</span><br><span class="line">        getDeclaredMethod(&quot;getPrivateString&quot;, null);</span><br><span class="line"></span><br><span class="line">privateStringMethod.setAccessible(true);</span><br><span class="line"></span><br><span class="line">String returnValue &#x3D; (String)</span><br><span class="line">        privateStringMethod.invoke(privateObject, null);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 反射 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger使用</title>
      <link href="2020/06/21/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/6%E3%80%81Swagger/1%E3%80%81Swagger%E4%BD%BF%E7%94%A8/"/>
      <url>2020/06/21/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/6%E3%80%81Swagger/1%E3%80%81Swagger%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。</p><p>作用：</p><pre><code>1. 接口的文档在线自动生成。2. 功能测试</code></pre><h2 id="1、引入依赖"><a href="#1、引入依赖" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;version&gt;2.2.2&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;version&gt;2.2.2&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2、在Application-java同级-下级目录创建Swagger2的配置类Swagger2"><a href="#2、在Application-java同级-下级目录创建Swagger2的配置类Swagger2" class="headerlink" title="2、在Application.java同级/下级目录创建Swagger2的配置类Swagger2"></a>2、在Application.java同级/下级目录创建Swagger2的配置类Swagger2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.qianlima.wcoceral.config.swagger2;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line">import springfox.documentation.builders.PathSelectors;</span><br><span class="line">import springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line">import springfox.documentation.service.ApiInfo;</span><br><span class="line">import springfox.documentation.spi.DocumentationType;</span><br><span class="line">import springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line">import springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class Swagger2&#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi()&#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.qianlima.wcoceral&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo()&#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;Spring Boot中使用Swagger2构建RESTful APIs&quot;)</span><br><span class="line">                .description(&quot;千里马-微商会&quot;)</span><br><span class="line">                .termsOfServiceUrl(&quot;http:&#x2F;&#x2F;zsx.com.cn&quot;)</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3、示例"><a href="#3、示例" class="headerlink" title="3、示例"></a>3、示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.swaggerTest.controller;</span><br><span class="line"> </span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.util.StringUtils;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"> </span><br><span class="line">import io.swagger.annotations.Api;</span><br><span class="line">import io.swagger.annotations.ApiImplicitParam;</span><br><span class="line">import io.swagger.annotations.ApiImplicitParams;</span><br><span class="line">import io.swagger.annotations.ApiOperation;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 一个用来测试swagger注解的控制器</span><br><span class="line"> * 注意@ApiImplicitParam的使用会影响程序运行，如果使用不当可能造成控制器收不到消息</span><br><span class="line"> * </span><br><span class="line"> * @author SUNF</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;&#x2F;say&quot;)</span><br><span class="line">@Api(value &#x3D; &quot;SayController|一个用来测试swagger注解的控制器&quot;)</span><br><span class="line">public class SayController &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    @ResponseBody</span><br><span class="line">    @RequestMapping(&quot;&#x2F;updatePassword&quot;)</span><br><span class="line">    @ApiOperation(value&#x3D;&quot;修改用户密码&quot;, notes&#x3D;&quot;根据用户id修改密码&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">        @ApiImplicitParam(paramType&#x3D;&quot;query&quot;, name &#x3D; &quot;userId&quot;, value &#x3D; &quot;用户ID&quot;, required &#x3D; true, dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">        @ApiImplicitParam(paramType&#x3D;&quot;query&quot;, name &#x3D; &quot;password&quot;, value &#x3D; &quot;旧密码&quot;, required &#x3D; true, dataType &#x3D; &quot;String&quot;),</span><br><span class="line">        @ApiImplicitParam(paramType&#x3D;&quot;query&quot;, name &#x3D; &quot;newPassword&quot;, value &#x3D; &quot;新密码&quot;, required &#x3D; true, dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    public String updatePassword(@RequestParam(value&#x3D;&quot;userId&quot;) Integer userId, @RequestParam(value&#x3D;&quot;password&quot;) String password, </span><br><span class="line">            @RequestParam(value&#x3D;&quot;newPassword&quot;) String newPassword)&#123;</span><br><span class="line">     </span><br><span class="line">      return &quot;密码修改成功!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完成上述代码添加上，启动Spring Boot程序，访问：<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></p><p>Swagger使用的注解及其说明：</p><p>@Api：用在类上，说明该类的作用。</p><p>@ApiOperation：注解来给API增加方法说明。</p><p>@ApiImplicitParams : 用在方法上包含一组参数说明。</p><p>@ApiImplicitParam：用来注解来给方法入参增加说明。</p><p>@ApiResponses：用于表示一组响应</p><p>@ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息</p><pre><code>l   code：数字，例如400l   message：信息，例如&quot;请求参数没填好&quot;l   response：抛出异常的类  </code></pre><h2 id="参数为一个实体："><a href="#参数为一个实体：" class="headerlink" title="参数为一个实体："></a>参数为一个实体：</h2><p>@ApiModel：描述一个Model的信息（一般用在请求参数无法使用@ApiImplicitParam注解进行描述的时候）</p><pre><code>l   @ApiModelProperty：描述一个model的属性</code></pre><p>注意：@ApiImplicitParam的参数说明：</p><p>paramType：指定参数放在哪个地方</p><pre><code>header：请求参数放置于Request Header，使用@RequestHeader获取query：请求参数放置于请求地址，使用@RequestParam获取path：（用于restful接口）--&gt;请求参数的获取：@PathVariablebody：（不常用）form（不常用）</code></pre><p>name：参数名</p><p>dataType：参数类型</p><p>required：参数是否必须传</p><pre><code>true | false</code></pre><p>value：说明参数的意思</p><p>defaultValue：参数的默认值</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@ApiOperation(value &#x3D; &quot;产品经理项目评价&quot;, notes &#x3D; &quot;产品经理项目评价&quot;)</span><br><span class="line">    @RequestMapping(path &#x3D; &quot;&#x2F;productManagerAssess&quot;, method &#x3D; RequestMethod.POST)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String productManagerAssess(ProductManagerAssess productManagerAssess) &#123;</span><br><span class="line">        logger.info(&quot;------------------method: productManagerAssess--------------------&quot;);</span><br><span class="line">        int result &#x3D; projectService.productManagerAssess(productManagerAssess);</span><br><span class="line">        return DataBean.requestSuccess(result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ApiModel(value&#x3D;&quot;产品经理评价实体&quot;,description&#x3D;&quot;产品经理评价实体&quot;)</span><br><span class="line">public class ProductManagerAssess &#123;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(value&#x3D;&quot;用户openId&quot;,name&#x3D;&quot;openId&quot;,dataType&#x3D;&quot;String&quot;,required&#x3D;true)</span><br><span class="line">    private String openId;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(value&#x3D;&quot;项目id&quot;,name&#x3D;&quot;projectId&quot;,dataType&#x3D;&quot;String&quot;,required&#x3D;true)</span><br><span class="line">    private String projectId;</span><br><span class="line">    &#x2F;&#x2F;get set方法 省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个注意点-："><a href="#两个注意点-：" class="headerlink" title="==两个注意点==："></a>==两个注意点==：</h2><p>1、paramType会直接影响程序的运行期，如果paramType与方法参数获取使用的注解不一致，会直接影响到参数的接收。</p><p>2、Conntroller中定义的方法必须在@RequestMapper中显示的指定RequestMethod类型，否则SawggerUi会默认为全类型皆可访问， API列表中会生成多条项目。</p>]]></content>
      
      
      <categories>
          
          <category> Swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B树和B+树</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6%E3%80%81%E6%A0%91/7%E3%80%81B%E6%A0%91%E5%92%8CB+%E6%A0%91/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6%E3%80%81%E6%A0%91/7%E3%80%81B%E6%A0%91%E5%92%8CB+%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>MySQL中MyISM和Innodb使用B+树作为索引数据结构</p><p>让二叉查找树支持按照区间来查找数据，我们可以对它进行这样的改造：==树中的节点并不存储数据本身，而是只是作为索引。除此之外，我们把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的==。类似跳表<br><img src="https://static001.geekbang.org/resource/image/25/f4/25700c1dc28ce094eed3ffac394531f4.jpg" alt="image"></p><p>我们给一亿个数据构建二叉查找树索引，那索引中会包含大约 1 亿个节点，每个节点假设占用 16 个字节，那就需要大约 1GB 的内存空间。给一张表建立索引，我们需要 1GB 的内存空间。如果我们要给 10 张表建立索引，那对内存的需求是无法满足的。如何解决这个索引占用太多内存的问题呢？</p><p>借助时间换空间的思路，==把索引存储在硬盘中==<br>那么每个节点的读取（或者访问），都对应一次磁盘 IO 操作。==树的高度就等于每次查询数据时磁盘 IO 操作的次数。==</p><p>如何降低树的高度,减少IO次数？==将二叉树转为m叉树==</p><ul><li><p>给 16 个数据构建二叉树索引，树的高度是 4，查找一个数据，就需要 4 个磁盘 IO 操作（如果根节点存储在内存中，其他结点存储在磁盘中）</p></li><li><p>构建五叉树索引，那高度只有 2，查找一个数据，对应只需要 2 次磁盘操作。</p></li><li><p>如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3，最多只要 3 次磁盘 IO 就能获取到数据。磁盘 IO 变少了，查找数据的效率也就提高了。<br><img src="https://static001.geekbang.org/resource/image/69/59/69d4c48c1257dcb7dd6077d961b86259.jpg" alt="image"><br><img src="https://static001.geekbang.org/resource/image/76/cc/769687f57190a826a8f6f82793491ccc.jpg" alt="image"></p></li></ul><p>那 m 叉树中的 m 是不是越大越好呢？到底多大才最合适呢？</p><p>==不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作。==</p><p>m 值是根据页的大小事先计算好的，也就是说，每个节点最多只能有 m 个子节点。在往数据库中写入数据的过程中，这样就有可能使索引中某些节点的子节点个数超过 m，这个节点的大小超过了一个页的大小，读取这样一个节点，就会导致多次磁盘 IO 操作。我们该如何解决这个问题呢？</p><p><img src="https://static001.geekbang.org/resource/image/ea/30/ea4472fd7bb7fa948532c8c8ba334430.jpg" alt="image"></p><p>插入索引数据：==分裂节点的方式==我们只需要将这个节点分裂成两个节点。但是，节点分裂之后，其上层父节点的子节点个数就有可能超过 m 个。不过这也没关系，我们可以用同样的方法，将父节点也分裂成两个节点。这种级联反应会从下往上，一直影响到根节点。这个分裂过程，你可以结合着下面这个图一块看，会更容易理解（图中的 B+ 树是一个三叉树。我们限定叶子节点中，数据的个数超过 2 个就分裂节点；非叶子节点中，子节点的个数超过 3 个就分裂节点）。<br><img src="https://static001.geekbang.org/resource/image/18/e0/1800bc80e1e05b32a042ff6873e6c2e0.jpg" alt="image"></p><p>删除索引数据：合并节点的方式，在 B+ 树中，这个阈值等于 m/2。如果某个节点的子节点个数小于 m/2，我们就将它跟相邻的兄弟节点合并。不过，合并之后结点的子节点个数有可能会超过 m。针对这种情况，我们可以借助插入数据时候的处理方法，再分裂节点。</p><p>图中的 B+ 树是一个五叉树。我们限定叶子节点中，数据的个数少于 2 个就合并节点；非叶子节点中，子节点的个数少于 3 个就合并节点。<br><img src="https://static001.geekbang.org/resource/image/17/18/1730e34450dad29f062e76536622c918.jpg" alt="image"></p><h3 id="B-树的特点："><a href="#B-树的特点：" class="headerlink" title="B+树的特点："></a>B+树的特点：</h3><ul><li>每个节点中子节点的个数不能超过 m，也不能小于 m/2；</li><li>==根节点的子节点个数可以不超过 m/2，这是一个例外==；</li><li>m 叉树只存储索引，并不真正存储数据，这个有点儿类似跳表；</li><li>通过链表将叶子节点串联在一起，这样可以方便按区间查找；</li><li>一般情况，根节点会被存储在内存中，其他节点存储在磁盘中。</li></ul><h2 id="B树与B-树的区别-：也是mysql为什么不采用B树"><a href="#B树与B-树的区别-：也是mysql为什么不采用B树" class="headerlink" title="==B树与B+树的区别==：也是mysql为什么不采用B树"></a>==B树与B+树的区别==：也是mysql为什么不采用B树</h2><ul><li>B+ 树中的节点不存储数据，只是索引，而 B 树中的节点存储数据；所以节点要讲数据存储完，势必树的高度相对会比B+树高，平均的I/O效率会比较低。</li><li>B 树中的叶子节点并不需要链表来串联。所以无法支持区间查询。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 这是 B+ 树非叶子节点的定义。</span><br><span class="line"> *</span><br><span class="line"> * 假设 keywords&#x3D;[3, 5, 8, 10]</span><br><span class="line"> * 4 个键值将数据分为 5 个区间：(-INF,3), [3,5), [5,8), [8,10), [10,INF)</span><br><span class="line"> * 5 个区间分别对应：children[0]...children[4]</span><br><span class="line"> *</span><br><span class="line"> * m 值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：</span><br><span class="line"> * PAGE_SIZE &#x3D; (m-1)*4[keywordss 大小]+m*8[children 大小]</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BPlusTreeNode &#123;</span><br><span class="line">  public static int m &#x3D; 5; &#x2F;&#x2F; 5 叉树</span><br><span class="line">  public int[] keywords &#x3D; new int[m-1]; &#x2F;&#x2F; 键值，用来划分数据区间</span><br><span class="line">  public BPlusTreeNode[] children &#x3D; new BPlusTreeNode[m];&#x2F;&#x2F; 保存子节点指针</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 这是 B+ 树中叶子节点的定义。</span><br><span class="line"> *</span><br><span class="line"> * B+ 树中的叶子节点跟内部结点是不一样的,</span><br><span class="line"> * 叶子节点存储的是值，而非区间。</span><br><span class="line"> * 这个定义里，每个叶子节点存储 3 个数据行的键值及地址信息。</span><br><span class="line"> *</span><br><span class="line"> * k 值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：</span><br><span class="line"> * PAGE_SIZE &#x3D; k*4[keyw.. 大小]+k*8[dataAd.. 大小]+8[prev 大小]+8[next 大小]</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BPlusTreeLeafNode &#123;</span><br><span class="line">  public static int k &#x3D; 3;</span><br><span class="line">  public int[] keywords &#x3D; new int[k]; &#x2F;&#x2F; 数据的键值</span><br><span class="line">  public long[] dataAddress &#x3D; new long[k]; &#x2F;&#x2F; 数据地址</span><br><span class="line"></span><br><span class="line">  public BPlusTreeLeafNode prev; &#x2F;&#x2F; 这个结点在链表中的前驱结点</span><br><span class="line">  public BPlusTreeLeafNode next; &#x2F;&#x2F; 这个结点在链表中的后继结点</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> B树和B+树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务消息</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/3%E3%80%81RocketMQ/7%E3%80%81%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/3%E3%80%81RocketMQ/7%E3%80%81%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>在RocketMQ4.3.0版本后，开放了事务消息这一特性，对于分布式事务而言，最常说的还是二阶段提交协议。</p><p>事务消息的成功投递是需要经历三个Topic的(见mq架构图章节)，分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Half Topic：用于记录所有的prepare消息</span><br><span class="line">Op Half Topic：记录已经提交了状态的prepare消息</span><br><span class="line">Real Topic：事务消息真正的Topic,在Commit后会才会将消息写入该Topic，从而进行消息的投递</span><br></pre></td></tr></table></figure><p>==我们创建一个事务消息生产者TransactionProducer,事务消息发送消息对象是TransactionMQProducer，为了实现本地事务操作和回查，我们需要创建一个监听器，监听器需要实现TransactionListener接口==</p><h3 id="事务消息生成者："><a href="#事务消息生成者：" class="headerlink" title="事务消息生成者："></a>事务消息生成者：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionListenerImpl implements TransactionListener &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;存储当前线程对应的事务状态</span><br><span class="line">    private ConcurrentHashMap&lt;String, Integer&gt; localTrans &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;***</span><br><span class="line">     * 发送prepare消息成功后回调该方法用于执行本地事务</span><br><span class="line">     * @param msg:回传的消息，利用transactionId即可获取到该消息的唯一Id</span><br><span class="line">     * @param arg:调用send方法时传递的参数，当send时候若有额外的参数可以传递到send方法中，这里能获取到</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public LocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取线程ID</span><br><span class="line">        String transactionId &#x3D; msg.getTransactionId();</span><br><span class="line">        &#x2F;&#x2F;初始状态为0</span><br><span class="line">        localTrans.put(transactionId,0);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;此处执行本地事务操作</span><br><span class="line">            System.out.println(&quot;....执行本地事务&quot;);</span><br><span class="line">            Thread.sleep(70000);</span><br><span class="line">            System.out.println(&quot;....执行完成本地事务&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            &#x2F;&#x2F;发生异常，则回滚消息</span><br><span class="line">            localTrans.put(transactionId,2);</span><br><span class="line">            return LocalTransactionState.UNKNOW;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;修改状态</span><br><span class="line">        localTrans.put(transactionId,1);</span><br><span class="line">        System.out.println(&quot;executeLocalTransaction------状态为1&quot;);</span><br><span class="line">        &#x2F;&#x2F;本地事务操作如果成功了，则提交该消息，让该消息可见</span><br><span class="line">        return LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;***</span><br><span class="line">     * 消息回查</span><br><span class="line">     * @param msg</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public LocalTransactionState checkLocalTransaction(MessageExt msg) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取事务id</span><br><span class="line">        String transactionId &#x3D; msg.getTransactionId();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;通过事务id获取对应的本地事务执行状态</span><br><span class="line">        Integer status &#x3D; localTrans.get(transactionId);</span><br><span class="line">        System.out.println(&quot;消息回查-----&quot;+status);</span><br><span class="line">        switch (status)&#123;</span><br><span class="line">            case 0:</span><br><span class="line">                return LocalTransactionState.UNKNOW;</span><br><span class="line">            case 1:</span><br><span class="line">                return LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">            case 2:</span><br><span class="line">                return LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">        &#125;</span><br><span class="line">        return LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionProducer &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;nameserver地址</span><br><span class="line">    private static String namesrvaddress&#x3D;&quot;192.168.211.143:9876;&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws MQClientException, UnsupportedEncodingException, InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;创建事务消息发送对象</span><br><span class="line">        TransactionMQProducer producer &#x3D; new TransactionMQProducer(&quot;transaction_producer_group_name&quot;);</span><br><span class="line">        &#x2F;&#x2F;设置namesrv地址</span><br><span class="line">        producer.setNamesrvAddr(namesrvaddress);</span><br><span class="line">        &#x2F;&#x2F;创建监听器</span><br><span class="line">        TransactionListener transactionListener &#x3D; new TransactionListenerImpl();</span><br><span class="line">        &#x2F;&#x2F;创建线程池</span><br><span class="line">        ExecutorService executorService &#x3D; new ThreadPoolExecutor(</span><br><span class="line">                2,</span><br><span class="line">                5,</span><br><span class="line">                100,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                new ArrayBlockingQueue&lt;Runnable&gt;(</span><br><span class="line">                        2000),</span><br><span class="line">                        new ThreadFactory() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public Thread newThread(Runnable runnable) &#123;</span><br><span class="line">                                Thread thread &#x3D; new Thread(runnable);</span><br><span class="line">                                thread.setName(&quot;client-transaction-msg-check-thread&quot;);</span><br><span class="line">                                return thread;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;设置线程池</span><br><span class="line">        producer.setExecutorService(executorService);</span><br><span class="line">        &#x2F;&#x2F;设置监听器</span><br><span class="line">        producer.setTransactionListener(transactionListener);</span><br><span class="line">        &#x2F;&#x2F;启动producer</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建消息</span><br><span class="line">        Message message &#x3D; new Message(</span><br><span class="line">                &quot;TopicTxt_Demo&quot;,</span><br><span class="line">                &quot;TagTx&quot;,</span><br><span class="line">                &quot;KeyTx1&quot;,</span><br><span class="line">                &quot;hello&quot;.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;发送事务消息,此时消息不可见</span><br><span class="line">        TransactionSendResult transactionSendResult &#x3D; producer.sendMessageInTransaction(message, &quot;发送消息，回传所需数据！&quot;);</span><br><span class="line">        System.out.println(transactionSendResult);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;休眠</span><br><span class="line">        Thread.sleep(120000);</span><br><span class="line">        &#x2F;&#x2F;关闭</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息消费者与之间一致</p><p>更多事务消息：事务消息参考地址：<a href="http://rocketmq.apache.org/docs/transaction-example/">http://rocketmq.apache.org/docs/transaction-example/</a></p><h3 id="RocketMQ实现分布式事务（最终一致性）："><a href="#RocketMQ实现分布式事务（最终一致性）：" class="headerlink" title="==RocketMQ实现分布式事务（最终一致性）：=="></a>==RocketMQ实现分布式事务（最终一致性）：==</h3><p>MQ事务消息解决分布式事务问题，但第三方MQ支持事务消息的中间件不多，比如==RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，<br>但是市面上一些主流的MQ都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。==</p><p>以阿里的 RocketMQ 中间件为例，其思路大致为：</p><ul><li>1、第一阶段Prepared消息，会拿到消息的地址。</li><li>2、第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。</li></ul><p>也就是说在业务方法内要向消息队列提交两次请求，<br>一次发送消息和一次确认消息。如果确认消息发送失败了RocketMQ会定期扫描消息集群中的事务消息，<br>这时候发现了Prepared消息，它会向消息发送者确认，<br>所以生产方需要实现一个check接口，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。<br>这样就保证了消息发送与本地事务同时成功或同时失败。</p>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务消息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solr定时增量更新</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/5%E3%80%81%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/2%E3%80%81solr/10%E3%80%81%20Solr%E5%AE%9A%E6%97%B6%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/5%E3%80%81%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/2%E3%80%81solr/10%E3%80%81%20Solr%E5%AE%9A%E6%97%B6%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1  概述"></a>1  概述</h2><p>将数据库中的数据导入到了solr中之后，如果数据库中的数据有变动，solr中还是第一次导入的旧的数据，因此需要定时检测数据库中的数据变化，并实时将变化的数据同步到solr中。</p><p>备注工作：<br>下载地址：<a href="http://download.csdn.net/detail/vtopqx/9891724">http://download.csdn.net/detail/vtopqx/9891724</a></p><p>将下载的solr-dataimport-scheduler.jar拷贝到solr的lib目录下，</p><h2 id="2、-数据库配置"><a href="#2、-数据库配置" class="headerlink" title="2、 数据库配置"></a>2、 数据库配置</h2><p>配置数据库字段，其中关键字段updateTime，该字段非常重要，有了这样一个字段，Solr才能判断增量导入的时候，哪些数据是新的。</p><p>因为Solr在dataimport.properties文件中会存储一个默认值last_index_time，记录最后一次做full import或者是delta import(增量导入）的时间。</p><p><strong>updateTime为timestamp类型 默认可为当前时间：CURRENT_TIMESTAMP</strong></p><h2 id="3、-solr配置"><a href="#3、-solr配置" class="headerlink" title="3、 solr配置"></a>3、 solr配置</h2><h4 id="3-1、修改数据库连接文件配置db-data-config-xml文件，配置如下"><a href="#3-1、修改数据库连接文件配置db-data-config-xml文件，配置如下" class="headerlink" title="3.1、修改数据库连接文件配置db-data-config.xml文件，配置如下"></a>3.1、修改数据库连接文件配置db-data-config.xml文件，配置如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dataConfig&gt; </span><br><span class="line">    &lt;dataSource type&#x3D;&quot;JdbcDataSource&quot;driver&#x3D;&quot;com.mysql.jdbc.Driver&quot;url&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;solr&quot; user&#x3D;&quot;root&quot;password&#x3D;&quot;root&quot; &#x2F;&gt;  </span><br><span class="line">    &lt;document&gt; </span><br><span class="line">        &lt;entity name&#x3D;&quot;solr_user&quot;pk&#x3D;&quot;id&quot;  </span><br><span class="line">query&#x3D;&quot;SELECT* FROM solr_user where isdelete &#x3D;0 &quot;  </span><br><span class="line">deltaImportQuery&#x3D;&quot;SELECT* FROM solr_user where id &#x3D; &#39;$&#123;dih.delta.id&#125;&#39;&quot;  </span><br><span class="line">deletedPkQuery&#x3D;&quot;SELECTid FROM solr_user where isdelete &#x3D;1 &quot;</span><br><span class="line">deltaQuery&#x3D;&quot;SELECTid FROM solr_user where updateTime &gt;&#39;$&#123;dataimporter.last_index_time&#125;&#39;&quot;&gt; </span><br><span class="line">            &lt;field column&#x3D;&quot;id&quot;name&#x3D;&quot;id&quot;&#x2F;&gt;   </span><br><span class="line">            &lt;field column&#x3D;&quot;name&quot;name&#x3D;&quot;name&quot;&#x2F;&gt;  </span><br><span class="line">            &lt;fieldcolumn&#x3D;&quot;updateTime&quot; name&#x3D;&quot;updateTime&quot;&#x2F;&gt; </span><br><span class="line">        &lt;&#x2F;entity&gt; </span><br><span class="line">    &lt;&#x2F;document&gt; </span><br><span class="line">&lt;&#x2F;dataConfig&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>属性说明：</strong></p><p>data-config.xml里面的数据 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- transformer 格式转化：HTMLStripTransformer 索引中忽略HTML标签   ---&gt; </span><br><span class="line"> &lt;!--  query:查询数据库表符合记录数据   ---&gt; </span><br><span class="line"> &lt;!--  deltaQuery:增量索引查询主键ID    ---&gt;    注意这个只能返回ID字段 </span><br><span class="line"> &lt;!--  deltaImportQuery:增量索引查询导入数据  ---&gt; </span><br><span class="line"> &lt;!--  deletedPkQuery:增量索引删除主键ID查询  ---&gt; 注意这个只能返回ID字段 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>配置说明：</strong></p><ul><li>query查询是指 查询出表里所有的符合条件的数据，因为笔者测试的有删除业务，所以 </li></ul><p>where  后面有一个限定条件isdelete=0，意思为查询未被删除的数据 </p><p>(注意这个query查询只对第一次全量导入有作用，对增量导入不起作用) </p><ul><li>deltaQuery的意思是，查询出所有经过修改的记录的ID </li></ul><p>可能是修改操作，添加操作，删除操作产生的 </p><p>(此查询只对增量导入起作用，而且只能返回ID值) </p><ul><li>deletedPkQuery此操作值查询那些数据库里伪删除的数据的ID（即isdelete标识为1的数据） </li></ul><p>solr通过它来删除索引里面对应的数据 </p><p>(此查询只对增量导入起作用，而且只能返回ID值) </p><ul><li>deltaImportQuery此查询是获取以上两步的ID，然后把其全部数据获取，根据获取的数据 </li></ul><p>对索引库进行更新操作，可能是删除，添加，修改 </p><p>(此查询只对增量导入起作用，可以返回多个字段的值,一般情况下，都是返回所有字段的列) </p><p>==注：==</p><p>==1.如果只涉及添加，与修改业务，那么数据库里只需额外有一个timpstamp字段<br>就可以了，默认值为当前系统时间，CURRENT_TIMESTAMP（笔者的数据为mysql的）<br>2.如果还涉及删除业务，那么数据里就需额外再多添加一个字段isdelete，int类型的<br>用0,1来标识，此条记录是否被删除，当然也可以用其他字段标识，ture或false都可以== </p><h4 id="3-2、修改managed-schema文件，新增索引字段"><a href="#3-2、修改managed-schema文件，新增索引字段" class="headerlink" title="3.2、修改managed-schema文件，新增索引字段"></a>3.2、修改managed-schema文件，新增索引字段</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;field name&#x3D;&quot;name&quot;type&#x3D;&quot;string&quot; indexed&#x3D;&quot;true&quot; stored&#x3D;&quot;true&quot;multiValued&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">&lt;field name&#x3D;&quot;content&quot;type&#x3D;&quot;string&quot; indexed&#x3D;&quot;true&quot; stored&#x3D;&quot;true&quot;multiValued&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">&lt;field name&#x3D;&quot;updateTime&quot;type&#x3D;&quot;date&quot; indexed&#x3D;&quot;true&quot; stored&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于solr5.x中已经有默认<uniqueKey>id</uniqueKey>属性配置，因此当数据库字段名称为id时可以不用配置，主键字段为其它名称时需要配置<field></p><h2 id="4、定时同步配置"><a href="#4、定时同步配置" class="headerlink" title="4、定时同步配置"></a>4、定时同步配置</h2><p>进入solr_home目录 新建conf目录，并创建dataimport.properties文件，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#################################################</span><br><span class="line">#                                              #</span><br><span class="line">#      dataimport scheduler properties        #</span><br><span class="line">#                                              #</span><br><span class="line">#################################################</span><br><span class="line"> </span><br><span class="line">#  tosync or not to sync</span><br><span class="line">#  1- active; anything else - inactive</span><br><span class="line"># 这里的配置不用修改</span><br><span class="line">syncEnabled&#x3D;1</span><br><span class="line"> </span><br><span class="line"># which cores to schedule</span><br><span class="line">#  ina multi-core environment you can decide which cores you want syncronized</span><br><span class="line"># leave empty or comment it out if using single-core deployment</span><br><span class="line">#  修改成你所使用的core，我这里是我自定义的core：simple</span><br><span class="line">syncCores&#x3D;solr_db_scheduler</span><br><span class="line"> </span><br><span class="line"># solr server name or IP address</span><br><span class="line"># [defaults to localhost if empty]</span><br><span class="line">这个一般都是localhost不会变</span><br><span class="line">server&#x3D;localhost</span><br><span class="line"> </span><br><span class="line"># solr server port</span><br><span class="line"># [defaults to 80 if empty]</span><br><span class="line">#  安装solr的tomcat端口，如果你使用的是默认的端口，就不用改了，否则改成自己的端口就好了</span><br><span class="line">port&#x3D;8983</span><br><span class="line"> </span><br><span class="line"># application name&#x2F;context</span><br><span class="line"># [defaults to current ServletContextListener&#39;s context (app) name]</span><br><span class="line">#  这里默认不改</span><br><span class="line">webapp&#x3D;solr</span><br><span class="line"> </span><br><span class="line"># URL params [mandatory]</span><br><span class="line"># remainder of URL</span><br><span class="line">#  这里改成下面的形式，solr同步数据时请求的链接</span><br><span class="line">params&#x3D;&#x2F;dataimport?command&#x3D;delta-import&amp;clean&#x3D;false&amp;commit&#x3D;true</span><br><span class="line"> </span><br><span class="line"># schedule interval</span><br><span class="line"># number of minutes between two runs</span><br><span class="line"># [defaults to 30 if empty]</span><br><span class="line">#这里是设置定时任务的，单位是分钟，也就是多长时间你检测一次数据同步，根据项目需求修改</span><br><span class="line">#  开始测试的时候为了方便看到效果，时间可以设置短一点</span><br><span class="line">interval&#x3D;1</span><br><span class="line"> </span><br><span class="line">#  重做索引的时间间隔，单位分钟，默认7200，即5天;</span><br><span class="line">#  为空,为0,或者注释掉:表示永不重做索引</span><br><span class="line">reBuildIndexInterval&#x3D;7200</span><br><span class="line"> </span><br><span class="line">#  重做索引的参数</span><br><span class="line">reBuildIndexParams&#x3D;&#x2F;select?qt&#x3D;&#x2F;dataimport&amp;command&#x3D;full-import&amp;clean&#x3D;true&amp;commit&#x3D;true</span><br><span class="line"> </span><br><span class="line">#  重做索引时间间隔的计时开始时间，第一次真正执行的时间&#x3D;reBuildIndexBeginTime+reBuildIndexInterval*60*1000；</span><br><span class="line">#  两种格式：2012-04-11 03:10:00 或者 03:10:00，后一种会自动补全日期部分为服务启动时的日期</span><br><span class="line">reBuildIndexBeginTime&#x3D;03:10:00</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上配置可以简单修改红色部分即可，默认为一分钟检测一次，如果有数据变动则同步。</p><h2 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h2><p>以上配置完成后，停止solr，并重启</p><p>Solr.cmd stop –all</p><p>Solr.cmd start</p><p>先查solr中的文档数据，然后更新数据库数据，再观察solr中国数据是否变化</p>]]></content>
      
      
      <categories>
          
          <category> solr </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solr定时增量更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引（上）</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%9E%B6%E6%9E%84/2%E3%80%81%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%9E%B6%E6%9E%84/2%E3%80%81%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>MySQL中MyISM和Innodb使用B+树作为索引数据结构</p><p>让二叉查找树支持按照区间来查找数据，我们可以对它进行这样的改造：==树中的节点并不存储数据本身，而是只是作为索引。除此之外，我们把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的==。类似跳表<br><img src="https://static001.geekbang.org/resource/image/25/f4/25700c1dc28ce094eed3ffac394531f4.jpg" alt="image"></p><p>我们给一亿个数据构建二叉查找树索引，那索引中会包含大约 1 亿个节点，每个节点假设占用 16 个字节，那就需要大约 1GB 的内存空间。给一张表建立索引，我们需要 1GB 的内存空间。如果我们要给 10 张表建立索引，那对内存的需求是无法满足的。如何解决这个索引占用太多内存的问题呢？</p><p>借助时间换空间的思路，==把索引存储在硬盘中==<br>那么每个节点的读取（或者访问），都对应一次磁盘 IO 操作。==树的高度就等于每次查询数据时磁盘 IO 操作的次数。==</p><p>如何降低树的高度,减少IO次数？==将二叉树转为m叉树==</p><ul><li><p>给 16 个数据构建二叉树索引，树的高度是 4，查找一个数据，就需要 4 个磁盘 IO 操作（如果根节点存储在内存中，其他结点存储在磁盘中）</p></li><li><p>构建五叉树索引，那高度只有 2，查找一个数据，对应只需要 2 次磁盘操作。</p></li><li><p>如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3，最多只要 3 次磁盘 IO 就能获取到数据。磁盘 IO 变少了，查找数据的效率也就提高了。<br><img src="https://static001.geekbang.org/resource/image/69/59/69d4c48c1257dcb7dd6077d961b86259.jpg" alt="image"><br><img src="https://static001.geekbang.org/resource/image/76/cc/769687f57190a826a8f6f82793491ccc.jpg" alt="image"></p></li></ul><p>那 m 叉树中的 m 是不是越大越好呢？到底多大才最合适呢？</p><p>==不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作。==</p><p>m 值是根据页的大小事先计算好的，也就是说，每个节点最多只能有 m 个子节点。在往数据库中写入数据的过程中，这样就有可能使索引中某些节点的子节点个数超过 m，这个节点的大小超过了一个页的大小，读取这样一个节点，就会导致多次磁盘 IO 操作。我们该如何解决这个问题呢？</p><p><img src="https://static001.geekbang.org/resource/image/ea/30/ea4472fd7bb7fa948532c8c8ba334430.jpg" alt="image"></p><p>插入索引数据：==分裂节点的方式==我们只需要将这个节点分裂成两个节点。但是，节点分裂之后，其上层父节点的子节点个数就有可能超过 m 个。不过这也没关系，我们可以用同样的方法，将父节点也分裂成两个节点。这种级联反应会从下往上，一直影响到根节点。这个分裂过程，你可以结合着下面这个图一块看，会更容易理解（图中的 B+ 树是一个三叉树。我们限定叶子节点中，数据的个数超过 2 个就分裂节点；非叶子节点中，子节点的个数超过 3 个就分裂节点）。<br><img src="https://static001.geekbang.org/resource/image/18/e0/1800bc80e1e05b32a042ff6873e6c2e0.jpg" alt="image"></p><p>删除索引数据：合并节点的方式，在 B+ 树中，这个阈值等于 m/2。如果某个节点的子节点个数小于 m/2，我们就将它跟相邻的兄弟节点合并。不过，合并之后结点的子节点个数有可能会超过 m。针对这种情况，我们可以借助插入数据时候的处理方法，再分裂节点。</p><p>图中的 B+ 树是一个五叉树。我们限定叶子节点中，数据的个数少于 2 个就合并节点；非叶子节点中，子节点的个数少于 3 个就合并节点。<br><img src="https://static001.geekbang.org/resource/image/17/18/1730e34450dad29f062e76536622c918.jpg" alt="image"></p><h3 id="B-树的特点："><a href="#B-树的特点：" class="headerlink" title="B+树的特点："></a>B+树的特点：</h3><ul><li>每个节点中子节点的个数不能超过 m，也不能小于 m/2；</li><li>==根节点的子节点个数可以不超过 m/2，这是一个例外==；</li><li>m 叉树只存储索引，并不真正存储数据，这个有点儿类似跳表；</li><li>通过链表将叶子节点串联在一起，这样可以方便按区间查找；</li><li>一般情况，根节点会被存储在内存中，其他节点存储在磁盘中。</li></ul><h2 id="B树与B-树的区别-：也是mysql为什么不采用B树"><a href="#B树与B-树的区别-：也是mysql为什么不采用B树" class="headerlink" title="==B树与B+树的区别==：也是mysql为什么不采用B树"></a>==B树与B+树的区别==：也是mysql为什么不采用B树</h2><ul><li>B+ 树中的节点不存储数据，只是索引，而 B 树中的节点存储数据；所以节点要讲数据存储完，势必树的高度相对会比B+树高，平均的I/O效率会比较低。</li><li>B 树中的叶子节点并不需要链表来串联。所以无法支持区间查询。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 这是 B+ 树非叶子节点的定义。</span><br><span class="line"> *</span><br><span class="line"> * 假设 keywords&#x3D;[3, 5, 8, 10]</span><br><span class="line"> * 4 个键值将数据分为 5 个区间：(-INF,3), [3,5), [5,8), [8,10), [10,INF)</span><br><span class="line"> * 5 个区间分别对应：children[0]...children[4]</span><br><span class="line"> *</span><br><span class="line"> * m 值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：</span><br><span class="line"> * PAGE_SIZE &#x3D; (m-1)*4[keywordss 大小]+m*8[children 大小]</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BPlusTreeNode &#123;</span><br><span class="line">  public static int m &#x3D; 5; &#x2F;&#x2F; 5 叉树</span><br><span class="line">  public int[] keywords &#x3D; new int[m-1]; &#x2F;&#x2F; 键值，用来划分数据区间</span><br><span class="line">  public BPlusTreeNode[] children &#x3D; new BPlusTreeNode[m];&#x2F;&#x2F; 保存子节点指针</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 这是 B+ 树中叶子节点的定义。</span><br><span class="line"> *</span><br><span class="line"> * B+ 树中的叶子节点跟内部结点是不一样的,</span><br><span class="line"> * 叶子节点存储的是值，而非区间。</span><br><span class="line"> * 这个定义里，每个叶子节点存储 3 个数据行的键值及地址信息。</span><br><span class="line"> *</span><br><span class="line"> * k 值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：</span><br><span class="line"> * PAGE_SIZE &#x3D; k*4[keyw.. 大小]+k*8[dataAd.. 大小]+8[prev 大小]+8[next 大小]</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BPlusTreeLeafNode &#123;</span><br><span class="line">  public static int k &#x3D; 3;</span><br><span class="line">  public int[] keywords &#x3D; new int[k]; &#x2F;&#x2F; 数据的键值</span><br><span class="line">  public long[] dataAddress &#x3D; new long[k]; &#x2F;&#x2F; 数据地址</span><br><span class="line"></span><br><span class="line">  public BPlusTreeLeafNode prev; &#x2F;&#x2F; 这个结点在链表中的前驱结点</span><br><span class="line">  public BPlusTreeLeafNode next; &#x2F;&#x2F; 这个结点在链表中的后继结点</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引（上） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springMvc架构</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/spring-mvc/2%E3%80%81springMvc%E6%9E%B6%E6%9E%84/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/spring-mvc/2%E3%80%81springMvc%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>==Spring MVC本质上是对原生ServletAPI的封装，所有请求都先被发送到DispatcherServlet，这就会触发DispatcherServlet的初始化，其中会对ApplicationContext进行进一步的初始化。==</p><p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15302319955704.jpg" alt="image"></p><h3 id="ApplicationContextAware-拿到容器实例"><a href="#ApplicationContextAware-拿到容器实例" class="headerlink" title="ApplicationContextAware:拿到容器实例"></a>ApplicationContextAware:拿到容器实例</h3><h3 id="EnvironmentAware：拿到环境变量等信息"><a href="#EnvironmentAware：拿到环境变量等信息" class="headerlink" title="EnvironmentAware：拿到环境变量等信息"></a>EnvironmentAware：拿到环境变量等信息</h3><p>在 Spring 中，Aware 类型的接口用于向 Spring “索要”一些框架中的信息。比如当某个 bean 实现了 ApplicationContextAware 接口时，Spring 在运行时会将当前的 ApplicationContext 实例通过接口方法 setApplicationContext 传给该 bean。</p><p>一下示例拿到环境变量、配置信息以及容器中所有 bean 的数据。这说明，Spring 在运行时向 SystemInfo 中注入了 ApplicationContext 和 Environment 实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;systeminfo&quot;)</span><br><span class="line">public class SystemInfo implements ApplicationContextAware, EnvironmentAware &#123;</span><br><span class="line"></span><br><span class="line">    private ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    private Environment environment;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        System.out.println(applicationContext.getClass());</span><br><span class="line">        this.applicationContext &#x3D; applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setEnvironment(Environment environment) &#123;</span><br><span class="line">        this.environment &#x3D; environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;env&quot;)</span><br><span class="line">    public String environment() &#123;</span><br><span class="line">        StandardServletEnvironment sse &#x3D; (StandardServletEnvironment) environment;</span><br><span class="line">        Map&lt;String, Object&gt; envs &#x3D; sse.getSystemEnvironment();</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">        sb.append(&quot;-------------------------++ System Environment ++-------------------------\n&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        list.addAll(envs.keySet());</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5 &amp;&amp; i &lt; list.size(); i++) &#123;</span><br><span class="line">            String key &#x3D; list.get(i);</span><br><span class="line">            Object val &#x3D; envs.get(key);</span><br><span class="line">            sb.append(String.format(&quot;%s &#x3D; %s\n&quot;, key, val.toString()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; props &#x3D; sse.getSystemProperties();</span><br><span class="line">        sb.append(&quot;\n-------------------------++ System Properties ++-------------------------\n&quot;);</span><br><span class="line">        list.clear();</span><br><span class="line">        list.addAll(props.keySet());</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5 &amp;&amp; i &lt; list.size(); i++) &#123;</span><br><span class="line">            String key &#x3D; list.get(i);</span><br><span class="line">            Object val &#x3D; props.get(key);</span><br><span class="line">            sb.append(String.format(&quot;%s &#x3D; %s\n&quot;, key, val.toString()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;beans&quot;)</span><br><span class="line">    public String listBeans() &#123;</span><br><span class="line">        ListableBeanFactory lbf &#x3D; applicationContext;</span><br><span class="line">        String[] beanNames &#x3D; lbf.getBeanDefinitionNames();</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">        sb.append(&quot;-------------------------++ Bean Info ++-------------------------\n&quot;);</span><br><span class="line">        Arrays.stream(beanNames).forEach(beanName -&gt; &#123;</span><br><span class="line">            Object bean &#x3D; lbf.getBean(beanName);</span><br><span class="line">            sb.append(String.format(&quot;beanName  &#x3D; %s\n&quot;, beanName));</span><br><span class="line">            sb.append(String.format(&quot;beanClass &#x3D; %s\n\n&quot;, bean.getClass().toString()));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EnvironmentCapable"><a href="#EnvironmentCapable" class="headerlink" title="EnvironmentCapable"></a>EnvironmentCapable</h3><p>EnvironmentCapable 仅包含一个方法定义 getEnvironment，通过该方法可以获取到环境变量对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.core.env;</span><br><span class="line"></span><br><span class="line">public interface EnvironmentCapable &#123;</span><br><span class="line">    Environment getEnvironment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class EnvironmentHolder implements EnvironmentCapable, EnvironmentAware &#123;</span><br><span class="line"></span><br><span class="line">    private Environment environment;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setEnvironment(Environment environment) &#123;</span><br><span class="line">        this.environment &#x3D; environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Environment getEnvironment() &#123;</span><br><span class="line">        return environment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HttpServletBean"><a href="#HttpServletBean" class="headerlink" title="HttpServletBean"></a>HttpServletBean</h3><p>HttpServletBean 是 HttpServlet 抽象类的简单拓展。HttpServletBean 覆写了父类中的无参 init 方法，并在该方法中将 ServletConfig 里的配置信息设置到子类对象中，比如 DispatcherServlet。</p><h3 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h3><p>FrameworkServlet 是 Spring Web 框架中的一个基础类，该类会在初始化时创建一个容器。同时该类覆写了 doGet、doPost 等方法，并将所有类型的请求委托给 doService 方法去处理。doService 是一个抽象方法，需要子类DispatcherServlet去实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public abstract class FrameworkServlet extends HttpServletBean implements ApplicationContextAware &#123;</span><br><span class="line">    </span><br><span class="line">    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        HttpMethod httpMethod &#x3D; HttpMethod.resolve(request.getMethod());</span><br><span class="line">        if (httpMethod !&#x3D; HttpMethod.PATCH &amp;&amp; httpMethod !&#x3D; null) &#123;</span><br><span class="line">            super.service(request, response);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.processRequest(request, response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        this.processRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        this.processRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final void doPut(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        this.processRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;省略部分代码</span><br><span class="line">        &#x2F;&#x2F;需要DispatcherServlet实现该方法，而DispatcherServlet.doService又调用的doDispatch(request, response);</span><br><span class="line">        this.doService(request, response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><p>DispatcherServlet 主要协调各个组件工作。除此之外，DispatcherServlet 还有一个重要的事情要做，即初始化各种组件，比如 HandlerMapping、HandlerAdapter 等。</p><p>总结：HttpServletBean是HttpServlet的子类，FrameworkServlet是HttpServletBean的子类。FrameworkServlet中覆盖了doGet等方法，一个请求过来调用FrameworkServlet.processRequest–&gt;FrameworkServlet.doService–&gt;DispatcherServlet.doService–&gt;DispatcherServlet.doDispatch</p>]]></content>
      
      
      <categories>
          
          <category> spring-mvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springMvc架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟http请求</title>
      <link href="2020/06/21/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/2%E3%80%81%E6%A8%A1%E6%8B%9Fhttp%E8%AF%B7%E6%B1%82/"/>
      <url>2020/06/21/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/2%E3%80%81%E6%A8%A1%E6%8B%9Fhttp%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP请求报文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;admin_ui&#x2F;rdx&#x2F;core&#x2F;images&#x2F;close.png HTTP&#x2F;1.1</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Referer: http:&#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;menu&#x2F;neo</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">User-Agent: Mozilla&#x2F;4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident&#x2F;7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET4.0C; .NET4.0E)</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Host: xxx.xxx.xxx.xxx</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Cookie: startupapp&#x3D;neo; is_cisco_platform&#x3D;0; rdx_pagination_size&#x3D;250%20Per%20Page; SESSID&#x3D;deb31b8eb9ca68a514cf55777744e339</span><br></pre></td></tr></table></figure><p>HTTP响应报文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Bdpagetype: 1</span><br><span class="line">Bdqid: 0xacbbb9d800005133</span><br><span class="line">Cache-Control: private</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line">Cxy_all: baidu+f8b5e5b521b3644ef7f3455ea441c5d0</span><br><span class="line">Date: Fri, 12 Oct 2018 06:36:28 GMT</span><br><span class="line">Expires: Fri, 12 Oct 2018 06:36:26 GMT</span><br><span class="line">Server: BWS&#x2F;1.1</span><br><span class="line">Set-Cookie: delPer&#x3D;0; path&#x3D;&#x2F;; domain&#x3D;.baidu.com</span><br><span class="line">Set-Cookie: BDSVRTM&#x3D;0; path&#x3D;&#x2F;</span><br><span class="line">Set-Cookie: BD_HOME&#x3D;0; path&#x3D;&#x2F;</span><br><span class="line">Set-Cookie: H_PS_PSSID&#x3D;1433_21112_18560_26350_27245_22158; path&#x3D;&#x2F;; domain&#x3D;.baidu.com</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Ua-Compatible: IE&#x3D;Edge,chrome&#x3D;1</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"> </span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;!--STATUS OK--&gt;</span><br></pre></td></tr></table></figure><p>HTTP 请求就是一段有特定格式的文本，所以我们只要使用SOCKET基于TCP，自己构建出这种特定格式的文本进行发送和接收，也就可以模拟HTTP请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">public class HttpServer &#123;</span><br><span class="line">    public static void main(String[] args)throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;创建serverSocketChannel,监听8080端口</span><br><span class="line">        ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.socket().bind(new InetSocketAddress( 8080));</span><br><span class="line">        &#x2F;&#x2F;设置为非阻塞式的</span><br><span class="line">        serverSocketChannel.configureBlocking(false);</span><br><span class="line">        &#x2F;&#x2F;为ssc注册选择器</span><br><span class="line">        Selector selector &#x3D; Selector.open();</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#x2F;&#x2F;创建处理器</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            &#x2F;&#x2F;等待请求，每次等待阻塞3秒，超过3秒后线程继续向下运行，如果传入0或者不传参数将一直阻塞</span><br><span class="line">            if(selector.select(3000)&#x3D;&#x3D;0)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;获取待处理的SelectionKey</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIter &#x3D; selector.selectedKeys().iterator();</span><br><span class="line">            while (keyIter.hasNext()) &#123;</span><br><span class="line">                SelectionKey key &#x3D; keyIter.next();</span><br><span class="line">                &#x2F;&#x2F;启动新线程处理SelectionKey</span><br><span class="line">                new Thread(new HttpHandeler(key)).run();</span><br><span class="line">                &#x2F;&#x2F;处理完成后，从待处理的SelectionKey迭代器中移除当前所使用的key</span><br><span class="line">                keyIter.remove();</span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class HttpHandeler implements Runnable&#123;</span><br><span class="line">        private int bufferSize &#x3D; 1024;</span><br><span class="line">        private String localCharset &#x3D; &quot;UTF-8&quot;;</span><br><span class="line">        private SelectionKey key;</span><br><span class="line">        public HttpHandeler(SelectionKey key) &#123;</span><br><span class="line">            this.key &#x3D; key;</span><br><span class="line">        &#125;</span><br><span class="line">        public void handleAccept()throws IOException&#123;</span><br><span class="line">            SocketChannel clientChannel &#x3D; ((ServerSocketChannel)key.channel()).accept();</span><br><span class="line">            clientChannel.configureBlocking(false);</span><br><span class="line">            clientChannel.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize));</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        public void handlRead() throws IOException&#123;</span><br><span class="line">            &#x2F;&#x2F;获取channel</span><br><span class="line">            SocketChannel sChannel &#x3D;(SocketChannel) key.channel();</span><br><span class="line">            &#x2F;&#x2F;获取buffer并重置</span><br><span class="line">            ByteBuffer buffer &#x3D; (ByteBuffer)key.attachment();</span><br><span class="line">            &#x2F;&#x2F;没有读到内容则关闭</span><br><span class="line">            if(sChannel.read(buffer)&#x3D;&#x3D;-1)&#123;</span><br><span class="line">                sChannel.close();</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                &#x2F;&#x2F;接受请求数据</span><br><span class="line">                buffer.flip();</span><br><span class="line">                String receivedString &#x3D; Charset.forName(localCharset).newDecoder().decode(buffer).toString();</span><br><span class="line">                &#x2F;&#x2F;控制台打印请求报文头</span><br><span class="line">                String[] requestMessage &#x3D; receivedString.split(&quot;\r\n&quot;);</span><br><span class="line">                for (String s: requestMessage) &#123;</span><br><span class="line">                    System.out.println(s);</span><br><span class="line">                    &#x2F;&#x2F;遇到空行说明报文头已经打印完</span><br><span class="line">                    if(s.isEmpty())&#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;控制台打印行首信息</span><br><span class="line">                String[] firstLine &#x3D; requestMessage[0].split(&quot; &quot;);</span><br><span class="line">                System.out.println();</span><br><span class="line">                System.out.println(&quot;Method:\t&quot;+firstLine[0]);</span><br><span class="line">                System.out.println(&quot;url:\t&quot; + firstLine[1]);</span><br><span class="line">                System.out.println(&quot;HTTP Version:\t&quot; + firstLine[2]);</span><br><span class="line">                System.out.println();</span><br><span class="line">                &#x2F;&#x2F;返回客户端</span><br><span class="line">                StringBuilder sendString &#x3D; new StringBuilder();</span><br><span class="line">                sendString.append(&quot;HTTP&#x2F;1.1 200 OK\r\n&quot;);&#x2F;&#x2F;响应报文首行，200表示成功</span><br><span class="line">                sendString.append(&quot;Content-Type:text&#x2F;html;charset&#x3D;&quot;+localCharset+&quot;\r\n&quot;);</span><br><span class="line">                sendString.append(&quot;\r\n&quot;);&#x2F;&#x2F;报文结束后加一个空行</span><br><span class="line">                 </span><br><span class="line">                sendString.append(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;显示报文&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&quot;);</span><br><span class="line">                sendString.append(&quot;接受到的请求报文是：&lt;br&#x2F;&gt;&quot;);</span><br><span class="line">                for(String s: requestMessage)&#123;</span><br><span class="line">                    sendString.append(s+&quot;&lt;br&#x2F;&gt;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                sendString.append(&quot;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&quot;);</span><br><span class="line">                buffer &#x3D; ByteBuffer.wrap(sendString.toString().getBytes(localCharset));</span><br><span class="line">                sChannel.write(buffer);</span><br><span class="line">                sChannel.close();</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;接受到连接请求时</span><br><span class="line">                if (key.isAcceptable()) &#123;</span><br><span class="line">                    handleAccept();</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;读数据</span><br><span class="line">                if(key.isReadable())&#123;</span><br><span class="line">                    handlRead();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟http请求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS介绍</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/AQS%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/AQS%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>同步器是用来构建锁和其他同步组件的基础框架，它的实现主要依赖一个int成员变量来表示同步状态以及通过一个FIFO队列构成等待队列。==子类被推荐定义为自定义同步组件的静态内部类==</p><p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者的关系：==锁是面向使用者，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作==。锁和同步器很好的隔离了使用者和实现者所需关注的领域。</p><h3 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h3><p>同步器提供的模板方法基本上分为3类：</p><ul><li>独占式获取与释放同步状态、</li><li>共享式获取与释放同步状态</li><li>查询同步队列中的等待线程情况</li></ul><h3 id="独占锁："><a href="#独占锁：" class="headerlink" title="独占锁："></a>独占锁：</h3><p>独占锁就是在同一时刻只能有一个线程获取到锁，而其他获取锁的线程只能<br>处于同步队列中等待，只有获取锁的线程释放了锁，后继的线程才能够获取锁，</p><p>AQS的设计是使用模板方法设计模式，==它将一些方法开放给子类进行重写，而同步器给同步组件所提供模板方法又会重新调用被子类所重写的方法== 示例：</p><p>AQS中需要重写的方法tryAcquire：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock中NonfairSync（继承AQS）会重写该方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而AQS中的模板方法acquire():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">       if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会调用tryAcquire方法，而此时当继承AQS的NonfairSync调用模板方法acquire时就会调用已经被NonfairSync重写的tryAcquire方法。这就是使用AQS的方式</p><p>AQS源码中的example。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">class Mutex implements Lock, java.io.Serializable &#123;</span><br><span class="line">    &#x2F;&#x2F; Our internal helper class</span><br><span class="line">    &#x2F;&#x2F; 继承AQS的静态内存类</span><br><span class="line">    &#x2F;&#x2F; 重写方法</span><br><span class="line">    private static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        &#x2F;&#x2F; Reports whether in locked state</span><br><span class="line">        protected boolean isHeldExclusively() &#123;</span><br><span class="line">            return getState() &#x3D;&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Acquires the lock if state is zero</span><br><span class="line">        public boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            assert acquires &#x3D;&#x3D; 1; &#x2F;&#x2F; Otherwise unused</span><br><span class="line">            if (compareAndSetState(0, 1)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Releases the lock by setting state to zero</span><br><span class="line">        protected boolean tryRelease(int releases) &#123;</span><br><span class="line">            assert releases &#x3D;&#x3D; 1; &#x2F;&#x2F; Otherwise unused</span><br><span class="line">            if (getState() &#x3D;&#x3D; 0) throw new IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(null);</span><br><span class="line">            setState(0);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Provides a Condition</span><br><span class="line">        Condition newCondition() &#123;</span><br><span class="line">            return new ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Deserializes properly</span><br><span class="line">        private void readObject(ObjectInputStream s)</span><br><span class="line">                throws IOException, ClassNotFoundException &#123;</span><br><span class="line">            s.defaultReadObject();</span><br><span class="line">            setState(0); &#x2F;&#x2F; reset to unlocked state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The sync object does all the hard work. We just forward to it.</span><br><span class="line">    private final Sync sync &#x3D; new Sync();</span><br><span class="line">    &#x2F;&#x2F;使用同步器的模板方法实现自己的同步语义</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        sync.acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return sync.tryAcquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isLocked() &#123;</span><br><span class="line">        return sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasQueuedThreads() &#123;</span><br><span class="line">        return sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean tryLock(long timeout, TimeUnit unit)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireNanos(1, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MutextDemo &#123;</span><br><span class="line">    private static Mutex mutex &#x3D; new Mutex();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Thread thread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                mutex.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    mutex.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现同步组件时需要把握的两个关键点是：</p><ul><li>实现同步组件时推荐定义继承AQS的静态内存类，并重写需要的protected修饰的方法；</li><li>同步组件语义的实现依赖于AQS的模板方法，而AQS模板方法又依赖于被AQS的子类所重写的方法。</li></ul><p>同步组件Mutex例子中通过tryAcquire方法实现自己的同步语义，在该方法中如果当前同步状态为0（即该同步组件没被任何线程获取），当前线程可以获取同时将状态更改为1返回true，否则，该组件已经被线程占用返回false。很显然，该同步组件只能在同一时刻被线程占用，Mutex专注于获取释放的逻辑来实现自己想要表达的同步语义。</p><p>同步组件通过重写AQS的方法实现自己想要表达的同步语义，而AQS只需要同步组件表达的true和false即可，AQS会针对true和false不同的情况做不同的处理（将当前线程插入同步队列等一系列的方法）</p>]]></content>
      
      
      <categories>
          
          <category> JUC锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>声明式事务底层原理</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Spring 的声明式事务管理在底层是建立在 AOP 的基础之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p><ul><li>基于<tx>和<aop>命名空间的xml配置文件；</li><li>基于@Transactional注解。</li></ul><p>声明式事务结合IoC容器和Spirng已有的FactoryBean来对事务管理进行属性配置</p><ul><li><p>TransactionAttributeSourceAdvisor，这是一个通知器，用它来对属性值进行存储、处理。</p></li><li><p>创建事物的过程，这个过程是委托给具体的事物管理器来创建的，Spring通过TransactionStatus来传递相关的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> public class TransactionProxyFactoryBean extends AbstractSingletonProxyFactoryBean  </span><br><span class="line">        implements FactoryBean, BeanFactoryAware &#123;  </span><br><span class="line">&#x2F;&#x2F;这里是Spring事务处理而使用的AOP拦截器，中间封装了Spring对事务处理的代码来支持声明式事务处理的实现  </span><br><span class="line">    private final TransactionInterceptor transactionInterceptor &#x3D; new TransactionInterceptor();  </span><br><span class="line">  </span><br><span class="line">    private Pointcut pointcut;  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;这里Spring把TransactionManager注入到TransactionInterceptor中去  </span><br><span class="line">    public void setTransactionManager(PlatformTransactionManager transactionManager) &#123;  </span><br><span class="line">        this.transactionInterceptor.setTransactionManager(transactionManager);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;这里把在bean配置文件中读到的事务管理的属性信息注入到TransactionInterceptor中去  </span><br><span class="line">    public void setTransactionAttributes(Properties transactionAttributes) &#123;  </span><br><span class="line">        this.transactionInterceptor.setTransactionAttributes(transactionAttributes);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    .........中间省略了其他一些方法.......  </span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;这里创建Spring AOP对事务处理的Advisor  </span><br><span class="line">    protected Object createMainInterceptor() &#123;  </span><br><span class="line">        this.transactionInterceptor.afterPropertiesSet();  </span><br><span class="line">        if (this.pointcut !&#x3D; null) &#123;  </span><br><span class="line">            &#x2F;&#x2F;这里使用默认的通知器  </span><br><span class="line">            return new DefaultPointcutAdvisor(this.pointcut, this.transactionInterceptor);  </span><br><span class="line">        &#125;  </span><br><span class="line">        else &#123;  </span><br><span class="line">            &#x2F;&#x2F; 使用上面定义好的TransactionInterceptor作为拦截器，同时使用TransactionAttributeSourceAdvisor  </span><br><span class="line">            return new TransactionAttributeSourceAdvisor(this.transactionInterceptor);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>IOC初始化bean的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void afterPropertiesSet() &#123;  </span><br><span class="line">    .......  </span><br><span class="line">    &#x2F;&#x2F;TransactionProxyFactoryBean实际上使用ProxyFactory完成AOP的基本功能。  </span><br><span class="line">    ProxyFactory proxyFactory &#x3D; new ProxyFactory();  </span><br><span class="line">  </span><br><span class="line">    if (this.preInterceptors !&#x3D; null) &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; this.preInterceptors.length; i++) &#123;  </span><br><span class="line">            proxyFactory.addAdvisor(this.advisorAdapterRegistry.wrap(this.preInterceptors[i]));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;这里是Spring加入通知器的地方  </span><br><span class="line">    &#x2F;&#x2F;有两种通知器可以被加入DefaultPointcutAdvisor或者TransactionAttributeSourceAdvisor  </span><br><span class="line">    &#x2F;&#x2F;这里把Spring处理声明式事务处理的AOP代码都放到ProxyFactory中去，怎样加入advisor我们可以参考ProxyFactory的父类AdvisedSupport()  </span><br><span class="line">    &#x2F;&#x2F;由它来维护一个advice的链表，通过这个链表的增删改来抽象我们对整个通知器配置的增删改操作。  </span><br><span class="line">    proxyFactory.addAdvisor(this.advisorAdapterRegistry.wrap(createMainInterceptor()));  </span><br><span class="line">  </span><br><span class="line">    if (this.postInterceptors !&#x3D; null) &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; this.postInterceptors.length; i++) &#123;  </span><br><span class="line">            proxyFactory.addAdvisor(this.advisorAdapterRegistry.wrap(this.postInterceptors[i]));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    proxyFactory.copyFrom(this);  </span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;这里创建AOP的目标源  </span><br><span class="line">    TargetSource targetSource &#x3D; createTargetSource(this.target);  </span><br><span class="line">    proxyFactory.setTargetSource(targetSource);  </span><br><span class="line">  </span><br><span class="line">    if (this.proxyInterfaces !&#x3D; null) &#123;  </span><br><span class="line">        proxyFactory.setInterfaces(this.proxyInterfaces);  </span><br><span class="line">    &#125;  </span><br><span class="line">    else if (!isProxyTargetClass()) &#123;  </span><br><span class="line">        proxyFactory.setInterfaces(ClassUtils.getAllInterfacesForClass(targetSource.getTargetClass()));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    this.proxy &#x3D; getProxy(proxyFactory);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Spring 已经定义了一个transctionInterceptor作为拦截器或者AOP advice的实现，在IOC容器中定义的其他属性比如transactionManager和事务管理的属性都会传到已经定义好的 TransactionInterceptor那里去进行处理。以上反映了基本的Spring AOP的定义过程，其中pointcut和advice都已经定义好，同时也通过通知器配置到ProxyFactory中去了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionAttributeSourceAdvisor extends AbstractPointcutAdvisor &#123;  </span><br><span class="line">    &#x2F;&#x2F;和其他Advisor一样，同样需要定义AOP中的用到的Interceptor和Pointcut  </span><br><span class="line">    &#x2F;&#x2F;Interceptor使用传进来的TransactionInterceptor  </span><br><span class="line">    &#x2F;&#x2F;而对于pointcut,这里定义了一个内部类，参见下面的代码    </span><br><span class="line">    private TransactionInterceptor transactionInterceptor;  </span><br><span class="line">  </span><br><span class="line">    private final TransactionAttributeSourcePointcut pointcut &#x3D; new TransactionAttributeSourcePointcut();  </span><br><span class="line">     </span><br><span class="line">    .........  </span><br><span class="line">    &#x2F;&#x2F;定义的PointCut内部类  </span><br><span class="line">        private class TransactionAttributeSourcePointcut extends StaticMethodMatcherPointcut implements Serializable &#123;  </span><br><span class="line">       .......  </span><br><span class="line">      &#x2F;&#x2F;方法匹配的实现，使用了TransactionAttributeSource类  </span><br><span class="line">        public boolean matches(Method method, Class targetClass) &#123;  </span><br><span class="line">            TransactionAttributeSource tas &#x3D; getTransactionAttributeSource();  </span><br><span class="line">            &#x2F;&#x2F;这里使用TransactionAttributeSource来对配置属性进行处理  </span><br><span class="line">            return (tas !&#x3D; null &amp;&amp; tas.getTransactionAttribute(method, targetClass) !&#x3D; null);  </span><br><span class="line">        &#125;  </span><br><span class="line">    ........省略了equal,hashcode,tostring的代码  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 声明式事务底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bean的注册</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/IOC/1%E3%80%81bean%E7%9A%84%E6%B3%A8%E5%86%8C/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/IOC/1%E3%80%81bean%E7%9A%84%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/songxinjianqwe/article/details/78824851">https://blog.csdn.net/songxinjianqwe/article/details/78824851</a></p><p>==IOC本质上是Spring管理一个容器，容器是BeanFactory的实现，容器中管理了所有用户指定的bean（xml或注解），最底层就是一个Map==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;bean的注册</span><br><span class="line">        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;bean的加载</span><br><span class="line">        UserService userService &#x3D; (UserService) applicationContext.getBean(&quot;userService&quot;);</span><br><span class="line">        userService.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bean注册"><a href="#bean注册" class="headerlink" title="bean注册"></a>bean注册</h3><p>==然后解析xml、注解中定义的bean。将bean信息解析存储到BeanDefinition相应的属性中，并将所有的benaName和对应的BeanDefinition存放到BeanFactory中成员变量的Map中。==</p><ul><li>BeanDefinition的保存的是Bean的类名、scope、属性、构造函数参数列表、依赖的bean、是否是单例类、是否是懒加载等，==后面对Bean的操作就直接对BeanDefinition进行==，例如拿到这个BeanDefinition后，可以根据里面的类名、构造函数、构造函数参数，使用反射进行对象创建。</li></ul><p><img src="https://img-blog.csdn.net/20171217162549343?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc29uZ3hpbmppYW5xd2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><p>在解析bean的过程中创建了BeanFactory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected DefaultListableBeanFactory createBeanFactory() &#123;</span><br><span class="line">    return new DefaultListableBeanFactory(this.getInternalParentBeanFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>且BeanFactory有成员变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap &#x3D; new ConcurrentHashMap(256);</span><br></pre></td></tr></table></figure><p>两个重要的方法：</p><ul><li>obtainFreshBeanFactory，读取到所有的beanDefinition（bean的定义，比如xml配置文件中的中定义的，或者@Component、@Service等标记的bean），并保存到beanFactroy中；</li><li>finishBeanFactoryInitialization，加载所有非延迟加载的、单例的bean <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">   synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">      &#x2F;&#x2F; 准备 刷新的上下文环境</span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 初始化BeanFactory，并进行XML文件的读取</span><br><span class="line">      ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 对BeanFactory进行各种功能填充</span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         &#x2F;&#x2F; 子类覆盖方法做额外的处理</span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 激活各种BeanFactory处理器</span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 注册拦截Bean创建的Bean处理器，这里只是注册，真正的调用是在getBean的时候</span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 为上下文初始化Message源，即不同语言的消息体，国际化处理</span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 初始化应用消息广播器，并放入applicationEventMulticaster bean中</span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 留给子类来初始化其他bean</span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 在所有注册的bean中查找Listener bean，注册到消息广播器中</span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 初始化剩下的单例实例（除了lazy-init）</span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 完成刷新过程，通知生命周期处理器lifecycleProcessor刷新过程，同时发出ContextRefreshEvent通知别人</span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      catch (BeansException ex) &#123;</span><br><span class="line">         if (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">                  &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; Destroy already created singletons to avoid dangling resources.</span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; Reset &#39;active&#39; flag.</span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; Propagate exception to caller.</span><br><span class="line">         throw ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      finally &#123;</span><br><span class="line">         &#x2F;&#x2F; Reset common introspection caches in Spring&#39;s core, since we</span><br><span class="line">         &#x2F;&#x2F; might not ever need metadata for singleton beans anymore...</span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>可跟踪代码，最后将解析到的beanName放入beanDefinitionMap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanDefinitionMap.put(beanName, beanDefinition);</span><br></pre></td></tr></table></figure><p>解析标签的时候，涉及到解析AOP标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;处理自定义标签</span><br><span class="line">public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) &#123;</span><br><span class="line">   String namespaceUri &#x3D; getNamespaceURI(ele);</span><br><span class="line">&#x2F;&#x2F; AopNamespaceHandler</span><br><span class="line">   NamespaceHandler handler &#x3D; this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">   if (handler &#x3D;&#x3D; null) &#123;</span><br><span class="line">      error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, ele);</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">   return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里返回的parser即为AspectJAutoProxyBeanDefinitionParser。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">   AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">   extendBeanDefinition(element, parserContext);</span><br><span class="line">   return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册这个creator</span><br><span class="line">public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">      ParserContext parserContext, Element sourceElement) &#123;</span><br><span class="line">   &#x2F;&#x2F; 注册或升级AutoProxyCreator定义beanName为internalAutoProxyCreator的BeanDefinition</span><br><span class="line">   BeanDefinition beanDefinition &#x3D; AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">         parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对于proxy-target-class以及expose-proxy属性的增强</span><br><span class="line">   useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">&#x2F;&#x2F; 注册组件并通知，便于监听器做进一步处理</span><br><span class="line">&#x2F;&#x2F; 其中beanDefinition的className为AnnotationAwareAspectJAutoProxyCreator</span><br><span class="line">   registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IOC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bean的注册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双端队列Deque</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E9%98%9F%E5%88%97/2%E3%80%81%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97Deque/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E9%98%9F%E5%88%97/2%E3%80%81%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97Deque/</url>
      
        <content type="html"><![CDATA[<p>双端队列（deque，全名double-ended queue），是一种具有队列和栈的性质的数据结构。</p><p>双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。双端队列可以在队列任意一端入队和出队。</p><ul><li>入队列（push）</li><li>出队列（pop）</li><li>队首入队列（unshift）</li><li>队首出队列（shift）</li><li>获取队列中某个元素（get）</li><li>将值插入队列某个位置（insert）</li><li>移除队列中指定位置的值（remove）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package LinearList;</span><br><span class="line"></span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">public interface LinearList&lt;E&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;获取队列指定位置元素</span><br><span class="line">    public E get(int i);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;获取队列长度</span><br><span class="line">    public int getSize();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;判断队列是否为空</span><br><span class="line">    public boolean isEmpty();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;队列指定位置插入元素</span><br><span class="line">    public boolean insert(int i, E o);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;移除指定位置元素</span><br><span class="line">    public boolean remove(int i);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;队尾入队列</span><br><span class="line">    public boolean push(E o);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;队首入队列</span><br><span class="line">    public boolean unshift(E o);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;队尾出队列</span><br><span class="line">    public E pop();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;队首出队列</span><br><span class="line">    public E shift();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;迭代器</span><br><span class="line">    public Iterator&lt;E&gt; iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">package LinearList.imp;</span><br><span class="line"></span><br><span class="line">import LinearList.*;</span><br><span class="line">import com.sun.istack.internal.NotNull;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 数组实现线性表</span><br><span class="line"> * author： xubaodian</span><br><span class="line"> * time： 2018&#x2F;9&#x2F;25</span><br><span class="line"> * @param</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ArrayLinearList&lt;E&gt; implements LinearList&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;采用数组实现队列，初始数组长度为8，</span><br><span class="line">    private int Len &#x3D; 8;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;队列长度，队列长度小于等于数据长度</span><br><span class="line">    private int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;数组，是队列的容器，用来保存队列元素</span><br><span class="line">    private Object []arrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public ArrayLinearList() &#123;</span><br><span class="line">        arrayList &#x3D; new Object[this.Len];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取队列中的指定元素，若索引大于队列长度，则抛出异常</span><br><span class="line">    @Override</span><br><span class="line">    public E get(int i) &#123;</span><br><span class="line">        if (i &lt; this.count) &#123;</span><br><span class="line">            return (E)this.arrayList[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException(&quot;索引超出队列长度&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取队列长度</span><br><span class="line">    @Override</span><br><span class="line">    public int getSize() &#123;</span><br><span class="line">        return this.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断队列是否为空</span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        if (this.count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return  true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;队列指定位置插入元素</span><br><span class="line">    @Override</span><br><span class="line">    public boolean insert(int i, E o) &#123;</span><br><span class="line">        if (i &lt;&#x3D; this.count) &#123;</span><br><span class="line">            for(int j &#x3D; this.count; j &gt; i ; j--) &#123;</span><br><span class="line">                this.arrayList[j] &#x3D; this.arrayList[j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            this.arrayList[i] &#x3D; o;</span><br><span class="line">            this.count++;</span><br><span class="line">            this.expandArray();</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException(&quot;索引超出队列长度&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;移除指定位置元素</span><br><span class="line">    @Override</span><br><span class="line">    public boolean remove(int i) &#123;</span><br><span class="line">        if (i &lt; this.count) &#123;</span><br><span class="line">            for (int j &#x3D; i; i &lt; this.count - 1; j++) &#123;</span><br><span class="line">                this.arrayList[j] &#x3D; this.arrayList[j + 1];</span><br><span class="line">            &#125;</span><br><span class="line">            this.count--;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException(&quot;索引超出队列长度&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;队尾压入数组</span><br><span class="line">    @Override</span><br><span class="line">    public boolean push(E o) &#123;</span><br><span class="line">        this.arrayList[this.count++] &#x3D; o;</span><br><span class="line">        this.expandArray();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;队首压入数组</span><br><span class="line">    @Override</span><br><span class="line">    public boolean unshift(E o) &#123;</span><br><span class="line">        for(int i &#x3D; this.count; i &gt; 0; i--) &#123;</span><br><span class="line">            this.arrayList[i] &#x3D; this.arrayList[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        this.count++;</span><br><span class="line">        this.arrayList[0] &#x3D; o;</span><br><span class="line">        this.expandArray();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;队尾出数组</span><br><span class="line">    @Override</span><br><span class="line">    public E pop() &#123;</span><br><span class="line">        if (this.count &gt; 0) &#123;</span><br><span class="line">            return (E)this.arrayList[this.count--];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;队首出数组</span><br><span class="line">    @Override</span><br><span class="line">    public E shift() &#123;</span><br><span class="line">        if (this.count &gt; 0) &#123;</span><br><span class="line">            Object tmp &#x3D; this.arrayList[0];</span><br><span class="line">            for (int i &#x3D; 0; i &lt; this.count; i++) &#123;</span><br><span class="line">                this.arrayList[0] &#x3D; this.arrayList[i + 1];</span><br><span class="line">            &#125;</span><br><span class="line">            this.count--;</span><br><span class="line">            return (E)tmp;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;数组容量扩充为原来的2倍，并将现有数组迁移入新的数组中</span><br><span class="line">    private void expand() &#123;</span><br><span class="line">        this.Len *&#x3D; 2;</span><br><span class="line">        Object [] array &#x3D; new Object[this.Len];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">            array[i] &#x3D; this.arrayList[i];</span><br><span class="line">        &#125;</span><br><span class="line">        this.arrayList &#x3D; array;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;判断数组是否已满，若数组已满，则扩充数组</span><br><span class="line">    private void expandArray() &#123;</span><br><span class="line">        if (this.count &#x3D;&#x3D; this.Len) &#123;</span><br><span class="line">            this.expand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回迭代器</span><br><span class="line">    @Override</span><br><span class="line">    @NotNull</span><br><span class="line">    public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return new ArrayLinearList.Itr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;迭代器私有类</span><br><span class="line">    private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">        int cursor &#x3D; 0;       &#x2F;&#x2F; index of next element to return</span><br><span class="line">        int lastRet &#x3D; -1; &#x2F;&#x2F; index of last element returned; -1 if no such</span><br><span class="line"></span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return cursor !&#x3D; count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public E next() &#123;</span><br><span class="line">            int i &#x3D; cursor;</span><br><span class="line">            if (i &gt;&#x3D; count)</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            cursor &#x3D; i + 1;</span><br><span class="line">            return (E) arrayList[lastRet &#x3D; i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            if (lastRet &lt; 0)</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            try &#123;</span><br><span class="line">                ArrayLinearList.this.remove(lastRet);</span><br><span class="line">                cursor &#x3D; lastRet;</span><br><span class="line">                lastRet &#x3D; -1;</span><br><span class="line">            &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双端队列Deque </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka生产者</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/4%E3%80%81kafka/5%E3%80%81kafka%E7%94%9F%E4%BA%A7%E8%80%85/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/4%E3%80%81kafka/5%E3%80%81kafka%E7%94%9F%E4%BA%A7%E8%80%85/</url>
      
        <content type="html"><![CDATA[<p>消息发送流程</p><p>Kafka 的 Producer发送消息采用的是异步发送的方式。在消息发送的过程中，涉及到了两个线程——main 线程和 Sender 线程，以及一个共享变量——RecordAccumulator。</p><p>main 线程将消息发送给 RecordAccumulator，<br>Sender 线程不断从 RecordAccumulator 中拉取消息发送到 Kafka broker。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 注意：消息发送失败会自动重试，不需要我们在回调函数中手动重试。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void send() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        Properties props &#x3D; new Properties();</span><br><span class="line">        &#x2F;&#x2F;kafka 集群，broker-list</span><br><span class="line">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;127.0.0.1:9092&quot;);</span><br><span class="line">        props.put(ProducerConfig.ACKS_CONFIG, &quot;all&quot;);</span><br><span class="line">        &#x2F;&#x2F;重试次数；消息发送失败会自动重试，不需要我们在回调函数中手动重试</span><br><span class="line">        props.put(ProducerConfig.RETRIES_CONFIG, 1);</span><br><span class="line">        &#x2F;&#x2F;批次大小.只有数据积累到 batch.size 之后，sender 才会发送数据。</span><br><span class="line">        props.put(ProducerConfig.BATCH_SIZE_CONFIG, 16384);</span><br><span class="line">        &#x2F;&#x2F;等待时间.如果数据迟迟未达到 batch.size，sender 等待 linger.time 之后就会发送数据。</span><br><span class="line">        props.put(ProducerConfig.LINGER_MS_CONFIG, 1);</span><br><span class="line">        &#x2F;&#x2F;RecordAccumulator 缓冲区大小:32M</span><br><span class="line">        props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, 33554432);</span><br><span class="line">        </span><br><span class="line">         &#x2F;&#x2F;构建拦截链</span><br><span class="line">        List&lt;String&gt; interceptors &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        interceptors.add(TimeInterceptor.class.getName());</span><br><span class="line">        &#x2F;&#x2F;添加拦截器</span><br><span class="line">        props.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, interceptors);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;key、value的fan序列化</span><br><span class="line">        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringSerializer.class.getName());</span><br><span class="line"></span><br><span class="line">        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringSerializer.class.getName());</span><br><span class="line">        &#x2F;&#x2F;自定义分区器</span><br><span class="line">        props.put(ProducerConfig.PARTITIONER_CLASS_CONFIG,</span><br><span class="line">                MyPartition.class.getName());</span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer &#x3D; new KafkaProducer&lt;String, String&gt;(props);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;发送到的主题</span><br><span class="line">            String topic &#x3D; &quot;firsTopic&quot;;</span><br><span class="line">            &#x2F;&#x2F;key可做分区使用</span><br><span class="line">            String key &#x3D; Integer.toString(i);</span><br><span class="line">            &#x2F;&#x2F;value为消息数据</span><br><span class="line">            String value &#x3D; Integer.toString(i);</span><br><span class="line">&#x2F;&#x2F;            int partition&#x3D;1;</span><br><span class="line">&#x2F;&#x2F;            ProducerRecord&lt;String, String&gt; record &#x3D; new ProducerRecord&lt;String, String&gt;(topic, partition,key, value);</span><br><span class="line">            ProducerRecord&lt;String, String&gt; record &#x3D; new ProducerRecord&lt;String, String&gt;(topic, key, value);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;（1）只管发，没有回调函数</span><br><span class="line">            &#x2F;&#x2F;Future&lt;RecordMetadata&gt; future &#x3D; producer.send(record);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;（2）Producer 收到 ack 时,异步回调Callback函数</span><br><span class="line">            &#x2F;&#x2F;如果 Exception 为 null，说明消息发送成功，反之为失败</span><br><span class="line">            Future&lt;RecordMetadata&gt; future &#x3D; producer.send(record, new Callback() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onCompletion(RecordMetadata metadata, Exception exception) &#123;</span><br><span class="line">                    if (exception &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        System.err.println(&quot;Producer收到消息发送成功的ack:&quot; + metadata.offset());</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        &#x2F;&#x2F;消息发送失败会自动重试，不需要我们在回调函数中手动重试</span><br><span class="line">                        System.err.println(&quot;Producer收到消息发送失败的ack&quot;);</span><br><span class="line">                        exception.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            &#x2F;&#x2F;返回future,可以根据需要调用get阻塞线程</span><br><span class="line">            &#x2F;&#x2F;future.get();</span><br><span class="line">        &#125;</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="自定义分区器"><a href="#自定义分区器" class="headerlink" title="自定义分区器"></a>自定义分区器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 自定义分区器</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyPartition implements Partitioner &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) &#123;</span><br><span class="line">        &#x2F;&#x2F;根据不同业务，可以根据key、value等 返回分区id</span><br><span class="line">        return key.toString().hashCode() % 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(Map&lt;String, ?&gt; map) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>实现一个简单的双 interceptor 组成的拦截链。第一个 interceptor 会在消息发送前将时间<br>戳信息加到消息 value 的最前部；第二个 interceptor 会在消息发送后更新成功发送消息数或<br>失败发送消息数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class TimeInterceptor implements ProducerInterceptor&lt;String, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取配置信息和初始化数据时调用。</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(Map&lt;String, ?&gt; configs) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;该方法封装进 KafkaProducer.send 方法中，即它运行在用户主线程中。Producer 确保在</span><br><span class="line">    &#x2F;&#x2F;消息被序列化以及计算分区前调用该方法。</span><br><span class="line">    @Override</span><br><span class="line">    public ProducerRecord&lt;String, String&gt; onSend(ProducerRecord&lt;String, String&gt; record) &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建一个新的 record，把时间戳写入消息体的最前部</span><br><span class="line">        String topic &#x3D; record.topic();</span><br><span class="line">        int partition &#x3D; record.partition();</span><br><span class="line">        String key &#x3D; record.key();</span><br><span class="line">        String value &#x3D; record.value();</span><br><span class="line">        String newValue&#x3D;System.currentTimeMillis() + &quot;,&quot; + value;</span><br><span class="line">        Long timestamp &#x3D; record.timestamp();</span><br><span class="line">        ProducerRecord recordResult&#x3D; new ProducerRecord(topic, partition, timestamp, key, newValue);</span><br><span class="line">        return recordResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;该方法会在消息从 RecordAccumulator 成功发送到 Kafka Broker 之后，或者在发送过程</span><br><span class="line">    &#x2F;&#x2F;中失败时调用。</span><br><span class="line">    @Override</span><br><span class="line">    public void onAcknowledgement(RecordMetadata metadata,</span><br><span class="line">                                  Exception exception) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;关闭 interceptor，主要用于执行一些资源清理工作</span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka生产者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka消费者</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/4%E3%80%81kafka/6%E3%80%81kafka%E6%B6%88%E8%B4%B9%E8%80%85/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/4%E3%80%81kafka/6%E3%80%81kafka%E6%B6%88%E8%B4%B9%E8%80%85/</url>
      
        <content type="html"><![CDATA[<p>consumer 需要实时记录自己消费到了哪个 offset，以便故障恢复后继续消费。</p><p>所以设计消费者时，offset是必须考虑的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public static void consumerMsg() &#123;</span><br><span class="line">        Properties props &#x3D; new Properties();</span><br><span class="line">        &#x2F;&#x2F;连接Kafka集群</span><br><span class="line">        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;hadoop102:9092&quot;);</span><br><span class="line">        &#x2F;&#x2F;消费者组，只要 group.id 相同，就属于同一个消费者组</span><br><span class="line">        props.put(ConsumerConfig.GROUP_ID_CONFIG, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;重置消费者的offset。只在两种情况生效：消费者换组，或者消息数据失效删除了</span><br><span class="line">        &#x2F;&#x2F;earliest：自动将偏移量重置为最早的偏移量（默认）</span><br><span class="line">        &#x2F;&#x2F;latest：自动将偏移量重置为最新偏移量</span><br><span class="line">        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, &quot;earliest&quot;);</span><br><span class="line">        &#x2F;&#x2F;关闭自动提交 offset&#x3D;false。则需要手动提交offset调用：consumer.commitSync();</span><br><span class="line">        &#x2F;&#x2F;若为自动提交offset&#x3D;true.无须手动调用consumer.commitSync();</span><br><span class="line">        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, &quot;false&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;key、value的fan序列化</span><br><span class="line">        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringDeserializer.class.getName());</span><br><span class="line"></span><br><span class="line">        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringDeserializer.class.getName());</span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer &#x3D; new</span><br><span class="line">                KafkaConsumer&lt;String, String&gt;(props);</span><br><span class="line">        &#x2F;&#x2F;消费者订阅的多个主题</span><br><span class="line">        consumer.subscribe(Arrays.asList(&quot;firstTopic&quot;));</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            &#x2F;&#x2F;消费者拉取数据延迟时间（一次会拉取多条消息）</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records &#x3D; consumer.poll(100);</span><br><span class="line">            for (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.print(&quot;offset:&quot; + record.offset() + &quot; key:&quot; + record.key() + &quot; value:&quot; + record.value());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;**注意：</span><br><span class="line">             * 无论是同步提交还是异步提交 offset，都有可能会造成数据的漏消费或者重复消费。</span><br><span class="line">             * 先提交 offset 后消费，有可能造成数据的漏消费；</span><br><span class="line">             * 而先消费后提交 offset，有可能会造成数据的重复消费。</span><br><span class="line">             *&#x2F;</span><br><span class="line">            &#x2F;&#x2F;同步提交，当前线程会阻塞直到 offset 提交成功</span><br><span class="line">            consumer.commitSync();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;异步提交</span><br><span class="line">            consumer.commitAsync(new OffsetCommitCallback() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onComplete(Map&lt;TopicPartition,</span><br><span class="line">                        OffsetAndMetadata&gt; offsets, Exception exception) &#123;</span><br><span class="line">                    if (exception !&#x3D; null) &#123;</span><br><span class="line">                        System.err.println(&quot;异步同步提交offset failed：&quot; + offsets);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>自定义存储 offset</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">private static Map&lt;TopicPartition, Long&gt; currentOffset &#x3D; new HashMap&lt;TopicPartition, Long&gt;();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;自定义存储 offset</span><br><span class="line">   public static void consumerMsgSaveOffset() &#123;</span><br><span class="line">       Properties props &#x3D; new Properties();</span><br><span class="line">       &#x2F;&#x2F;连接Kafka集群</span><br><span class="line">       props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;hadoop102:9092&quot;);</span><br><span class="line">       &#x2F;&#x2F;消费者组，只要 group.id 相同，就属于同一个消费者组</span><br><span class="line">       props.put(ConsumerConfig.GROUP_ID_CONFIG, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;重置消费者的offset。只在两种情况生效：消费者换组，或者消息数据失效删除了</span><br><span class="line">       &#x2F;&#x2F;earliest：自动将偏移量重置为最早的偏移量（默认）</span><br><span class="line">       &#x2F;&#x2F;latest：自动将偏移量重置为最新偏移量</span><br><span class="line">       props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, &quot;earliest&quot;);</span><br><span class="line">       &#x2F;&#x2F;关闭自动提交 offset&#x3D;false。则需要手动提交offset调用：consumer.commitSync();</span><br><span class="line">       &#x2F;&#x2F;若为自动提交offset&#x3D;true.无须手动调用consumer.commitSync();</span><br><span class="line">       props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, &quot;false&quot;);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;key、value的fan序列化</span><br><span class="line">       props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">               StringDeserializer.class.getName());</span><br><span class="line"></span><br><span class="line">       props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">               StringDeserializer.class.getName());</span><br><span class="line">       final KafkaConsumer&lt;String, String&gt; consumer &#x3D; new</span><br><span class="line">               KafkaConsumer&lt;String, String&gt;(props);</span><br><span class="line"></span><br><span class="line">       ConsumerRebalanceListener listener &#x3D; new ConsumerRebalanceListener() &#123;</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F;该方法会在 Rebalance 之前调用</span><br><span class="line">           @Override</span><br><span class="line">           public void onPartitionsRevoked(Collection&lt;TopicPartition&gt; partitions) &#123;</span><br><span class="line">               commitOffset(currentOffset);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; &#x2F;&#x2F;该方法会在 Rebalance 之后调用</span><br><span class="line">           @Override</span><br><span class="line">           public void onPartitionsAssigned(Collection&lt;TopicPartition&gt; partitions) &#123;</span><br><span class="line">               currentOffset.clear();</span><br><span class="line">               for (TopicPartition partition : partitions) &#123;</span><br><span class="line">                   consumer.seek(partition, getOffset(partition));</span><br><span class="line">                   &#x2F;&#x2F;定位到最近提交的 offset 位置继续消费</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;消费者订阅的多个主题</span><br><span class="line">       consumer.subscribe(Arrays.asList(&quot;firstTopic&quot;), listener);</span><br><span class="line">       while (true) &#123;</span><br><span class="line">           &#x2F;&#x2F;消费者拉取数据延迟时间（一次会拉取多条消息）</span><br><span class="line">           ConsumerRecords&lt;String, String&gt; records &#x3D; consumer.poll(100);</span><br><span class="line">           for (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">               System.out.print(&quot;offset:&quot; + record.offset() + &quot; key:&quot; + record.key() + &quot; value:&quot; + record.value());</span><br><span class="line">           &#125;</span><br><span class="line">           commitOffset(currentOffset);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;获取某分区的最新 offset</span><br><span class="line">   private static long getOffset(TopicPartition partition) &#123;</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;提交该消费者所有分区的 offset</span><br><span class="line">   private static void commitOffset(Map&lt;TopicPartition, Long&gt; currentOffset) &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka消费者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册servlet的三大组件</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-boot/6%E3%80%81%E6%B3%A8%E5%86%8Cservlet%E7%9A%84%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-boot/6%E3%80%81%E6%B3%A8%E5%86%8Cservlet%E7%9A%84%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>传统spring应用注册servlet的三个组件 </p><p>Servlet,Listener,Filter是在WEB-INF/web.xml中注册。</p><p>在Springboot中没有xml，还是使用配置类</p><p>ServletRegistrationBean </p><p>ServletListenerRegistrationBean </p><p>FilterRegistrationBean </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @Configuration 指明当前类是一个注解类，就是替代之前的spring配置文件</span><br><span class="line"> * 再配置文件中使用&lt;bean&gt;&lt;&#x2F;bean&gt;来添加组件</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ServletRegistrationBean servletRegistrationBean()&#123;</span><br><span class="line">        ServletRegistrationBean servletRegistrationBean &#x3D; new ServletRegistrationBean(new MyServlet,&quot;&#x2F;**&quot;);</span><br><span class="line">        return servletRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ServletListenerRegistrationBean servletListenerRegistrationBean()&#123;</span><br><span class="line">        ServletListenerRegistrationBean servletListenerRegistrationBean &#x3D; new ServletListenerRegistrationBean(new MyListner());</span><br><span class="line">        return servletListenerRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public FilterRegistrationBean filterRegistrationBean()&#123;</span><br><span class="line">        FilterRegistrationBean filterRegistrationBean &#x3D; new FilterRegistrationBean();</span><br><span class="line">        filterRegistrationBean.setFilter(new MyFliter());</span><br><span class="line">        filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;&#x2F;**&quot;));</span><br><span class="line">        return filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>附带：</p><p>MyFliter.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.wangping.fliter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class MyFliter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MyServlet.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.wangping.servler;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class MyServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        super.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        super.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MyListner.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.wangping.listener;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletContextEvent;</span><br><span class="line">import javax.servlet.ServletContextListener;</span><br><span class="line"></span><br><span class="line">public class MyListner  implements ServletContextListener &#123;</span><br><span class="line"></span><br><span class="line">    Logger logger&#x3D;LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextInitialized(ServletContextEvent event) &#123;</span><br><span class="line">        logger.error(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;服务器启动&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextDestroyed(ServletContextEvent event) &#123;</span><br><span class="line">        logger.error(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;服务器关闭&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="嵌入式Servlet容器"><a href="#嵌入式Servlet容器" class="headerlink" title="嵌入式Servlet容器"></a>嵌入式Servlet容器</h3><p>Springboot的嵌入式Servlet容器（应用打包为可执行的jar包）</p><p>优点：简单 快捷</p><p>缺点：默认不支持JSP,优化定制化比较难<br>Springboot嵌入式Servlet容器的相关配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;配置嵌入式的Servlet容器</span><br><span class="line">    @Bean</span><br><span class="line">    public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123;</span><br><span class="line">        return new EmbeddedServletContainerCustomizer() &#123;</span><br><span class="line">            &#x2F;&#x2F;定制嵌入式的Servlet容器相关的规则</span><br><span class="line">            @Override</span><br><span class="line">            public void customize(ConfigurableEmbeddedServletContainer container) &#123;</span><br><span class="line">                container.setPort(8083);</span><br><span class="line">&#x2F;&#x2F;与再properties中修改效果一致。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Springboot默认使用tmcat，如何切换其他嵌入式容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入web模块 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;&#x2F;exclusion&gt;</span><br><span class="line">    &lt;&#x2F;exclusions&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--引入其他的Servlet容器--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jetty&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>如何使用外部servlet容器（应用打包为war包）：</p><p>1、现在idea配置号外部tomcat。见文末</p><p>2、必须创建一个war包</p><p>3、将嵌入式的tomcat指定为provided（目标环境已经有了tomcat,则打包时不用嵌入式的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>4、必须编写一个SpringBootServletInitializer 的子类，目的调用configure方法。方法里面是固定写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Servletinitializer extends SpringBootServletInitializer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123;</span><br><span class="line">        return builder.sources(MyApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、外部服务器则可以使用了。<br>原理：<br>jar:执行Springboot的启动类的main方法，启动spring的ico容器，创建嵌入式的servlet容器</p><p>war:先启动外部服务器，外部服务器启动springboot应用（如何启动：就是之前SpringBootServletInitializer 子类的configure方法），然后再启动IOC容器</p><p>附录：<br>先在IDEA中添加配置外部tomcat</p>]]></content>
      
      
      <categories>
          
          <category> spring-boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注册servlet的三大组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪花算法</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>分布式ID生成 - 雪花算法:SnowFlake</p><p>分布式系统中，有一些需要使用全局唯一ID的场景，这种时候为了防止ID冲突可以使用36位的UUID，但是UUID有一些缺点，首先他相对比较长，另外UUID一般是无序的。</p><p>twitter的SnowFlake解决了这种需求，最初Twitter把存储系统从MySQL迁移到Cassandra，因为Cassandra没有顺序ID生成机制，所以开发了这样一套全局唯一ID生成服务。</p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>SnowFlake算法产生的ID是一个64位的整型，结构如下（每一部分用“-”符号分隔）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000</span><br></pre></td></tr></table></figure><p>1位标识部分，在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以为0；</p><p>41位时间戳部分，这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L 60 60 24 365) = 69年；</p><p>10位节点部分，Twitter实现中使用==前5位作为数据中心标识，后5位作为机器标识==，可以部署1024个节点；（可以根据我们业务的需要，灵活分配节点部分，如：若不需要数据中心，完全可以使用全部10位作为机器标识；若数据中心不多，也可以只使用3位作为数据中心，7位作为机器标识。）</p><p>12位序列号部分，支持同一毫秒内同一个节点可以生成4096个ID；（snowflake每秒能够产生26万个ID。）</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li>1、twitter的SnowFlake生成ID能够按照时间有序生成</li><li>2、SnowFlake算法生成id的结果是一个64bit大小的整数</li><li>3、分布式系统内不会产生重复id（用有datacenterId和machineId来做区分）</li><li>datacenterId（分布式）（服务ID 1，2，3…..） 每个服务中写死</li><li>machineId（用于集群） 机器ID 读取机器的环境变量MACHINEID 部署时每台服务器ID不一样</li></ul><h4 id="两个问题："><a href="#两个问题：" class="headerlink" title="两个问题："></a>两个问题：</h4><ul><li><p>机器ID（5位）和数据中心ID（5位）配置没有解决，分布式部署的时候会使用相同的配置，任然有ID重复的风险。</p></li><li><p>使用的时候需要实例化对象，没有形成开箱即用的工具类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 描述: Twitter的分布式自增ID雪花算法snowflake (Java版)</span><br><span class="line"> *</span><br><span class="line"> **&#x2F;</span><br><span class="line">public class SnowFlake &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 起始的时间戳</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final static long START_STMP &#x3D; 1480166465631L;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 每一部分占用的位数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final static long SEQUENCE_BIT &#x3D; 12; &#x2F;&#x2F;序列号占用的位数</span><br><span class="line">    private final static long MACHINE_BIT &#x3D; 5;   &#x2F;&#x2F;机器标识占用的位数</span><br><span class="line">    private final static long DATACENTER_BIT &#x3D; 5;&#x2F;&#x2F;数据中心占用的位数</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 每一部分的最大值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final static long MAX_DATACENTER_NUM &#x3D; -1L ^ (-1L &lt;&lt; DATACENTER_BIT);</span><br><span class="line">    private final static long MAX_MACHINE_NUM &#x3D; -1L ^ (-1L &lt;&lt; MACHINE_BIT);</span><br><span class="line">    private final static long MAX_SEQUENCE &#x3D; -1L ^ (-1L &lt;&lt; SEQUENCE_BIT);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 每一部分向左的位移</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final static long MACHINE_LEFT &#x3D; SEQUENCE_BIT;</span><br><span class="line">    private final static long DATACENTER_LEFT &#x3D; SEQUENCE_BIT + MACHINE_BIT;</span><br><span class="line">    private final static long TIMESTMP_LEFT &#x3D; DATACENTER_LEFT + DATACENTER_BIT;</span><br><span class="line"></span><br><span class="line">    private long datacenterId;  &#x2F;&#x2F;数据中心</span><br><span class="line">    private long machineId;     &#x2F;&#x2F;机器标识</span><br><span class="line">    private long sequence &#x3D; 0L; &#x2F;&#x2F;序列号</span><br><span class="line">    private long lastStmp &#x3D; -1L;&#x2F;&#x2F;上一次时间戳</span><br><span class="line"></span><br><span class="line">    public SnowFlake(long datacenterId, long machineId) &#123;</span><br><span class="line">        if (datacenterId &gt; MAX_DATACENTER_NUM || datacenterId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;datacenterId can&#39;t be greater than MAX_DATACENTER_NUM or less than 0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (machineId &gt; MAX_MACHINE_NUM || machineId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;machineId can&#39;t be greater than MAX_MACHINE_NUM or less than 0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.datacenterId &#x3D; datacenterId;</span><br><span class="line">        this.machineId &#x3D; machineId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 产生下一个ID</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized long nextId() &#123;</span><br><span class="line">        long currStmp &#x3D; getNewstmp();</span><br><span class="line">        if (currStmp &lt; lastStmp) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Clock moved backwards.  Refusing to generate id&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (currStmp &#x3D;&#x3D; lastStmp) &#123;</span><br><span class="line">            &#x2F;&#x2F;相同毫秒内，序列号自增</span><br><span class="line">            sequence &#x3D; (sequence + 1) &amp; MAX_SEQUENCE;</span><br><span class="line">            &#x2F;&#x2F;同一毫秒的序列数已经达到最大</span><br><span class="line">            if (sequence &#x3D;&#x3D; 0L) &#123;</span><br><span class="line">                currStmp &#x3D; getNextMill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;不同毫秒内，序列号置为0</span><br><span class="line">            sequence &#x3D; 0L;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastStmp &#x3D; currStmp;</span><br><span class="line"></span><br><span class="line">        return (currStmp - START_STMP) &lt;&lt; TIMESTMP_LEFT &#x2F;&#x2F;时间戳部分</span><br><span class="line">                | datacenterId &lt;&lt; DATACENTER_LEFT       &#x2F;&#x2F;数据中心部分</span><br><span class="line">                | machineId &lt;&lt; MACHINE_LEFT             &#x2F;&#x2F;机器标识部分</span><br><span class="line">                | sequence;                             &#x2F;&#x2F;序列号部分</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long getNextMill() &#123;</span><br><span class="line">        long mill &#x3D; getNewstmp();</span><br><span class="line">        while (mill &lt;&#x3D; lastStmp) &#123;</span><br><span class="line">            mill &#x3D; getNewstmp();</span><br><span class="line">        &#125;</span><br><span class="line">        return mill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long getNewstmp() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SnowFlake snowFlake &#x3D; new SnowFlake(2, 3);</span><br><span class="line"></span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">            System.out.println(snowFlake.nextId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis() - start);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 雪花算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪花算法</title>
      <link href="2020/06/21/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/9%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E5%99%A8/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"/>
      <url>2020/06/21/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/9%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E5%99%A8/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>分布式ID生成 - 雪花算法:SnowFlake</p><p>分布式系统中，有一些需要使用全局唯一ID的场景，这种时候为了防止ID冲突可以使用36位的UUID，但是UUID有一些缺点，首先他相对比较长，另外UUID一般是无序的。</p><p>twitter的SnowFlake解决了这种需求，最初Twitter把存储系统从MySQL迁移到Cassandra，因为Cassandra没有顺序ID生成机制，所以开发了这样一套全局唯一ID生成服务。</p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>SnowFlake算法产生的ID是一个64位的整型，结构如下（每一部分用“-”符号分隔）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000</span><br></pre></td></tr></table></figure><p>1位标识部分，在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以为0；</p><p>41位时间戳部分，这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L 60 60 24 365) = 69年；</p><p>10位节点部分，Twitter实现中使用==前5位作为数据中心标识，后5位作为机器标识==，可以部署1024个节点；（可以根据我们业务的需要，灵活分配节点部分，如：若不需要数据中心，完全可以使用全部10位作为机器标识；若数据中心不多，也可以只使用3位作为数据中心，7位作为机器标识。）</p><p>12位序列号部分，支持同一毫秒内同一个节点可以生成4096个ID；（snowflake每秒能够产生26万个ID。）</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li>1、twitter的SnowFlake生成ID能够按照时间有序生成</li><li>2、SnowFlake算法生成id的结果是一个64bit大小的整数</li><li>3、分布式系统内不会产生重复id（==用datacenterId和machineId来做区分==）</li><li>datacenterId（分布式）（服务ID 1，2，3…..） 每个服务中写死</li><li>machineId（用于集群） 机器ID 读取机器的环境变量MACHINEID 部署时每台服务器ID不一样</li></ul><h4 id="两个问题："><a href="#两个问题：" class="headerlink" title="两个问题："></a>两个问题：</h4><ul><li><p>机器ID（5位）和数据中心ID（5位）配置没有解决，分布式部署的时候会使用相同的配置，任然有ID重复的风险。</p></li><li><p>使用的时候需要实例化对象，没有形成开箱即用的工具类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 描述: Twitter的分布式自增ID雪花算法snowflake (Java版)</span><br><span class="line"> *</span><br><span class="line"> **&#x2F;</span><br><span class="line">public class SnowFlake &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 起始的时间戳</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final static long START_STMP &#x3D; 1480166465631L;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 每一部分占用的位数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final static long SEQUENCE_BIT &#x3D; 12; &#x2F;&#x2F;序列号占用的位数</span><br><span class="line">    private final static long MACHINE_BIT &#x3D; 5;   &#x2F;&#x2F;机器标识占用的位数</span><br><span class="line">    private final static long DATACENTER_BIT &#x3D; 5;&#x2F;&#x2F;数据中心占用的位数</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 每一部分的最大值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final static long MAX_DATACENTER_NUM &#x3D; -1L ^ (-1L &lt;&lt; DATACENTER_BIT);</span><br><span class="line">    private final static long MAX_MACHINE_NUM &#x3D; -1L ^ (-1L &lt;&lt; MACHINE_BIT);</span><br><span class="line">    private final static long MAX_SEQUENCE &#x3D; -1L ^ (-1L &lt;&lt; SEQUENCE_BIT);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 每一部分向左的位移</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final static long MACHINE_LEFT &#x3D; SEQUENCE_BIT;</span><br><span class="line">    private final static long DATACENTER_LEFT &#x3D; SEQUENCE_BIT + MACHINE_BIT;</span><br><span class="line">    private final static long TIMESTMP_LEFT &#x3D; DATACENTER_LEFT + DATACENTER_BIT;</span><br><span class="line"></span><br><span class="line">    private long datacenterId;  &#x2F;&#x2F;数据中心</span><br><span class="line">    private long machineId;     &#x2F;&#x2F;机器标识</span><br><span class="line">    private long sequence &#x3D; 0L; &#x2F;&#x2F;序列号</span><br><span class="line">    private long lastStmp &#x3D; -1L;&#x2F;&#x2F;上一次时间戳</span><br><span class="line"></span><br><span class="line">    public SnowFlake(long datacenterId, long machineId) &#123;</span><br><span class="line">        if (datacenterId &gt; MAX_DATACENTER_NUM || datacenterId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;datacenterId can&#39;t be greater than MAX_DATACENTER_NUM or less than 0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (machineId &gt; MAX_MACHINE_NUM || machineId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;machineId can&#39;t be greater than MAX_MACHINE_NUM or less than 0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.datacenterId &#x3D; datacenterId;</span><br><span class="line">        this.machineId &#x3D; machineId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 产生下一个ID</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized long nextId() &#123;</span><br><span class="line">        long currStmp &#x3D; getNewstmp();</span><br><span class="line">        if (currStmp &lt; lastStmp) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Clock moved backwards.  Refusing to generate id&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (currStmp &#x3D;&#x3D; lastStmp) &#123;</span><br><span class="line">            &#x2F;&#x2F;相同毫秒内，序列号自增</span><br><span class="line">            sequence &#x3D; (sequence + 1) &amp; MAX_SEQUENCE;</span><br><span class="line">            &#x2F;&#x2F;同一毫秒的序列数已经达到最大</span><br><span class="line">            if (sequence &#x3D;&#x3D; 0L) &#123;</span><br><span class="line">                currStmp &#x3D; getNextMill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;不同毫秒内，序列号置为0</span><br><span class="line">            sequence &#x3D; 0L;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastStmp &#x3D; currStmp;</span><br><span class="line"></span><br><span class="line">        return (currStmp - START_STMP) &lt;&lt; TIMESTMP_LEFT &#x2F;&#x2F;时间戳部分</span><br><span class="line">                | datacenterId &lt;&lt; DATACENTER_LEFT       &#x2F;&#x2F;数据中心部分</span><br><span class="line">                | machineId &lt;&lt; MACHINE_LEFT             &#x2F;&#x2F;机器标识部分</span><br><span class="line">                | sequence;                             &#x2F;&#x2F;序列号部分</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long getNextMill() &#123;</span><br><span class="line">        long mill &#x3D; getNewstmp();</span><br><span class="line">        while (mill &lt;&#x3D; lastStmp) &#123;</span><br><span class="line">            mill &#x3D; getNewstmp();</span><br><span class="line">        &#125;</span><br><span class="line">        return mill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long getNewstmp() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SnowFlake snowFlake &#x3D; new SnowFlake(2, 3);</span><br><span class="line"></span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">            System.out.println(snowFlake.nextId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis() - start);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式ID生成器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 雪花算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interrupts</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/13%E3%80%81Interrupts/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/13%E3%80%81Interrupts/</url>
      
        <content type="html"><![CDATA[<p>Interrupts 线程中断</p><p>==一个线程通过调用另一个线程的Thread对象（注意这里是线程对象，不是Thread类的静态interrupt方法）    的interrupt()方法，发送中断信号。告诉它应该停止正在做的事并去做其他事情，为了让中断机制正常工作，被中断的线程必须支持它自己的中断(即要自己处理中断)==</p><h1 id="中断支持？"><a href="#中断支持？" class="headerlink" title="中断支持？"></a>中断支持？</h1><p>线程如何支持自身的中断,这取决于它当前正在做什么</p><p>1、可捕获InterruptedException异常的线程调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; importantInfo.length; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; Pause for 4 seconds</span><br><span class="line">    try &#123;</span><br><span class="line">       Thread.sleep(4000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">    &#x2F;&#x2F;线程中断，可响应相关操作</span><br><span class="line">       &#x2F;&#x2F; We&#39;ve been interrupted: no more messages.</span><br><span class="line">      return;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F; Print a message</span><br><span class="line"> System.out.println(importantInfo[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上：线程正在频繁调用会抛InterruptedException异常的方法，线程在收到另一个线程发送的中断信号（线程获得CPU执行权，自我中断），时，会被中断异常捕获。</p><p>2、如果一个线程长时间运行而不调用会抛InterruptedException异常，那它必须周期性地调用Thread.interrupted()方法，该方法在接收到中断请求后返回true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; inputs.length; i++) &#123;</span><br><span class="line">    heavyCrunch(inputs[i]);</span><br><span class="line">    if (Thread.interrupted()) &#123;</span><br><span class="line">        &#x2F;&#x2F;收到线程中断信号，且自我中断时执行，</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码可改进为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (Thread.interrupted())&#123;</span><br><span class="line">   throw new InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==收到中断信号后，抛出一个InterruptedException异常可能更有意义。使得中断处理代码能集中在catch语句中==。</p><h1 id="中断状态标记"><a href="#中断状态标记" class="headerlink" title="中断状态标记"></a>中断状态标记</h1><p>thread.interrupt()设置中断标记。当线程通过调用静态方法Thread.interrupted()检测中断时，==中断状态会被清除==。</p><p>非静态的isInterrupted()方法被线程用来检测其他线程的中断状态，不改变中断状态标记。</p><p>按照惯例，任何通过抛出一个InterruptedException异常退出的方法，当抛该异常时会清除中断状态。不过，通过其他的线程调用interrupt()方法，中断状态总是有可能会立即被重新设置。</p><p>官方定义：（很重要）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interrupt()的作用是中断本线程。</span><br><span class="line">本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。</span><br><span class="line">如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。</span><br><span class="line">如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。</span><br><span class="line">如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。</span><br><span class="line">中断一个“已终止的线程”不会产生任何操作。</span><br></pre></td></tr></table></figure><h1 id="1、终止处于“阻塞状态”的线程"><a href="#1、终止处于“阻塞状态”的线程" class="headerlink" title="1、终止处于“阻塞状态”的线程"></a>1、终止处于“阻塞状态”的线程</h1><p>当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的为止就能终止线程，形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            &#x2F;&#x2F; 执行任务...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException ie) &#123;  </span><br><span class="line">        &#x2F;&#x2F; 由于产生InterruptedException异常，退出while(true)循环，线程终止！</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！</p><h1 id="2-终止处于“运行状态”的线程"><a href="#2-终止处于“运行状态”的线程" class="headerlink" title="2 终止处于“运行状态”的线程"></a>2 终止处于“运行状态”的线程</h1><p>(01) 通过“中断标记”终止线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    while (!isInterrupted()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行任务...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。<br>注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。</p><p>(02) 通过“额外添加标记”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private volatile boolean flag&#x3D; true;</span><br><span class="line">protected void stopTask() &#123;</span><br><span class="line">    flag &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    while (flag) &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行任务...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。<br>注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。</p>]]></content>
      
      
      <categories>
          
          <category> 常用方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interrupts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC回收三：垃圾回收器</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/10%E3%80%81GC%E5%9B%9E%E6%94%B6%E4%B8%89%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/10%E3%80%81GC%E5%9B%9E%E6%94%B6%E4%B8%89%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>1、通过引用计数和可达性算法可以分析出谁需要被收回</li><li>2、同过了解回收算法知道如何去回收</li><li>3、接下来就是使用不同垃圾回收器去回收</li></ul><p>JDK7之后的HotSpot虚拟机包含垃圾回收器有：</p><p><img src="https://img-blog.csdn.net/20170906171932635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2lsZW5jZU9P/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><p>其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。</p><h3 id="Serial收集器（复制算法"><a href="#Serial收集器（复制算法" class="headerlink" title="Serial收集器（复制算法)"></a>Serial收集器（复制算法)</h3><p>Serial收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。Serial收集器依然是client模式下的虚拟机新生代的默认收集器<br><img src="https://img-blog.csdn.net/20170906172624319?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2lsZW5jZU9P/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><h3 id="ParNew收集器-复制算法"><a href="#ParNew收集器-复制算法" class="headerlink" title="ParNew收集器 (复制算法)"></a>ParNew收集器 (复制算法)</h3><p>新生代并行收集器，ParNew收集器其实就是Serial收集器的多线程版本<img src="https://img-blog.csdn.net/20170906172857773?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2lsZW5jZU9P/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><h3 id="Parallel-Scavenge收集器-复制算法"><a href="#Parallel-Scavenge收集器-复制算法" class="headerlink" title="Parallel Scavenge收集器(复制算法)"></a>Parallel Scavenge收集器(复制算法)</h3><p>新生代并行收集器，追求高吞吐量，高效利用 CPU。</p><p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。由于与吞吐量关系密切，Parallel Scavenge收集器也经常称为“吞吐量优先”收集器。</p><p><img src="https://img-blog.csdn.net/20170906173049744?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2lsZW5jZU9P/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><h3 id="Serial-Old收集器-标记-整理算法"><a href="#Serial-Old收集器-标记-整理算法" class="headerlink" title="Serial Old收集器(标记-整理算法)"></a>Serial Old收集器(标记-整理算法)</h3><p>老年代单线程收集器，Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用[1]，另一种用途就是作为CMS收集器的后备预案，在并发收集发生ConcurrentMode Failure时使用。</p><h3 id="Parallel-Old收集器-标记-整理算法"><a href="#Parallel-Old收集器-标记-整理算法" class="headerlink" title="Parallel Old收集器 (标记-整理算法)"></a>Parallel Old收集器 (标记-整理算法)</h3><p>老年代并行收集器，吞吐量优先</p><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在JDK 1.6中才开始提供的。</p><h3 id="CMS收集器（标记-清除算法）"><a href="#CMS收集器（标记-清除算法）" class="headerlink" title="CMS收集器（标记-清除算法）"></a>CMS收集器（标记-清除算法）</h3><p>老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</p><p>CMS（Concurrent Mark Sweep）<br>垃圾回收和程序的线程同时运行，可以降低stw200ms左右的时间。</p><p>收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。<br>运作过程分为4个步骤，包括：<br>a)初始标记（CMS initial mark）<br>b)并发标记（CMS concurrent mark）<br>c)重新标记（CMS remark）<br>d)并发清除（CMS concurrent sweep）</p><p>CMS收集器存在3个缺点：<br>1 对CPU资源敏感。一般并发执行的程序对CPU数量都是比较敏感的<br>2 无法处理浮动垃圾。在并发清理阶段用户线程还在执行，这时产生的垃圾无法清理。<br>3 由于标记-清除算法产生大量的空间碎片</p><h3 id="G1收集器-标记-整理算法"><a href="#G1收集器-标记-整理算法" class="headerlink" title="G1收集器 (标记-整理算法)"></a>G1收集器 (标记-整理算法)</h3><p>Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</p><ul><li><p>G1是一款面向服务端应用的垃圾收集器。 </p></li><li><p>G1收集器的运作大致可划分为以下几个步骤：</p></li><li><p>a)初始标记（Initial Marking） </p></li><li><p>b)并发标记（Concurrent Marking） </p></li><li><p>c)最终标记（Final Marking） </p></li><li><p>d)筛选回收（Live Data Counting and Evacuation）</p></li></ul><h3 id="常见生成环境的垃圾回收器组合"><a href="#常见生成环境的垃圾回收器组合" class="headerlink" title="常见生成环境的垃圾回收器组合"></a>常见生成环境的垃圾回收器组合</h3><p>jdk1.8的默认垃圾回收器时Parallel Scavenge+Parallel Old</p><h3 id="设置垃圾收集器参数"><a href="#设置垃圾收集器参数" class="headerlink" title="设置垃圾收集器参数"></a>设置垃圾收集器参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC，虚拟机运行在Client模式下的默认值，Serial+Serial Old。</span><br><span class="line"></span><br><span class="line">-XX:+UseParNewGC，ParNew+Serial Old，在JDK1.8被废弃，在JDK1.7还可以使用。</span><br><span class="line"></span><br><span class="line">-XX:+UseConcMarkSweepGC，ParNew+CMS+Serial Old。</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelGC，虚拟机运行在Server模式下的默认值，Parallel Scavenge+Serial Old(PS Mark Sweep)。</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC，Parallel Scavenge+Parallel Old。</span><br><span class="line"></span><br><span class="line">-XX:+UseG1GC，G1+G1。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC回收三：垃圾回收器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java内存模型</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2%E3%80%81java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2%E3%80%81java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<ul><li>缓存导致的可见性问题</li><li>线程切换带来的原子性问题，</li><li>指令重排带来的有序性问题。</li></ul><h2 id="1、Java内存模型"><a href="#1、Java内存模型" class="headerlink" title="1、Java内存模型"></a>1、Java内存模型</h2><p>Java虚拟机内部划分为线程栈和堆</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-3.png" alt="image"></p><ul><li>一个局部变量可能是原简单类型，在这种情况下，它总是“呆在”线程栈上。</li><li>一个局部变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。</li><li>一个对象可能包含方法，这些方法可能包含局部变量。这些局部变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。</li><li>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</li><li>静态成员变量跟随着类定义一起也存放在堆上。</li><li>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个局部变量的私有拷贝。</li></ul><h2 id="2、硬件内存架构（CPU缓存导致可见性问题）"><a href="#2、硬件内存架构（CPU缓存导致可见性问题）" class="headerlink" title="2、硬件内存架构（CPU缓存导致可见性问题）"></a>2、硬件内存架构（CPU缓存导致可见性问题）</h2><p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png" alt="image"></p><ol><li>一个现代计算机通常由两个或者多个CPU。其中一些CPU还有多核。从这一点可以看出，在一个有两个或者多个CPU的现代计算机上同时运行多个线程是可能的。每个CPU在某一时刻运行一个线程是没有问题的。这意味着，如果你的Java程序是多线程的，在你的Java程序中每个CPU上一个线程可能同时（并发）执行。</li><li>每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。</li><li>、每个CPU可能还有一个CPU缓存层。实际上，绝大多数的现代CPU都有一定大小的缓存层。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。一些CPU还有多层缓存，但这些对理解Java内存模型如何和内存交互不是那么重要。只要知道CPU中可以有一个缓存层就可以了。</li><li>、一个计算机还包含一个主存。所有的CPU都可以访问主存。主存通常比CPU中的缓存大得多</li></ol><p>==操作流程：<br>当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。==</p><h3 id="缓存导致-可见性问题-："><a href="#缓存导致-可见性问题-：" class="headerlink" title="缓存导致==可见性问题==："></a>缓存导致==可见性问题==：</h3><p>如果两个或者更多的线程在没有正确的使用volatile声明或者同步的情况下共享一个对象，共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中。然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。</p><p>使用volatile解决可见性和有序性问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class VolatileExample &#123;</span><br><span class="line">  int x &#x3D; 0;</span><br><span class="line">  volatile boolean v &#x3D; false;</span><br><span class="line">  public void writer() &#123;</span><br><span class="line">    x &#x3D; 42;</span><br><span class="line">    v &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line">  public void reader() &#123;</span><br><span class="line">    if (v &#x3D;&#x3D; true) &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里 x 会是多少呢？</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何解决：先行发生原则。</p><p>JDK1.5 以前的版本会出现 x = 0 的情况, 1.5 版本对 volatile 语义进行了增强。怎么增强的呢？答案是一项 Happens-Before 先行发生原则，用来解决可见性问题。</p><p>==先行发生原则：前面一个操作的结果对后续操作是可见的==</p><ul><li>程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作</li><li>管程锁定规则：一个unlock操作先行发生与后面对同一个锁的lock操作</li><li>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作</li><li>线程启动规则：Thread对象的start方法先行发生于此线程的每一个动作</li><li>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生</li><li>对象终结规则：一个对象的初始化完成，先行发生于它的finalize()方法的开始</li></ul><h3 id="原子性问题-竞态条件"><a href="#原子性问题-竞态条件" class="headerlink" title="==原子性问题==,竞态条件:"></a>==原子性问题==,竞态条件:</h3><p>如果线程A读一个共享对象的变量count到它的CPU缓存中。再想象一下，线程B也做了同样的事情，但是往一个不同的CPU缓存中。现在线程A将count加1，线程B也做了同样的事情。现在count已经被增在了两个，每个CPU缓存中一次。</p><p>如果这些增加操作被顺序的执行，变量count应该被增加两次，然后原值+2被写回到主存中去。</p><p>然而，两次增加都是在没有适当的同步下并发执行的。无论是线程A还是线程B将count修改后的版本写回到主存中取，修改后的值仅会被原值大1，尽管增加了两次。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LockSupport</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/LockSupport/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/LockSupport/</url>
      
        <content type="html"><![CDATA[<p>当需要阻塞或者唤醒一个线程时，都会使用LockSupport工具类来完成相应的工作。LockSupport定义了一组最基本的线程阻塞和唤醒功能的公共静态方法</p><p>LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread)方法来唤醒一个被阻塞的线程，这些方法描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- void park()：阻塞当前线程，如果调用unpark方法或者当前线程被中断，从能从park()方法中返回</span><br><span class="line">- void park(Object blocker)：功能同方法1，入参增加一个Object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；</span><br><span class="line">- void parkNanos(long nanos)：阻塞当前线程，最长不超过nanos纳秒，增加了超时返回的特性；</span><br><span class="line">- void parkNanos(Object blocker, long nanos)：功能同方法3，入参增加一个Object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；</span><br><span class="line">- void parkUntil(long deadline)：阻塞当前线程，知道deadline；</span><br><span class="line">- void parkUntil(Object blocker, long deadline)：功能同方法5，入参增加一个Object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；</span><br><span class="line">- void unpark(Thread thread):唤醒处于阻塞状态的指定线程</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class LockSupportDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;被唤醒&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        LockSupport.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LockSupport源码注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">package java.util.concurrent.locks;</span><br><span class="line">import sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 提供阻塞线程和唤醒线程的方法。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class LockSupport &#123;</span><br><span class="line">    &#x2F;&#x2F; 构造函数是私有的，所以不能在外部实例化</span><br><span class="line">    private LockSupport() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用来设置线程t的parkBlocker属性。此对象在线程受阻塞时被记录，以允许监视工具和诊断工具确定线程受阻塞的原因。</span><br><span class="line">    private static void setBlocker(Thread t, Object arg) &#123;</span><br><span class="line">        UNSAFE.putObject(t, parkBlockerOffset, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 唤醒处于阻塞状态下的thread线程</span><br><span class="line">    public static void unpark(Thread thread) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当线程不为null时调用</span><br><span class="line">        if (thread !&#x3D; null)</span><br><span class="line">            &#x2F;&#x2F; 通过UNSAFE的unpark唤醒被阻塞的线程</span><br><span class="line">            UNSAFE.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 阻塞当前线程</span><br><span class="line">    public static void park(Object blocker) &#123;</span><br><span class="line">        Thread t &#x3D; Thread.currentThread();</span><br><span class="line">        &#x2F;&#x2F; 设置线程t的parkBlocker属性，用于记录线程阻塞情况</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        &#x2F;&#x2F; 通过UNSAFE的park方法阻塞线程</span><br><span class="line">        UNSAFE.park(false, 0L);</span><br><span class="line">        setBlocker(t, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 阻塞当前线程nanos纳秒时间，超出时间线程就会被唤醒返回</span><br><span class="line">    public static void parkNanos(Object blocker, long nanos) &#123;</span><br><span class="line">        if (nanos &gt; 0) &#123;</span><br><span class="line">            Thread t &#x3D; Thread.currentThread();</span><br><span class="line">            setBlocker(t, blocker);</span><br><span class="line">            UNSAFE.park(false, nanos);</span><br><span class="line">            setBlocker(t, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 阻塞当前线程，超过deadline日期线程就会被唤醒返回</span><br><span class="line">    public static void parkUntil(Object blocker, long deadline) &#123;</span><br><span class="line">        Thread t &#x3D; Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        UNSAFE.park(true, deadline);</span><br><span class="line">        setBlocker(t, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取线程t的parkBlocker属性</span><br><span class="line">    public static Object getBlocker(Thread t) &#123;</span><br><span class="line">        if (t &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        return UNSAFE.getObjectVolatile(t, parkBlockerOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 阻塞当前线程，不设置parkBlocker属性</span><br><span class="line">    public static void park() &#123;</span><br><span class="line">        UNSAFE.park(false, 0L);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void parkNanos(long nanos) &#123;</span><br><span class="line">        if (nanos &gt; 0)</span><br><span class="line">            UNSAFE.park(false, nanos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void parkUntil(long deadline) &#123;</span><br><span class="line">        UNSAFE.park(true, deadline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static final int nextSecondarySeed() &#123;</span><br><span class="line">        int r;</span><br><span class="line">        Thread t &#x3D; Thread.currentThread();</span><br><span class="line">        if ((r &#x3D; UNSAFE.getInt(t, SECONDARY)) !&#x3D; 0) &#123;</span><br><span class="line">            r ^&#x3D; r &lt;&lt; 13;   &#x2F;&#x2F; xorshift</span><br><span class="line">            r ^&#x3D; r &gt;&gt;&gt; 17;</span><br><span class="line">            r ^&#x3D; r &lt;&lt; 5;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((r &#x3D; ThreadLocalRandom.current().nextInt()) &#x3D;&#x3D; 0)</span><br><span class="line">            r &#x3D; 1; &#x2F;&#x2F; avoid zero</span><br><span class="line">        UNSAFE.putInt(t, SECONDARY, r);</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Hotspot implementation via intrinsics API</span><br><span class="line">    private static final Unsafe UNSAFE;</span><br><span class="line">    private static final long parkBlockerOffset;</span><br><span class="line">    private static final long SEED;</span><br><span class="line">    private static final long PROBE;</span><br><span class="line">    private static final long SECONDARY;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            UNSAFE &#x3D; Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; tk &#x3D; Thread.class;</span><br><span class="line">            parkBlockerOffset &#x3D; UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(&quot;parkBlocker&quot;));</span><br><span class="line">            SEED &#x3D; UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(&quot;threadLocalRandomSeed&quot;));</span><br><span class="line">            PROBE &#x3D; UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(&quot;threadLocalRandomProbe&quot;));</span><br><span class="line">            SECONDARY &#x3D; UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(&quot;threadLocalRandomSecondarySeed&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LockSupport </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p2p原生编程</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/1%E3%80%81ActiveMQ/2%E3%80%81p2p%E5%8E%9F%E7%94%9F%E7%BC%96%E7%A8%8B/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/1%E3%80%81ActiveMQ/2%E3%80%81p2p%E5%8E%9F%E7%94%9F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="activeMQ启动过程："><a href="#activeMQ启动过程：" class="headerlink" title="activeMQ启动过程："></a>activeMQ启动过程：</h2><p>1、通过我们提供特定环境的连接信息来构造factory。</p><ol start="2"><li><p>利用factory构造JMS connection</p></li><li><p>启动connection</p></li><li><p>通过connection创建JMS session.</p></li><li><p>指定JMS destination.</p></li><li><p>创建JMS producer或者创建JMS message并提供destination.</p></li><li><p>创建JMS consumer或注册JMS message listener.</p></li><li><p>发送和接收JMS message.</p></li><li><p>关闭所有JMS资源，包括connection, session, producer, consumer等。</p></li></ol><h2 id="activeMQ的三种通信模式："><a href="#activeMQ的三种通信模式：" class="headerlink" title="activeMQ的三种通信模式："></a>activeMQ的三种通信模式：</h2><p>==1、P2P：点对点模式。一个生产者对应一个消费者，消息消费之后就从内存中国删除。==</p><h3 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者:"></a>消息生产者:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Publisher｛</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          System.out.println(&quot;进入生产者--&quot;);</span><br><span class="line">            &#x2F;&#x2F;连接信息设置</span><br><span class="line">            String username &#x3D; &quot;system&quot;;</span><br><span class="line">            String password &#x3D; &quot;manager&quot;;</span><br><span class="line">            String brokerURL &#x3D; &quot;failover:&#x2F;&#x2F;tcp:&#x2F;&#x2F;localhost:61616&quot;;</span><br><span class="line">            &#x2F;&#x2F;默认的URL的值：ActiveMQConnection.DEFAULT_BROKER_URL;</span><br><span class="line">            System.out.println(&quot;默认的URL：&quot;+brokerURL); </span><br><span class="line">            &#x2F;&#x2F;1、创建工厂</span><br><span class="line">            ConnectionFactory  connectionFactory &#x3D; new ActiveMQConnectionFactory(username, password, brokerURL);</span><br><span class="line">            &#x2F;&#x2F;2. 利用factory构造JMS connection</span><br><span class="line">            Connection connection &#x3D; connectionFactory.createConnection();</span><br><span class="line">            &#x2F;&#x2F;3、启动连接</span><br><span class="line">            connection.start();</span><br><span class="line">            &#x2F;&#x2F;4、创建session</span><br><span class="line">            Session  session &#x3D; connection.createSession(true, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            &#x2F;&#x2F;消息的目的地创建一个名称为QueueTest的消息队列</span><br><span class="line">            Destination   destination &#x3D; session.createQueue(&quot;QueueTest&quot;);</span><br><span class="line">            &#x2F;&#x2F;消息生产者</span><br><span class="line">            MessageProducer  messageProducer &#x3D; session.createProducer(destination);</span><br><span class="line">            &#x2F;&#x2F;发送消息</span><br><span class="line">            try &#123;</span><br><span class="line">                TextMessage message &#x3D; null;</span><br><span class="line">                TextMessage message1 &#x3D;  session.createTextMessage();</span><br><span class="line">                message1.setText(&quot;这是字符串呀&quot;);</span><br><span class="line">                for (int i&#x3D;0; i&lt;100; i++) &#123;</span><br><span class="line">                    &#x2F;&#x2F;创建要发送的文本信息</span><br><span class="line">                    message &#x3D; session.createTextMessage(&quot;Queue消息测试&quot; +(i+1));</span><br><span class="line">                    &#x2F;&#x2F;通过消息生产者发出消息 </span><br><span class="line">                    messageProducer.send(message);</span><br><span class="line">                    System.out.println(&quot;发送成功：&quot; + message.getText());</span><br><span class="line">                &#125;</span><br><span class="line">                session.commit();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;finally&#123;</span><br><span class="line">                if(null !&#x3D; connection)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        connection.close();</span><br><span class="line">                    &#125; catch (JMSException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><h3 id="消费者：（包含同步和异步接收消息）"><a href="#消费者：（包含同步和异步接收消息）" class="headerlink" title="消费者：（包含同步和异步接收消息）"></a>消费者：（包含同步和异步接收消息）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class Consumer&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;进入消费者--&quot;);</span><br><span class="line">        &#x2F;&#x2F;连接信息设置</span><br><span class="line">        String username &#x3D; &quot;system&quot;;</span><br><span class="line">        String password &#x3D; &quot;manager&quot;;</span><br><span class="line">        String brokerURL &#x3D; ActiveMQConnection.DEFAULT_BROKER_URL;</span><br><span class="line">        &#x2F;&#x2F;1、创建工厂</span><br><span class="line">        ConnectionFactory   connectionFactory &#x3D; new ActiveMQConnectionFactory(username, password, brokerURL);</span><br><span class="line">        &#x2F;&#x2F;2、获取连接</span><br><span class="line">        Connection  connection &#x3D; connectionFactory.createConnection();</span><br><span class="line">         &#x2F;&#x2F;3、启动连接</span><br><span class="line">        connection.start();</span><br><span class="line">        &#x2F;&#x2F;4、获取session</span><br><span class="line">        Session  session &#x3D; connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        &#x2F;&#x2F;5、消息的目的地</span><br><span class="line">        Destination   destination &#x3D; session.createQueue(&quot;QueueTest&quot;);</span><br><span class="line">        &#x2F;&#x2F;6、消息消费者</span><br><span class="line">        MessageConsumer  messageConsumer &#x3D; session.createConsumer(destination);</span><br><span class="line">&#x2F;&#x2F;两种接收方式选其一即可</span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;异步接收：&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">messageConsumer.setMessageListener(new MessageListener() &#123;</span><br><span class="line">    public void onMessage(Message message) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String text &#x3D; ((TextMessage) message).getText();</span><br><span class="line">            System.out.println(text);</span><br><span class="line">        &#125; catch (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;同步接收：&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                System.out.println(&quot;消费者准备接收消息-----&quot;);</span><br><span class="line"> &#x2F;&#x2F;同步接收，是在获取MessageConsumer实例之后，调用以下的API：</span><br><span class="line">&#x2F;&#x2F;receive():</span><br><span class="line">&#x2F;&#x2F;获取下一个消息。这个调用将导致无限期的阻塞，直到有新的消息产生。</span><br><span class="line">&#x2F;&#x2F;receive(long timeout):</span><br><span class="line">&#x2F;&#x2F;获取下一个消息。这个调用可能导致一段时间的阻塞，直到超时或者有新的消息产生。超时则返回null。</span><br><span class="line">&#x2F;&#x2F;receiveNoWait():</span><br><span class="line">&#x2F;&#x2F;获取下一个消息。这个调用不会导致阻塞，如果没有下一个消息，直接返回null。</span><br><span class="line">                TextMessage textMessage &#x3D; (TextMessage) messageConsumer.receive(100000);</span><br><span class="line">               System.out.println(&quot;消费者成功接收消息-----&quot;);</span><br><span class="line">                if(textMessage !&#x3D; null)&#123;</span><br><span class="line">                    System.out.println(&quot;成功接收消息:&quot; + textMessage.getText());</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ActiveMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> p2p原生编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h5 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h5><ul><li><p>面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</p></li><li><p>面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</p></li></ul><h5 id="面向对象编程特性（比如继承、多态、封装）"><a href="#面向对象编程特性（比如继承、多态、封装）" class="headerlink" title="面向对象编程特性（比如继承、多态、封装）"></a>面向对象编程特性（比如继承、多态、封装）</h5><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><ol><li>关于封装特性封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</li></ol><h5 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h5><ol start="2"><li>关于抽象特性封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</li></ol><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ol start="3"><li>关于继承特性继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题</li></ol><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><ol start="4"><li>关于多态特性多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。课堂讨论</li></ol><h5 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h5><ul><li>抽象类不允许被实例化，只能被继承。也就是说，你不能 new 一个抽象类的对象出来（Logger logger = new Logger(…); 会报编译错误）。</li><li>抽象类可以包含属性和方法。方法可以是抽象方法和具体方法。</li><li>子类继承抽象类，必须实现抽象类中的所有抽象方法。</li></ul><p>接口不能包含属性（也就是成员变量）。接口只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。</p><p>抽象类实际上就是类，只不过是一种特殊的类.对于接口，有一个更加形象的叫法，那就是协议（contract）。</p><h5 id="如何决定该用抽象类还是接口？"><a href="#如何决定该用抽象类还是接口？" class="headerlink" title="如何决定该用抽象类还是接口？"></a>如何决定该用抽象类还是接口？</h5><p>实际上，判断的标准很简单。如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；</p><p>如果我们要表示一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。</p><p>从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface ImageStore &#123;</span><br><span class="line">  String upload(Image image, String bucketName);</span><br><span class="line">  Image download(String url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AliyunImageStore implements ImageStore &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略属性、构造函数等...</span><br><span class="line"></span><br><span class="line">  public String upload(Image image, String bucketName) &#123;</span><br><span class="line">    createBucketIfNotExisting(bucketName);</span><br><span class="line">    String accessToken &#x3D; generateAccessToken();</span><br><span class="line">    &#x2F;&#x2F;...上传图片到阿里云...</span><br><span class="line">    &#x2F;&#x2F;...返回图片在阿里云上的地址(url)...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Image download(String url) &#123;</span><br><span class="line">    String accessToken &#x3D; generateAccessToken();</span><br><span class="line">    &#x2F;&#x2F;...从阿里云下载图片...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void createBucketIfNotExisting(String bucketName) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...创建bucket...</span><br><span class="line">    &#x2F;&#x2F; ...失败会抛出异常..</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String generateAccessToken() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...根据accesskey&#x2F;secrectkey等生成access token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上传下载流程改变：私有云不需要支持access token</span><br><span class="line">public class PrivateImageStore implements ImageStore  &#123;</span><br><span class="line">  public String upload(Image image, String bucketName) &#123;</span><br><span class="line">    createBucketIfNotExisting(bucketName);</span><br><span class="line">    &#x2F;&#x2F;...上传图片到私有云...</span><br><span class="line">    &#x2F;&#x2F;...返回图片的url...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Image download(String url) &#123;</span><br><span class="line">    &#x2F;&#x2F;...从私有云下载图片...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void createBucketIfNotExisting(String bucketName) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...创建bucket...</span><br><span class="line">    &#x2F;&#x2F; ...失败会抛出异常..</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ImageStore的使用举例</span><br><span class="line">public class ImageProcessingJob &#123;</span><br><span class="line">  private static final String BUCKET_NAME &#x3D; &quot;ai_images_bucket&quot;;</span><br><span class="line">  &#x2F;&#x2F;...省略其他无关代码...</span><br><span class="line">  </span><br><span class="line">  public void process() &#123;</span><br><span class="line">    Image image &#x3D; ...;&#x2F;&#x2F;处理图片，并封装为Image对象</span><br><span class="line">    ImageStore imageStore &#x3D; new PrivateImageStore(...);</span><br><span class="line">    imagestore.upload(image, BUCKET_NAME);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复合优先于继承</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/10%E3%80%81%E5%A4%8D%E5%90%88%E4%BC%98%E5%85%88%E4%BA%8E%E7%BB%A7%E6%89%BF/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/10%E3%80%81%E5%A4%8D%E5%90%88%E4%BC%98%E5%85%88%E4%BA%8E%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="一：继承的缺陷："><a href="#一：继承的缺陷：" class="headerlink" title="一：继承的缺陷："></a>一：继承的缺陷：</h3><ul><li>1、打破封装原则：</li></ul><p>继承使得子类依赖于超类的实现，从这一点来说，就不符合封装的原则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在不应该继承的时候使用继承，会暴露不必要的API给子类。</span><br><span class="line">这一点，Java平台就犯过错，典型的例子就是Properties继承了HashTable，这是不合理的，</span><br><span class="line">属性列表不是散列表，但是Java代码里的Properties却继承了HashTable，导致用户创建Properties实例后，</span><br><span class="line">有put和setProperties两个方法，而put和get方法是不应该给用户暴露的。</span><br></pre></td></tr></table></figure><ul><li>2、子类代码容易受到破坏：</li></ul><p>子类继承的超类随着版本的发布而有所变化，子类就有可能遭到破坏，即使子类自己的代码完全没有改变。</p><p> 如果父类新增了方法，而子类恰好已经提供了一个签名相同但是返回值不同的方法，那么子类将无法通过编译。</p><h3 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h3><p> 一个程序使用了 HashSet，为了调优该程序的性能，需要查询HashSet，统计他被创建以来添加了多少个元素，因此需要覆盖add和addAll</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line"> </span><br><span class="line">public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;用于统计共添加了多少个元素</span><br><span class="line">private int count &#x3D; 0;</span><br><span class="line">public InstrumentedHashSet() &#123;</span><br><span class="line">&#125;</span><br><span class="line">public InstrumentedHashSet(int initCap, float loadFactor) &#123;</span><br><span class="line">super(initCap, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">count++;</span><br><span class="line">return super.add(e);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">count +&#x3D; c.size();</span><br><span class="line">return super.addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public int getCount() &#123;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">InstrumentedHashSet&lt;String&gt; hashSet &#x3D; new InstrumentedHashSet&lt;String&gt;();</span><br><span class="line">hashSet.addAll(Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;));</span><br><span class="line">System.out.println(hashSet.getCount());</span><br><span class="line">&#x2F;&#x2F;添加3个元素，却返回6</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加3个元素，却返回6。</p><p>仔细阅读上面代码发现，这是因为addAll方法是基于add方法来实现的。</p><p>既然HashSet是这样实现的，那么我们就不要复写addAll方法就行了，但是这样虽然可以正常工作，但是它的正确性却依赖于这样的事实。一旦超类修改了addAll实现细节，我们的功能就会有可能受影响。</p><p>二：复合<br>继承的替代方案</p><p>==使用复合的方式，对超类进行修饰，使得子类更加的健壮，同时功能更加强大。==</p><p>首先我们需要一个持有Set对象的一个类，这个类实现了Set接口，实现方法里调用了所持有的Set对象的对应的方法，因此我们也叫它转发类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; &#123;</span><br><span class="line">    private final Set&lt;E&gt; s;</span><br><span class="line">    public ForwardingSet(Set&lt;E&gt; s) &#123; this.s &#x3D; s; &#125;</span><br><span class="line"> </span><br><span class="line">    public void clear()               &#123; s.clear();            &#125;</span><br><span class="line">    public boolean contains(Object o) &#123; return s.contains(o); &#125;</span><br><span class="line">    public boolean isEmpty()          &#123; return s.isEmpty();   &#125;</span><br><span class="line">    public int size()                 &#123; return s.size();      &#125;</span><br><span class="line">    public Iterator&lt;E&gt; iterator()     &#123; return s.iterator();  &#125;</span><br><span class="line">    public boolean add(E e)           &#123; return s.add(e);      &#125;</span><br><span class="line">    public boolean remove(Object o)   &#123; return s.remove(o);   &#125;</span><br><span class="line">    public boolean containsAll(Collection&lt;?&gt; c)</span><br><span class="line">                                   &#123; return s.containsAll(c); &#125;</span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c)</span><br><span class="line">                                   &#123; return s.addAll(c);      &#125;</span><br><span class="line">    public boolean removeAll(Collection&lt;?&gt; c)</span><br><span class="line">                                   &#123; return s.removeAll(c);   &#125;</span><br><span class="line">    public boolean retainAll(Collection&lt;?&gt; c)</span><br><span class="line">                                   &#123; return s.retainAll(c);   &#125;</span><br><span class="line">    public Object[] toArray()          &#123; return s.toArray();  &#125;</span><br><span class="line">    public &lt;T&gt; T[] toArray(T[] a)      &#123; return s.toArray(a); &#125;</span><br><span class="line">    @Override public boolean equals(Object o)</span><br><span class="line">                                       &#123; return s.equals(o);  &#125;</span><br><span class="line">    @Override public int hashCode()    &#123; return s.hashCode(); &#125;</span><br><span class="line">    @Override public String toString() &#123; return s.toString(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着，我们就可以设计具有统计功能的类了，只需要去继承我们刚刚创建的转发类，然后统计的逻辑代码的编写即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt; &#123;</span><br><span class="line">    private int addCount &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">    public InstrumentedSet(Set&lt;E&gt; s) &#123;</span><br><span class="line">        super(s);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override public boolean add(E e) &#123;</span><br><span class="line">        addCount++;</span><br><span class="line">        return super.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        addCount +&#x3D; c.size();</span><br><span class="line">        return super.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAddCount() &#123;</span><br><span class="line">        return addCount;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        InstrumentedSet&lt;String&gt; s &#x3D;</span><br><span class="line">            new InstrumentedSet&lt;String&gt;(new HashSet&lt;String&gt;());</span><br><span class="line">        s.addAll(Arrays.asList(&quot;Snap&quot;, &quot;Crackle&quot;, &quot;Pop&quot;));    </span><br><span class="line">        System.out.println(s.getAddCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样的实现方式，避免了上一节讲的所有问题，由于不使用继承，它不依赖于超类的实现逻辑，也不用担心超类新增新的方法对我们的影响。<br>而且这样写还有一个好处，这个类可以给所有实现了Set接口的类添加统计功能，而不仅仅是HashSet，还包括TreeSet等其他Set。</p><p>其实，这就是装饰模式，InstrumentedSet对Set进行了修饰，给它增加了计数属性。</p>]]></content>
      
      
      <categories>
          
          <category> 类和接口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复合优先于继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentLinkedQueue</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/10%E3%80%81ConcurrentLinkedQueue/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/10%E3%80%81ConcurrentLinkedQueue/</url>
      
        <content type="html"><![CDATA[<p><a href="http://ifeve.com/concurrentlinkedqueue/">http://ifeve.com/concurrentlinkedqueue/</a></p><p>ConcurrentLinkedQueue 单向链表<br><img src="http://ifeve.com/wp-content/uploads/2013/01/ConcurrentLinekedQueue%E9%98%9F%E5%88%97%E5%85%A5%E9%98%9F%E7%BB%93%E6%9E%84%E5%8F%98%E5%8C%96%E5%9B%BE.jpg" alt="image"></p><ul><li>第一步添加元素1。队列更新head节点的next节点为元素1节点。又因为tail节点默认情况下等于head节点，所以它们的next节点都指向元素1节点。</li><li>第二步添加元素2。队列首先设置元素1节点的next节点为元素2节点，然后更新tail节点指向元素2节点。</li><li>第三步添加元素3，设置tail节点的next节点为元素3节点。</li><li>第四步添加元素4，设置元素3的next节点为元素4节点，然后将tail节点指向元素4节点。</li></ul><p>发现入队主要做两件事情，第一是将入队节点设置成当前队列尾节点的下一个节点。</p><p>第二是更新tail节点:==如果tail节点的next节点不为空，则将入队节点设置成tail节点;<br>如果tail节点的next节点为空，则将入队节点设置成tail的next节点==</p><p>上面的分析让我们从单线程入队的角度来理解入队过程，但是多个线程同时进行入队情况就变得更加复杂，因为可能会出现其他线程插队的情况。如果有一个线程正在入队，那么它必须先获取尾节点，然后设置尾节点的下一个节点为入队节点，但这时可能有另外一个线程插队了，那么队列的尾节点就会发生变化，这时当前线程要暂停入队操作，然后重新获取尾节点。让我们再通过源码来详细分析下它是如何使用CAS算法来入队的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line"></span><br><span class="line">        if (e &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        &#x2F;&#x2F;入队前，创建一个入队节点</span><br><span class="line">        Node&lt;&#x2F;e&gt;&lt;e&gt; n &#x3D; new Node&lt;&#x2F;e&gt;&lt;e&gt;(e);</span><br><span class="line">        retry:</span><br><span class="line">        &#x2F;&#x2F;死循环，入队不成功反复入队。</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            &#x2F;&#x2F;创建一个指向tail节点的引用</span><br><span class="line">            Node&lt;&#x2F;e&gt;&lt;e&gt; t &#x3D; tail;</span><br><span class="line">            &#x2F;&#x2F;p用来表示队列的尾节点，默认情况下等于tail节点。</span><br><span class="line">            Node&lt;&#x2F;e&gt;&lt;e&gt; p &#x3D; t;</span><br><span class="line">            for (int hops &#x3D; 0; ; hops++) &#123;</span><br><span class="line">            &#x2F;&#x2F;获得p节点的下一个节点。</span><br><span class="line">                Node&lt;&#x2F;e&gt;&lt;e&gt; next &#x3D; succ(p);</span><br><span class="line">     &#x2F;&#x2F;next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</span><br><span class="line">                if (next !&#x3D; null) &#123;                   &#x2F;&#x2F;循环了两次及其以上，并且当前节点还是不等于尾节点</span><br><span class="line">                    if (hops &gt; HOPS &amp;&amp; t !&#x3D; tail)</span><br><span class="line">                        continue retry;</span><br><span class="line">                    p &#x3D; next;</span><br><span class="line">                &#125;               &#x2F;&#x2F;如果p是尾节点，则设置p节点的next节点为入队节点。</span><br><span class="line">                else if (p.casNext(null, n)) &#123;                 &#x2F;&#x2F;如果tail节点有大于等于1个next节点，则将入队节点设置成tair节点，更新失败了也没关系，因为失败了表示有其他线程成功更新了tair节点。</span><br><span class="line"></span><br><span class="line">if (hops &gt;&#x3D; HOPS)</span><br><span class="line"></span><br><span class="line">                        casTail(t, n); &#x2F;&#x2F; 更新tail节点，允许失败</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">               &#x2F;&#x2F; p有next节点,表示p的next节点是尾节点，则重新设置p节点</span><br><span class="line">                else &#123;</span><br><span class="line">                    p &#x3D; succ(p);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h2><p> 出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用。让我们通过每个节点出队的快照来观察下head节点的变化。<br> <img src="http://ifeve.com/wp-content/uploads/2013/01/%E5%87%BA%E9%98%9F%E5%88%97.jpg" alt="image"></p><p> 从上图可知，并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点。这种做法也是通过hops变量来减少使用CAS更新head节点的消耗，从而提高出队效率。让我们再通过源码来深入分析下出队过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line"></span><br><span class="line">           Node&lt;&#x2F;e&gt;&lt;e&gt; h &#x3D; head;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; p表示头节点，需要出队的节点</span><br><span class="line"></span><br><span class="line">           Node&lt;&#x2F;e&gt;&lt;e&gt; p &#x3D; h;</span><br><span class="line"></span><br><span class="line">           for (int hops &#x3D; 0;; hops++) &#123;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 获取p节点的元素</span><br><span class="line"></span><br><span class="line">                E item &#x3D; p.getItem();</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,如果成功则返回p节点的元素。</span><br><span class="line"></span><br><span class="line">                if (item !&#x3D; null &amp;&amp; p.casItem(item, null)) &#123;</span><br><span class="line"></span><br><span class="line">                     if (hops &gt;&#x3D; HOPS) &#123;</span><br><span class="line"></span><br><span class="line">                          &#x2F;&#x2F;将p节点下一个节点设置成head节点</span><br><span class="line"></span><br><span class="line">                          Node&lt;&#x2F;e&gt;&lt;e&gt; q &#x3D; p.getNext();</span><br><span class="line"></span><br><span class="line">                          updateHead(h, (q !&#x3D; null) ? q : p);</span><br><span class="line"></span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     return item;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外一个线程修改了。那么获取p节点的下一个节点</span><br><span class="line"></span><br><span class="line">                Node&lt;&#x2F;e&gt;&lt;e&gt; next &#x3D; succ(p);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 如果p的下一个节点也为空，说明这个队列已经空了</span><br><span class="line"></span><br><span class="line">                if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">              &#x2F;&#x2F; 更新头节点。</span><br><span class="line"></span><br><span class="line">                     updateHead(h, p);</span><br><span class="line"></span><br><span class="line">                     break;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 如果下一个元素不为空，则将头节点的下一个节点设置成头节点</span><br><span class="line"></span><br><span class="line">                p &#x3D; next;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           return null;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ConcurrentLinkedQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能监控工具</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/11%E3%80%81%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/11%E3%80%81%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/lengyue309/article/details/80590119">https://blog.csdn.net/lengyue309/article/details/80590119</a></p><p><a href="https://www.bbsmax.com/A/kmzLXkpKzG/">https://www.bbsmax.com/A/kmzLXkpKzG/</a></p><p>JDK自带VM分析工具jps，jstat，jmap，jconsole </p><h2 id="1、jps-查看进程状况"><a href="#1、jps-查看进程状况" class="headerlink" title="1、jps 查看进程状况"></a>1、jps 查看进程状况</h2><p>(JavaVirtual Machine Process Status )是jdk提供的一个查看当前java进程的小工具。显示系统内所有的hotSpot虚拟机进程</p><p>  命令格式：jps [options ] [ hostid ] </p><p> -q：仅输出VM标识符，不包括classname,jar name,arguments in main method<br>-m：输出main method的参数<br>-l：输出完全的包名，应用主类名，jar的完全路径名<br>-v：输出jvm参数<br>-V：输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags=所指定的文件<br>-Joption：传递参数到vm,例如:-J-Xms512m</p><h2 id="2、jstat-虚拟机统计信息监控"><a href="#2、jstat-虚拟机统计信息监控" class="headerlink" title="2、jstat 虚拟机统计信息监控"></a>2、jstat 虚拟机统计信息监控</h2><p>jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]</p><ul><li>　Options — 选项，我们一般使用 -gcutil 查看gc情况</li><li>t,h–t是显示Timestamp时间间隔列，h是显示标题,-h3每三行显示标题</li><li>vmid —VM的进程号，即当前运行的java进程号</li><li>interval– 间隔时间，单位为秒或者毫秒</li><li>count —打印次数，如果缺省则打印无数次</li></ul><h4 id="Option选项："><a href="#Option选项：" class="headerlink" title="Option选项："></a>Option选项：</h4><ul><li>-class    监视类的装载、卸载数量以及类的装载总空间和耗费时间等</li><li>-gc    监视Java堆，包含eden、2个survivor区、old区和永久带区域的容量、已用空间、GC时间合计等信息</li><li>-gccapcity    监视内容与-gc相同，但输出主要关注Java区域用到的最大和最小空间</li><li>-gcutil    监视内容与-gc相同，但输出主要关注已使用空间占总空间的百分比</li><li>-gccause    与-gcutil输出信息相同，额外输出导致上次GC产生的原因</li><li>-gcnew    监控新生代的GC情况</li><li>-gcnewcapacity    与-gcnew监控信息相同，输出主要关注使用到的最大和最小空间</li><li>-gcold    监控老生代的GC情况</li><li>-gcoldcapacity    与-gcold监控信息相同，输出主要关注使用到的最大和最小空间</li><li>-gcpermcapacity    输出永久带用到的最大和最小空间</li><li>-compiler    输出JIT编译器编译过的方法、耗时信息</li><li>printcompilation    输出已经被JIT编译的方法</li></ul><h4 id="示例：jstat-gcutil-进程id-输出时间间隔"><a href="#示例：jstat-gcutil-进程id-输出时间间隔" class="headerlink" title="示例：jstat -gcutil 进程id 输出时间间隔"></a>示例：jstat -gcutil 进程id 输出时间间隔</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">S0 — Heap上的 Survivor space 0 区已使用空间的百分比</span><br><span class="line">S1 — Heap上的 Survivor space 1 区已使用空间的百分比</span><br><span class="line">E — Heap上的 Eden space 区已使用空间的百分比</span><br><span class="line">O — Heap上的 Old space 区已使用空间的百分比</span><br><span class="line">P — Perm space 区已使用空间的百分比</span><br><span class="line">YGC — 从应用程序启动到采样时发生 Young GC 的次数</span><br><span class="line">YGCT– 从应用程序启动到采样时 Young GC 所用的时间(单位秒)</span><br><span class="line">FGC — 从应用程序启动到采样时发生 Full GC 的次数</span><br><span class="line">FGCT– 从应用程序启动到采样时 Full GC 所用的时间(单位秒)</span><br><span class="line">GCT — 从应用程序启动到采样时用于垃圾回收的总时间(单位秒)</span><br><span class="line">GCT 是YGCT 和FGCT的时间总和。</span><br></pre></td></tr></table></figure><h3 id="查看类加载信息"><a href="#查看类加载信息" class="headerlink" title="查看类加载信息"></a>查看类加载信息</h3><p>　jstat -class pid　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Loaded 装载的类的数量 </span><br><span class="line">Bytes 装载类所占用的字节数 </span><br><span class="line">Unloaded 卸载类的数量 </span><br><span class="line">Bytes 卸载类的字节数 </span><br><span class="line">Time 装载和卸载类所花费的时间</span><br></pre></td></tr></table></figure><h2 id="3、jinfo"><a href="#3、jinfo" class="headerlink" title="3、jinfo"></a>3、jinfo</h2><p>jinfo: 实时地查看和调整虚拟机各项参数，==使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数==</p><h2 id="4、jmap（JVM-Memory-Map-for-Java）"><a href="#4、jmap（JVM-Memory-Map-for-Java）" class="headerlink" title="4、jmap（JVM Memory Map for Java）"></a>4、jmap（JVM Memory Map for Java）</h2><p>jmap（Memory Map for Java）命令用于生成堆转储快照.</p><p>如果不使用 jmap 命令，要想获取 Java 堆转储，可以使用 “-XX:+HeapDumpOnOutOfMemoryError” 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 kill -3 发送进程退出信号也能拿到 dump 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;$&#123;目录&#125;。</span><br></pre></td></tr></table></figure><h2 id="5、jhat（JVM-Heap-Analysis-Tool）"><a href="#5、jhat（JVM-Heap-Analysis-Tool）" class="headerlink" title="5、jhat（JVM Heap Analysis Tool）"></a>5、jhat（JVM Heap Analysis Tool）</h2><p>jhat是用来分析dump文件的一个微型的HTTP/HTML服务器，它能将生成的dump文件生成在线的HTML文件，让我们可以通过浏览器进行查阅，然而实际中我们很少使用这个工具，因为一般服务器上设置的堆、栈内存都比较大，生成的dump也比较大，直接用jhat容易造成内存溢出，而是我们大部分会将对应的文件拷贝下来，通过其他可视化的工具进行分析    </p><h2 id="6、jstack（JVM-Stack-Trace-for-java）"><a href="#6、jstack（JVM-Stack-Trace-for-java）" class="headerlink" title="6、jstack（JVM Stack Trace for java）"></a>6、jstack（JVM Stack Trace for java）</h2><p>jstack用于JVM当前时刻的线程快照，又称threaddump文件，它是JVM当前每一条线程正在执行的堆栈信息的集合。生成线程快照的主要目的是为了定位线程出现长时间停顿的原因，如线程死锁、死循环、请求外部时长过长导致线程停顿的原因。通过jstack我们就可以知道哪些进程在后台做些什么？在等待什么资源等！其运行格式如下：</p><p>jstack [option] vmid    </p><p>如何利用以上工具：进行线上问题排查：</p><p>频繁GC问题或内存溢出问题 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">一、使用jps查看线程ID</span><br><span class="line"></span><br><span class="line">二、使用jstat -gc 3331 250 20 查看gc情况，一般比较关注PERM区的情况，查看GC的增长情况。</span><br><span class="line"></span><br><span class="line">三、使用jstat -gccause：额外输出上次GC原因</span><br><span class="line"></span><br><span class="line">四、使用jmap -dump:format&#x3D;b,file&#x3D;heapDump 3331生成堆转储文件</span><br><span class="line"></span><br><span class="line">五、使用jhat或者可视化工具（Eclipse Memory Analyzer 、IBM HeapAnalyzer）分析堆情况。</span><br><span class="line"></span><br><span class="line">六、结合代码解决内存溢出或泄露问题。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能监控工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典树</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6%E3%80%81%E6%A0%91/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6%E3%80%81%E6%A0%91/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>树形结构。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题</p><p>我们有 6 个字符串，它们分别是：how，hi，her，hello，so，see。我们希望在里面多次查找某个字符串是否存在</p><p>Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起<br><img src="https://static001.geekbang.org/resource/image/28/32/280fbc0bfdef8380fcb632af39e84b32.jpg" alt="image"></p><p>==根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）==</p><p>如何构造一个字典树？</p><p>构造过程的每一步，都相当于往 Trie 树中插入一个字符串。当所有字符串都插入完成之后，Trie 树就构造好了。<br><img src="https://static001.geekbang.org/resource/image/06/b6/06b45fde2ca8077465e0c557bc749ab6.jpg" alt="image"></p><p>比如查找字符串“her”，那我们将要查找的字符串分割成单个的字符 h，e，r，然后从 Trie 树的根节点开始匹配。如图所示，绿色的路径就是在 Trie 树中匹配的路径。<br><img src="https://static001.geekbang.org/resource/image/6d/b9/6dbed0579a60c6d170bd8fde5990bfb9.jpg" alt="image"></p><p>如果查找字符串“he”呢？从根节点开始，沿着某条路径来匹配，路径的最后一个节点“e”并不是红色的。也就是说，“he”是某个字符串的前缀子串，但并不能完全匹配任何字符串。<br><img src="https://static001.geekbang.org/resource/image/05/f9/05c3c5d534921f00a9ae33e7e65b1bf9.jpg" alt="image"></p><h2 id="如何实现一颗字典树？"><a href="#如何实现一颗字典树？" class="headerlink" title="如何实现一颗字典树？"></a>如何实现一颗字典树？</h2><p>。二叉树中，一个节点的左右子节点是通过两个指针来存储的，那==Trie 树是一个多叉树==来说，我们怎么存储一个节点的所有子节点的指针呢？</p><p>借助散列表的思想，我们通过一个下标与字符一一映射的数组，来存储子节点的指针<br><img src="https://static001.geekbang.org/resource/image/f5/35/f5a4a9cb7f0fe9dcfbf29eb1e5da6d35.jpg" alt="image"></p><p>字符串中只有从 a 到 z 这 26 个小写字母，我们在数组中下标为 0 的位置，存储指向子节点 a 的指针，下标为 1 的位置存储指向子节点 b 的指针，以此类推，下标为 25 的位置，存储的是指向的子节点 z 的指针。如果某个字符的子节点不存在，我们就在对应的下标的位置存储 null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode &#123;</span><br><span class="line">  char data;</span><br><span class="line">  TrieNode children[26];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 Trie 树中查找字符串的时候，我们就可以通过字符的 ASCII 码减去“a”的 ASCII 码，迅速找到匹配的子节点的指针。比如，d 的 ASCII 码减去 a 的 ASCII 码就是 3，那子节点 d 的指针就存储在数组中下标为 3 的位置中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Trie &#123;</span><br><span class="line">  private TrieNode root &#x3D; new TrieNode(&#39;&#x2F;&#39;); &#x2F;&#x2F; 存储无意义字符</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 往 Trie 树中插入一个字符串</span><br><span class="line">  public void insert(char[] text) &#123;</span><br><span class="line">    TrieNode p &#x3D; root;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; text.length; ++i) &#123;</span><br><span class="line">      int index &#x3D; text[i] - &#39;a&#39;;</span><br><span class="line">      if (p.children[index] &#x3D;&#x3D; null) &#123;</span><br><span class="line">        TrieNode newNode &#x3D; new TrieNode(text[i]);</span><br><span class="line">        p.children[index] &#x3D; newNode;</span><br><span class="line">      &#125;</span><br><span class="line">      p &#x3D; p.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    p.isEndingChar &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 在 Trie 树中查找一个字符串</span><br><span class="line">  public boolean find(char[] pattern) &#123;</span><br><span class="line">    TrieNode p &#x3D; root;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; pattern.length; ++i) &#123;</span><br><span class="line">      int index &#x3D; pattern[i] - &#39;a&#39;;</span><br><span class="line">      if (p.children[index] &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return false; &#x2F;&#x2F; 不存在 pattern</span><br><span class="line">      &#125;</span><br><span class="line">      p &#x3D; p.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    if (p.isEndingChar &#x3D;&#x3D; false) return false; &#x2F;&#x2F; 不能完全匹配，只是前缀</span><br><span class="line">    else return true; &#x2F;&#x2F; 找到 pattern</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public class TrieNode &#123;</span><br><span class="line">    public char data;</span><br><span class="line">    public TrieNode[] children &#x3D; new TrieNode[26];</span><br><span class="line">    public boolean isEndingChar &#x3D; false;</span><br><span class="line">    public TrieNode(char data) &#123;</span><br><span class="line">      this.data &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Trie 树是非常耗内存的，用的是一种空间换时间的思路.但是稍微牺牲一点查询的效率，可以用有序数组、跳表、散列表、红黑树等。代替数组。尽可能优化。</p><h3 id="Trie树-VS-散列表、红黑树"><a href="#Trie树-VS-散列表、红黑树" class="headerlink" title="Trie树 VS 散列表、红黑树"></a>Trie树 VS 散列表、红黑树</h3><ul><li>第一，字符串中包含的字符集不能太大。我们前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。</li><li>第二，要求字符串的前缀重合比较多，不然空间消耗会变大很多。</li><li>第三，如果要用 Trie 树解决问题，那我们就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。</li><li>第四，我们知道，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。</li><li>综合这几点，针对在一组字符串中查找字符串的问题，我们在工程中，更倾向于用散列表或者红黑树。因为这两种数据结构，我们都不需要自己去实现，直接利用编程语言中提供的现成类库就行了。</li></ul><p>==Trie 树比较适合的是查找前缀匹配的字符串==</p><ul><li>应用：</li><li>关键词搜索联想功能</li><li>代码自动补全，输入法自动补全</li></ul>]]></content>
      
      
      <categories>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中获取request的几种方法</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/spring-mvc/5%E3%80%81Spring%E4%B8%AD%E8%8E%B7%E5%8F%96request%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/spring-mvc/5%E3%80%81Spring%E4%B8%AD%E8%8E%B7%E5%8F%96request%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>获取request的方式：</p><h2 id="方法1：Controller中加参数"><a href="#方法1：Controller中加参数" class="headerlink" title="方法1：Controller中加参数"></a>方法1：Controller中加参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController &#123;</span><br><span class="line">   @RequestMapping(&quot;&#x2F;test&quot;)</span><br><span class="line">   public void test(HttpServletRequest request) throws InterruptedException &#123;</span><br><span class="line">       &#x2F;&#x2F; 模拟程序执行了一段时间</span><br><span class="line">       Thread.sleep(1000);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法实现的原理是，在Controller方法开始处理请求时，Spring会将request对象赋值到方法参数中。除了request对象，可以通过这种方法获取的参数还有很多，具体可以参见：<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods</a><br>Controller中获取request对象后，如果要在其他方法中（如service方法、工具类方法等）使用request对象，需要在调用这些方法时将request对象作为参数传入。<br>此时request对象是方法参数，相当于局部变量，毫无疑问是线程安全的。<br>优缺点<br>这种方法的主要缺点是request对象写起来冗余太多，主要体现在两点：</p><ol><li>如果多个controller方法中都需要request对象，那么在每个方法中都需要添加一遍request参数</li><li>request对象的获取只能从controller开始，如果使用request对象的地方在函数调用层级比较深的地方，那么整个调用链上的所有方法都需要添加request参数</li></ol><p>实际上，在整个请求处理的过程中，request对象是贯穿始终的；也就是说，除了定时器等特殊情况，request对象相当于线程内部的一个全局变量。而该方法，相当于将这个全局变量，传来传去。</p><h2 id="方法2：自动注入-推荐使用"><a href="#方法2：自动注入-推荐使用" class="headerlink" title="方法2：自动注入(推荐使用)"></a>方法2：自动注入(推荐使用)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController&#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   private HttpServletRequest request; &#x2F;&#x2F;自动注入request</span><br><span class="line">   @RequestMapping(&quot;&#x2F;test&quot;)</span><br><span class="line">   public void test() throws InterruptedException&#123;</span><br><span class="line">       &#x2F;&#x2F;模拟程序执行了一段时间</span><br><span class="line">       Thread.sleep(1000);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：在Spring中，Controller的scope是singleton(单例)，也就是说在整个web系统中，只有一个TestController；但是其中注入的request却是线程安全的，原因在于：<br>使用这种方式，当Bean（本例的TestController）初始化时，Spring并没有注入一个request对象，而是注入了一个代理（proxy）；当Bean中需要使用request对象时，通过该代理获取request对象<br>该方法的主要优点：</p><ol><li>注入不局限于Controller中：在方法1中，只能在Controller中加入request参数。而对于方法2，不仅可以在Controller中注入，还可以在任何Bean中注入，包括Service、Repository及普通的Bean。</li><li>注入的对象不限于request：除了注入request对象，该方法还可以注入其他scope为request或session的对象，如response对象、session对象等；并保证线程安全。</li><li>减少代码冗余：只需要在需要request对象的Bean中注入request对象，便可以在该Bean的各个方法中使用，与方法1相比大大减少了代码冗余。<br>缺点:<br>方法也会存在代码冗余。考虑这样的场景：web系统中有很多controller，每个controller中都会使用request对象（这种场景实际上非常频繁），这时就需要写很多次注入request的代码；如果还需要注入response，代码就更繁琐了。下面说明自动注入方法的改进方法，并分析其线程安全性及优缺点。<h2 id="方法3：基类中自动注入-推荐使用-："><a href="#方法3：基类中自动注入-推荐使用-：" class="headerlink" title="方法3：基类中自动注入(推荐使用)："></a>方法3：基类中自动注入(推荐使用)：</h2></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class BaseController &#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   protected HttpServletRequest request;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：在理解了方法2的线程安全性的基础上，很容易理解方法3是线程安全的：当创建不同的派生类对象时，基类中的域（这里是注入的request）在不同的派生类对象中会占据不同的内存空间，也就是说将注入request的代码放在基类中对线程安全性没有任何影响；测试结果也证明了这一点。线程安全<br>优缺点<br>与方法2相比，避免了在不同的Controller中重复注入request；但是考虑到java只允许继承一个基类，所以如果Controller需要继承其他类时，该方法便不再好用。<br>无论是方法2和方法3，都只能在Bean中注入request；如果其他方法（如工具类中static方法）需要使用request对象，则需要在调用这些方法时将request参数传递进去。下面介绍的方法4，则可以直接在诸如工具类中的static方法中使用request对象（当然在各种Bean中也可以使用）。</p><h2 id="方法4：手动调用"><a href="#方法4：手动调用" class="headerlink" title="方法4：手动调用"></a>方法4：手动调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TestUtil &#123;</span><br><span class="line">   public void test() throws InterruptedException &#123; HttpServletRequest request &#x3D;((ServletRequestAttributes)(RequestContextHolder.currentRequestAttributes())).getRequest();</span><br><span class="line">       &#x2F;&#x2F; 模拟程序执行了一段时间</span><br><span class="line">       Thread.sleep(1000);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：线程安全<br>分析：该方法与方法2（自动注入）类似，只不过方法2中通过自动注入实现，本方法通过手动方法调用实现。因此本方法也是线程安全的<br>优缺点<br>优点：可以在非Bean中直接获取。缺点：如果使用的地方较多，代码非常繁琐；因此可以与其他方法配合使用。</p><h2 id="方法5：-ModelAttribute方法"><a href="#方法5：-ModelAttribute方法" class="headerlink" title="方法5：@ModelAttribute方法"></a>方法5：@ModelAttribute方法</h2>]]></content>
      
      
      <categories>
          
          <category> spring-mvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring中获取request的几种方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读写锁ReadWriteLock</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/%E8%AF%BB%E5%86%99%E9%94%81ReadWriteLock/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/%E8%AF%BB%E5%86%99%E9%94%81ReadWriteLock/</url>
      
        <content type="html"><![CDATA[<p>排他锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，</p><p>但是在==写线程访问时，所有的读线程和其他写线程均被阻塞==。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p><p>在没有读写锁支持的（Java 5之前）时候，如果需要完成上述工作就要使用Java的等待通知<br>机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并进行通知之后，所有等待的读操作才能继续执行（写操作之间依靠synchronized关键进行同步）</p><p>有了读写锁实现上述功能，只需要在读操作时获取读锁，写操作时获取写锁即可。当写锁被获取到时，后续（非当前写<br>操作线程）的读写操作都会被阻塞，写锁释放之后，所有操作继续执行，编程方式相对于使用<br>等待通知机制的实现方式而言，变得简单明了</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Cache &#123;</span><br><span class="line">    static Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;String, Object&gt;();</span><br><span class="line">    static ReentrantReadWriteLock rwl &#x3D; new ReentrantReadWriteLock();</span><br><span class="line">    static Lock r &#x3D; rwl.readLock();</span><br><span class="line">    static Lock w &#x3D; rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取一个key对应的value</span><br><span class="line">    public static final Object get(String key) &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.get(key);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 设置key对应的value，并返回旧的value</span><br><span class="line">    public static final Object put(String key, Object value) &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.put(key, value);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 清空所有的内容</span><br><span class="line">    public static final void clear() &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><p>ReadWriteLock接口只定义了两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ReadWriteLock &#123;</span><br><span class="line"></span><br><span class="line">    Lock readLock();</span><br><span class="line"></span><br><span class="line">    Lock writeLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReentrantReadWriteLock（常用的实现类）"><a href="#ReentrantReadWriteLock（常用的实现类）" class="headerlink" title="ReentrantReadWriteLock（常用的实现类）"></a>ReentrantReadWriteLock（常用的实现类）</h3><p>ReadWriteLock接口的实现ReentrantReadWriteLock<br>除了readLock、writeLock接口方法外，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int getReadLockCount()返回当前读锁被获取的次数。该次数不等于获取读锁的线程数，比如：仅一个线程，它连续获取（重进入）了n次读锁，那么占据读锁的线程数是1，但该方法返回n</span><br><span class="line">int getReadHoldCount()返回当前线程获取读锁的次数。该方法在Java 6 中加入到ReentrantReadWriteLock中，使用ThreadLocal保存当前线程获取的次数，这也使得Java 6 的实现变得更加复杂</span><br><span class="line">boolean isWriteLocked()判断写锁是否被获取</span><br><span class="line">int getWriteHoldCount()返回当前写锁被获取的次数</span><br></pre></td></tr></table></figure><h3 id="读写锁的原理："><a href="#读写锁的原理：" class="headerlink" title="读写锁的原理："></a>读写锁的原理：</h3><h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static ReentrantReadWriteLock rwl &#x3D; new ReentrantReadWriteLock();</span><br><span class="line">    static Lock readLock &#x3D; rwl.readLock();</span><br><span class="line">    static Lock writeLock &#x3D; rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    public void processData() &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        if (!update) &#123;</span><br><span class="line">            &#x2F;&#x2F; 必须先释放读锁</span><br><span class="line">            readLock.unlock();</span><br><span class="line">            &#x2F;&#x2F; 锁降级从写锁获取到开始</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!update) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 准备数据的流程（略）</span><br><span class="line">                    update &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">                readLock.lock();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                writeLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 锁降级完成，写锁降级为读锁</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 使用数据的流程（略）</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>锁降级是指把持住（当前拥有的）写锁，再获取到<br>读锁，随后释放（先前拥有的）写锁的过程。</p><p>当数据发生变更后，update变量（布尔类型且volatile修饰）被设置为false，此<br>时所有访问processData()方法的线程都能够感知到变化，但只有一个线程能够获取到写锁，其<br>他线程会被阻塞在读锁和写锁的lock()方法上。当前线程获取写锁完成数据准备之后，再获取<br>读锁，随后释放写锁，完成锁降级。<br>锁降级中读锁的获取是否必要呢？答案是必要的。主要是为了保证数据的可见性，如果<br>当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修<br>改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级<br>的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进<br>行数据更新。<br>RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。目的<br>也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了<br>数据，则其更新对其他获取到读锁的线程是不可见的。</p>]]></content>
      
      
      <categories>
          
          <category> JUC锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读写锁ReadWriteLock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Myabtis逆向工程</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/12%E3%80%81Myabtis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/12%E3%80%81Myabtis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>需求背景：</p><p>项目数据库表已经创建完成，N张表，如果我们一个个去写 pojo/bean的代码以及各种sql语句的话未免太过麻烦而且很容易出错，这个时候我们就需要MyBatis逆向工程去为我们生成这些基本的东西。<br>1、添加相关依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">      &lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.17&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">   &lt;!--添加mybatis逆向工程依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-generator-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.3.5&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;5.1.38&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--mybatis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;3.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="MyBatisGeneratorApp-java"><a href="#MyBatisGeneratorApp-java" class="headerlink" title="MyBatisGeneratorApp.java"></a>MyBatisGeneratorApp.java</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class MyBatisGeneratorApp &#123;</span><br><span class="line">    public void generator() throws Exception &#123;</span><br><span class="line">        List&lt;String&gt; warnings &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        boolean overwrite &#x3D; true;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;指定 逆向工程配置文件</span><br><span class="line">        File configFile &#x3D; new File(&quot;generatorConfig.xml&quot;);</span><br><span class="line"></span><br><span class="line">        ConfigurationParser cp &#x3D; new ConfigurationParser(warnings);</span><br><span class="line"></span><br><span class="line">        Configuration config &#x3D; cp.parseConfiguration(configFile);</span><br><span class="line"></span><br><span class="line">        DefaultShellCallback callback &#x3D; new DefaultShellCallback(overwrite);</span><br><span class="line"></span><br><span class="line">        MyBatisGenerator myBatisGenerator &#x3D; new MyBatisGenerator(config,</span><br><span class="line">                callback, warnings);</span><br><span class="line">        myBatisGenerator.generate(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;执行逆向工程</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MyBatisGeneratorApp generatorSqlmap &#x3D; new MyBatisGeneratorApp();</span><br><span class="line">            generatorSqlmap.generator();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="generatorConfig-xml"><a href="#generatorConfig-xml" class="headerlink" title="generatorConfig.xml"></a>generatorConfig.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD MyBatis Generator Configuration 1.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;context id&#x3D;&quot;testTables&quot; targetRuntime&#x3D;&quot;MyBatis3&quot;&gt;</span><br><span class="line">        &lt;commentGenerator&gt;</span><br><span class="line">            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;suppressAllComments&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;commentGenerator&gt;</span><br><span class="line">        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 ,加上“useSSL&#x3D;false”是因为我SSL连接数据库出现了错误 --&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass&#x3D;&quot;com.mysql.jdbc.Driver&quot; connectionURL&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;kpi_project?useSSL&#x3D;false&quot; userId&#x3D;&quot;root&quot; password&#x3D;&quot;xxx&quot;&gt;&lt;&#x2F;jdbcConnection&gt;</span><br><span class="line">        &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL </span><br><span class="line">            和 NUMERIC 类型解析为java.math.BigDecimal --&gt;</span><br><span class="line">        &lt;javaTypeResolver&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;forceBigDecimals&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;javaTypeResolver&gt;</span><br><span class="line">        &lt;!-- targetProject:生成pojo类的位置 --&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage&#x3D;&quot;pojo&quot; targetProject&#x3D;&quot;.\src\main\java&quot;&gt;</span><br><span class="line">            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;</span><br><span class="line">            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;trimStrings&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;javaModelGenerator&gt;</span><br><span class="line">        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage&#x3D;&quot;mapper&quot; targetProject&#x3D;&quot;.\src\main\java&quot;&gt;</span><br><span class="line">            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;sqlMapGenerator&gt;</span><br><span class="line">        &lt;!-- targetPackage：mapper接口生成的位置 --&gt;</span><br><span class="line">        &lt;javaClientGenerator type&#x3D;&quot;XMLMAPPER&quot; targetPackage&#x3D;&quot;mapper&quot; targetProject&#x3D;&quot;.\src\main\java&quot;&gt;</span><br><span class="line">            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;javaClientGenerator&gt;</span><br><span class="line">        &lt;!-- 指定数据库表 --&gt;</span><br><span class="line">        &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;com_role&quot;&gt;&lt;&#x2F;table&gt;</span><br><span class="line">        &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;com_rule&quot;&gt;&lt;&#x2F;table&gt;</span><br><span class="line">        &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;kpi_assess&quot;&gt;&lt;&#x2F;table&gt;</span><br><span class="line">        &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;kpi_assign&quot;&gt;&lt;&#x2F;table&gt;</span><br><span class="line">        &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;kpi_complain&quot;&gt;&lt;&#x2F;table&gt;</span><br><span class="line">        &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;kpi_index&quot;&gt;&lt;&#x2F;table&gt;</span><br><span class="line">        &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;kpi_institute&quot;&gt;&lt;&#x2F;table&gt;</span><br><span class="line">        &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;kpi_peformance&quot;&gt;&lt;&#x2F;table&gt;</span><br><span class="line">        &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;kpi_result&quot;&gt;&lt;&#x2F;table&gt;</span><br><span class="line">        &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;kpi_score&quot;&gt;&lt;&#x2F;table&gt;</span><br><span class="line">        &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;sys_permission&quot;&gt;&lt;&#x2F;table&gt;</span><br><span class="line">        &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;sys_role&quot;&gt;&lt;&#x2F;table&gt;</span><br><span class="line">        &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;sys_role_perm&quot;&gt;&lt;&#x2F;table&gt;</span><br><span class="line">        &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;sys_user&quot;&gt;&lt;&#x2F;table&gt;</span><br><span class="line">        &lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;sys_user_role&quot;&gt;&lt;&#x2F;table&gt;</span><br><span class="line">    &lt;&#x2F;context&gt;</span><br><span class="line">&lt;&#x2F;generatorConfiguration&gt;</span><br></pre></td></tr></table></figure><p>MyBatis的Mapper接口以及Example的实例函数及详解：<br><a href="https://blog.csdn.net/biandous/article/details/65630783">https://blog.csdn.net/biandous/article/details/65630783</a></p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Myabtis逆向工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="2020/06/21/Study%20notes/6%E3%80%81server/nginx/1%E3%80%81nginx/"/>
      <url>2020/06/21/Study%20notes/6%E3%80%81server/nginx/1%E3%80%81nginx/</url>
      
        <content type="html"><![CDATA[<p>Nginx 是高性能的HTTP和反向代理的服务器，处理高并发能力是十分强大的，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。</p><h3 id="正向代理："><a href="#正向代理：" class="headerlink" title="正向代理："></a>正向代理：</h3><p>客户端通过配置代理服务器，由代理服务器去请求目标服务器。</p><p>如：客户端要访问google,先用代理服务器xxx.com,通过xxx.com访问google.</p><h3 id="反向代理："><a href="#反向代理：" class="headerlink" title="反向代理："></a>反向代理：</h3><p>所谓反向代理正好与正向代理相反，代理服务器是为目标服务器服务的，虽然整体的请求返回路线都是一样的都是Client到Proxy到Server。但对于客户端隐藏了真实服务器 IP 地址。</p><p>Nginx的作用：</p><p>1、反向代理    </p><p>2、负载均衡</p><p>3、动静分离</p><h3 id="一：Nginx的安装"><a href="#一：Nginx的安装" class="headerlink" title="一：Nginx的安装"></a>一：Nginx的安装</h3><ol><li>首先下载 Nginx (<a href="http://nginx.org/en/download.html)%E5%9C%A8Linux%E4%B8%8A%E8%A7%A3%E5%8E%8B">http://nginx.org/en/download.html)在Linux上解压</a> tar zxvf nginx-0.x.xx.tar.gz</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进入解压目录：cd nginx-0.x.xx</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>备注：如果是Windows只需要解压即可完成安装</p><h3 id="二：Nginx的启动："><a href="#二：Nginx的启动：" class="headerlink" title="二：Nginx的启动："></a>二：Nginx的启动：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">以上安装 nginx默认解压在 usr&#x2F;local&#x2F;nginx目录下。</span><br><span class="line">所以启动的时候：usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">-c在这里是指定配置文件的路径，如果不指定，那么就是默认的</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">启动后我们可以通过 ps -ef | grep nginx 来查找Nginx的主进程号</span><br><span class="line">master process代表住进程</span><br></pre></td></tr></table></figure><p>备注：如果是Windows 直接点击解压包中的nginx.exe</p><h3 id="三：Nginx的停止"><a href="#三：Nginx的停止" class="headerlink" title="三：Nginx的停止"></a>三：Nginx的停止</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1) 从容停止Nginx</span><br><span class="line">kill - QUIT &lt;Nginx 主进程号&gt;</span><br><span class="line">或 kill - QUIT &#39;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid&#39;</span><br><span class="line">2) 快速停止Nginx</span><br><span class="line">kill - TEAM &lt;Nginx 主进程号&gt;</span><br><span class="line">kill - TEAM Nginx &#39;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid&#39;</span><br><span class="line">或</span><br><span class="line">kill - INT &lt;Nginx 主进程号&gt;</span><br><span class="line">kill - INT &#39;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid&#39;</span><br><span class="line">3) 强制停止所有Nginx进程</span><br><span class="line">pkill -9 nginx</span><br><span class="line">4) Nginx的平滑重启(因为是从容地重启，因此服务是不中断的)</span><br><span class="line">kill - HUP &lt;Nginx 主进程号&gt;</span><br><span class="line">kill - HUP &#39;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid&#39;</span><br></pre></td></tr></table></figure><p>备注：如果是Windows下退出直接在任务管理器停止进程即可</p><h3 id="四：配置负载均衡"><a href="#四：配置负载均衡" class="headerlink" title="四：配置负载均衡"></a>四：配置负载均衡</h3><p>注：配置文件是nginx.conf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  2;#工作进程的个数，一般与计算机的cpu核数一致，或者是双倍</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;#单个进程最大连接数（最大连接数&#x3D;连接数*进程数）</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types; #文件扩展名与文件类型映射表</span><br><span class="line">    default_type  application&#x2F;octet-stream;#默认文件类型</span><br><span class="line">    sendfile        on;#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I&#x2F;O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span><br><span class="line">keepalive_timeout  65; #长连接超时时间，单位是秒</span><br><span class="line">    gzip  on;#启用Gizp压缩</span><br><span class="line">#服务器的集群</span><br><span class="line">    upstream  netitcast.com &#123;  #服务器集群名字  此处是两个tomcat</span><br><span class="line">        #配置负载策略：如 ip_hash;  </span><br><span class="line">server    127.0.0.1:18080  weight&#x3D;1;#服务器配置   weight是权重的意思，权重越大，分配的概率越大。</span><br><span class="line">server    127.0.0.1:28080  weight&#x3D;2;</span><br><span class="line">&#125;</span><br><span class="line">#当前的Nginx的配置</span><br><span class="line">    server &#123;</span><br><span class="line">        listen  80;#监听80端口，可以改成其他端口</span><br><span class="line">        server_name  localhost;##############当前服务的域名</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;netitcast.com;</span><br><span class="line">            proxy_redirect default;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">        location ~* \.php$ &#123;                                # location匹配将php结尾的交给PHP服务器</span><br><span class="line">                fastcgi_pass 10.10.0.22:9000;</span><br><span class="line">                fastcgi_index index.php;</span><br><span class="line">                fastcgi_param SCRIPT_FILENAME &#x2F;app&#x2F;blog$fastcgi_script_name;</span><br><span class="line">                include fastcgi_params;</span><br><span class="line">        &#125; </span><br><span class="line">        location ~* \.(jpg|gif)$ &#123;                          # location匹配将图片交给Image处理</span><br><span class="line">                proxy_pass http:&#x2F;&#x2F;10.10.0.23:80;            # Image服务器要开启web服务</span><br><span class="line">        &#125;</span><br><span class="line">        error_page 404 &#x2F;404.html;</span><br><span class="line">            location &#x3D; &#x2F;40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page 500 502 503 504 &#x2F;50x.html;</span><br><span class="line">            location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="五：关闭日志操作-可选"><a href="#五：关闭日志操作-可选" class="headerlink" title="五：关闭日志操作(可选)"></a>五：关闭日志操作(可选)</h3><p>由于我们的服务需要在服务器上长久运行，日志文件的产生会导致服务器硬盘空间的不足，并且会对系统稳定性造成一定影响，所以我们可以选择关掉日志文件。<br>Tomcat日志关闭</p><p>将server.xml下的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Valve className&#x3D;&quot;org.apache.catalina.valves.AccessLogValve&quot; directory&#x3D;&quot;logs&quot;</span><br><span class="line">prefix&#x3D;&quot;localhost_access_log&quot; suffix&#x3D;&quot;.txt&quot;</span><br><span class="line">pattern&#x3D;&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>注释掉即可。<br>Nginx日志关闭</p><p>开发环境我默认不写日志，即不配置任何access_log<br>Nginx的http段中，设置access log：access_log off;<br>其他日志可以百度查找相关方法</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU最近最少使用</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/LRU%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/LRU%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：</p><ul><li>先进先出策略 FIFO（First In，First Out）</li><li>最少使用策略 LFU（Least Frequently Used）</li><li>最近最少使用策略 LRU（Least Recently Used）</li></ul><p>【LRU的淘汰规则是基于访问时间，而LFU是基于访问次数的】</p><p>不常用的</p><ul><li>OPT 最佳置换算法 （理想中存在的）</li><li>NRU Clock置换算法</li><li>PBA 页面缓冲算法</li></ul><p>Cache算法和内存页面置换算法的核心思想是一样的：都是在给定一个限定大小的空间的前提下，设计一个原则如何来更新和访问其中的元素。</p><p>LRU算法的设计原则是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。==淘汰最近最少使用的元素==</p><p>基于链表+Hash表实现思路：</p><p>我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。</p><p>当有一个新的数据被访问时，</p><ul><li>数据已经被缓存<br>若这个数据已经被缓存（已经存在于hash表中）,则从hasn表获取该数据对应链表的角标，并将其从原来的链表位置删除，然后再插入到链表的头部。更新hash表数据。</li></ul><ul><li>如果此数据没有在缓存hash表中，又可以分为两种情况：</li></ul><ol><li>如果此时缓存未满，则将此结点直接插入到链表的头部,并将数据和数据所在链表的角标记录在hash表中。</li><li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。并将数据和数据所在链表的角标记录在hash表中。这样我们就用链表实现了一个 LRU 缓存</li></ol><p>将缓存访问的时间复杂度降到 O(1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class LRUCache&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 容量</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int capacity &#x3D; 1024;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Node记录表</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Map&lt;String, ListNode&lt;String, V&gt;&gt; table &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 双向链表头部</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private ListNode&lt;String, V&gt; head;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 双向链表尾部</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private ListNode&lt;String, V&gt; tail;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        this();</span><br><span class="line">        this.capacity &#x3D; capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public LRUCache() &#123;</span><br><span class="line">        head &#x3D; new ListNode&lt;&gt;();</span><br><span class="line">        tail &#x3D; new ListNode&lt;&gt;();</span><br><span class="line">        head.next &#x3D; tail;</span><br><span class="line">        head.prev &#x3D; null;</span><br><span class="line">        tail.prev &#x3D; head;</span><br><span class="line">        tail.next &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public V get(String key) &#123;</span><br><span class="line"></span><br><span class="line">        ListNode&lt;String, V&gt; node &#x3D; table.get(key);</span><br><span class="line">        &#x2F;&#x2F;如果Node不在表中，代表缓存中并没有</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果存在，则需要移动Node节点到表头</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;截断链表，node.prev -&gt; node  -&gt; node.next &#x3D;&#x3D;&#x3D;&#x3D;&gt; node.prev -&gt; node.next</span><br><span class="line">        &#x2F;&#x2F;         node.prev &lt;- node &lt;- node.next  &#x3D;&#x3D;&#x3D;&#x3D;&gt;  node.prev &lt;- node.next</span><br><span class="line">        node.prev.next &#x3D; node.next;</span><br><span class="line">        node.next.prev &#x3D; node.prev;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;移动节点到表头</span><br><span class="line">        node.next &#x3D; head.next;</span><br><span class="line">        head.next.prev &#x3D; node;</span><br><span class="line">        node.prev &#x3D; head;</span><br><span class="line">        head.next &#x3D; node;</span><br><span class="line">        &#x2F;&#x2F;存在缓存表</span><br><span class="line">        table.put(key, node);</span><br><span class="line">        return node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void put(String key, V value) &#123;</span><br><span class="line">        ListNode&lt;String, V&gt; node &#x3D; table.get(key);</span><br><span class="line">        &#x2F;&#x2F;如果Node不在表中，代表缓存中并没有</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            if (table.size() &#x3D;&#x3D; capacity) &#123;</span><br><span class="line">                &#x2F;&#x2F;超过容量了 ,首先移除尾部的节点</span><br><span class="line">                table.remove(tail.prev.key);</span><br><span class="line">                tail.prev &#x3D; tail.next;</span><br><span class="line">                tail.next &#x3D; null;</span><br><span class="line">                tail &#x3D; tail.prev;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            node &#x3D; new ListNode&lt;&gt;();</span><br><span class="line">            node.key &#x3D; key;</span><br><span class="line">            node.value &#x3D; value;</span><br><span class="line">            table.put(key, node);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果存在，则需要移动Node节点到表头</span><br><span class="line">        node.next &#x3D; head.next;</span><br><span class="line">        head.next.prev &#x3D; node;</span><br><span class="line">        node.prev &#x3D; head;</span><br><span class="line">        head.next &#x3D; node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 双向链表内部类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static class ListNode&lt;K, V&gt; &#123;</span><br><span class="line">        private K key;</span><br><span class="line">        private V value;</span><br><span class="line">        ListNode&lt;K, V&gt; prev;</span><br><span class="line">        ListNode&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">        public ListNode(K key, V value) &#123;</span><br><span class="line">            this.key &#x3D; key;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public ListNode() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LRUCache&lt;ListNode&gt; cache &#x3D; new LRUCache&lt;&gt;(4);</span><br><span class="line">        ListNode&lt;String, Integer&gt; node1 &#x3D; new ListNode&lt;&gt;(&quot;key1&quot;, 1);</span><br><span class="line">        ListNode&lt;String, Integer&gt; node2 &#x3D; new ListNode&lt;&gt;(&quot;key2&quot;, 2);</span><br><span class="line">        ListNode&lt;String, Integer&gt; node3 &#x3D; new ListNode&lt;&gt;(&quot;key3&quot;, 3);</span><br><span class="line">        ListNode&lt;String, Integer&gt; node4 &#x3D; new ListNode&lt;&gt;(&quot;key4&quot;, 4);</span><br><span class="line">        ListNode&lt;String, Integer&gt; node5 &#x3D; new ListNode&lt;&gt;(&quot;key5&quot;, 5);</span><br><span class="line">        cache.put(&quot;key1&quot;, node1);</span><br><span class="line">        cache.put(&quot;key2&quot;, node2);</span><br><span class="line">        cache.put(&quot;key3&quot;, node3);</span><br><span class="line">        cache.put(&quot;key4&quot;, node4);</span><br><span class="line">        cache.get(&quot;key2&quot;);</span><br><span class="line">        cache.put(&quot;key5&quot;, node5);</span><br><span class="line">        cache.get(&quot;key2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 页面置换算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LRU最近最少使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hibernate的开发步骤</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/Hibernate/3%E3%80%81hibernate%E7%9A%84%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/Hibernate/3%E3%80%81hibernate%E7%9A%84%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<p>1、创建hibernate的配置文件hibernate.cfg.xml（配置数据源等等）</p><p>2、创建对象关系映射文件Person.hbm.xml（类-&gt;表，对象-&gt;记录，属性-&gt;字段）</p><p>3、创建持久化类entity</p><p>4、编写ORM api访问数据库的代码</p><p>导入以上jar包</p><p>1、编写hibernate.cfg.xml文件，这个文件可以放在src下，也可以放在classes下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-configuration PUBLIC</span><br><span class="line">    &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">    &quot;http:&#x2F;&#x2F;hibernate.sourceforge.net&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;hibernate-configuration&gt;</span><br><span class="line">    &lt;session-factory&gt;</span><br><span class="line">        &lt;!--驱动路径注意数据库类型  --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;connection.driver_class&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;!--数据库路径  --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;connection.url&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;!--数据库用户名  --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;connection.username&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;!--数据库密码  --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;connection.password&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;!--方言，便于hibernate对象操作转化为合适的数据库语句  --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;!--是否显示sql语句，sql一般会很难看  默认为false--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;!--下一个层级的映射文件，用来配置bean对象与数据表之间的关系  --&gt;</span><br><span class="line">        &lt;mapping resource&#x3D;&quot;com&#x2F;dhh&#x2F;pojo&#x2F;Person.hbm.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;session-factory&gt;</span><br><span class="line">&lt;&#x2F;hibernate-configuration&gt;</span><br></pre></td></tr></table></figure><p>2、Person.hbm.xml。一般跟bean放在同一个目录下，接受hibernate.cfg.xml管理的对象与数据表的关系中间件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC </span><br><span class="line">    &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">    &quot;http:&#x2F;&#x2F;hibernate.sourceforge.net&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;</span><br><span class="line">&lt;!-- 注意包名。不写的话下面要写全限定名 --&gt;</span><br><span class="line">&lt;hibernate-mapping    package&#x3D;&quot;com.dhh.pojo&quot;&gt;</span><br><span class="line">    &lt;!-- 类名对应表名 --&gt;</span><br><span class="line">    &lt;class name&#x3D;&quot;Person&quot; table&#x3D;&quot;person&quot;&gt;</span><br><span class="line">        &lt;!-- 主键使用id标签。然后对应属性名与列名 --&gt;</span><br><span class="line">        &lt;id name&#x3D;&quot;id&quot; type&#x3D;&quot;int&quot; column&#x3D;&quot;id&quot;&gt;</span><br><span class="line">            &lt;!-- 自增长主键不同数据库有不同类型的自增长类型，有需要可以百度到答案的 --&gt;</span><br><span class="line">            &lt;generator class&#x3D;&quot;identity&quot;&gt;&lt;&#x2F;generator&gt;</span><br><span class="line">        &lt;&#x2F;id&gt;</span><br><span class="line">        &lt;!-- 非主键映射关系，注意类型并不是单纯的java类型也不是数据库类型，而是一种中间类型，注意大小写特别是String在这里开头要小写 --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; type&#x3D;&quot;string&quot; column&#x3D;&quot;name&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;age&quot; type&#x3D;&quot;int&quot; column&#x3D;&quot;age&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;address&quot; type&#x3D;&quot;string&quot; column&#x3D;&quot;address&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;class&gt;</span><br><span class="line">&lt;&#x2F;hibernate-mapping&gt;</span><br></pre></td></tr></table></figure><p>4、ORM PAI</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.dhh.Util;</span><br><span class="line"></span><br><span class="line">import org.hibernate.Session;</span><br><span class="line">import org.hibernate.SessionFactory;</span><br><span class="line">import org.hibernate.Transaction;</span><br><span class="line">import org.hibernate.cfg.Configuration;</span><br><span class="line"></span><br><span class="line">public class Util &#123;</span><br><span class="line">    public static Configuration cfg;</span><br><span class="line">    public static SessionFactory sessionFactory;</span><br><span class="line">    static&#123;</span><br><span class="line">        &#x2F;&#x2F;启动原本设定好的配置管理文件</span><br><span class="line">        cfg&#x3D;new Configuration().configure();</span><br><span class="line">        &#x2F;&#x2F;建立会话工厂用来产生会话，工厂可以只有一个</span><br><span class="line">        sessionFactory&#x3D;cfg.buildSessionFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Session openSesson()&#123;</span><br><span class="line">        return sessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Transaction beginTransaction(Session session)&#123;</span><br><span class="line">        return session.beginTransaction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中session接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Session接口</span><br><span class="line"></span><br><span class="line">Session接口：是应用程序与数据库之间交互操作的核心对象，是 Hibernate 运作的中心，所有持久化对象（javabean）必须在 session 的管理下才可以进行持久化（更新数据库）操作。</span><br><span class="line"></span><br><span class="line">获取Session对象的方式：</span><br><span class="line"></span><br><span class="line">Session session  &#x3D; sessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">Session的主要方法简介：</span><br><span class="line"></span><br><span class="line">取得持久化对象的方法： get() load()</span><br><span class="line"></span><br><span class="line">持久化对象保存，更新和删除：save(),update(),saveOrUpdate(),delete()</span><br><span class="line"></span><br><span class="line">开启事务: beginTransaction().</span><br><span class="line"></span><br><span class="line">管理 Session 的方法：isOpen(),flush(), clear(), evict(), close()等</span><br></pre></td></tr></table></figure><p>上面所说的主键自增长类型可参考下表：<br><img src="https://images2015.cnblogs.com/blog/1055646/201706/1055646-20170616114315087-1880783859.png" alt="image"></p><p>执行原理与流程</p><p>a、应用程序先调用Configuration类,该类读取Hibernate配置文件及映射文件中的信息，</p><p>b、并用这些信息生成一个SessionFactory对象，</p><p>c、然后从SessionFactory对象生成一个Session对象，</p><p>d、并用Session对象生成Transaction对象；</p><p>e、可通过Session对象的get(),load(),save(),update(),delete()和saveOrUpdate()、createQuery()等方法对进行CURD等操作；</p><p>f、提交事物。</p><p><img src="https://images2015.cnblogs.com/blog/1055646/201706/1055646-20170616114130884-2134062939.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> Hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hibernate的开发步骤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Config</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/6%E3%80%81spring-config%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/2%E3%80%81Spring%20Cloud%20Config/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/6%E3%80%81spring-config%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/2%E3%80%81Spring%20Cloud%20Config/</url>
      
        <content type="html"><![CDATA[<p>1、思路：</p><p>第一：所有配置文件存放在github或其他git仓库上，由spring-cloud-config server与其通信。</p><p>所以：微服务首先要告诉spring-cloud-config自己需要那个配置文件，spring-cloud-config再从github上将配置文件读取过来。微服务在解析成自己的配置</p><p>config server端搭建步骤：</p><h3 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h3><p>新建一个配置中心的配置文件：application.yml 上传至github上</p><p>1、从前文得知，spring-cloud-config分为服务端和客户端（各个微服务），服务端也是一个独立的微服务，所以新建一个微服务作为配置中心引入spring-cloud-config的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--配置中心添加安全认证--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、在配置文件中指明github地址，与其通信<br>#注意是git的ssh地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8901</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-server</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git: #配置存储配置信息的Git仓库</span><br><span class="line">          uri: https:&#x2F;&#x2F;gitee.com&#x2F;macrozheng&#x2F;springcloud-config.git</span><br><span class="line">          username: macro</span><br><span class="line">          password: 123456</span><br><span class="line">          clone-on-start: true #开启启动时直接从git获取配置</span><br><span class="line">  security: #配置用户名和密码</span><br><span class="line">    user:</span><br><span class="line">      name: macro</span><br><span class="line">      password: 123456</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8001&#x2F;eureka&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、在启动类中添加注解<br>@EnableConfigServer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@EnableConfigServer</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时该配置中心可以与github通信了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 获取配置信息</span><br><span class="line">&#x2F;&#123;label&#125;&#x2F;&#123;application&#125;-&#123;profile&#125;</span><br><span class="line"># 获取配置文件信息</span><br><span class="line">&#x2F;&#123;label&#125;&#x2F;&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>application：代表应用名称，默认为配置文件中的spring.application.name，如果配置了spring.cloud.config.name，则为该名称；</li><li>label：代表分支名称，对应配置文件中的spring.cloud.config.label；</li><li>profile：代表环境名称，对应配置文件中的spring.cloud.config.profile。</li></ul><h4 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h4><p>搞定配置中心。剩下就是微服务与配置中心通信。告诉配置中心自己所需要的配置文件，让他从github上读取到该文件给微服务。</p><p>准备工作：新建一个微服务提供者的配置文件，并上传至github上。</p><p>1、新建一个微服务提供者，引入依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、为微服务提供者的resource目录下新建一个系统级的bootstrap.yml文件，这是一个优先级高于用户级的配置文件application.yml</p><p>内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9001</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-client</span><br><span class="line">  cloud:</span><br><span class="line">    #告诉springcloud-config配置中心需要从github上读取的资源名称  注意末尾没有yml</span><br><span class="line">    config: #Config客户端配置</span><br><span class="line">      profile: dev #启用配置后缀名称</span><br><span class="line">      label: dev #分支名称</span><br><span class="line">      uri: http:&#x2F;&#x2F;localhost:8901 #config server配置中心的地址，让过配置中心微服务获取github上的文件</span><br><span class="line">      name: config #配置文件名称</span><br><span class="line">      #配置中心添加了安全认证</span><br><span class="line">      username: macro</span><br><span class="line">      password: 123456</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8001&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p>微服务客户端获取配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class ConfigClientController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;config.info&#125;&quot;)</span><br><span class="line">    private String configInfo;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;configInfo&quot;)</span><br><span class="line">    public String getConfigInfo() &#123;</span><br><span class="line">        return configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="刷新配置"><a href="#刷新配置" class="headerlink" title="刷新配置"></a>刷新配置</h4><p>当Git仓库中的配置信息更改后，我们可以通过SpringBoot Actuator的refresh端点来刷新客户端配置信息，以下更改都需要在config-client中进行。</p><p>在pom.xml中添加Actuator的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开启refresh端点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#39;refresh&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加@RefreshScope注解用于刷新配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RefreshScope</span><br><span class="line">public class ConfigClientController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;config.info&#125;&quot;)</span><br><span class="line">    private String configInfo;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;configInfo&quot;)</span><br><span class="line">    public String getConfigInfo() &#123;</span><br><span class="line">        return configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring-config配置中心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud Config </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeHandler</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/4%E3%80%81TypeHandler/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/4%E3%80%81TypeHandler/</url>
      
        <content type="html"><![CDATA[<p>Mybatis在预处理语句（PreparedStateMent）中设置一个参数，将参数从javaType转化为jdbcType  ,或从ResultSet中取出一个值时候，将参数从jdbcType转化为javaType,都会用注册了的TypeHandler进行处理。</p><p>mybatis定义了<br><img src="https://www.2cto.com/uploadfile/Collfiles/20180507/20180507093707132.png" alt="image"></p><p><img src="https://www.2cto.com/uploadfile/Collfiles/20180507/20180507093707133.png" alt="image"></p><p><img src="https://www.2cto.com/uploadfile/Collfiles/20180507/20180507093707134.png" alt="image"></p><p>StringTypeHandler为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class StringTypeHandler extends BaseTypeHandler&lt;String&gt; &#123;</span><br><span class="line">    public StringTypeHandler() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException &#123;</span><br><span class="line">        ps.setString(i, parameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getNullableResult(ResultSet rs, String columnName) throws SQLException &#123;</span><br><span class="line">        return rs.getString(columnName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123;</span><br><span class="line">        return rs.getString(columnIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123;</span><br><span class="line">        return cs.getString(columnIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义typeHandler</p><p>自定义typeHandler 直接实现 TypeHandler<T>  也可以继承 BaseTypeHandler<T>，我们选择继承吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package com.yihaomen.mybatis.type;</span><br><span class="line"></span><br><span class="line">import org.apache.ibatis.type.BaseTypeHandler;</span><br><span class="line">import org.apache.ibatis.type.JdbcType;</span><br><span class="line">import org.apache.ibatis.type.MappedJdbcTypes;</span><br><span class="line">import org.apache.ibatis.type.MappedTypes;</span><br><span class="line"></span><br><span class="line">import java.sql.CallableStatement;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *   </span><br><span class="line"> *  @ProjectName: springmvc-mybatis </span><br><span class="line"> *  @Description: 自定义处理日期Hander,</span><br><span class="line"> *                将Date类型转换为时间戳字符串戳存入到数据库中</span><br><span class="line"> *  1.@MappedJdbcTypes定义的是JdbcType类型，这里的类型不可自己随意定义，</span><br><span class="line"> *   必须要是枚举类org.apache.ibatis.type.JdbcType所枚举的数据类型。</span><br><span class="line"> *  2.@MappedTypes定义的是JavaType的数据类型，描述了哪些Java类型可被拦截。</span><br><span class="line"> *  3.在我们启用了我们自定义的这个TypeHandler之后，数据的读写都会被这个类所过滤</span><br><span class="line"> *&#x2F;</span><br><span class="line">@MappedTypes(&#123;Date.class&#125;)</span><br><span class="line">@MappedJdbcTypes(JdbcType.VARCHAR)</span><br><span class="line">public class MyDateTypeHandler extends BaseTypeHandler&lt;Date&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将时间戳字符串存入数据库</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void setNonNullParameter(PreparedStatement ps, int i, Date parameter, JdbcType jdbcType) throws SQLException &#123;</span><br><span class="line">        ps.setString(i, String.valueOf(parameter.getTime()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 把时间戳类型的字符串取出转换为Date</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Date getNullableResult(ResultSet rs, String columnName) throws SQLException &#123;</span><br><span class="line">        return new Date(rs.getLong(columnName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 把时间戳类型的字符串取出转换为Date</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Date getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123;</span><br><span class="line">        return new Date(rs.getLong(columnIndex));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 把时间戳类型的字符串取出转换为Date</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Date getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123;</span><br><span class="line">        return cs.getDate(columnIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在configuration.xml中注册typeHandler</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">        注册typeHandler,注册有两种不同的方式</span><br><span class="line">        1.可以像下面这样一个类一个类的注册</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;typeHandlers&gt;</span><br><span class="line">        &lt;typeHandler handler&#x3D;&quot;com.yihaomen.mybatis.type.MyDateTypeHandler&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;typeHandlers&gt;</span><br><span class="line">    &lt;!--2.也可以直接注册一个包中所有的typeHandler--&gt;</span><br><span class="line">    &lt;!--&lt;typeHandlers&gt;</span><br><span class="line">        &lt;package name&#x3D;&quot;com.yihaomen.mybatis.type&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;typeHandlers&gt;--&gt;</span><br></pre></td></tr></table></figure><p>在User.xml文件中写<resultMap/>、<select/>和<insert/></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;resultMap id&#x3D;&quot;resultListUser&quot; type&#x3D;&quot;User&quot;&gt;</span><br><span class="line">　　&lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot; &#x2F;&gt;</span><br><span class="line">　　&lt;result column&#x3D;&quot;userName&quot; property&#x3D;&quot;userName&quot; &#x2F;&gt;</span><br><span class="line">　　&lt;result column&#x3D;&quot;userAge&quot; property&#x3D;&quot;userAge&quot; &#x2F;&gt;</span><br><span class="line">　　&lt;result column&#x3D;&quot;userAddress&quot; property&#x3D;&quot;userAddress&quot; &#x2F;&gt;</span><br><span class="line">　　&lt;result column&#x3D;&quot;reg_time&quot; property&#x3D;&quot;regTime&quot; javaType&#x3D;&quot;java.util.Date&quot; jdbcType&#x3D;&quot;VARCHAR&quot; typeHandler&#x3D;&quot;com.yihaomen.mybatis.type.MyDateTypeHandler&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;resultMap&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;selectUserById2&quot; parameterType&#x3D;&quot;int&quot; resultMap&#x3D;&quot;resultListUser&quot;&gt;</span><br><span class="line">    select * from user where id &#x3D; #&#123;id&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line">&lt;insert id&#x3D;&quot;addUser&quot; parameterType&#x3D;&quot;User&quot; useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;id&quot;&gt; </span><br><span class="line">　　insert into user(userName,userAge,userAddress,reg_time) values(#&#123;userName&#125;,#&#123;userAge&#125;, #&#123;userAddress&#125;, </span><br><span class="line">　　#&#123;regTime,javaType&#x3D;Date,jdbcType&#x3D;VARCHAR,typeHandler&#x3D;com.yihaomen.mybatis.type.MyDateTypeHandler&#125;) </span><br><span class="line">&lt;&#x2F;insert&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeHandler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java事务的类型</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/Java%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%B1%BB%E5%9E%8B/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/Java%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Java事务的类型：</p><ul><li>JDBC事务、</li><li>JTA（Java Transaction API）事务、</li><li>容器事务:容器事务:主要指的是J2EE应用服务器提供的事务管理，局限于EJB应用使用。</li></ul><h4 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h4><p>　JDBC 事务是用 Connection 对象控制的。JDBC Connection 接口（ java.sql.Connection ）提供了两种事务模式：自动提交和手工提交。 java.sql.Connection 提供了以下控制事务的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setAutoCommit(boolean)  </span><br><span class="line">public boolean getAutoCommit()  </span><br><span class="line">public void commit()  </span><br><span class="line">public void rollback()  </span><br></pre></td></tr></table></figure><p>使用 JDBC 事务界定时，您可以将多个 SQL 语句结合到一个事务中，==缺点是事务的范围局限于一个数据库连接。无法实现分布式事务。==</p><h4 id="JTA事务（java-Transaction-API）-不常用"><a href="#JTA事务（java-Transaction-API）-不常用" class="headerlink" title="JTA事务（java Transaction API）(不常用)"></a>JTA事务（java Transaction API）(不常用)</h4><p>简单的支付流程的操作，其中调用了五个服务，这五个服务都通过RPC的方式调用，==增加了@Transactional注解，但是由于采用调用了分布式服务，该事务并不能达到ACID的效果。==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 支付订单处理 **&#x2F;</span><br><span class="line">@Transactional(rollbackFor &#x3D; Exception.class)</span><br><span class="line">public void completeOrder() &#123;</span><br><span class="line">    orderDao.update(); &#x2F;&#x2F; 订单服务本地更新订单状态</span><br><span class="line">    accountService.update(); &#x2F;&#x2F; 调用资金账户服务给资金帐户加款</span><br><span class="line">    pointService.update(); &#x2F;&#x2F; 调用积分服务给积分帐户增加积分</span><br><span class="line">    accountingService.insert(); &#x2F;&#x2F; 调用会计服务向会计系统写入会计原始凭证</span><br><span class="line">    merchantNotifyService.notify(); &#x2F;&#x2F; 调用商户通知服务向商户发送支付结果通知</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个JTA事务可以有多个参与者，而一个JDBC事务则被限定在一个单一的数据库连接.常见的JTA实现有以下2种：</p><ul><li>1.J2EE容器所提供的JTA实现(JBoss)</li><li>2.独立的JTA实现:如JOTM，Atomikos.这些实现可以应用在那些不使用J2EE应用服务器的环境里用以提供分布事事务保证。如Tomcat,Jetty以及普通的java应用。</li></ul><ul><li>JTA的优点:提供了分布式事务的解决方案，严格的ACID。但</li><li>缺点:</li></ul><p>实现复杂,用 JTA 事务，那么就需要有一个实现 javax.sql.XADataSource 、javax.sql.XAConnection 和 javax.sql.XAResource 接口的 JDBC 驱动程序。</p><p>通常情况下，JTA UserTransaction需要从JNDI获取。这意味着，如果我们使用JTA，就需要同时使用JTA和JNDI。</p><h2 id="spring事务"><a href="#spring事务" class="headerlink" title="spring事务"></a>spring事务</h2><p>Spring并不直接管理事务，而是提供了多种事务管理器 ，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;平台事务管理器接口</span><br><span class="line">Public interface PlatformTransactionManager()...&#123;  </span><br><span class="line">    &#x2F;&#x2F; 根据指定的传播行为，返回当前活动的事务或创建一个新事务。</span><br><span class="line">    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; </span><br><span class="line">    &#x2F;&#x2F; 使用事务目前的状态提交事务</span><br><span class="line">    Void commit(TransactionStatus status) throws TransactionException;  </span><br><span class="line">  &#x2F;&#x2F; transaction（对执行的事务进行回滚）</span><br><span class="line">    Void rollback(TransactionStatus status) throws TransactionException;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h4><p>Spring为不同的持久化框架提供了不同的PlatformTransactionManager如: </p><ul><li>JDBC或iBatis:DataSourceTransactionManager </li><li>Hibernate:HibernateTransactionManager</li><li>JPA：JtaTransactionManager</li></ul><h4 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h4><p>事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionDefinition &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;7种传播行为</span><br><span class="line">    int PROPAGATION_REQUIRED &#x3D; 0;</span><br><span class="line">    int PROPAGATION_SUPPORTS &#x3D; 1;</span><br><span class="line">    int PROPAGATION_MANDATORY &#x3D; 2;</span><br><span class="line">    int PROPAGATION_REQUIRES_NEW &#x3D; 3;</span><br><span class="line">    int PROPAGATION_NOT_SUPPORTED &#x3D; 4;</span><br><span class="line">    int PROPAGATION_NEVER &#x3D; 5;</span><br><span class="line">    int PROPAGATION_NESTED &#x3D; 6;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;5种隔离级别</span><br><span class="line">    </span><br><span class="line">    int ISOLATION_DEFAULT &#x3D; -1;</span><br><span class="line">    int ISOLATION_READ_UNCOMMITTED &#x3D; 1;</span><br><span class="line">    int ISOLATION_READ_COMMITTED &#x3D; 2;</span><br><span class="line">    int ISOLATION_REPEATABLE_READ &#x3D; 4;</span><br><span class="line">    int ISOLATION_SERIALIZABLE &#x3D; 8;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务</span><br><span class="line">    int TIMEOUT_DEFAULT &#x3D; -1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 返回事务的传播行为</span><br><span class="line">    int getPropagationBehavior(); </span><br><span class="line">    &#x2F;&#x2F; 返回事务的隔离级别，</span><br><span class="line">    int getIsolationLevel(); </span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F;返回事务的名字</span><br><span class="line">    String getName()；</span><br><span class="line">    </span><br><span class="line">     &#x2F;&#x2F; 返回事务必须在多少秒内完成</span><br><span class="line">    int getTimeout();  </span><br><span class="line">    &#x2F;&#x2F; 返回是否优化为只读事务。</span><br><span class="line">    boolean isReadOnly();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="TransactionStatus：-事务运行状态"><a href="#TransactionStatus：-事务运行状态" class="headerlink" title="TransactionStatus： 事务运行状态"></a>TransactionStatus： 事务运行状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionStatus&#123;</span><br><span class="line">    &#x2F;&#x2F; 是否是新的事物</span><br><span class="line">    boolean isNewTransaction();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 返回此事务是否内部携带保存点，也就是基于保存点创建为嵌套事务</span><br><span class="line">    boolean hasSavepoint(); </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 设置事务回滚</span><br><span class="line">    void setRollbackOnly();  </span><br><span class="line">    </span><br><span class="line">     &#x2F;&#x2F; 返回事务是否已被标记为仅回滚    </span><br><span class="line">    boolean isRollbackOnly();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 返回此事务是否完成，即是否已经提交或回滚</span><br><span class="line">    boolean isCompleted; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java事务的类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot文件上传</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-boot/springboot%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-boot/springboot%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>上传配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class UploadFileConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;file.uploadFolder&#125;&quot;)</span><br><span class="line">    private String uploadFolder;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    MultipartConfigElement multipartConfigElement() &#123;</span><br><span class="line">        MultipartConfigFactory factory &#x3D; new MultipartConfigFactory();</span><br><span class="line">        factory.setLocation(uploadFolder);</span><br><span class="line">        &#x2F;&#x2F;文件最大</span><br><span class="line">        factory.setMaxFileSize(&quot;10MB&quot;);</span><br><span class="line">        &#x2F;&#x2F; 设置总上传数据总大小</span><br><span class="line">        factory.setMaxRequestSize(&quot;500MB&quot;);</span><br><span class="line">        return factory.createMultipartConfig();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加映射路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class UploadFilePathConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;file.staticAccessPath&#125;&quot;)</span><br><span class="line">    private String staticAccessPath;</span><br><span class="line">    @Value(&quot;$&#123;file.uploadFolder&#125;&quot;)</span><br><span class="line">    private String uploadFolder;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        &#x2F;&#x2F;staticAccessPath 作为访问路径 uploadFolder 实际路径</span><br><span class="line">        registry.addResourceHandler(staticAccessPath).addResourceLocations(&quot;file:&quot; + uploadFolder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在application配置文件 添加一下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#静态资源对外暴露的访问路径</span><br><span class="line">file:</span><br><span class="line">  staticAccessPath: &#x2F;api&#x2F;file&#x2F;**</span><br><span class="line">#  （注意Linux和Windows上的目录结构不同）</span><br><span class="line">#  uploadFolder: &#x2F;runtime&#x2F;rmldImages&#x2F;</span><br><span class="line">  uploadFolder: d:&#x2F;&#x2F;uploadFiles&#x2F;</span><br></pre></td></tr></table></figure><p>附件：图片下载工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class DownloadPicFromURL &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String url &#x3D; &quot;https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;cgi-bin&#x2F;showqrcode?ticket&#x3D;gQH-7zwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAyY05GbWRkeDdkT0QxVnZuR2hyMWEAAgTfXOFbAwSAOgkA&quot;;</span><br><span class="line">        String path&#x3D;&quot;d:&#x2F;pic.jpg&quot;;</span><br><span class="line">        downloadPicture(url,path);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;链接url下载图片</span><br><span class="line">    public static void downloadPicture(String urlList,String path) &#123;</span><br><span class="line"></span><br><span class="line">        System.err.println(&quot;图片下载的地址：&quot;+urlList);</span><br><span class="line">        System.err.println(&quot;图片保存的地址：&quot;+path);</span><br><span class="line">        URL url &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            url &#x3D; new URL(urlList);</span><br><span class="line">            DataInputStream dataInputStream &#x3D; new DataInputStream(url.openStream());</span><br><span class="line">            File file&#x3D; new File(path);</span><br><span class="line">            if(!file.exists())&#123;</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">            FileOutputStream fileOutputStream &#x3D; new FileOutputStream(file);</span><br><span class="line">            ByteArrayOutputStream output &#x3D; new ByteArrayOutputStream();</span><br><span class="line">            byte[] buffer &#x3D; new byte[1024];</span><br><span class="line">            int length;</span><br><span class="line">            while ((length &#x3D; dataInputStream.read(buffer)) &gt; 0) &#123;</span><br><span class="line">                output.write(buffer, 0, length);</span><br><span class="line">            &#125;</span><br><span class="line">            fileOutputStream.write(output.toByteArray());</span><br><span class="line">            dataInputStream.close();</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">        &#125; catch (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.qianlima.rmld.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.boot.web.servlet.MultipartConfigFactory;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import javax.servlet.MultipartConfigElement;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;图片上传配置类</span><br><span class="line">@Configuration</span><br><span class="line">public class UploadFileConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;file.uploadFolder&#125;&quot;)</span><br><span class="line">    private String uploadFolder;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    MultipartConfigElement multipartConfigElement() &#123;</span><br><span class="line">        MultipartConfigFactory factory &#x3D; new MultipartConfigFactory();</span><br><span class="line">        factory.setLocation(uploadFolder);</span><br><span class="line">        &#x2F;&#x2F;文件最大</span><br><span class="line">        factory.setMaxFileSize(&quot;10MB&quot;);</span><br><span class="line">        &#x2F;&#x2F; 设置总上传数据总大小</span><br><span class="line">        factory.setMaxRequestSize(&quot;500MB&quot;);</span><br><span class="line">        return factory.createMultipartConfig();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问路径配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.qianlima.rmld.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class UploadFilePathConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;file.staticAccessPath&#125;&quot;)</span><br><span class="line">    private String staticAccessPath;</span><br><span class="line">    @Value(&quot;$&#123;file.uploadFolder&#125;&quot;)</span><br><span class="line">    private String uploadFolder;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        &#x2F;&#x2F;staticAccessPath 作为访问路径 uploadFolder 实际路径</span><br><span class="line">        registry.addResourceHandler(staticAccessPath).addResourceLocations(&quot;file:&quot; + uploadFolder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在yml配置文件中配置路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file:</span><br><span class="line">  staticAccessPath: &#x2F;api&#x2F;file&#x2F;**</span><br><span class="line">#  （注意Linux和Windows上的目录结构不同）</span><br><span class="line">  uploadFolder: &#x2F;rmld&#x2F;data&#x2F;images&#x2F;</span><br><span class="line">#  uploadFolder: d:&#x2F;&#x2F;uploadFiles&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring-boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>doubbo-入门DEMO(注解式)</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/7%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/3%E3%80%81doubbo-%E5%85%A5%E9%97%A8DEMO(%E6%B3%A8%E8%A7%A3%E5%BC%8F)/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/7%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/3%E3%80%81doubbo-%E5%85%A5%E9%97%A8DEMO(%E6%B3%A8%E8%A7%A3%E5%BC%8F)/</url>
      
        <content type="html"><![CDATA[<p>准备三个工程</p><p>公共接口-api  存放java bean和接口（该工程也可以不用，放入服务提供者里面）官方推荐使用api</p><p>服务提供者：dubbo-provider</p><p>服务消费者：dubbo-consumser</p><h3 id="一：服务提供者的配置："><a href="#一：服务提供者的配置：" class="headerlink" title="一：服务提供者的配置："></a>一：服务提供者的配置：</h3><p>1、在服务提供者中引入dubbo依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dubbo&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、添加配置类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DubboConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean &#x2F;&#x2F;配置服务提供者的应用名称</span><br><span class="line">    public ApplicationConfig applicationConfig() &#123;</span><br><span class="line">        ApplicationConfig applicationConfig &#x3D; new ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(&quot;dubbo-provider01&quot;);</span><br><span class="line">        return applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;配置dubbo的注册中心</span><br><span class="line">&#x2F;&#x2F;配置了注册中心 表示该服务注册进该注册中心</span><br><span class="line">   @Bean</span><br><span class="line">public RegistryConfig registryConfig() &#123;</span><br><span class="line">    RegistryConfig registryConfig &#x3D; new RegistryConfig();</span><br><span class="line">    &#x2F;&#x2F;注册协议 注册中心为multicast</span><br><span class="line">    registryConfig.setProtocol(&quot;multicast&quot;);</span><br><span class="line">    &#x2F;&#x2F;注册地址</span><br><span class="line">    registryConfig.setAddress(&quot;224.5.6.7:1234&quot;);</span><br><span class="line">    return registryConfig;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、编写接口实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import com.znt.dubbo.api.service.PersonService;</span><br><span class="line">import com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line">@Service &#x2F;&#x2F;这是一个dubbo service</span><br><span class="line">public class PersonServiceImpl implements PersonService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String sayHi(String name) &#123;</span><br><span class="line">        return &quot;hell dubbo&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String working(String work) &#123;</span><br><span class="line">        return &quot;dubbo_work&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、在启动类中，添加dubbo组件扫描（扫描到dubbo-service）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@DubboComponentScan(basePackages &#x3D; &quot;com.znt.dubbo.provider01.serviceimpl&quot;)</span><br><span class="line">public class MyProvider01Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MyProvider01Application.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二：服务消费者配置"><a href="#二：服务消费者配置" class="headerlink" title="二：服务消费者配置"></a>二：服务消费者配置</h3><p>1、在服务消费者中引入dubbo依赖</p><p>2、添加配置类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DubboConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean &#x2F;&#x2F;配置服务消费者的应用名称</span><br><span class="line">    public ApplicationConfig applicationConfig() &#123;</span><br><span class="line">        ApplicationConfig applicationConfig &#x3D; new ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(&quot;dubbo-consumer01&quot;);</span><br><span class="line">        return applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;配置dubbo的注册中心（与服务提供者注册进同一个注册中心）</span><br><span class="line">&#x2F;&#x2F;配置了注册中心 表示该服务注册进该注册中心</span><br><span class="line">   @Bean</span><br><span class="line">public RegistryConfig registryConfig() &#123;</span><br><span class="line">    RegistryConfig registryConfig &#x3D; new RegistryConfig();</span><br><span class="line">     &#x2F;&#x2F;注册协议 注册中心为multicast</span><br><span class="line">    registryConfig.setProtocol(&quot;multicast&quot;);</span><br><span class="line">    &#x2F;&#x2F;注册地址</span><br><span class="line">    registryConfig.setAddress(&quot;224.5.6.7:1234&quot;);</span><br><span class="line">    return registryConfig;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、引用service接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class MyController &#123;</span><br><span class="line">    @Reference</span><br><span class="line">    PersonService personService;</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;getData&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public String getData()&#123;</span><br><span class="line">        return personService.working(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、在启动类中，添加dubbo组件扫描（扫描到Reference）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@DubboComponentScan(basePackages &#x3D; &quot;com.znt.dubbo.consumer01.controller&quot;)</span><br><span class="line">public class MyConsumer01Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MyConsumer01Application.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上的demo dubbo服务注册进multicast 改为zookeeper<br>注册进zookeeper：</p><p>1、提供者 消费者引入zookeeper客户端依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.101tec&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zkclient&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.10&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 采坑，一定要多加一个依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">将原来的注册中心由multicast 改为zookeeper</span><br><span class="line">@Bean</span><br><span class="line">public RegistryConfig registryConfig() &#123;</span><br><span class="line">    RegistryConfig registryConfig &#x3D; new RegistryConfig();</span><br><span class="line">     &#x2F;&#x2F;注册协议 注册中心为multicast</span><br><span class="line">    registryConfig.setProtocol(&quot;multicast&quot;);</span><br><span class="line">    &#x2F;&#x2F;注册地址</span><br><span class="line">    registryConfig.setAddress(&quot;224.5.6.7:1234&quot;);</span><br><span class="line">    return registryConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为：zookeeper注册中心</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RegistryConfig registryConfig() &#123;</span><br><span class="line">    RegistryConfig registryConfig &#x3D; new RegistryConfig();</span><br><span class="line">     &#x2F;&#x2F;注册协议 注册中心为zookeeper</span><br><span class="line">    registryConfig.setProtocol(&quot;zookeeper&quot;);</span><br><span class="line">    &#x2F;&#x2F;注册地址</span><br><span class="line">    registryConfig.setAddress(&quot;127.0.0.1:2181&quot;);</span><br><span class="line">    return registryConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doubbo-入门DEMO(注解式) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mycat配置文件详解</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/MyCat/2%E3%80%81mycat%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/MyCat/2%E3%80%81mycat%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1、rule-xml"><a href="#1、rule-xml" class="headerlink" title="1、rule.xml"></a>1、rule.xml</h1><p>该文件主要定义了分片的规则，这个文件里面主要有tableRule和function这两个标签。在具体使用过程中可以按照需求添加tableRule和function</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--name：用户标识不同的分表规则 --&gt;</span><br><span class="line">&lt;tableRule name&#x3D;&quot;auto-sharding-long&quot;&gt;</span><br><span class="line">    &lt;rule&gt;</span><br><span class="line">    &lt;!--columns：指定按哪一列进行拆分--&gt;</span><br><span class="line">        &lt;columns&gt;id&lt;&#x2F;columns&gt;</span><br><span class="line">       &lt;!-- algorithm：该属性值为下面function标签中name的属性值，定义了连接表规则的具体的路由算法，多个表规则可以连接到同一个路由算法上--&gt;</span><br><span class="line">        &lt;algorithm&gt;rang-long&lt;&#x2F;algorithm&gt;</span><br><span class="line">    &lt;&#x2F;rule&gt;</span><br><span class="line">&lt;&#x2F;tableRule&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--标识算法的名字与上面的algorithm节点对应 --&gt;</span><br><span class="line">&lt;function name&#x3D;&quot;rang-long&quot;</span><br><span class="line">&lt;!--指定路由算法具体的类名字 --&gt;</span><br><span class="line">    class&#x3D;&quot;org.opencloudb.route.function.AutoPartitionByLong&quot;&gt;</span><br><span class="line">   &lt;!-- 具体算法用到的一些属性--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;mapFile&quot;&gt;autopartition-long.txt&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;function&gt;</span><br></pre></td></tr></table></figure><h1 id="2、schema-xml"><a href="#2、schema-xml" class="headerlink" title="2、schema.xml"></a>2、schema.xml</h1><p>该文件是MyCat中重要的配置文件之一，管理着MyCat的逻辑库、表、分片规则、DataNode以及DataSource</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;</span><br><span class="line">&lt;mycat:schema xmlns:mycat&#x3D;&quot;http:&#x2F;&#x2F;org.opencloudb&#x2F;&quot;&gt;</span><br><span class="line">&lt;!-- 逻辑库配置，与server.xml中的数据库对应 --&gt;</span><br><span class="line">    &lt;schema name&#x3D;&quot;e3mall&quot; checkSQLschema&#x3D;&quot;false&quot; sqlMaxLimit&#x3D;&quot;100&quot;&gt;</span><br><span class="line">        &lt;table name&#x3D;&quot;tb_item&quot; dataNode&#x3D;&quot;dn1,dn2,dn3&quot; rule&#x3D;&quot;auto-sharding-long&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;schema&gt;</span><br><span class="line">    &lt;!-- 分片配置 --&gt;</span><br><span class="line">    &lt;dataNode name&#x3D;&quot;dn1&quot; dataHost&#x3D;&quot;localhost1&quot; database&#x3D;&quot;db1&quot; &#x2F;&gt;</span><br><span class="line">    &lt;dataNode name&#x3D;&quot;dn2&quot; dataHost&#x3D;&quot;localhost1&quot; database&#x3D;&quot;db2&quot; &#x2F;&gt;</span><br><span class="line">    &lt;dataNode name&#x3D;&quot;dn3&quot; dataHost&#x3D;&quot;localhost1&quot; database&#x3D;&quot;db3&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- 物理数据库配置 --&gt;</span><br><span class="line">    &lt;dataHost name&#x3D;&quot;localhost1&quot; maxCon&#x3D;&quot;1000&quot; minCon&#x3D;&quot;10&quot; balance&#x3D;&quot;0&quot;</span><br><span class="line">        writeType&#x3D;&quot;0&quot; dbType&#x3D;&quot;mysql&quot; dbDriver&#x3D;&quot;native&quot; switchType&#x3D;&quot;1&quot;  slaveThreshold&#x3D;&quot;100&quot;&gt;</span><br><span class="line">        &lt;heartbeat&gt;select user()&lt;&#x2F;heartbeat&gt;</span><br><span class="line">        &lt;writeHost host&#x3D;&quot;hostM1&quot; url&#x3D;&quot;192.168.20.216:3306&quot; user&#x3D;&quot;root&quot;</span><br><span class="line">            password&#x3D;&quot;root&quot;&gt;</span><br><span class="line">        &lt;&#x2F;writeHost&gt;</span><br><span class="line">    &lt;&#x2F;dataHost&gt;</span><br><span class="line">&lt;&#x2F;mycat:schema&gt;</span><br></pre></td></tr></table></figure><h5 id="schema标签："><a href="#schema标签：" class="headerlink" title="schema标签："></a>schema标签：</h5><p>定义mycat实例中的逻辑库 </p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>逻辑数据库名，与server.xml中的schema对应</td></tr><tr><td>checkSQLschema</td><td>数据库前缀相关设置，建议看文档，这里暂时设为folse</td></tr><tr><td>sqlMaxLimit</td><td>select 时默认的limit，避免查询全表</td></tr></tbody></table><h5 id="table标签："><a href="#table标签：" class="headerlink" title="table标签："></a>table标签：</h5><p>定义mycat实例中的逻辑表<br>属性 | 说明<br>—|—<br>name |表名，物理数据库中表名<br>dataNode |表存储到哪些节点，多个节点用逗号分隔。节点为下文dataNode设置的name<br>primaryKey |     主键字段名，自动生成主键时需要设置<br>autoIncrement | 是否自增<br>rule |     分片规则名</p><h5 id="dataNode标签："><a href="#dataNode标签：" class="headerlink" title="dataNode标签："></a>dataNode标签：</h5><p>定义mycat中的数据节点，也是通常说的数据分片<br>属性 | 说明<br>—|—<br>name | 节点名，与table中dataNode对应<br>datahost |物理数据库名，与datahost中name对应<br>database | 物理数据库中数据库名</p><h5 id="dataHost标签："><a href="#dataHost标签：" class="headerlink" title="dataHost标签："></a>dataHost标签：</h5><p>作为最底层标签存在，定义了具体的真正存放数据的数据库实例，读写分离配置和心跳语句，我这只用来一台主键，所以只配了一个dataHost，如果你配了N个主机，就要配N个dataHost节点<br>属性 | 说明<br>—|—<br>name | 物理数据库名，与dataNode中dataHost对应<br>maxCon | 指定每个读写实例连接池的最大连接。<br>minCon | 指定每个读写实例连接池的最小连接，初始化连接池的大小<br>balance | 均衡负载的方式<br>writeType | 写入方式<br>dbType | 数据库类型<br>heartbeat | 心跳检测语句，注意语句结尾的分号要加。</p><h1 id="3、server-xml"><a href="#3、server-xml" class="headerlink" title="3、server.xml"></a>3、server.xml</h1><p>Mycat的配置文件，设置账号、参数等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE mycat:server SYSTEM &quot;server.dtd&quot;&gt;</span><br><span class="line">&lt;mycat:server xmlns:mycat&#x3D;&quot;http:&#x2F;&#x2F;org.opencloudb&#x2F;&quot;&gt;</span><br><span class="line">      &lt;!-- system标签：内嵌的所有property标签都与系统配置有关 --&gt;</span><br><span class="line">    &lt;system&gt;</span><br><span class="line">    &lt;!--defaultSqlParser：指定默认的解析器(如解析sql)，目前的可用的取值有：druidparser和 fdbparser。使用的时候可以选择其中的一种，目前一般都使用druidparser--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;defaultSqlParser&quot;&gt;druidparser&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;system&gt;</span><br><span class="line">    &lt;!--name：逻辑用户名，即登录mycat的用户名 可配多个user节点--&gt;</span><br><span class="line">    &lt;user name&#x3D;&quot;user&quot;&gt;</span><br><span class="line">         &lt;!--   password：逻辑密码，即登录mycat的用户名对应的密码 --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;password&quot;&gt;user&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;!-- schemas：逻辑数据库，可配置多个，用英文逗号隔开，对应于schema.xml文件中配置的逻辑数据库，两者对应 --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;schemas&quot;&gt;e3mall&lt;&#x2F;property&gt;</span><br><span class="line">       &lt;!-- readOnly：该数据库是否为只读，如果true就是只读--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;readOnly&quot;&gt;false&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;user&gt;</span><br><span class="line">&lt;&#x2F;mycat:server&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyCat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mycat配置文件详解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cypher</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/5%E3%80%81%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/Neo4j/6%E3%80%81Cypher/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/5%E3%80%81%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/Neo4j/6%E3%80%81Cypher/</url>
      
        <content type="html"><![CDATA[<h2 id="1、CREATE”命令"><a href="#1、CREATE”命令" class="headerlink" title="1、CREATE”命令"></a>1、CREATE”命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE (</span><br><span class="line">   &lt;node-name&gt;:&lt;label-name&gt;</span><br><span class="line">   &#123; </span><br><span class="line">      &lt;Property1-name&gt;:&lt;Property1-Value&gt;</span><br><span class="line">      ........</span><br><span class="line">      &lt;Propertyn-name&gt;:&lt;Propertyn-Value&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line">#示例：</span><br><span class="line">CREATE (dept:Dept &#123; deptno:10,dname:&quot;Accounting&quot;,location:&quot;Hyderabad&quot; &#125;)</span><br></pre></td></tr></table></figure><p>创建多个标签到节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE (&lt;node-name&gt;:&lt;label-name1&gt;:&lt;label-name2&gt;.....:&lt;label-namen&gt;)</span><br><span class="line"></span><br><span class="line">#示例：</span><br><span class="line">CREATE (m:Movie:Cinema:Film:Picture)</span><br></pre></td></tr></table></figure><p>批量创建节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#示例：</span><br><span class="line"></span><br><span class="line">UNWIND [&#123;name:&quot;李四&quot;&#125;,&#123;name:&quot;张三&quot;&#125;] AS mynodes</span><br><span class="line">CREATE (n) SET n &#x3D; mynodes</span><br></pre></td></tr></table></figure><h2 id="2、MATCH-amp-RETURN"><a href="#2、MATCH-amp-RETURN" class="headerlink" title="2、MATCH &amp;  RETURN"></a>2、MATCH &amp;  RETURN</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从数据库获取有关节点和属性的数据</span><br><span class="line"></span><br><span class="line">从数据库获取有关节点，关系和属性的数据</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">MATCH </span><br><span class="line">(</span><br><span class="line">   &lt;node-name&gt;:&lt;label-name&gt;</span><br><span class="line">)</span><br><span class="line">RETURN </span><br><span class="line">   &lt;node-name&gt;.&lt;property1-name&gt;,</span><br><span class="line">   ........</span><br><span class="line">   &lt;node-name&gt;.&lt;propertyn-name&gt;</span><br><span class="line">   </span><br><span class="line">#示例：</span><br><span class="line">MATCH (dept: Dept)</span><br><span class="line">RETURN dept.deptno,dept.dname,dept.location</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MATCH (dept: Dept)</span><br><span class="line">RETURN dept</span><br></pre></td></tr></table></figure><p>查询所有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match(n) return n</span><br></pre></td></tr></table></figure><h2 id="3、创建关系："><a href="#3、创建关系：" class="headerlink" title="3、创建关系："></a>3、创建关系：</h2><p>使用新节点创建关系</p><p>根据属性图模型，关系应该是定向的。 否则，Neo4j将抛出一个错误消息。<br>关系分：</p><p>单向关系：上司与下属</p><p>双向关系：朋友</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE (e:Employee)-[r:DemoRelation]-&gt;(c:Employee)</span><br><span class="line"></span><br><span class="line">#这句会创建节点e，节点c，以及e -&gt; c的关系r，这里需要注意方向，比如双向是</span><br><span class="line"></span><br><span class="line">CREATE (e:Employee)&lt;-[r:DemoRelation]-&gt;(c:Employee)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用已知节点创建带属性的关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MATCH (&lt;node1-label-name&gt;:&lt;node1-name&gt;),(&lt;node2-label-name&gt;:&lt;node2-name&gt;)</span><br><span class="line">CREATE  </span><br><span class="line">    (&lt;node1-label-name&gt;)-[&lt;relationship-label-name&gt;:&lt;relationship-name&gt;</span><br><span class="line">    &#123;&lt;define-properties-list&gt;&#125;]-&gt;(&lt;node2-label-name&gt;)</span><br><span class="line">RETURN &lt;relationship-label-name&gt;</span><br><span class="line"></span><br><span class="line">#示例：</span><br><span class="line"></span><br><span class="line">MATCH (cust:Customer),(cc:CreditCard) </span><br><span class="line">CREATE (cust)-[r:DO_SHOPPING_WITH&#123;shopdate:&quot;12&#x2F;12&#x2F;2014&quot;,price:55000&#125;]-&gt;(cc) </span><br><span class="line">RETURN r</span><br></pre></td></tr></table></figure><p> 新节点+新关系+无属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE  </span><br><span class="line">   (&lt;node1-label-name&gt;:&lt;node1-name&gt;)-</span><br><span class="line">   [&lt;relationship-label-name&gt;:&lt;relationship-name&gt;]-&gt;</span><br><span class="line">   (&lt;node1-label-name&gt;:&lt;node1-name&gt;)</span><br><span class="line">RETURN &lt;relationship-label-name&gt;</span><br></pre></td></tr></table></figure><p>新的节点+新的关系，有属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE  </span><br><span class="line">(&lt;node1-label-name&gt;:&lt;node1-name&gt;&#123;&lt;define-properties-list&gt;&#125;)-</span><br><span class="line">[&lt;relationship-label-name&gt;:&lt;relationship-name&gt;&#123;&lt;define-properties-list&gt;&#125;]</span><br><span class="line">-&gt;(&lt;node1-label-name&gt;:&lt;node1-name&gt;&#123;&lt;define-properties-list&gt;&#125;)</span><br><span class="line">RETURN &lt;relationship-label-name&gt;</span><br><span class="line">#RETURN子句是可选的。 如果我们想立即看到结果，那么使用它。 否则，我们可以省略这个子句。</span><br></pre></td></tr></table></figure><p>现有节点+新的关系，无属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MATCH (&lt;node1-label-name&gt;:&lt;node1-name&gt;),(&lt;node2-label-name&gt;:&lt;node2-name&gt;)</span><br><span class="line">CREATE  </span><br><span class="line">(&lt;node1-label-name&gt;)-[&lt;relationship-label-name&gt;:&lt;relationship-name&gt;]-&gt;(&lt;node2-label-name&gt;)</span><br><span class="line">RETURN &lt;relationship-label-name&gt;</span><br><span class="line">#RETURN子句是可选的。 如果我们想立即看到结果，那么使用它。 否则，我们可以省略这个子句。</span><br></pre></td></tr></table></figure><p>创建节点的同时创建关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE (TheMatrix:Movie &#123;title:&#39;The Matrix&#39;, released:1999, tagline:&#39;Welcome to the Real World&#39;&#125;)</span><br><span class="line">CREATE (Keanu:Person &#123;name:&#39;Keanu Reeves&#39;, born:1964&#125;)</span><br><span class="line">CREATE (Carrie:Person &#123;name:&#39;Carrie-Anne Moss&#39;, born:1967&#125;)</span><br><span class="line">CREATE (Laurence:Person &#123;name:&#39;Laurence Fishburne&#39;, born:1961&#125;)</span><br><span class="line">CREATE (Hugo:Person &#123;name:&#39;Hugo Weaving&#39;, born:1960&#125;)</span><br><span class="line">CREATE (LillyW:Person &#123;name:&#39;Lilly Wachowski&#39;, born:1967&#125;)</span><br><span class="line">CREATE (LanaW:Person &#123;name:&#39;Lana Wachowski&#39;, born:1965&#125;)</span><br><span class="line">CREATE (JoelS:Person &#123;name:&#39;Joel Silver&#39;, born:1952&#125;)</span><br><span class="line">CREATE</span><br><span class="line">  (Keanu)-[:ACTED_IN &#123;roles:[&#39;Neo&#39;]&#125;]-&gt;(TheMatrix),</span><br><span class="line">  (Carrie)-[:ACTED_IN &#123;roles:[&#39;Trinity&#39;]&#125;]-&gt;(TheMatrix),</span><br><span class="line">  (Laurence)-[:ACTED_IN &#123;roles:[&#39;Morpheus&#39;]&#125;]-&gt;(TheMatrix),</span><br><span class="line">  (Hugo)-[:ACTED_IN &#123;roles:[&#39;Agent Smith&#39;]&#125;]-&gt;(TheMatrix),</span><br><span class="line">  (LillyW)-[:DIRECTED]-&gt;(TheMatrix),</span><br><span class="line">  (LanaW)-[:DIRECTED]-&gt;(TheMatrix),</span><br><span class="line">  (JoelS)-[:PRODUCED]-&gt;(TheMatrix)</span><br><span class="line"></span><br><span class="line">CREATE (Emil:Person &#123;name:&quot;Emil Eifrem&quot;, born:1978&#125;)</span><br><span class="line">CREATE (Emil)-[:ACTED_IN &#123;roles:[&quot;Emil&quot;]&#125;]-&gt;(TheMatrix)</span><br></pre></td></tr></table></figure><p>删除：delete   remove</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE &lt;node-name-list&gt;</span><br><span class="line"></span><br><span class="line">MATCH (e: &#39;Employee&#39;) DELETE e </span><br></pre></td></tr></table></figure><p>Neo4j CQL DELETE和REMOVE命令之间的主要区别 - </p><p>1、DELETE操作用于删除节点和关联关系。</p><p>2、REMOVE操作用于删除标签和属性。</p><p>where</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match(user:User) where user.name&#x3D;&quot;zhangsan&quot; remove user.age</span><br></pre></td></tr></table></figure><p>删除所有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH (n)</span><br><span class="line">OPTIONAL MATCH (n)-[r]-()</span><br><span class="line">DELETE n,r</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>set</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match(user:User) where user.name&#x3D;&quot;zhangsan&quot; set user.sex&#x3D;&quot;nan&quot;</span><br></pre></td></tr></table></figure><p>order by</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (emp:Employee)</span><br><span class="line">RETURN emp.empid,emp.name,emp.salary,emp.deptno</span><br><span class="line">ORDER BY emp.name</span><br></pre></td></tr></table></figure><p>UNION</p>]]></content>
      
      
      <categories>
          
          <category> Neo4j </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cypher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/7%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/7%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。</p><p>　</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(Iterator it&#x3D; list.iterator(); it.hasNext(); )&#123;</span><br><span class="line">   String str &#x3D; (String) it.next();</span><br><span class="line">   System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Iterator接口定义了如下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean hasNext();    判断是否有元素没有被遍历</span><br><span class="line">Object next();    返回游标当前位置的元素，并将游标移动到下一个位置</span><br><span class="line">void remove();    删除游标左面的元素（刚刚遍历完的那个元素），在执行完next之后该操作只能执行一次</span><br></pre></td></tr></table></figure><h4 id="2、内部原理"><a href="#2、内部原理" class="headerlink" title="2、内部原理"></a>2、内部原理</h4><p>ArrayList LinkendList HashSet TreeSet中都有一个内部类实现了Iterator接口</p><p>hasNext()、next()、remove()是在这个内部类里面重写的</p><h4 id="modCount"><a href="#modCount" class="headerlink" title="modCount:"></a>modCount:</h4><p>该字段表示list结构上被修改的次数。结构上的修改指的是那些改变了list的长度大小或者使得遍历过程中产生不正确的结果的其它方式。<br>该字段被Iterator以及ListIterator的实现类所使用，如果该值被意外更改，Iterator或者ListIterator 将抛出ConcurrentModificationException异常，<br>这是jdk在面对迭代遍历的时候为了避免不确定性而采取的快速失败原则。</p><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">       &#x2F;&#x2F;计数器--&gt;指针 游标</span><br><span class="line">        int cursor; </span><br><span class="line">        int lastRet &#x3D; -1; </span><br><span class="line">        int expectedModCount &#x3D; modCount;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return cursor !&#x3D; size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public E next() &#123;</span><br><span class="line">            &#x2F;&#x2F;检查modCount !&#x3D; expectedModCount 快速失败机制</span><br><span class="line">            checkForComodification();</span><br><span class="line">            int i &#x3D; cursor;</span><br><span class="line">            if (i &gt;&#x3D; size)</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            Object[] elementData &#x3D; ArrayList.this.elementData;</span><br><span class="line">            if (i &gt;&#x3D; elementData.length)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            cursor &#x3D; i + 1;</span><br><span class="line">            return (E) elementData[lastRet &#x3D; i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            if (lastRet &lt; 0)</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                ArrayList.this.remove(lastRet);</span><br><span class="line">                cursor &#x3D; lastRet;</span><br><span class="line">                lastRet &#x3D; -1;</span><br><span class="line">                expectedModCount &#x3D; modCount;</span><br><span class="line">            &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123;</span><br><span class="line">            Objects.requireNonNull(consumer);</span><br><span class="line">            final int size &#x3D; ArrayList.this.size;</span><br><span class="line">            int i &#x3D; cursor;</span><br><span class="line">            if (i &gt;&#x3D; size) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            final Object[] elementData &#x3D; ArrayList.this.elementData;</span><br><span class="line">            if (i &gt;&#x3D; elementData.length) &#123;</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            while (i !&#x3D; size &amp;&amp; modCount &#x3D;&#x3D; expectedModCount) &#123;</span><br><span class="line">                consumer.accept((E) elementData[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; update once at end of iteration to reduce heap write traffic</span><br><span class="line">            cursor &#x3D; i;</span><br><span class="line">            lastRet &#x3D; i - 1;</span><br><span class="line">            checkForComodification();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final void checkForComodification() &#123;</span><br><span class="line">            if (modCount !&#x3D; expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    boolean hasNext();</span><br><span class="line"></span><br><span class="line">    E next();</span><br><span class="line"></span><br><span class="line">    boolean hasPrevious();</span><br><span class="line"></span><br><span class="line">    E previous();</span><br><span class="line"></span><br><span class="line">    int nextIndex();</span><br><span class="line"></span><br><span class="line">    int previousIndex();</span><br><span class="line"></span><br><span class="line">    void remove();</span><br><span class="line"></span><br><span class="line">    void set(E e);</span><br><span class="line"></span><br><span class="line">    void add(E e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="和ListIterator主要区别在以下方面："><a href="#和ListIterator主要区别在以下方面：" class="headerlink" title="和ListIterator主要区别在以下方面："></a>和ListIterator主要区别在以下方面：</h4><ul><li><p>　1. iterator()方法在set和list接口中都有定义，但是ListIterator（）仅存在于list接口中（或实现类中）；</p></li><li><p>　　2. ListIterator有add()方法，可以向List中添加对象，而Iterator不能</p></li><li><p>　　3. ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。</p></li><li><p>　　4. ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。</p></li><li><p>　　5. 都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。　　</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迭代器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clone</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/4%E3%80%81Object%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/3%E3%80%81clone/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/4%E3%80%81Object%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/3%E3%80%81clone/</url>
      
        <content type="html"><![CDATA[<p>==一个类要想实现克隆，需要实现Cloneable接口，表明这个类的对象具有克隆的功能。==</p><p>类似的接口有Serializable接口，表明该类的对象可以序列化功能。</p><p>clone()方法的通用约束如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x.clone() !&#x3D; x        </span><br><span class="line">&#x2F;&#x2F;应该返回true</span><br><span class="line">x.clone().getClass() &#x3D;&#x3D; x.getClass()</span><br><span class="line">&#x2F;&#x2F;应该返回true</span><br><span class="line">x.clone().equals(x)           </span><br><span class="line">&#x2F;&#x2F;应该返回true</span><br></pre></td></tr></table></figure><h1 id="一：浅拷贝"><a href="#一：浅拷贝" class="headerlink" title="一：浅拷贝:"></a>一：浅拷贝:</h1><p>1、对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。</p><p>2、对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</p><p>浅拷贝实现方式：clone()方法只调用super.clone()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class CloneTest implements Cloneable &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二：深拷贝："><a href="#二：深拷贝：" class="headerlink" title="二：深拷贝："></a>二：深拷贝：</h1><p>深拷贝对引用数据类型的成员变量的对象图中所有的对象都开辟了内存空间；而浅拷贝只是传递地址指向，新的对象并没有对引用数据类型创建内存空间。克隆的对象与原对象均独立，改变一个，另一个饿对象不受影响</p><h4 id="深拷贝实现方式1："><a href="#深拷贝实现方式1：" class="headerlink" title="深拷贝实现方式1："></a>深拷贝实现方式1：</h4><p>重写clone 对每一层的每个对象都进行浅拷贝</p><p>与通过重写clone方法实现浅拷贝的基本思路一样，只需要为对象图的每一层的每一个对象都实现Cloneable接口并重写clone方法，最后在最顶层的类的重写的clone方法中调用所有的clone方法即可实现深拷贝。简单的说就是：每一层的每个对象都进行浅拷贝就相当于深拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Age implements Cloneable&#123;</span><br><span class="line">    &#x2F;&#x2F;年龄类的成员变量（属性）</span><br><span class="line">    private int age;</span><br><span class="line">    &#x2F;&#x2F;get set方法</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;重写Object的clone方法</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        Object obj&#x3D;null;</span><br><span class="line">        try &#123;</span><br><span class="line">            obj&#x3D;super.clone();</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Student implements Cloneable&#123;</span><br><span class="line">    &#x2F;&#x2F;学生类的成员变量（属性）,其中一个属性为类的对象</span><br><span class="line">    private Age aage;</span><br><span class="line">    private int length;</span><br><span class="line">    &#x2F;&#x2F;get set 方法</span><br><span class="line">    &#x2F;&#x2F;重写Object类的clone方法</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        Object obj&#x3D;null;</span><br><span class="line">        &#x2F;&#x2F;调用Object类的clone方法——浅拷贝</span><br><span class="line">        try &#123;</span><br><span class="line">            obj&#x3D; super.clone();</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;调用Age类的clone方法进行深拷贝</span><br><span class="line">        &#x2F;&#x2F;先将obj转化为学生类实例</span><br><span class="line">        Student stu&#x3D;(Student)obj;</span><br><span class="line">        &#x2F;&#x2F;学生类实例的Age对象属性，调用其clone方法进行拷贝</span><br><span class="line">        stu.aage&#x3D;(Age)stu.getaAge().clone();</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深拷贝实现方式2：通过对象序列化实现深拷贝"><a href="#深拷贝实现方式2：通过对象序列化实现深拷贝" class="headerlink" title="深拷贝实现方式2：通过对象序列化实现深拷贝"></a>深拷贝实现方式2：通过对象序列化实现深拷贝</h4><p>虽然层次调用clone方法可以实现深拷贝，但是显然层级过深则代码量实在太大。</p><p>将对象序列化为字节序列后，默认会将该对象的整个对象都进行序列化，再通过反序列即可完美地实现深拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">class Age implements Serializable&#123;</span><br><span class="line">    &#x2F;&#x2F;年龄类的成员变量（属性）</span><br><span class="line">    private int age;</span><br><span class="line">    &#x2F;&#x2F;get set方法</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 创建学生类</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Student implements Serializable&#123;</span><br><span class="line">    &#x2F;&#x2F;学生类的成员变量（属性）,其中一个属性为类的对象</span><br><span class="line">    private String name;</span><br><span class="line">    private Age aage;</span><br><span class="line">    private int length;</span><br><span class="line">    &#x2F;&#x2F;get set方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 通过序列化实现深拷贝 *&#x2F;</span><br><span class="line">Age a&#x3D;new Age(20);</span><br><span class="line">Student stu1&#x3D;new Student(&quot;摇头耶稣&quot;,a,175);</span><br><span class="line">&#x2F;&#x2F;通过序列化方法实现深拷贝</span><br><span class="line">ByteArrayOutputStream bos&#x3D;new ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream oos&#x3D;new ObjectOutputStream(bos);</span><br><span class="line">oos.writeObject(stu1);</span><br><span class="line">oos.flush();</span><br><span class="line">ObjectInputStream ois&#x3D;new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));</span><br><span class="line">Student stu2&#x3D;(Student)ois.readObject();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Object中的方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> clone </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指令重排</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/3%E3%80%81%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/3%E3%80%81%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<ul><li>缓存导致的可见性问题</li><li>线程切换带来的原子性问题，</li><li>指令重排带来的有序性问题。</li></ul><p>编译器为了优化性能，在不影响最终结果的基础上，有时候会改变程序中语句的先后顺序，例如程序中：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”指令重排并发下的==有序性问题==：</p><p>重排序分3种类型:从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序</p><ul><li>1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句<br>的执行顺序。</li><li>2）处理器的指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level<br>Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应<br>机器指令的执行顺序。</li><li>3）处理器的内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上<br>去可能是在乱序执行。</li></ul><p>示例:单例模式</p><p>非线程安全的单例模式：当两个线程都进入if (instance == null)下一步时，便会创建两个对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  private Singleton()&#123;&#125;</span><br><span class="line">  private static Singleton instance;</span><br><span class="line">  public static  Singleton getInstance()&#123;</span><br><span class="line">        if (instance &#x3D;&#x3D; null)</span><br><span class="line">          instance &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用同步加锁的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  private Singleton()&#123;&#125;</span><br><span class="line">  private static Singleton instance;</span><br><span class="line">  public static  Singleton getInstance()&#123;</span><br><span class="line">        synchronized(Singleton.class)&#123;</span><br><span class="line">            if(singleTon&#x3D;&#x3D;null)&#123;     </span><br><span class="line">             instance &#x3D; new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果getInstance()方法被多个线程频繁的调用，一个线程获取锁，进去创建对象。其他线程将阻塞挂起。导致程序执行性能的下降。</p><p>人们想通过双重检查<br>锁定来降低同步的开销。<br>如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始<br>化操作。因此，可以大幅降低synchronized带来的性能开销</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;双重检测</span><br><span class="line">public class Singleton &#123;</span><br><span class="line">  private Singleton()&#123;&#125;</span><br><span class="line">  private static Singleton instance;</span><br><span class="line">  public static Singleton getInstance()&#123;</span><br><span class="line">        if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">              synchronized(Singleton.class) &#123;</span><br><span class="line">                    if (instance &#x3D;&#x3D; null)</span><br><span class="line">                      instance &#x3D; new Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。</p><p>看似稳的一逼 实际不堪一击。</p><p>instance = new Singleton();操作并不是一个原子性指令，会被分为多个指令：</p><ul><li>分配一块内存 M；</li><li>在内存 M 上初始化 Singleton 对象；</li><li>然后 M 的地址赋值给 instance 变量。</li></ul><p>发生指令重排后：</p><ul><li>分配一块内存 M；</li><li>将 M 的地址赋值给 instance 变量；</li><li>最后在内存 M 上初始化 Singleton 对象。</li></ul><p>所以A线程执行完重排后的第二步，且未执行初始化对象。此时B线程来取instance时，发现instance不为空，于是便直接返回该值，便返回null.</p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>1、基于volatile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  private Singleton()&#123;&#125;</span><br><span class="line">  private volatile static Singleton instance;</span><br><span class="line">  static Singleton getInstance()&#123;</span><br><span class="line">    if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">      synchronized(Singleton.class) &#123;</span><br><span class="line">        if (instance &#x3D;&#x3D; null)</span><br><span class="line">          instance &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile禁止指令重排。</p><h3 id="2、基于类的初始化（饿汉式单例模式）"><a href="#2、基于类的初始化（饿汉式单例模式）" class="headerlink" title="2、基于类的初始化（饿汉式单例模式）"></a>2、基于类的初始化（饿汉式单例模式）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton instance &#x3D; new Singleton();</span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">    return Singleton.instance ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==instance = new Singleton();一样会指令重排，但对于<br>非构造线程是不可见的。==</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指令重排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库双写一致性</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="3、数据库与缓存双写不一致问题"><a href="#3、数据库与缓存双写不一致问题" class="headerlink" title="3、数据库与缓存双写不一致问题"></a>3、数据库与缓存双写不一致问题</h3><p>先更新数据库，再更新缓存</p><p>若数据库更新成功缓存更新失败，则此后读到的都是缓存中过期的数据，造成不一致问题。当两个写线程发生冲突时，可以通过比较数据版本方式避免线程A写入旧的数据。 </p><p>先更新缓存，再更新数据库。</p><p>缓存更新成功数据库更新失败 则此后读到的都是未持久化的数据。因为缓存中的数据是易失的，这种状态非常危险。<br>因为数据库因为键约束导致写入失败的可能性较高，所以这种策略风险较大。</p><p>先更新数据库，再删除缓存。</p><p>若数据库更新成功，删除缓存操作失败，则此后读到的都是缓存中过期的数据，造成不一致问题。</p><p>先删除缓存，再更新数据库<br>并发请求的时候，数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。另一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中。（脏读）</p><ul><li>方案</li></ul><p>数据库与缓存更新与读取操作进行异步串行化。（引入队列）：</p><p>(1)更新数据的时候，将相应操作发送到一个jvm内部的队列中；</p><p>(2)读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据的操作也发送到同一个jvm内部的队列中。</p><p>(3)队列消费者串行拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先执行删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p><p>这里有两个可以优化的点：</p><p>一个队列中，其实多个读缓存，更新缓存的请求串在一起是没意义的，而且如果读同一缓存的大量请求到来时，会依次进入队列等待，这样会导致队列最后一个的请求响应时间超时。</p><p>因此可以做过滤，如果发现队列中已经有一个读缓存，更新缓存的请求了，那么就不用再放个新请求操作进去了，直接等待前面的更新操作请求完成即可。如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回; 如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</p><p>如果请求量特别大的时候，可以用多个队列，每个队列对应一个线程。每个请求来时可以根据请求的标识id进行hash路由进入到不同的队列。</p><p>最后，一定要做根据实际业务系统的运行情况，去进行一些压力测试，和模拟线上环境，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求，会hang多少时间，如果读请求在200ms返回，如果你计算过后，哪怕是最繁忙的时候，积压10个更新操作，最多等待200ms，那还可以的。如果一个内存队列可能积压的更新操作特别多，那么你就要加机器，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少。其实根据之前的项目经验，一般来说数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的。</p><p>举个例子：一秒就100个写操作。单台机器，20个内存队列，每个内存队列，可能就积压5个写操作，每个写操作性能测试后，一般在20ms左右就完成，那么针对每个内存队列中的数据的读请求，也就最多hang一会儿，200ms以内肯定能返回了。如果把写QPS扩大10倍，但是经过刚才的测算，就知道，单机支撑写QPS几百没问题，那么就扩容机器，扩容10倍的机器，10台机器，每个机器20个队列，200个队列。大部分的情况下，应该是这样的，大量的读请求过来，都是直接走缓存取到数据的，少量情况下，可能遇到读跟数据更新冲突的情况，如上所述，那么此时更新操作如果先入队列，之后可能会瞬间来了对这个数据大量的读请求，但是因为做了去重的优化，所以也就一个更新缓存的操作跟在它后面。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库双写一致性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表练习</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2%E3%80%81%E9%93%BE%E8%A1%A8/7%E3%80%81%E9%93%BE%E8%A1%A8%E7%BB%83%E4%B9%A0/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2%E3%80%81%E9%93%BE%E8%A1%A8/7%E3%80%81%E9%93%BE%E8%A1%A8%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="单链表反转"><a href="#单链表反转" class="headerlink" title="单链表反转"></a>单链表反转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Node reverse(Node head) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null)</span><br><span class="line">        return head;</span><br><span class="line">    Node temp &#x3D; head.next;</span><br><span class="line">    Node newHead &#x3D; reverse(head.next);</span><br><span class="line">    temp.next &#x3D; head;</span><br><span class="line">    head.next &#x3D; null;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序到达Node newHead = reverse(head.next);时进入递归</li><li>我们假设此时递归到了3结点，此时head=3结点，temp=3结点.next(实际上是4结点)</li><li>执行Node newHead = reverse(head.next);传入的head.next是4结点，返回的newHead是4结点。</li><li>接下来就是弹栈过程了</li></ul><ol><li>程序继续执行 temp.next = head就相当于4-&gt;3</li><li>head.next = null 即把3结点指向4结点的指针断掉。</li><li>返回新链表的头结点newHead</li></ol><p>注意：当retuen后，系统会恢复2结点压栈时的现场，此时的head=2结点；temp=2结点.next(3结点)，再进行上述的操作。最后完成整个链表的翻转。</p><h3 id="链表中环的检测"><a href="#链表中环的检测" class="headerlink" title="链表中环的检测"></a>链表中环的检测</h3><p>利用快、慢指针解法。慢指针，一次遍历一个节点。快指针，一次遍历两个节点。如果在某一次遍历中相遇。则检测到环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static boolean hasLoopV1(Node headNode) &#123;</span><br><span class="line">    </span><br><span class="line">    if(headNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node p &#x3D; headNode;</span><br><span class="line">    Node q &#x3D; headNode.next;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 快指针未能遍历完所有节点</span><br><span class="line">    while (q !&#x3D; null &amp;&amp; q.next !&#x3D; null) &#123;</span><br><span class="line">        p &#x3D; p.next; &#x2F;&#x2F; 遍历一个节点</span><br><span class="line">        q &#x3D; q.next.next; &#x2F;&#x2F; 遍历两个个节点</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 已到链表末尾</span><br><span class="line">        if (q &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else if (p &#x3D;&#x3D; q) &#123;</span><br><span class="line">            &#x2F;&#x2F; 快慢指针相遇，存在环</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个有序的链表合并"><a href="#两个有序的链表合并" class="headerlink" title="两个有序的链表合并"></a>两个有序的链表合并</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> public static Node mergeTwoList(Node head1, Node head2) &#123;</span><br><span class="line">&#x2F;&#x2F;递归结束条件</span><br><span class="line">       if (head1 &#x3D;&#x3D; null &amp;&amp; head2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return null;</span><br><span class="line">       &#125;</span><br><span class="line">if (head1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return head2;</span><br><span class="line">       &#125;</span><br><span class="line">if (head2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return head1;</span><br><span class="line">       &#125;</span><br><span class="line">&#x2F;&#x2F;合并后的链表</span><br><span class="line">       Node head &#x3D; null;</span><br><span class="line">       if (head1.data &gt; head2.data) &#123;</span><br><span class="line">    &#x2F;&#x2F;把head较小的结点给头结点</span><br><span class="line">           head &#x3D; head2;</span><br><span class="line">           &#x2F;&#x2F;继续递归head2</span><br><span class="line">           head.next &#x3D; mergeTwoList(head1, head2.next);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">    head &#x3D; head1;</span><br><span class="line">           head.next &#x3D; mergeTwoList(head1.next, head2);</span><br><span class="line">       &#125;</span><br><span class="line">return head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="删除链表倒数第-n-个结点"><a href="#删除链表倒数第-n-个结点" class="headerlink" title="删除链表倒数第 n 个结点"></a>删除链表倒数第 n 个结点</h3><p>利用快、慢指针解法。让快指针先走N步，再让两个在指针同时后移，直到快指针到达尾部，此时，慢指针的下一个节点就是要被删除的节点了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public Node removeNthFromEnd(Node head, int n) &#123;</span><br><span class="line"></span><br><span class="line">    Node preNode &#x3D; head;</span><br><span class="line">    Node curNode &#x3D; head;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        curNode &#x3D; curNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (curNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return preNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while (curNode.next !&#x3D; null) &#123;</span><br><span class="line">        preNode &#x3D; preNode.next;</span><br><span class="line">        curNode &#x3D; curNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    preNode.next &#x3D; preNode.next.next;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求链表的中间结点"><a href="#求链表的中间结点" class="headerlink" title="求链表的中间结点"></a>求链表的中间结点</h3><p>利用快、慢指针解法。慢指针一次遍历一个节点，快指针一次遍历两个节点，由于快指针的速度是慢指针的两倍，所以当快指针遍历完链表时，慢指针所处的节点就是链表的中间节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static Node middleNode(Node head) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node slow &#x3D; head;</span><br><span class="line">    Node fast &#x3D; head.next;</span><br><span class="line">    while (fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null) &#123;</span><br><span class="line">        slow &#x3D; slow.next;</span><br><span class="line">        fast &#x3D; fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return fast &#x3D;&#x3D; null ? slow : slow.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从尾到头打印链表-不改变链表结构，就是不反转链表"><a href="#从尾到头打印链表-不改变链表结构，就是不反转链表" class="headerlink" title="从尾到头打印链表(不改变链表结构，就是不反转链表)"></a>从尾到头打印链表(不改变链表结构，就是不反转链表)</h3><p>从头到尾打印链表，所谓的“后进先出”，这时候就可以联想到栈这个数据结构。但是会开辟新的内存空间。想到栈就要想到递归</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;       </span><br><span class="line">        FromTailToHead(listNode);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">     public void FromTailToHead(ListNode listNode)&#123;</span><br><span class="line">        if(listNode!&#x3D;null)&#123;</span><br><span class="line">            FromTailToHead(listNode.next);</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">        &#125;      </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主从配置</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%9E%B6%E6%9E%84/%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%9E%B6%E6%9E%84/%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>mysql的安装：<a href="https://blog.csdn.net/shawnhu007/article/details/52651596">https://blog.csdn.net/shawnhu007/article/details/52651596</a></p><p><a href="https://www.jianshu.com/p/276d59cbc529">https://www.jianshu.com/p/276d59cbc529</a></p><p>14、主从配置</p><h3 id="【Mysql主服务器配置】"><a href="#【Mysql主服务器配置】" class="headerlink" title="【Mysql主服务器配置】"></a>【Mysql主服务器配置】</h3><p>第一步：修改my.cnf文件，在[mysqld]节点下添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 同步的数据库名</span><br><span class="line">binlog-do-db&#x3D;db1</span><br><span class="line">#如果同步多个库一定是分开写 如再加一行binlog-do-db&#x3D;db2</span><br><span class="line">#无需开启二进制日志文件的数据库</span><br><span class="line">binlog-ignore-db&#x3D;mysql</span><br><span class="line">#启用二进制日志</span><br><span class="line">log-bin&#x3D;mysql-bin</span><br><span class="line">#服务器唯一ID，一般取IP最后一段</span><br><span class="line">server-id&#x3D;134</span><br></pre></td></tr></table></figure><p>第二步：重启mysql服务：service mysqld restart </p><p>第三步：建立帐户并授权slave</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建用户</span><br><span class="line">mysql&gt;GRANT FILE ON *.* TO &#39;backup&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">&#x2F;&#x2F;授权用户</span><br><span class="line">&#x2F;&#x2F;“%”表示所有客户端都可能连，只要帐号，密码正确，此处可用具体客户端IP代替192.168.145.226或客户端ip段192.168.145.* 加强安全。</span><br><span class="line">mysql&gt;GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* to &#39;backup&#39;@&#39;%&#39; identified by &#39;123456&#39;; </span><br></pre></td></tr></table></figure><p>第四步：刷新权限：mysql&gt; FLUSH PRIVILEGES; </p><h3 id="【Mysql从服务器配置】"><a href="#【Mysql从服务器配置】" class="headerlink" title="【Mysql从服务器配置】"></a>【Mysql从服务器配置】</h3><p>第一步：修改my.cnf文件，在[mysqld]节点下添加一个唯一的server-id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id&#x3D;191</span><br></pre></td></tr></table></figure><p>第二步：配置从服务器，在从服务器中执行以下命令，关联主服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;change master to master_host&#x3D;&#39;192.168.25.134&#39;,master_port&#x3D;3306,master_user&#x3D;&#39;backup&#39;,master_password&#x3D;&#39;123456&#39;,master_log_file&#x3D;&#39;mysql-bin.000001&#39;,master_log_pos&#x3D;1061</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【注】： </span><br><span class="line">  1、master_host为主服务器的ip地址，带引号 </span><br><span class="line">  2、master_port为mysql主服务器的端口号，不带引号 </span><br><span class="line">  3、master_user为执行同步操作的数据库账号，带引号 </span><br><span class="line">  4、master_password为对应账号密码，带引号 </span><br><span class="line">  5、master_log_file为在主服务器中执行show master status中看到的的file </span><br><span class="line">  6、master_log_pos为在主服务器中执行show master status中看到的的position</span><br></pre></td></tr></table></figure><p>第三步：启动从服务器复制功能Mysql&gt;start slave; 关闭是：Mysql&gt;stop slave; </p><p>  第四步：检查从服务器复制状态mysql&gt; show slave status，在linux中显示如下：</p><h1 id="1、mysql集群（同步复制）："><a href="#1、mysql集群（同步复制）：" class="headerlink" title="1、mysql集群（同步复制）："></a>1、mysql集群（同步复制）：</h1><p>share-nothing,分布式节点架构的存储方案，以便于提供容错性和高性能。</p><p>需要用到mysql cluster安装包，在集群中的每一个机器上安装。</p><h2 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h2><p>a) Master执行提交语句时，事务被发送到slave，slave开始准备事务的提交。 </p><p>b) 每个slave都要准备事务，然后向master发送OK(或ABORT)消息，表明事务已经准备好（或者无法准备该事务）。 </p><p>c) Master等待所有Slave发送OK或ABORT消息，如果Master收到所有 Slave的OK消息，它就会向所有Slave发送提交消息，告诉Slave提交该事务；如果 Master收到来自任何一个Slave的ABORT消息，它就向所有 Slave发送ABORT消息，告诉Slave去中止事务。</p><p>e) 每个Slave等待来自Master的OK或ABORT消息。如果Slave收到提交请求，它们就会提交事务，并向Master发送事务已提交 的确认；如果Slave收到取消请求,它们就会撤销所有改变并释放所占有的资源，从而中止事务，然后向Masterv送事务已中止的确认。</p><p>f) Master收到来自所有Slave的确认后，就会报告该事务被提交（或中止），然后继续进行下一个事务处理。</p><p>集群小结：<br>由于同步复制一共需要4次消息传递，故mysql cluster的数据更新速度比单机mysql要慢。所以mysql cluster要求运行在千兆以上的局域网内，节点可以采用双网卡，节点组之间采用直连方式</p><h1 id="2、主从复制（异步）："><a href="#2、主从复制（异步）：" class="headerlink" title="2、主从复制（异步）："></a>2、主从复制（异步）：</h1><p>主从（Master-Slave）: 主从机器上安装mysql community（普通版）就可以。<br>主从之间是通过mysql的replication来保证数据的一致性。相对mysql cluster的数据同步方式来讲是异步的。 </p><p>Replication：主节点要开启binlog，设置一个唯一的服务器id（局域网内唯一）；从节点设置服务器id，binlog记录了master上的所有操作，会被复制到从节点的relaylog并在从节点<br><img src="WEBRESOURCE75b756fc9d52296c090c0b9fa69a678a" alt="master-alave主从.png"><br>该模式下，容易单点故障，就是当master宕机后，整个数据库的写操作不可用。<br>所以采用dual master<br><img src="WEBRESOURCE93bae9beb8a3b351b40ce15abfaa42a4" alt="lucene与solr的区别.png"></p><p>具体实现步骤见文章：<a href="https://www.cnblogs.com/ygqygq2/p/6045279.html">https://www.cnblogs.com/ygqygq2/p/6045279.html</a></p>]]></content>
      
      
      <categories>
          
          <category> mysql架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主从配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka的partition分区策略</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/4%E3%80%81kafka/4%E3%80%81kafka%E7%9A%84partition%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/4%E3%80%81kafka/4%E3%80%81kafka%E7%9A%84partition%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="分区策略："><a href="#分区策略：" class="headerlink" title="分区策略："></a>分区策略：</h3><p>方便在集群中扩展，每个 Partition 可以通过调整以适应它所在的机器，而一个 topic<br>又可以有多个 Partition 组成，因此整个集群就可以适应任意大小的数据了；</p><p>可以提高并发，因为可以以 Partition 为单位读写了。</p><p>我们需要将 producer 发送的数据封装成一个 ProducerRecord 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord(String topic, Integer partition, K key, V value)</span><br><span class="line"></span><br><span class="line">ProducerRecord(String topic, Integer partition, Long timestamp, K key, V value)</span><br><span class="line"></span><br><span class="line">ProducerRecord(String topic, K key, V value)</span><br><span class="line"></span><br><span class="line">ProducerRecord(String topic, V value)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>（1）指明 partition 的情况下，直接将指明的值直接作为 partiton 值；</li><li>（2）没有指明 partition 值但有 key 的情况下，将 key 的 hash 值与 topic 的 partition<br>数进行取余得到 partition 值；</li><li>（3）既没有 partition 值又没有 key 值的情况下，第一次调用时随机生成一个整数（后<br>面每次调用在这个整数上自增），将这个值与 topic 可用的 partition 总数取余得到 partition<br>值，也就是常说的 round-robin 算法。</li></ul><h3 id="ACK机制-保证生产者数据不丢失"><a href="#ACK机制-保证生产者数据不丢失" class="headerlink" title="ACK机制(保证生产者数据不丢失)"></a>ACK机制(保证生产者数据不丢失)</h3><p>生产者将消息发送到broker,broker需要告诉生产者，消息是否发送成功。未成功，生产者还可以采取重发的机制。因为消息是发送到Partition,而Partition同时有多个副本。副本是需要实时同步消息的。</p><p>所以有两种机制保证数据可靠性。</p><ul><li><p>半数副本以上消息完成同步，就发送ack。延迟低，但选举新的 leader 时，容忍 n 台<br>节点的故障，需要 2n+1 个副本</p></li><li><p>全部副本完成消息同步，才发送ack。虽然延迟高，但<br>选举新的 leader 时，容忍 n 台节点的故障，需要 n+1个副本</p></li></ul><p>Kafka 选择的第二种方案，虽然延迟高，但网络延迟对 Kafka 的影响较小，且为Kafka 的每个分区都有大量的数据，第一种方案会造成大量数据的冗余。</p><h5 id="优化方案：ISR"><a href="#优化方案：ISR" class="headerlink" title="优化方案：ISR"></a>优化方案：ISR</h5><p>leader 收到数据，所有 follower 都开始同步数据，<br>但有一个 follower，因为某种故障，迟迟不能与 leader 进行同步，那 leader 就要一直等下去，<br>直到它完成同步，才能发送 ack。这个问题怎么解决呢？</p><p>Leader 维护了一个动态集合in-sync replica set（和 leader 保持同步的 follower 集合）。通过参数replica.lag.time.max.ms设置时间阈值，当follower在规定时间未完成同步，则将该follower剔出这个集合。</p><p>当某些消息数据，不需要可靠。即生成者不需要ack机制时，对于不需要数据的可靠性时，kafka就没必要等 ISR 中的 follower 全部接收成功，才返回ack.所以 Kafka 为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡，</p><p>acks 参数配置：</p><p>acks：</p><p>0：(只管发)  producer 不等待 broker 的数据落盘就直接返回 ack，当broker故障时有可能丢失数据</p><p>1：（只保证broker数据落盘）producer 等待 broker 的 ack，partition的leader落盘成功后就不等follower同步便直接返回 ack</p><p>如果在 follower同步成功之前leader故障，那么将会丢失数据；</p><p>-1（all）：（保证broker和所有follower数据落盘）producer 等待 broker 的 ack，partition 的 leader 和 follower 全部落盘成功后才<br>返回 ack。</p><p>但是如果在 follower 同步完成后，broker 发送 ack 之前，leader 发生故障，那么会<br>造成数据重复。</p><h3 id="消息幂等性"><a href="#消息幂等性" class="headerlink" title="消息幂等性"></a>消息幂等性</h3><p>kafka0.11版本之前解决消息幂等性，需要在每个消费端手动进行去消息判重（可以使用redis,或者mysql主键特性，将消费后的消息进行存储）</p><p>kafka0.11版本后，borker支持了幂等性。将原来下游消费者需要做的去重放在了数据上游borker中。</p><p>要启用幂等性，只需要将 Producer 的参数中 enable.idompotence 设置为 true 即可</p><p>原理：<br>开启幂等性的 Producer 在初始化的时候会被分配一个 PID，发往同一 Partition 的消息会附带 Sequence Number。而Broker 端会对&lt;PID, Partition, SeqNumber&gt;做缓存，当具有相同主键的消息提交时，Broker 只会持久化一条。但是 PID 重启就会变化，同时不同的 Partition 也具有不同主键，所以broker解决消息的幂等性无法保证跨分区跨会话的 Exactly Once。所以不能重启生产者。</p>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka的partition分区策略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lookup-method</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/IOC/7%E3%80%81lookup-method/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/IOC/7%E3%80%81lookup-method/</url>
      
        <content type="html"><![CDATA[<p>假设一个单例的Bean A需要引用一个非单例模式的Bean B,就是说在每次引用B的时候都需要拿到一个新的B,但是,Bean A是单例模式的,只会被创建一次,注入一次属性，==这就导致了本来应该表现出prototype 行为的B,却表现出了singleton行为。==</p><p>作用域问题注入的两种解决方案：</p><h3 id="1、让bean-A-实现ApplicationContextAware"><a href="#1、让bean-A-实现ApplicationContextAware" class="headerlink" title="1、让bean A 实现ApplicationContextAware"></a>1、让bean A 实现ApplicationContextAware</h3><p>ApplicationContextAware 通过它Spring容器会自动把上下文环境对象调用ApplicationContextAware接口中的setApplicationContext方法。从而能在运行时通过ApplicationContext.getBean(String beanName)的方法来获取最新的bean B。但是如果用ApplicationContextAware接口，就让我们与Spring代码耦合了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class BeanA implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    BeanB Beanb;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext&#x3D;applicationContext;</span><br><span class="line">        Beanb&#x3D;applicationContext.getBean(BeanB.class);</span><br><span class="line">    &#125;</span><br><span class="line">    class BeanB&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、lookup-method方法注入"><a href="#2、lookup-method方法注入" class="headerlink" title="2、lookup-method方法注入"></a>2、lookup-method方法注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class BeanA &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 需要使用到BeanB的方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void doSomething() &#123;</span><br><span class="line">BeanB beanB &#x3D; this.getBeanB();</span><br><span class="line">System.out.println(beanB);</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 定义一个返回值为BeanB的方法，用来获取BeanB类型的bean，该方法将由Spring来重写。</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public BeanB getBeanB() &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;beanB&quot; class&#x3D;&quot;com.app.BeanB&quot; scope&#x3D;&quot;prototype&quot;&#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;beanA&quot; class&#x3D;&quot;com.app.BeanA&quot;&gt;</span><br><span class="line">&lt;!-- 表示将由Spring重写getBeanB()方法，并返回名为beanB的bean --&gt;</span><br><span class="line">&lt;lookup-method name&#x3D;&quot;getBeanB&quot; bean&#x3D;&quot;beanB&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><h3 id="拓展：replaced-method的使用"><a href="#拓展：replaced-method的使用" class="headerlink" title="拓展：replaced-method的使用"></a>拓展：replaced-method的使用</h3><p>使用场景：动态替换原有的业务逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;myBean&quot; class&#x3D;&quot;com.zzr.web.test.MyBean&quot;&gt;</span><br><span class="line">    &lt;replaced-method name&#x3D;&quot;display&quot; replacer&#x3D;&quot;replacer&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;replacer&quot; class&#x3D;&quot;com.zzr.web.test.MyBeanReplacer&quot;&#x2F;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyBean &#123;</span><br><span class="line">    public void display()&#123;</span><br><span class="line">        System.out.println(&quot;我是原来的方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyBeanReplacer implements MethodReplacer&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object reimplement(Object obj, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;我替换了原来的方法&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BeanFactory beanFactory &#x3D; new XmlBeanFactory(new ClassPathResource(&quot;bean.xml&quot;));</span><br><span class="line">        MyBean myBean &#x3D; (MyBean) beanFactory.getBean(&quot;myBean&quot;);</span><br><span class="line">        myBean.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出了：我替换了原来的方法</span><br></pre></td></tr></table></figure><h3 id="lookup-method和replaced-method原理："><a href="#lookup-method和replaced-method原理：" class="headerlink" title="lookup-method和replaced-method原理："></a>lookup-method和replaced-method原理：</h3><p>createBean方法中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 5.1处理 lookup-method 和 replace-method 配置</span><br><span class="line">mbdToUse.prepareMethodOverrides();</span><br></pre></td></tr></table></figure><p>当用户配置了 lookup-method 和 replace-method 时，Spring 需要对目标 bean 进行增强，在增强之前，需要做一些准备工作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void prepareMethodOverrides() throws BeanDefinitionValidationException &#123;</span><br><span class="line">    MethodOverrides methodOverrides &#x3D; getMethodOverrides();</span><br><span class="line">    if (!methodOverrides.isEmpty()) &#123;</span><br><span class="line">        Set&lt;MethodOverride&gt; overrides &#x3D; methodOverrides.getOverrides();</span><br><span class="line">        synchronized (overrides) &#123;</span><br><span class="line">            &#x2F;&#x2F; 循环处理每个 MethodOverride 对象</span><br><span class="line">            for (MethodOverride mo : overrides) &#123;</span><br><span class="line">                prepareMethodOverride(mo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void prepareMethodOverride(MethodOverride mo) throws BeanDefinitionValidationException &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取方法名为 mo.getMethodName() 的方法数量，当方法重载时，count 的值就会大于1</span><br><span class="line">    int count &#x3D; ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName());</span><br><span class="line">    &#x2F;&#x2F; count &#x3D; 0，表明根据方法名未找到相应的方法，此时抛出异常</span><br><span class="line">    if (count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        throw new BeanDefinitionValidationException(</span><br><span class="line">                &quot;Invalid method override: no method with name &#39;&quot; + mo.getMethodName() +</span><br><span class="line">                &quot;&#39; on class [&quot; + getBeanClassName() + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 若 count &#x3D; 1，表明仅存在已方法名为 mo.getMethodName()，这意味着方法不存在重载</span><br><span class="line">    else if (count &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 方法不存在重载，则将 overloaded 成员变量设为 false</span><br><span class="line">        mo.setOverloaded(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IOC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lookup-method </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK动态代理</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/2%E3%80%81JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/2%E3%80%81JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>代理就是在调用实现类的方法时，可以在方法执行前后做额外的工作，这个就是代理。</p><h3 id="静态代理："><a href="#静态代理：" class="headerlink" title="静态代理："></a>静态代理：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 目标对象实现的接口</span><br><span class="line"> * @author jiyukai</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface BussinessInterface &#123;</span><br><span class="line"> </span><br><span class="line">    void execute();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 目标对象实现类</span><br><span class="line"> * @author jiyukai</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Bussiness implements BussinessInterface&#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        System.out.println(&quot;执行业务逻辑...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 代理类，通过实现与目标对象相同的接口</span><br><span class="line"> * 并维护一个代理对象，通过构造器传入实际目标对象并赋值</span><br><span class="line"> * 执行代理对象实现的接口方法，实现对目标对象实现的干预</span><br><span class="line"> * @author jiyukai</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BussinessProxy implements BussinessInterface&#123;</span><br><span class="line">     </span><br><span class="line">    private BussinessInterface bussinessImpl;</span><br><span class="line">     </span><br><span class="line">    public BussinessProxy(BussinessInterface bussinessImpl) &#123;</span><br><span class="line">        this.bussinessImpl &#x3D; bussinessImpl;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        System.out.println(&quot;前拦截...&quot;);</span><br><span class="line">        bussinessImpl.execute();</span><br><span class="line">        System.out.println(&quot;后拦截...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：可以做到不对目标对象进行修改的前提下，对目标对象进行功能的扩展和拦截。</p><p>　　缺点：因为代理对象，需要实现与目标对象一样的接口，会导致代理类十分繁多，不易维护，同时一旦接口增加方法，则目标对象和代理类都需要维护。</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>==JDK动态代理机制是委托机制，在动态生成的实现类里面委托为hanlder去调用原始实现类方法。==</p><p>接口的实现类(即要代理的对象)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package org.dynamicproxy.test;</span><br><span class="line"></span><br><span class="line">public class UserDaoMysqlImpl implements UserDao &#123;</span><br><span class="line"></span><br><span class="line">    public void addUser(User user) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        System.out.println(&quot;connect to MySQL DataBase...&quot;);</span><br><span class="line">        System.out.println(&quot;id为&quot;+user.getId()+&quot;的用户信息成功添加到数据库表中...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface UserDao &#123;</span><br><span class="line">    void addUser(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代理类的方法执行时，能够做额外工作的类，而这个类必须继承InvocationHandler接口  处理类(即能够做额外工作的类)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package org.dynamicproxy.test;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class LogHandler implements InvocationHandler &#123;</span><br><span class="line">    &#x2F;&#x2F; 持有被代理对象的引用（此引用可以有外部灵活制定的）</span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public LogHandler(Object target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">            throws Throwable &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        System.out.println(&quot;开始记录日志，添加用户方法开始执行...&quot;);</span><br><span class="line">        method.invoke(target, args);</span><br><span class="line">        System.out.println(&quot;开始记录日志，添加用户方法执行结束...&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为代理类的实例在调用实现类的方法的时候，不会调真正的实现类的这个方法， 而是转而调用这个类的invoke方法（继承时必须实现的方法），在这个方法中你可以调用真正的实现类的这个方法。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TestProxy&#123;</span><br><span class="line"> </span><br><span class="line">    @Test</span><br><span class="line">    public void testProxy()&#123;</span><br><span class="line">    UserDao userDAO &#x3D; new UserDaoMysqlImpl();</span><br><span class="line">    LogHandler li &#x3D; new LogHandler(userDAO);  &#x2F;&#x2F;创建一个Handerler对象</span><br><span class="line">　　</span><br><span class="line">    UserDao userDAOProxy &#x3D; (UserDao)Proxy.newProxyInstance(userDAO.getClass().getClassLoader(), userDAO.getClass().getInterfaces(), li);</span><br><span class="line">    userDAOProxy.addUser(new User(&quot;001&quot;));</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="newProxyInstance参数含义"><a href="#newProxyInstance参数含义" class="headerlink" title="newProxyInstance参数含义"></a>newProxyInstance参数含义</h4><ul><li>第一个参数：代理的类加载器，必须和被代理的对象是一个类加载器</li><li>第二个参数含义:代理对象要实现的那些接口</li><li>第三个参数：指派方法调用的调用处理程序</li></ul><h4 id="代理调用过程"><a href="#代理调用过程" class="headerlink" title="代理调用过程"></a>代理调用过程</h4><ul><li>得到UserDaoMysqlImpl这个类的一个代理类userDAOProxy，同时为代理类绑定了一个处理类LogHandler li</li><li>每次调用UserDaoMysqlImpl这个子类的addUser方法时， </li><li>不是userDAO这个UserDaoMysqlImpl类的实例去调用， </li><li>而是这个UserDaoMysqlImpl的代理类userDAOProxy去调用它自己的invoke方法, </li><li>这个invoke方法里呢可以调用userDAO这个实例的addUser方法</li></ul><h3 id="动态代理原理："><a href="#动态代理原理：" class="headerlink" title="动态代理原理："></a>动态代理原理：</h3>]]></content>
      
      
      <categories>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>aop源码</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/aop%E6%BA%90%E7%A0%81/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/aop%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>织入：在切点的引导下，将通知逻辑插入到方法调用上，使得我们的通知逻辑在方法调用时得以执行。</p><p>spring通过后置处理器 BeanPostProcessor 接口实现。在 bean 初始化完成后，即 bean 执行完初始化方法（init-method）。Spring通过切点对 bean 类中的方法进行匹配。若匹配成功，则会为该 bean 生成代理对象，并将代理对象返回给容器。容器向后置处理器输入 bean 对象，得到 bean 对象的代理，这样就完成了织入过程。</p><p>AOP 入口分析：</p><ol><li>若 bean 是 AOP 基础设施类型，则直接返回</li><li>为 bean 查找合适的通知器</li><li>如果通知器数组不为空，则为 bean 生成代理对象，并返回该对象</li><li>若数组为空，则返回原始 bean<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport</span><br><span class="line">        implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    &#x2F;** bean 初始化后置处理方法 *&#x2F;</span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        if (bean !&#x3D; null) &#123;</span><br><span class="line">            Object cacheKey &#x3D; getCacheKey(bean.getClass(), beanName);</span><br><span class="line">            if (!this.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果需要，为 bean 生成代理对象</span><br><span class="line">                return wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123;</span><br><span class="line">        if (beanName !&#x3D; null &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">            return bean;</span><br><span class="line">        &#125;</span><br><span class="line">        if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">            return bean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 如果是基础设施类（Pointcut、Advice、Advisor 等接口的实现类），或是应该跳过的类，</span><br><span class="line">         * 则不应该生成代理，此时直接返回 bean</span><br><span class="line">         *&#x2F; </span><br><span class="line">        if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 将 &lt;cacheKey, FALSE&gt; 键值对放入缓存中，供上面的 if 分支使用</span><br><span class="line">            this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">            return bean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 1、为目标 bean 查找合适的通知器</span><br><span class="line">        Object[] specificInterceptors &#x3D; getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 若 specificInterceptors !&#x3D; null，即 specificInterceptors !&#x3D; DO_NOT_PROXY，</span><br><span class="line">         * 则为 bean 生成代理对象，否则直接返回 bean</span><br><span class="line">         *&#x2F; </span><br><span class="line">        if (specificInterceptors !&#x3D; DO_NOT_PROXY) &#123;</span><br><span class="line">            this.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">            &#x2F;&#x2F; 创建代理</span><br><span class="line">            Object proxy &#x3D; createProxy(</span><br><span class="line">                    bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</span><br><span class="line">            this.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * 返回代理对象，此时 IOC 容器输入 bean，得到 proxy。此时，</span><br><span class="line">             * beanName 对应的 bean 是代理对象，而非原始的 bean</span><br><span class="line">             *&#x2F; </span><br><span class="line">            return proxy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        &#x2F;&#x2F; specificInterceptors &#x3D; null，直接返回 bean</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource targetSource) &#123;</span><br><span class="line">    &#x2F;&#x2F; 查找合适的通知器</span><br><span class="line">    List&lt;Advisor&gt; advisors &#x3D; findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">    if (advisors.isEmpty()) &#123;</span><br><span class="line">        return DO_NOT_PROXY;</span><br><span class="line">    &#125;</span><br><span class="line">    return advisors.toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class="line">    &#x2F;&#x2F; 查找所有的通知器</span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors &#x3D; findCandidateAdvisors();</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 筛选可应用在 beanClass 上的 Advisor，通过 ClassFilter 和 MethodMatcher</span><br><span class="line">     * 对目标类和方法进行匹配</span><br><span class="line">     *&#x2F;</span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors &#x3D; findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">    &#x2F;&#x2F; 拓展操作</span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    if (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        eligibleAdvisors &#x3D; sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    return eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aop源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟内存溢出</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/7%E3%80%81%E6%A8%A1%E6%8B%9F%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/7%E3%80%81%E6%A8%A1%E6%8B%9F%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="内存溢出-（out-of-memory）："><a href="#内存溢出-（out-of-memory）：" class="headerlink" title="内存溢出 （out of memory）："></a>内存溢出 （out of memory）：</h2><p>是指程序在申请内存时，没有足够的内存空间供其使用。</p><p>比如之前讲到若声明一个数组，大小为10m的连续的一块空间 byte[] arr=new byte[1024*10] 。若内存不足10m或者 即使这时候内存空间大于10m，但腾不出一块连续内存空间（存在内存碎片），都导致装不下声明的内存块。内存溢出</p><h2 id="内存泄露-memory-leak"><a href="#内存泄露-memory-leak" class="headerlink" title="内存泄露 memory leak:"></a>内存泄露 memory leak:</h2><p>长期持有引用不释放，导致无法释放内存空间，若内存泄露堆积后最终会导致内存溢出</p><ul><li><p>静态集合类引起内存泄漏</p><p> HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放（即使这个object已经为null了），所以需要手动从集合类中删除</p></li><li><p>当集合里面的对象属性被修改后，再调用remove()方法时不起作用</p></li><li><p>内部类和外部模块的引用</p></li></ul><p>内部类有个特性，是他会持有一个外部类的引用。如果内部类的实例一直存活，那么外部类activity的实例也就一直在。比如持有一个static的内部类引用</p><ul><li><p>单例模式或监听器</p><p>若单例对象或监听器持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏</p></li></ul><h2 id="1、堆溢出"><a href="#1、堆溢出" class="headerlink" title="1、堆溢出"></a>1、堆溢出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line"> </span><br><span class="line">    static class Demo&#123;&#125;</span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ArrayList&lt;Demo&gt; arrayList &#x3D; new ArrayList&lt;Demo&gt;();</span><br><span class="line">while (true) &#123;</span><br><span class="line">Demo demo &#x3D; new Demo();</span><br><span class="line">arrayList.add(demo);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调整jvm运行内存：</p><p>-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</p><p>-Xmx    堆的最大分配内存，通常为操作系统可用内存的1/4</p><p>-Xms    堆的最小分配内存，通常为操作系统可用内存的1/64</p><p>-XX:+HeapDumpOnOutOfMemoryError:设置JVM最大和最小堆内存都为20m，且在堆溢出时保存快照。</p><h2 id="2、栈溢出"><a href="#2、栈溢出" class="headerlink" title="2、栈溢出"></a>2、栈溢出</h2><p>例如：无限递归方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public void test()&#123;</span><br><span class="line">List s &#x3D; new ArrayList();</span><br><span class="line">test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new Test().test();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>没执行test方法时，将一个栈帧（栈帧里存数据）压栈，但未执行完，永不弹栈。，当虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</p><p>在单线程的操作中，无论是由于栈帧太大（通过定义大量本地变量增大方法帧中本地变量表的长度），还是虚拟机栈空间太小（通过设置-Xss减小栈内存容量），当栈空间无法分配时，虚拟机抛出的都是StackOverflowError异常，而不会得到OutOfMemoryError异常.而在多线程环境下，则会抛出OutOfMemoryError异常。</p><p>-Xss 设置栈的大小<br>hotspot的-Xoss 设置方法栈的大小（无效的） </p><h2 id="3、方法区和运行时常量池溢出"><a href="#3、方法区和运行时常量池溢出" class="headerlink" title="3、方法区和运行时常量池溢出"></a>3、方法区和运行时常量池溢出</h2><p>-XX:P-XX:PermSize=10M 方法区最小分配内存</p><p>-XX:MaxPermSize=10M 方法区最大分配内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;验证字符串常量池已在堆中</span><br><span class="line">        List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        String s &#x3D; &quot;abc&quot;;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">        s &#x3D; s + s;</span><br><span class="line">        list.add(s.intern());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Java8上运行的，Java7出现结果应该一样，可以验证从Java7开始，字符串常量池就移到了堆中。<br>在Spring hibernate对类进行增强时，用到cglib动态代理，会创建大量的类，而一个类要被垃圾回收的判断条件比较苛刻</p><h2 id="4、本机直接内存溢出"><a href="#4、本机直接内存溢出" class="headerlink" title="4、本机直接内存溢出"></a>4、本机直接内存溢出</h2><p>-XX:MaxDirectMemorySize=10m 指定直接内存大小，如果不指定，则默认与Java堆的最大值（-Xmx指定）一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"> </span><br><span class="line">import sun.misc.Unsafe;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x2F;**  </span><br><span class="line">* VM Args：-Xmx20M -XX:MaxDirectMemorySize&#x3D;10M </span><br><span class="line">   </span><br><span class="line">*&#x2F;</span><br><span class="line">public class DirectMemoryOOM &#123;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static final int _1MB &#x3D; 1024 * 1024;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">Field unsafeField &#x3D; Unsafe.class.getDeclaredFields()[0];  </span><br><span class="line">unsafeField.setAccessible(true);  </span><br><span class="line">Unsafe unsafe &#x3D; (Unsafe) unsafeField.get(null);  </span><br><span class="line">while (true) &#123;  </span><br><span class="line">        unsafe.allocateMemory(_1MB);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟内存溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis6.0</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/15%E3%80%81redis6.0/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/15%E3%80%81redis6.0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.toutiao.com/a6824284073519743499/?tt_from=copy_link&amp;utm_campaign=client_share&amp;timestamp=1588990579&amp;app=news_article_lite&amp;utm_source=copy_link&amp;utm_medium=toutiao_ios&amp;req_id=202005091016190100270570861A3DF309&amp;group_id=6824284073519743499">https://www.toutiao.com/a6824284073519743499/?tt_from=copy_link&amp;utm_campaign=client_share&amp;timestamp=1588990579&amp;app=news_article_lite&amp;utm_source=copy_link&amp;utm_medium=toutiao_ios&amp;req_id=202005091016190100270570861A3DF309&amp;group_id=6824284073519743499</a></p><p>Redis 6.0 之前的版本真的是单线程吗？</p><p>Redis 在处理客户端的请求时，包括获取（Socket 读）、解析、执行、内容返回（Socket 写）等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。</p><p>但如果严格来讲从 Redis 4.0 之后并不是单线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 Key 的删除等等。</p><p>②Redis 6.0 之前为什么一直不使用多线程？</p><p>官方曾做过类似问题的回复：使用 Redis 时，几乎不存在 CPU 成为瓶颈的情况， Redis 主要受限于内存和网络。</p><p>例如在一个普通的 Linux 系统上，Redis 通过使用 Pipelining 每秒可以处理 100 万个请求，所以如果应用程序主要使用 O(N) 或 O(log(N)) 的命令，它几乎不会占用太多 CPU。</p><p>使用了单线程后，可维护性高。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。</p><p>Redis 通过 AE 事件模型以及 IO 多路复用等技术，处理性能非常高，因此没有必要使用多线程。</p><p>单线程机制使得 Redis 内部实现的复杂度大大降低，Hash 的惰性 Rehash、Lpush 等等 “线程不安全” 的命令都可以无锁进行。</p><p>③Redis 6.0 为什么要引入多线程呢？</p><p>Redis 将所有数据放在内存中，内存的响应时长大约为 100 纳秒，对于小数据包，Redis 服务器可以处理 80,000 到 100,000 QPS，这也是 Redis 处理的极限了，对于 80% 的公司来说，单线程的 Redis 已经足够使用了。</p><p>但随着越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的 QPS。</p><p>常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但该方案有非常大的缺点，例如要管理的 Redis 服务器太多，维护代价大。</p><p>某些适用于单个 Redis 服务器的命令不适用于数据分区；数据分区无法解决热点读/写问题；数据偏斜，重新分配和放大/缩小变得更加复杂等等。</p><p>从 Redis 自身角度来说，因为读写网络的 Read/Write 系统调用占用了 Redis 执行期间大部分 CPU 时间，瓶颈主要在于网络的 IO 消耗。</p><p>优化主要有两个方向:</p><p>提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式。<br>使用多线程充分利用多核，典型的实现比如 Memcached。</p><p>协议栈优化的这种方式跟 Redis 关系不大，支持多线程是一种最有效最便捷的操作方式。</p><p>所以总结起来，Redis 支持多线程主要就是两个原因：</p><p>可以充分利用服务器 CPU 资源，目前主线程只能利用一个核。<br>多线程任务可以分摊 Redis 同步 IO 读写负荷。</p><p>④Redis 6.0 默认是否开启了多线程？</p><p>Redis 6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis.conf 配置文件：io-threads-do-reads yes。</p><p>⑤Redis 6.0 多线程开启时，线程数如何设置？</p><p>开启多线程后，还需要设置线程数，否则是不生效的。同样修改 redis.conf 配置文件：</p><p>支持多线程的Redis 6.0终于发布了<br>关于线程数的设置，官方有一个建议：4 核的机器建议设置为 2 或 3 个线程，8 核的建议设置为 6 个线程，线程数一定要小于机器核数。</p><p>还需要注意的是，线程数并不是越大越好，官方认为超过了 8 个基本就没什么意义了。</p><p>⑦Redis 6.0 多线程的实现机制？</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis6.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/1%E3%80%81redis/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/1%E3%80%81redis/</url>
      
        <content type="html"><![CDATA[<p>redis的设计与实现：<a href="http://redisbook.com/">http://redisbook.com/</a></p><p>redis最新版本5.0.5。是C语言写的字典。<br>key/value的最大为512M。<br>。</p><h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><p>1、缓存</p><p>缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。</p><p>2、排行榜</p><p>很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。</p><p>3、计数器</p><p>什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。</p><p>4、分布式会话管理</p><p>集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的session服务，session不再由容器管理，而是由session服务及内存数据库管理。</p><p>5、分布式锁</p><p>在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的==setnx和expire==功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败。redis分布式锁的核心命令就是setnx和expire。expire防止死锁。但redis的单条命令具备原子性，这两个命令如何保证原子性呢?可以使用lua脚本</p><p>6、 社交网络</p><p>点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。</p><p>7、最新列表</p><p>Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。</p><p>8、消息系统</p><p>消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。</p><p>9、秒杀活动</p><p>利用list数据结构，先进先出。</p><h2 id="Redis和memcahe的区别"><a href="#Redis和memcahe的区别" class="headerlink" title="Redis和memcahe的区别:"></a>Redis和memcahe的区别:</h2><ul><li>==Redis中，并不是所有的数据都一直存储在内存中的，这是和Memcache相比一个最大的区别==。<br>区别:</li></ul><p>Memcache</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Memcache可以利用多核优势，单实例吞吐量极高，可以达到几十万QPS,适用于最大程度扛量</span><br><span class="line"></span><br><span class="line">只支持简单的key&#x2F;value数据结构，不像Redis可以支持丰富的数据类型。</span><br><span class="line"></span><br><span class="line">无法进行持久化，数据不能备份，只能用于缓存使用，且重启后数据全部丢失</span><br></pre></td></tr></table></figure><p>Redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">支持多种数据结构，如string,list,dict,set,zset,hyperloglog</span><br><span class="line"></span><br><span class="line">单线程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。</span><br><span class="line"></span><br><span class="line">支持持久化操作，可以进行aof及rdb数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。</span><br><span class="line"></span><br><span class="line">支持通过Replication进行数据复制，通过master-slave机制，可以实时进行数据的同步复制，支持多级复制和增量复制.</span><br><span class="line"></span><br><span class="line">支持pub&#x2F;sub消息订阅机制，可以用来进行消息订阅与通知。</span><br><span class="line"></span><br><span class="line">支持简单的事务需求，但业界使用场景很少，并不成熟</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker命令</title>
      <link href="2020/06/21/Study%20notes/9%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/docker/4%E3%80%81docker%E5%91%BD%E4%BB%A4/"/>
      <url>2020/06/21/Study%20notes/9%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/docker/4%E3%80%81docker%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="镜像命令："><a href="#镜像命令：" class="headerlink" title="镜像命令："></a>镜像命令：</h2><p>1、搜索镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eg:docker search tomcat</span><br><span class="line"></span><br><span class="line">docker search XXX镜像</span><br><span class="line">docker search [OPTIONS] 镜像名字</span><br><span class="line">OPTIONS说明：</span><br><span class="line">    --no-trunc : 显示完整的镜像描述</span><br><span class="line">    -s : 列出收藏数不小于指定值的镜像。</span><br><span class="line">    --automated : 只列出 automated build类型的镜像</span><br></pre></td></tr></table></figure><p>2、下载镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull XXX镜像（默认最新版）</span><br><span class="line">docker pull XXX镜像[:TAG]</span><br></pre></td></tr></table></figure><p>3、查看镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">列出本地主机上的镜像：docker images [OPTIONS]</span><br><span class="line"></span><br><span class="line">OPTIONS说明：</span><br><span class="line">   -a :列出本地所有的镜像（含中间映像层）</span><br><span class="line">   -q :只显示镜像ID。</span><br><span class="line">   --digests :显示镜像的摘要信息</span><br><span class="line">   --no-trunc :显示完整的镜像信息</span><br><span class="line">   </span><br><span class="line">返回镜像信息说明：</span><br><span class="line">    REPOSITORY：表示镜像的仓库源</span><br><span class="line">    TAG：镜像的标签</span><br><span class="line">    IMAGE ID：镜像ID</span><br><span class="line">    CREATED：镜像创建时间</span><br><span class="line">    SIZE：镜像大小</span><br></pre></td></tr></table></figure><p>4、删除镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker rmi XXX镜像ID</span><br><span class="line">    删除单个：</span><br><span class="line">    docker rmi  -f 镜像ID</span><br><span class="line">    删除多个：</span><br><span class="line">    docker rmi -f 镜像名1:TAG 镜像名2:TAG </span><br><span class="line">    删除全部：</span><br><span class="line">    docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure><p>提交自定义镜像文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker提交:将当前容器提交为一个新的镜像</span><br><span class="line">docker commit -a&#x3D;&quot;作者wp&quot; -m&#x3D;&quot;描述luanqibazao&quot; b53385e46952 wangping&#x2F;tomcat:1.1</span><br><span class="line">                 镜像id别名</span><br></pre></td></tr></table></figure><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>1、启动容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">OPTIONS说明：（有些是一个减号，有些是两个减号）</span><br><span class="line">--name&#x3D;&quot;容器新名字&quot;: 为容器指定一个名称；</span><br><span class="line">-d: 后台运行容器，并返回容器ID，也即启动守护式容器；</span><br><span class="line">-i：以交互模式运行容器，通常与 -t 同时使用；</span><br><span class="line">-t：为容器重新分配一个伪输入终端，通常与 -i同时使用；</span><br><span class="line">-P: 随机端口映射；</span><br><span class="line">-p: 指定端口映射，有以下四种格式</span><br><span class="line">      ip:hostPort:containerPort</span><br><span class="line">      ip::containerPort</span><br><span class="line">      hostPort:containerPort</span><br><span class="line">      containerPort</span><br></pre></td></tr></table></figure><p>2、启动交互式容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker run -it centos &#x2F;bin&#x2F;bash </span><br><span class="line"></span><br><span class="line">exit离开并关闭容器。</span><br><span class="line">ctrl+P+q 离开容器 不关闭</span><br><span class="line"></span><br><span class="line">docker  attach 容器id   直接进入容器</span><br><span class="line">进入tomcat</span><br><span class="line">docker exec -it tomcat容器id &#x2F;bin&#x2F;bash 进入运行的tomcat容器中</span><br><span class="line">进入mysql</span><br><span class="line">docker exec -it mysql1 bash &#x2F;&#x2F;mysql1是我启动的mysql服务的name</span><br><span class="line">docker exec -t 容器id   进入容器指定命令后返回</span><br><span class="line"></span><br><span class="line">eg:docker run --name myTomcat -d tomcat:7 </span><br><span class="line">后台运行的容器 使用命令  docker exec -it 容器id   进入该容器的控制台</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看启动正在运行的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br><span class="line"></span><br><span class="line">OPTIONS说明（常用）：</span><br><span class="line">-a :列出当前所有正在运行的容器+历史上运行过的</span><br><span class="line">-l :显示最近创建的容器。</span><br><span class="line">-n：显示最近n个创建的容器。</span><br><span class="line">-q :静默模式，只显示容器编号。</span><br><span class="line">--no-trunc :不截断输出。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>停止容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#停止容器：</span><br><span class="line">docker stop 容器ID或者容器名</span><br><span class="line">#强制停止容器：</span><br><span class="line">docker kill 容器ID或者容器名</span><br></pre></td></tr></table></figure><p>启动容器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#启动容器：</span><br><span class="line">docker start 容器ID或者容器名</span><br><span class="line">#重启：</span><br><span class="line">docker restart 容器ID或者容器名</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4、容器命令（二）"><a href="#4、容器命令（二）" class="headerlink" title="4、容器命令（二）"></a>4、容器命令（二）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、启动守护式容器：docker run -d 容器名</span><br><span class="line">问题：然后docker ps -a 进行查看, 会发现容器已经退出，这个是docker的机制问题，Docker容器后台运行,就必须有一个前台进程.否则会自动退出的。</span><br><span class="line"></span><br><span class="line">2、查看容器日志：docker logs -f -t --tail 容器ID</span><br><span class="line">docker logs -f -t --tail 100 容器ID</span><br><span class="line">*   -t 是加入时间戳</span><br><span class="line">*   -f 跟随最新的日志打印</span><br><span class="line">*   --tail 数字 显示最后多少条</span><br><span class="line"></span><br><span class="line">3、查看容器内运行的进程：docker top 容器ID</span><br><span class="line">4、查看容器内部细节：docker inspect 容器ID</span><br><span class="line">5、进入正在运行的容器并以命令行交互：docker exec -it 容器ID &#x2F;bin&#x2F;bash</span><br><span class="line">6、重新进入：docker attach 容器ID</span><br><span class="line">    5和6的区别：</span><br><span class="line">    attach 直接进入容器启动命令的终端，不会启动新的进程</span><br><span class="line">    exec 是在容器中打开新的终端，并且可以启动新的进程</span><br><span class="line">7、从容器内拷贝文件到主机上：docker cp  容器ID:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized原理</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/6%E3%80%81synchronized%E5%8E%9F%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/6%E3%80%81synchronized%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Synchronized保证原子性，可见性，有序性</p><p>保证可见性：当线程获取锁时，JMM会把该线程对应的本地内存置为无效。必须从主内存中读取共享变量，当线程释放锁时，将共享变量刷新到主内存中。（java锁Lock也是一样）</p><p>保证原子性：以依靠两个指令：monitorenter，monitorexit<br>保证线程互斥。</p><p>有序性：synchronized==不会==禁止指令重排，但同步块中的共享变量对其他线程不可见，所以指令重排不会有影响。</p><h1 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h1><p>==Synchronized同步代码块实现同步其本质是对一个对象的监视器（monitor）进行获取(任意一个对象都拥有自己的监视器).<br>，线程进入同步队列，线程状态变为BLOCKED。当访问Object的前驱（获得了锁的线程）释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取。==</p><p>Synchronized同步代码块获取对象的监视器靠两个指令：monitorenter，monitorexit</p><ul><li>monitorenter指令是在编译后插入到同步代码块的开始位置，</li><li>monitorexit是插入到方法结<br>束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2615789-58bf5739c7c49c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/993/format/webp" alt="image"></p><h3 id="等待唤醒进制："><a href="#等待唤醒进制：" class="headerlink" title="等待唤醒进制："></a>等待唤醒进制：</h3><p>Synchronized搭配wait()、notify()、notifyAll()方法：</p><p>==等待/通知机制，是指一个线程A调用了对象O的wait()、方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的<br>关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作==。</p><p><img src="https://img2018.cnblogs.com/blog/1121374/201901/1121374-20190107145049686-1499118897.png" alt="image"></p><ol><li>WaitThread首先获取了对象的锁，然后调用对象的wait()方法，从而放弃了锁并进入了对象的等待队列WaitQueue中，进入等待状态。</li><li>由于WaitThread释放了对象的锁，NotifyThread随后获取了对象的锁，并调用对象的notify()方法，将WaitThread从WaitQueue移到SynchronizedQueue中，此时WaitThread的状态变为阻塞状态。</li><li>NotifyThread释放了锁之后，WaitThread再次获取到锁并从wait()方法返回继续执行。</li></ol><h3 id="wait和notify为什么需要在synchronized里面？"><a href="#wait和notify为什么需要在synchronized里面？" class="headerlink" title="wait和notify为什么需要在synchronized里面？"></a>wait和notify为什么需要在synchronized里面？</h3><p>wait方法的语义有两个，一个是释放当前的对象锁、另一个是使得当前线程进入阻塞队列，而这些操作都和监视器是相关的，所以wait必须要获得一个监视器锁。</p><p>而对于notify来说也是一样，它是唤醒一个线程，既然要去唤醒，首先得知道它在哪里，所以就必须要找到这个对象获取到这个对象的锁，然后到这个对象的等待队列中去唤醒一个线程。</p><h1 id="Synchronized应用："><a href="#Synchronized应用：" class="headerlink" title="Synchronized应用："></a>Synchronized应用：</h1><h3 id="1、实例方法同步"><a href="#1、实例方法同步" class="headerlink" title="1、实例方法同步"></a>1、实例方法同步</h3><p>==锁：该方法所属的实例==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void add(int value)&#123;</span><br><span class="line">this.count +&#x3D; value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、静态方法同步"><a href="#2、静态方法同步" class="headerlink" title="2、静态方法同步"></a>2、静态方法同步</h3><p>==锁：静态方法的同步是指同步在该方法所在的类对象上。因为在Java虚拟机中一个类只能对应一个类对象==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static synchronized void add(int value)&#123;</span><br><span class="line">this.count +&#x3D; value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、实例方法中的同步块"><a href="#3、实例方法中的同步块" class="headerlink" title="3、实例方法中的同步块"></a>3、实例方法中的同步块</h3><p>==锁：可自行指定 当为this时，等价于实例方法同步==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void add(int value) &#123;</span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           this.count +&#x3D; value;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="4、静态方法中的同步块"><a href="#4、静态方法中的同步块" class="headerlink" title="4、静态方法中的同步块"></a>4、静态方法中的同步块</h3><p>==锁：可自行指定 当为当前类的class字节码对象时，等价静态方法同步==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void log2(String msg1, String msg2) &#123;</span><br><span class="line">       synchronized (MyClass.class) &#123;</span><br><span class="line">           log.writeln(msg1);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> synchronized原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis使用的小细节</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/11%E3%80%81mybatis%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/11%E3%80%81mybatis%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h2 id="1、使用mybatis插入自增主键ID的数据后返回自增的ID："><a href="#1、使用mybatis插入自增主键ID的数据后返回自增的ID：" class="headerlink" title="1、使用mybatis插入自增主键ID的数据后返回自增的ID："></a>1、使用mybatis插入自增主键ID的数据后返回自增的ID：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;insert id&#x3D;&quot;insert&quot; keyProperty&#x3D;&quot;id&quot; useGeneratedKeys&#x3D;&quot;true&quot;  parameterType&#x3D;&quot;com.demo.domain.User&quot;&gt; </span><br><span class="line">insert into User_t(name,age,addr) values(#&#123;name&#125;,#&#123;age&#125;,#&#123;addr&#125;)</span><br><span class="line">&lt;&#x2F;insert&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2、返回自定义对象的映射"><a href="#2、返回自定义对象的映射" class="headerlink" title="2、返回自定义对象的映射"></a>2、返回自定义对象的映射</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id&#x3D;&quot;BaseResultMap&quot; type&#x3D;&quot;com.example.domain.User&quot; &gt;</span><br><span class="line">    &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot; jdbcType&#x3D;&quot;INTEGER&quot; &#x2F;&gt;</span><br><span class="line">    &lt;result column&#x3D;&quot;user_name&quot; property&#x3D;&quot;userName&quot; jdbcType&#x3D;&quot;VARCHAR&quot; &#x2F;&gt;</span><br><span class="line">    &lt;result column&#x3D;&quot;password&quot; property&#x3D;&quot;password&quot; jdbcType&#x3D;&quot;VARCHAR&quot; &#x2F;&gt;</span><br><span class="line">    &lt;result column&#x3D;&quot;age&quot; property&#x3D;&quot;age&quot; jdbcType&#x3D;&quot;INTEGER&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;resultMap&gt;</span><br><span class="line">  &lt;sql id&#x3D;&quot;Base_Column_List&quot; &gt;</span><br><span class="line">    id, user_name, password, age</span><br><span class="line">  &lt;&#x2F;sql&gt;</span><br><span class="line">  &lt;select id&#x3D;&quot;selectByPrimaryKey&quot; resultMap&#x3D;&quot;BaseResultMap&quot; parameterType&#x3D;&quot;com.example.domain.User&quot; &gt;</span><br><span class="line">    select </span><br><span class="line">    &lt;include refid&#x3D;&quot;Base_Column_List&quot; &#x2F;&gt;</span><br><span class="line">    from user_t</span><br><span class="line">    where id &#x3D; #&#123;id,jdbcType&#x3D;INTEGER&#125;</span><br><span class="line">  &lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><h2 id="3、参数parameterType为map，resultMap为HashMap类型"><a href="#3、参数parameterType为map，resultMap为HashMap类型" class="headerlink" title="3、参数parameterType为map，resultMap为HashMap类型"></a>3、参数parameterType为map，resultMap为HashMap类型</h2><p>（在调用时候，先把参数存储到Map中，注意key值就是 mapper.xml中参数的名字，返回结果map中的key值就是resultMap设置的property）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id&#x3D;&quot;loopSpeedResult&quot;   type&#x3D;&quot;HashMap&quot;&gt; </span><br><span class="line">&lt;!-- cabName、speed为map的key的值 将cab_name、speed映射到key对应的value值 --&gt;</span><br><span class="line">    &lt;result column&#x3D;&quot;cab_name&quot; property&#x3D;&quot;cabName&quot;&#x2F;&gt;  </span><br><span class="line">    &lt;result column&#x3D;&quot;speed&quot; property&#x3D;&quot;speed&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;resultMap&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;selectLoopSpeed&quot;  parameterType&#x3D;&quot;java.util.Map&quot;  resultMap&#x3D;&quot;loopSpeedResult&quot;&gt;        </span><br><span class="line">    SELECT B.cab_name as cab_name, round(avg(speed),2) as speed  </span><br><span class="line">    FROM table1 as A, table2 as B</span><br><span class="line">    Where left(right(B.unit_name,3),2) &#x3D; &#39;__&#39; </span><br><span class="line">&lt;!-- minLon为参数map中的key的值 --&gt;</span><br><span class="line">    and (B.lon between #&#123;minLon&#125;  and #&#123;maxLon&#125; )</span><br><span class="line">    and (B.lat between #&#123;minLat&#125;  and #&#123;maxLat&#125; )</span><br><span class="line">    and stamp &lt;![CDATA[ &gt;&#x3D; ]]&gt;  #&#123;beginTime,jdbcType&#x3D;TIMESTAMP&#125; and stamp &lt;![CDATA[ &lt;&#x3D; ]]&gt;  #&#123;endTime,jdbcType&#x3D;TIMESTAMP&#125;</span><br><span class="line">    and A.lid &#x3D; B.id </span><br><span class="line">    group by B.id</span><br><span class="line">  &lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><h2 id="4、mybatis执行多条sql"><a href="#4、mybatis执行多条sql" class="headerlink" title="4、mybatis执行多条sql"></a>4、mybatis执行多条sql</h2><p>1、jdbc连接增加allowMultiQueries=true即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc.jdbcUrl&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;database?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;allowMultiQueries&#x3D;true</span><br></pre></td></tr></table></figure><p>2、sql之间使用;分隔</p><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id&#x3D;&quot;down&quot;&gt;</span><br><span class="line">    UPDATE table SET </span><br><span class="line">        order_num &#x3D; order_num - 1</span><br><span class="line">    WHERE order_num &#x3D; #&#123;orderNum&#125; + 1;</span><br><span class="line">    UPDATE table SET </span><br><span class="line">        order_num &#x3D; order_num + 1</span><br><span class="line">    WHERE id &#x3D; #&#123;id&#125;;</span><br><span class="line">&lt;&#x2F;update&gt;</span><br></pre></td></tr></table></figure><h2 id="4、mybatis的级联查询时resultMap的映射"><a href="#4、mybatis的级联查询时resultMap的映射" class="headerlink" title="4、mybatis的级联查询时resultMap的映射"></a>4、mybatis的级联查询时resultMap的映射</h2><p>association（一对一）</p><p>collection (一对多)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--column不做限制，可以为任意表的字段，而property须为type 定义的pojo属性--&gt;</span><br><span class="line">&lt;resultMap id&#x3D;&quot;唯一的标识&quot; type&#x3D;&quot;映射的pojo对象&quot;&gt;</span><br><span class="line">  &lt;id column&#x3D;&quot;表的主键字段，或者可以为查询语句中的别名字段&quot; jdbcType&#x3D;&quot;字段类型&quot; property&#x3D;&quot;映射pojo对象的主键属性&quot; &#x2F;&gt;</span><br><span class="line">  &lt;result column&#x3D;&quot;表的一个字段（可以为任意表的一个字段）&quot; jdbcType&#x3D;&quot;字段类型&quot; property&#x3D;&quot;映射到pojo对象的一个属性（须为type定义的pojo对象中的一个属性）&quot;&#x2F;&gt;</span><br><span class="line">  &lt;association property&#x3D;&quot;pojo的一个对象属性&quot; javaType&#x3D;&quot;pojo关联的pojo对象&quot;&gt;</span><br><span class="line">    &lt;id column&#x3D;&quot;关联pojo对象对应表的主键字段&quot; jdbcType&#x3D;&quot;字段类型&quot; property&#x3D;&quot;关联pojo对象的主席属性&quot;&#x2F;&gt;</span><br><span class="line">    &lt;result  column&#x3D;&quot;任意表的字段&quot; jdbcType&#x3D;&quot;字段类型&quot; property&#x3D;&quot;关联pojo对象的属性&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;association&gt;</span><br><span class="line">  &lt;!-- 集合中的property须为oftype定义的pojo对象的属性--&gt;</span><br><span class="line">  &lt;collection property&#x3D;&quot;pojo的集合属性&quot; ofType&#x3D;&quot;集合中的pojo对象&quot;&gt;</span><br><span class="line">    &lt;id column&#x3D;&quot;集合中pojo对象对应的表的主键字段&quot; jdbcType&#x3D;&quot;字段类型&quot; property&#x3D;&quot;集合中pojo对象的主键属性&quot; &#x2F;&gt;</span><br><span class="line">    &lt;result column&#x3D;&quot;可以为任意表的字段&quot; jdbcType&#x3D;&quot;字段类型&quot; property&#x3D;&quot;集合中的pojo对象的属性&quot; &#x2F;&gt;  </span><br><span class="line">  &lt;&#x2F;collection&gt;</span><br><span class="line">&lt;&#x2F;resultMap&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis使用的小细节 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql执行计划</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/sql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/sql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>explain select * from table where table.id = 1 </p><p>运行上面的sql语句后你会看到，下面的表头信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table | type | possible_keys | key | key_len | ref | rows | Extra</span><br></pre></td></tr></table></figure><h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><p>显示这一行的数据是关于哪张表的</p><h5 id="type"><a href="#type" class="headerlink" title="==type=="></a>==type==</h5><p>这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL</p><p>说明：不同连接类型的解释（按照效率高低的顺序排序）</p><p>system：表只有一行：system表。这是const连接类型的特殊情况。</p><p>const ：表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待。</p><p>eq_ref：在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用。</p><p>ref：这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好。</p><p>range：这个连接类型使用索引返回一个范围中的行，比如使用&gt;或&lt;查找东西时发生的情况。</p><p>index：这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据）。</p><p>ALL：这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免。</p><h5 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h5><p>显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</p><h5 id="key"><a href="#key" class="headerlink" title="==key=="></a>==key==</h5><p>实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引</p><h5 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h5><p>使用的索引的长度。在不损失精确性的情况下，长度越短越好</p><h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><p>显示索引的哪一列被使用了，如果可能的话，是一个常数</p><h5 id="rows"><a href="#rows" class="headerlink" title="==rows=="></a>==rows==</h5><p>MYSQL认为必须检查的用来返回请求数据的行数</p><p>Extra<br>关于MYSQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MYSQL根本不能使用索引，结果是检索会很慢</p><p>说明：extra列返回的描述的意义</p><p>Distinct ：一旦mysql找到了与行相联合匹配的行，就不再搜索了。</p><p>Not exists ：mysql优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了。</p><p>Range checked for each Record（index map:#） ：没有找到理想的索引，因此对从前面表中来的每一个行组合，mysql检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一。</p><p>Using filesort ：看到这个的时候，查询就需要优化了。mysql需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行。</p><p>Using index ：列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候。</p><p>Using temporary ：看到这个的时候，查询需要优化了。这里，mysql需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上。</p><p>Where used ：使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql执行计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/8%E3%80%81volatile/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/8%E3%80%81volatile/</url>
      
        <content type="html"><![CDATA[<p>被 volatile 修饰的变量具备两种特性：</p><ul><li>1、保证该变量对所有线程的可见性；</li></ul><p>CPU修改数据，首先是对缓存的修改，然后再同步回主存，在同步回主存的时候，如果其他CPU也缓存了这个数据，就会导致其他CPU缓存上的数据失效，这样，当其他CPU再去它的缓存读取这个数据的时候，就必须从主存重新获取</p><ul><li>2、禁止指令重排序优化。</li></ul><p>==想要线程安全必须保证原子性，可见性，有序性==。而volatile只能保证可见性和有序性。所以基于 volatile 变量的运算在并发下不一定是安全的</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileTest &#123;</span><br><span class="line"></span><br><span class="line">    private static final int THREADS_COUNT &#x3D; 20;</span><br><span class="line"></span><br><span class="line">    private static volatile int race &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private static void increase() &#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Thread[] threads &#x3D; new Thread[THREADS_COUNT];</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (Thread.activeCount() &gt; 1) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;race &#x3D; &quot; + race);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>race++的操作分解：</p><ul><li>a）读取 race 的值；</li><li>b）将 race 值加一；</li><li>c）将 race 值写回内存。</li></ul><p>volatile 关键字能够保证 a）操作读取的 race 的值在这一时刻是正确的，但在执行 b）、c）操作时，可能有其他的线程已经对 race 的值进行了修改，导致了 c）操作可能把较小的 race 值同步回主内存之中。所以要想保证结果的正确性，需要在 increase() 方法加锁才行。</p><h3 id="因此使用volatile的场景："><a href="#因此使用volatile的场景：" class="headerlink" title="因此使用volatile的场景："></a>因此使用volatile的场景：</h3><ul><li><p>运算结果并不依赖变量的当前值，或者能够保证确保只有单一的线程修改变量的值。</p></li><li><p>变量不需要与其他的状态变量共同参与不变约束。 </p></li><li></li></ul><p>olatile的写-读相当于锁的释放-获取有相同的内存效果</p><p>==从JDK5开始，volatile变量的写-读可以实现线程之间的通信==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Example &#123;</span><br><span class="line">    private boolean stop &#x3D; false;</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        System.out.println(&quot;thread1 start loop.&quot;);</span><br><span class="line">        while(!getStop()) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;thread1 finish loop,i&#x3D;&quot; + i);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean getStop() &#123;</span><br><span class="line">        return stop; &#x2F;&#x2F; 对普通变量的读</span><br><span class="line">    &#125;</span><br><span class="line">    public void setStop(boolean flag) &#123;</span><br><span class="line">        this.stop &#x3D; flag; &#x2F;&#x2F; 对普通变量的写</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class VolatileExample &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        final Example example &#x3D; new Example();</span><br><span class="line">        Thread t1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                example.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        System.out.println(&quot;主线程即将置stop值为true...&quot;);</span><br><span class="line">        example.setStop(true);</span><br><span class="line">        System.out.println(&quot;主线程已将stop值为：&quot; + example.getStop());</span><br><span class="line">        System.out.println(&quot;主线程等待线程1执行完...&quot;);</span><br><span class="line"></span><br><span class="line">        t1.join();</span><br><span class="line">        System.out.println(&quot;线程1已执行完毕，整个流程结束...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==想要理解透volatile特性有一个很好的方法，就是把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步。==</p><h3 id="volatile写-读的内存语义"><a href="#volatile写-读的内存语义" class="headerlink" title="volatile写-读的内存语义"></a>volatile写-读的内存语义</h3><ul><li><p>当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</p></li><li><p>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引（下）</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%9E%B6%E6%9E%84/2%E3%80%81%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%9E%B6%E6%9E%84/2%E3%80%81%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>聚集索引以及非聚集索引用的是B+树索引。==区别在于叶子节点是否存放数据库一整行的数据。==</p><p>hash索引对范围查询支持较差。<br>有序数组索引对精确查询和范围查询支持都很好。但更增删操作代价很大。所以值适合存储静态数据。</p><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>通过表的主键构建一颗B+树索引，同时叶子节点存放整行的数据记录。</p><h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p>叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外,每个叶子节点中的索引行中还包含了一个书签( bookmark：聚集索引键)。该书签用来告诉 InnoDB存储引擎哪里可以找到与索引相对应的行数据。由于 InnoDB存储引擎表是索引组织表,因此 InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">index k(k))</span><br><span class="line">engine&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">插入：(ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)</span><br></pre></td></tr></table></figure><p>聚集索引查询：</p><ul><li>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；便将所有字段数据查询到</li></ul><p>非聚集索引查询：</p><ul><li>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。</li></ul><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，==索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引==。</p><h3 id="联合索引："><a href="#联合索引：" class="headerlink" title="联合索引："></a>联合索引：</h3><p>联合索引(col1, col2, col3)也是一棵B+树，其非叶子节点存储的是第一个关键字的索引，而叶子节点存储的则是三个关键字col1、col2、col3三个关键字的数据，且==按照col1-col2-col3的顺序进行排序==。</p><p><img src="https://img-blog.csdn.net/20180509204539590?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTQ2MjA0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"><img src="https://img-blog.csdn.net/20180509204754682?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTQ2MjA0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p><ul><li><p>SELECT * FROM T WHERE col2=‘Tom’ AND col3=4567;<br>那么无法使用索引，==因为索引是用col1字段先排序的，如果没有先确定col1，直接查找col2和col3，那么将会是全表查询。==</p></li><li><p>SELECT * FROM T WHERE col1=‘30’ AND col2=Demi;<br>那么，会先找到col1字段，再在col1等于30的数据中（比如有很多条），找col2等于Demi的数据。这样是可以用到索引的。</p></li><li><p>SELECT * FROM T WHERE col1=‘18’ AND col3=1234;<br>那么，col1字段可以索引，而col3不能索引。所以可以部分索引，也比全表查询快。</p></li></ul><h3 id="普通索引和唯一索引"><a href="#普通索引和唯一索引" class="headerlink" title="普通索引和唯一索引"></a>普通索引和唯一索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#身份证号码是建立唯一索引还是普通索引？</span><br><span class="line">select name from CUser where id_card &#x3D; &#39;xxxxxxxyyyyyyzzzzz&#39;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="索引失效的场景总结："><a href="#索引失效的场景总结：" class="headerlink" title="索引失效的场景总结："></a>索引失效的场景总结：</h3><ul><li>1）、破坏联合索引最佳左前缀法则：未只使用联合索引的前几个字段</li><li>2）、在索引的列上做运算转换等操作（运算，函数，自动或手动的类型转换），会导致索引失效，导致全表扫描</li><li>3）、范围条件右边的列索引失效 &gt; &lt; like后面的条件索引失效</li><li>4）、使用！= 或者&lt;&gt; 索引失效 导致全表扫描</li><li>5)、is null 和is not null比较 也会导致索引失效，全表扫描。==因为索引是有序的，无法存储Null值==</li><li>6）、%like字段% 导致索引失效，解决办法 覆盖索引–思考</li><li>7）、字符串不加单引号 会导致索引失效</li><li>8）、少用or 用它练连接 会导致索引失效</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引（下） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mycat分库分表、读写分离配置</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/MyCat/3%E3%80%81mycat%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E3%80%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E9%85%8D%E7%BD%AE/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/MyCat/3%E3%80%81mycat%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E3%80%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>用mycat做读写分离：基于 MySQL主从复制</p><h3 id="修改schema-xml："><a href="#修改schema-xml：" class="headerlink" title="修改schema.xml："></a>修改schema.xml：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;</span><br><span class="line">&lt;mycat:schema xmlns:mycat&#x3D;&quot;http:&#x2F;&#x2F;io.mycat&#x2F;&quot;&gt;</span><br><span class="line">       &lt;!-- mycat逻辑库--&gt;</span><br><span class="line">        &lt;schema name&#x3D;&quot;mycatdb&quot; checkSQLschema&#x3D;&quot;false&quot; sqlMaxLimit&#x3D;&quot;100&quot;&gt;</span><br><span class="line">               &lt;!-- mycay逻辑表，配置表区分--&gt;</span><br><span class="line">                &lt;!-- 自动取模分片 --&gt;</span><br><span class="line">                &lt;table name&#x3D;&quot;t_person&quot; dataNode&#x3D;&quot;dn1,dn2,dn3&quot; rule&#x3D;&quot;mod-long&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">                &lt;!-- 一致性hash分片，分片列不要使用MySQL原生函数 --&gt;</span><br><span class="line">                &lt;table name&#x3D;&quot;t_user&quot; primaryKey&#x3D;&quot;id&quot; dataNode&#x3D;&quot;dn1,dn2&quot; rule&#x3D;&quot;sharding-by-murmur&quot; &#x2F;&gt;</span><br><span class="line">                &lt;!-- 全局表 --&gt;</span><br><span class="line">                &lt;table name&#x3D;&quot;province&quot; type&#x3D;&quot;global&quot; dataNode&#x3D;&quot;dn1,dn2,dn3&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- E-R关系分片 --&gt;</span><br><span class="line">                &lt;table name&#x3D;&quot;customer&quot; dataNode&#x3D;&quot;dn1,dn2,dn3&quot; rule&#x3D;&quot;auto-sharding-long-customer&quot;&gt;</span><br><span class="line">                        &lt;childTable name&#x3D;&quot;orders&quot; joinKey&#x3D;&quot;customer_id&quot; parentKey&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;table&gt;</span><br><span class="line">                &lt;!-- E-R关系分片，多表 --&gt;</span><br><span class="line">                &lt;table name&#x3D;&quot;user&quot; primaryKey&#x3D;&quot;id&quot; dataNode&#x3D;&quot;dn1,dn2&quot; rule&#x3D;&quot;mod-long-test&quot;&gt;</span><br><span class="line">                        &lt;childTable name&#x3D;&quot;cell&quot; joinKey&#x3D;&quot;user_id&quot; parentKey&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">                        &lt;childTable name&#x3D;&quot;note&quot; joinKey&#x3D;&quot;user_id&quot; parentKey&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">                        &lt;childTable name&#x3D;&quot;lit&quot; joinKey&#x3D;&quot;user_id&quot; parentKey&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">                        &lt;childTable name&#x3D;&quot;lit_usr&quot; joinKey&#x3D;&quot;user_id&quot; parentKey&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line">        &lt;&#x2F;schema&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 分片节点信息 --&gt;</span><br><span class="line">        &lt;dataNode name&#x3D;&quot;dn1&quot; dataHost&#x3D;&quot;localhost1&quot; database&#x3D;&quot;db1&quot; &#x2F;&gt;</span><br><span class="line">        &lt;dataNode name&#x3D;&quot;dn2&quot; dataHost&#x3D;&quot;localhost1&quot; database&#x3D;&quot;db2&quot; &#x2F;&gt;</span><br><span class="line">        &lt;dataNode name&#x3D;&quot;dn3&quot; dataHost&#x3D;&quot;localhost1&quot; database&#x3D;&quot;db3&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        &lt;!-- 连接MySQL的信息 &amp;&amp; 读写分离策略 --&gt;</span><br><span class="line">        &lt;dataHost name&#x3D;&quot;localhost1&quot; maxCon&#x3D;&quot;500&quot; minCon&#x3D;&quot;100&quot; balance&#x3D;&quot;0&quot;</span><br><span class="line">                          writeType&#x3D;&quot;0&quot; dbType&#x3D;&quot;mysql&quot; dbDriver&#x3D;&quot;native&quot; switchType&#x3D;&quot;1&quot;  slaveThreshold&#x3D;&quot;100&quot;&gt;</span><br><span class="line">                &lt;heartbeat&gt;select user();&lt;&#x2F;heartbeat&gt;</span><br><span class="line">                &lt;writeHost host&#x3D;&quot;hostM1&quot; url&#x3D;&quot;localhost:3306&quot; user&#x3D;&quot;root&quot; password&#x3D;&quot;abcdef&quot;&gt;</span><br><span class="line">                        &lt;readHost host&#x3D;&quot;hostS1&quot; url&#x3D;&quot;localhost:3306&quot; user&#x3D;&quot;root&quot; password&#x3D;&quot;123456&quot; &#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;writeHost&gt;</span><br><span class="line">        &lt;&#x2F;dataHost&gt;</span><br><span class="line">&lt;&#x2F;mycat:schema&gt;</span><br></pre></td></tr></table></figure><p>以上为最简单的配置，一主一从结构。<br>MyCat支持双主多从，配置两个writeHost兄弟节点，多个readHost节点即可</p><h3 id="此处有三点需要注意："><a href="#此处有三点需要注意：" class="headerlink" title="此处有三点需要注意："></a>此处有三点需要注意：</h3><p>balance=”1”，writeType=”0” ,switchType=”1” </p><h4 id="balance："><a href="#balance：" class="headerlink" title="balance："></a>balance：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">balance&#x3D;&quot;0&quot;, 不开启读写分离机制，所有读操作都发送到当前可用的writeHost 上。</span><br><span class="line">balance&#x3D;&quot;1&quot;，全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡，简单的说，当双主双从模式(M1 -&gt;S1 ， M2-&gt;S2，并且 M1 与 M2 互为主备)，正常情况下， M2,S1,S2 都参与 select 语句的负载均衡。</span><br><span class="line">balance&#x3D;&quot;2&quot;，所有读操作都随机的在 writeHost、 readhost 上分发。</span><br><span class="line">balance&#x3D;&quot;3&quot;， 所有读请求随机的分发到 wiriterHost 对应的 readhost 执行,writerHost 不负担读压力，注意 balance&#x3D;3 只在 1.4 及其以后版本有， 1.3 没有。</span><br></pre></td></tr></table></figure><h4 id="writeType："><a href="#writeType：" class="headerlink" title="writeType："></a>writeType：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">writeType&#x3D;&quot;0&quot;, 所有写操作发送到配置的第一个 writeHost，第一个挂了切到还生存的第二个writeHost，重新启动后已切换后的为准，切换记录在配置文件中:dnindex.properties .</span><br><span class="line">writeType&#x3D;&quot;1&quot;，所有写操作都随机的发送到配置的 writeHost。</span><br><span class="line">writeType&#x3D;&quot;2&quot;，所有写操作都随机的在writeHost、readhost分上发</span><br></pre></td></tr></table></figure><h4 id="switchType："><a href="#switchType：" class="headerlink" title="switchType："></a>switchType：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1 表示不自动切换</span><br><span class="line">1 默认值，自动切换</span><br><span class="line">2 基于mycal主从同步的状态决定是否切换（如果同步状态正常，就按配置的，如果不正常，读写就自动切换到能用的一者了）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyCat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mycat分库分表、读写分离配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳跃链表skipList</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2%E3%80%81%E9%93%BE%E8%A1%A8/6%E3%80%81%E8%B7%B3%E8%B7%83%E9%93%BE%E8%A1%A8skipList/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2%E3%80%81%E9%93%BE%E8%A1%A8/6%E3%80%81%E8%B7%B3%E8%B7%83%E9%93%BE%E8%A1%A8skipList/</url>
      
        <content type="html"><![CDATA[<p>用跳表可以高效==维护一组有序==的数据的列表，尽可能在插入、删除、查找等操作上能够尽可能的快速。</p><p>数组：使用数组存储的话，采用二分法可以在 O(logn) 的时间里找到指定的元素，在进行插入和删除则时间复杂度为 O(n) </p><p>链表：使用链表存储的话，就插入、删除动作而言，所需的时间复杂度为 O(1) ，加上查找所需的时间复杂度为O（n），故插入、删除所需的总的时间复杂度为O(n)。</p><p>跳跃链表在有序链表的基础上进行了扩展（它具有二分查找的功能）。</p><p>查找特定值的时间复杂度为O(logn)，单插入和删除时间复杂度为O(1)，根据时间复杂度加法原则，增删时需要先定位到某位置，所以要加上查询所需O(lngn)，所以跳跃链表在查询、插入、删除的时间复杂度为O(lng)。</p><p>他是一种可以代替平衡树的数据结构。B+树结构的思想和跳跃链表同理。最底层存储数据，将特定数据提取到上一层作为索引。</p><p><img src="https://img-blog.csdnimg.cn/20190823065749202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzMwMTMwNzgz,size_16,color_FFFFFF,t_70" alt="image"></p><p>小结：跳表的特点：</p><p>(1) 由很多层结构组成</p><p>(2) 每一层都是一个有序的链表</p><p>(3) 最底层的链表包含所有元素</p><p>(4) 如果一个元素出现x层，则x下的一层也会出现。</p><p>(5) 每个节点包含两个指针，一个指向同一层的下一个元素，一个指向下面一层的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *跳跃链表</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SkipListNode &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;元素</span><br><span class="line">    private int data;</span><br><span class="line">    &#x2F;&#x2F;同一链表中的下一个元素指针</span><br><span class="line">    private SkipListNode next;</span><br><span class="line">    &#x2F;&#x2F;指向下面一层的元素指针</span><br><span class="line">    private SkipListNode downNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包括前面的数据结构，很多时候看一个类的成员变量，便能从宏观上把握这个类的作用。因为无论方法再多，都是再维护这些变量。</p><h3 id="跳表的增删改查操作"><a href="#跳表的增删改查操作" class="headerlink" title="跳表的增删改查操作"></a>跳表的增删改查操作</h3><p>（1）插入节点</p><p>插入结点的操作，最底层数据节点会增加，底层往上的各层索引节点会逐渐减少。这时候需要决定插入的节点是否需要添加到各层中作为索引。解决方式：抛硬币法</p><p>【抛硬币法】 也就是随机决定新节点是否提拔，每次向上提拔一层的几率是50%</p><ul><li><p>因为跳跃表删除和添加的节点是不可预测的，很难用一种有效的算法来保证跳表的索引部分始终均匀。</p></li><li><p>随机抛硬币的方法可以让索引部分大体趋于均匀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;抛硬币：</span><br><span class="line">int random_level()  </span><br><span class="line">&#123;  </span><br><span class="line">    K &#x3D; 1;  </span><br><span class="line">    while (random(0,1))  </span><br><span class="line">        K++;  </span><br><span class="line">    return K;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>(2)删除节点：</p></li><li><p>只要在【索引层】找到要删除的节点，然后一次查找每一层删除相同节点。</p></li><li><p>如果某一层索引在删除后只剩下一个节点，那么整个一层就可以干掉了。</p></li></ul><p>（3）查询节点：介绍跳表的图中已说明</p><h3 id="跳表的应用"><a href="#跳表的应用" class="headerlink" title="跳表的应用"></a>跳表的应用</h3><p>ConcurrentSkipListMap </p><p>ConcurrentSkipListSet </p><p>Redis sorted set的内部使用HashMap和跳跃表(SkipList)</p><h3 id="4、跳表与其他数据结构的比较"><a href="#4、跳表与其他数据结构的比较" class="headerlink" title="4、跳表与其他数据结构的比较"></a>4、跳表与其他数据结构的比较</h3><ul><li>跳跃表 vs 二叉查找树</li></ul><p>二叉查找树的插入、删除、查找也是近似 O(logn) 的时间复杂度。 不过，二叉查找树是有可能偏向一方，将退化成O(n)的链表</p><ul><li>跳跃表 vs 红黑树</li></ul><p>红黑在查找，插入，删除也是近似O(logn)的时间复杂度，通过旋转（改变了原本数据结构）达到近似平衡，比起跳跃表直接通过一个随机数来决定跨越几层要复杂得多</p><p>java提供了工业级的红黑树TreeMap,但是链表并没有，需要自己手动实现。</p>]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跳跃链表skipList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式原则</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>设计模式遵循的七大原则：</p><h3 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h3><p>出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p><ul><li>类中的代码行数、函数或者属性过多；</li><li>类依赖的其他类过多，或者依赖类的其他类过多；</li><li>私有方法过多；</li><li>比较难给类起一个合适的名字；</li><li>类中大量的方法都是集中操作类中的某几个属性。</li></ul><p>单一职责原则 要求一个接口或类只有一个原因引起变化</p><p>对类来说的，即一个类应该只负责一项职责。<br>意在原子性，降低类之间的耦合度。</p><h3 id="2、里氏替换原则"><a href="#2、里氏替换原则" class="headerlink" title="2、里氏替换原则"></a>2、里氏替换原则</h3><p>==翻译就是：复合优于继承，因为继承会增加类的耦合性。==</p><p>里氏替换原则为良好的继承定义了一个规范.</p><p>1.子类必须完全实现父类的方法,如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发 生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。</p><p>2.子类可以有自己的个性</p><p>3.覆盖或实现父类的方法时输入参数可以被放大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Father &#123;</span><br><span class="line">    public Collection doSomething(HashMap map)&#123;</span><br><span class="line">        System.out.println(&quot;父类被执行...&quot;);</span><br><span class="line">        return map.values();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Son extends Father &#123;</span><br><span class="line">&#x2F;&#x2F;放大输入参数类型</span><br><span class="line">    public Collection doSomething(HashMap map)&#123;</span><br><span class="line">        System.out.println(&quot;子类被执行...&quot;);</span><br><span class="line">        return map.values();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;父类存在的地方，子类就应该能够存在</span><br><span class="line">Father f &#x3D; new Father(); </span><br><span class="line">HashMap map &#x3D; new HashMap();</span><br><span class="line">f.doSomething(map);</span><br><span class="line">&#x2F;&#x2F;父类被执行</span><br><span class="line"></span><br><span class="line">Son f &#x3D;new Son(); </span><br><span class="line">HashMap map &#x3D; new HashMap();</span><br><span class="line">f.doSomething(map);</span><br><span class="line">&#x2F;&#x2F;父类被执行</span><br></pre></td></tr></table></figure><ol start="4"><li>覆写或实现父类的方法时输出结果可以被缩小</li></ol><p>如果是覆写，父类和子类的同名方法的 输入参数是相同的，两个方法的范围值S小于等于T，这是覆写的要求，</p><p>如果是重载，则要求方法的输入参数类型或数量不相同，在 里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这 个方法是不会被调用的</p><p>==总结==：在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，这个子 类和父类之间的关系就很难调和了</p><h3 id="3、依赖倒转原则"><a href="#3、依赖倒转原则" class="headerlink" title="3、依赖倒转原则"></a>3、依赖倒转原则</h3><p>翻译就是：注重面向接口编程</p><p>具体依赖倒置原则在Java语言中的表现就是：</p><ul><li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过 接口或抽象类产生的； </li><li>接口或抽象类不依赖于实现类； </li><li>实现类依赖接口或抽象类。</li></ul><h3 id="4、接口隔离原则"><a href="#4、接口隔离原则" class="headerlink" title="4、接口隔离原则"></a>4、接口隔离原则</h3><p>尽量使用多个隔离的接口，比融合使用单个接口要好。也是意在原子性，降低类之间的耦合度。</p><h3 id="5、开闭原则"><a href="#5、开闭原则" class="headerlink" title="5、开闭原则"></a>5、开闭原则</h3><p>一个类应该对调用方扩展开放，对修改关闭。即在程序需要进行功能拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。注重面向接口编程</p><h3 id="6、迪米特法则"><a href="#6、迪米特法则" class="headerlink" title="6、迪米特法则"></a>6、迪米特法则</h3><p>又称最少知道原则。即一个类对自己依赖的类知道的<br>越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public 方法，不对外泄露任何信息。注重封装性</p><h3 id="7、合成复用原则"><a href="#7、合成复用原则" class="headerlink" title="7、合成复用原则"></a>7、合成复用原则</h3><p>尽量使用合成/聚合的方式，而不是使用继承。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式原则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVC</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/MVC/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/MVC/</url>
      
        <content type="html"><![CDATA[<p>MVC 三层架构中的 M 表示 Model，V 表示 View，C 表示 Controller。它将整个项目分为三层：展示层、逻辑层、数据层。MVC 三层开发架构是一个比较笼统的分层方式，落实到具体的开发层面，很多项目也并不会 100% 遵从 MVC 固定的分层方式，而是会根据具体的项目需求，做适当的调整。</p><p>比如，现在很多 Web 或者 App 项目都是前后端分离的，后端负责暴露接口给前端调用。这种情况下，我们一般就将后端项目分为 Repository 层、Service 层、Controller 层。其中，Repository 层负责数据访问，Service 层负责业务逻辑，Controller 层负责暴露接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Controller+VO(View Object) &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">public class UserController &#123;</span><br><span class="line">  private UserService userService; &#x2F;&#x2F;通过构造函数或者IOC框架注入</span><br><span class="line">  </span><br><span class="line">  public UserVo getUserById(Long userId) &#123;</span><br><span class="line">    UserBo userBo &#x3D; userService.getUserById(userId);</span><br><span class="line">    UserVo userVo &#x3D; [...convert userBo to userVo...];</span><br><span class="line">    return userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserVo &#123;&#x2F;&#x2F;省略其他属性、get&#x2F;set&#x2F;construct方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private String name;</span><br><span class="line">  private String cellphone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Service+BO(Business Object) &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">public class UserService &#123;</span><br><span class="line">  private UserRepository userRepository; &#x2F;&#x2F;通过构造函数或者IOC框架注入</span><br><span class="line">  </span><br><span class="line">  public UserBo getUserById(Long userId) &#123;</span><br><span class="line">    UserEntity userEntity &#x3D; userRepository.getUserById(userId);</span><br><span class="line">    UserBo userBo &#x3D; [...convert userEntity to userBo...];</span><br><span class="line">    return userBo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserBo &#123;&#x2F;&#x2F;省略其他属性、get&#x2F;set&#x2F;construct方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private String name;</span><br><span class="line">  private String cellphone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Repository+Entity &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">public class UserRepository &#123;</span><br><span class="line">  public UserEntity getUserById(Long userId) &#123; &#x2F;&#x2F;... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserEntity &#123;&#x2F;&#x2F;省略其他属性、get&#x2F;set&#x2F;construct方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private String name;</span><br><span class="line">  private String cellphone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="贫血模型"><a href="#贫血模型" class="headerlink" title="贫血模型"></a>贫血模型</h5><p>UserBo 是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在 UserService 中。我们通过 UserService 来操作 UserBo。换句话说，Service 层的数据和业务逻辑，被分割为 BO 和 Service 两个类中。像 UserBo,UserEntity、UserVo 这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型</p><p>这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。</p><h5 id="充血模型"><a href="#充血模型" class="headerlink" title="充血模型"></a>充血模型</h5><p>最近更加被推崇的开发模式：基于充血模型的 DDD 开发模式。<br>在贫血模型中，数据和业务逻辑被分割到不同的类中。</p><p>充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。</p><p>两种开发模式，落实到代码层面，区别在于一个将业务逻辑放到 Service 类中，一个将业务逻辑放到 Domain 领域模型中。</p><p>两种不同的开发模式会导致不同的开发流程。</p><p>大部分都是 SQL 驱动，业务逻辑包裹在一个大的 SQL 语句中，而 Service 层可以做的事情很少。SQL 都是针对特定的业务功能编写的，复用性差。当我要开发另一个业务功能的时候，只能重新写个满足新需求的 SQL 语句</p><p>在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单向循环链表</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2%E3%80%81%E9%93%BE%E8%A1%A8/2%E3%80%81%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2%E3%80%81%E9%93%BE%E8%A1%A8/2%E3%80%81%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="单向循环链表"><a href="#单向循环链表" class="headerlink" title="单向循环链表"></a>单向循环链表</h4><p>单向循环链表跟单链表==唯一的区别就在尾结点==。单链表的尾结点指针指向空地址，表示这就是最后的结点了。</p><p>而循环链表的尾结点指针是指向链表的头结点。<br><img src="https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg" alt="image"></p><p>单向循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;单向循环链表类</span><br><span class="line">public class CycleLinkList implements List &#123;</span><br><span class="line"></span><br><span class="line">    Node head; &#x2F;&#x2F;头指针</span><br><span class="line">    Node current;&#x2F;&#x2F;当前结点对象</span><br><span class="line">    int size;&#x2F;&#x2F;结点个数</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;初始化一个空链表</span><br><span class="line">    public CycleLinkList()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;初始化头结点，让头指针指向头结点。并且让当前结点对象等于头结点。</span><br><span class="line">        this.head &#x3D; current &#x3D; new Node(null);</span><br><span class="line">        this.size &#x3D;0;&#x2F;&#x2F;单向链表，初始长度为零。</span><br><span class="line">        this.head.next &#x3D; this.head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;定位函数，实现当前操作对象的前一个结点，也就是让当前结点对象定位到要操作结点的前一个结点。</span><br><span class="line">    &#x2F;&#x2F;比如我们要在a2这个节点之前进行插入操作，那就先要把当前节点对象定位到a1这个节点，然后修改a1节点的指针域</span><br><span class="line">    public void index(int index) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        if(index &lt;-1 || index &gt; size -1)</span><br><span class="line">        &#123;</span><br><span class="line">          throw new Exception(&quot;参数错误！&quot;);    </span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;说明在头结点之后操作。</span><br><span class="line">        if(index&#x3D;&#x3D;-1)    &#x2F;&#x2F;因为第一个数据元素结点的下标是0，那么头结点的下标自然就是-1了。</span><br><span class="line">            return;</span><br><span class="line">        current &#x3D; head.next;</span><br><span class="line">        int j&#x3D;0;&#x2F;&#x2F;循环变量</span><br><span class="line">        while(current !&#x3D; head&amp;&amp;j&lt;index)</span><br><span class="line">        &#123;</span><br><span class="line">            current &#x3D; current.next;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void delete(int index) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        &#x2F;&#x2F;判断链表是否为空</span><br><span class="line">        if(isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            throw new Exception(&quot;链表为空，无法删除！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(index &lt;0 ||index &gt;size)</span><br><span class="line">        &#123;</span><br><span class="line">            throw new Exception(&quot;参数错误！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        index(index-1);&#x2F;&#x2F;定位到要操作结点的前一个结点对象。</span><br><span class="line">        current.setNext(current.next.next);</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object get(int index) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        if(index &lt;-1 || index &gt;size-1)</span><br><span class="line">        &#123;</span><br><span class="line">            throw new Exception(&quot;参数非法！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        index(index);</span><br><span class="line">        </span><br><span class="line">        return current.getElement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void insert(int index, Object obj) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        if(index &lt;0 ||index &gt;size)</span><br><span class="line">        &#123;</span><br><span class="line">            throw new Exception(&quot;参数错误！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        index(index-1);&#x2F;&#x2F;定位到要操作结点的前一个结点对象。</span><br><span class="line">        current.setNext(new Node(obj,current.next));</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        return size&#x3D;&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        return this.size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单向循环链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息广播</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/3%E3%80%81RocketMQ/8%E3%80%81%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/3%E3%80%81RocketMQ/8%E3%80%81%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<p>上面发送消息，我们测试的时候，可以发现消息只有一个消费者能收到，如果我们想实现消息广播，让每个消费者都能收到消息也是可以实现的。而且上面发送消息的时候，每次都是发送单条Message对象，能否批量发送呢？答案是可以的。</p><h3 id="广播生产者："><a href="#广播生产者：" class="headerlink" title="广播生产者："></a>广播生产者：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class BroadcastingProducer &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;nameserver地址</span><br><span class="line">    private static String namesrvaddress&#x3D;&quot;192.168.211.143:9876;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws UnsupportedEncodingException, MQClientException, RemotingException, InterruptedException, MQBrokerException &#123;</span><br><span class="line">        &#x2F;&#x2F;创建DefaultMQProducer</span><br><span class="line">        DefaultMQProducer producer &#x3D; new DefaultMQProducer(&quot;broadcasting_producer_group&quot;);</span><br><span class="line">        &#x2F;&#x2F;指定nameserver地址</span><br><span class="line">        producer.setNamesrvAddr(namesrvaddress);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;启动</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建消息</span><br><span class="line">        List&lt;Message&gt; messages &#x3D; new ArrayList&lt;Message&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt;20 ; i++) &#123;</span><br><span class="line">            Message message &#x3D; new Message(</span><br><span class="line">                    &quot;Topic_broadcasting&quot;,</span><br><span class="line">                    &quot;TagBroad&quot;,</span><br><span class="line">                    &quot;KeyBroad&quot;+i,</span><br><span class="line">                    (i+&quot;--hello brodcasting&quot;).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;将消息添加到集合中</span><br><span class="line">            messages.add(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;批量发送消息</span><br><span class="line">        producer.send(messages);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;关闭</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><p>==广播消费模式其实就是每个消费者都能读取到消息，我们这里只需要将消费者的消费模式设置成广播模式即可。==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class BroadcastingConsumerDemo1 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;广播模式</span><br><span class="line">    private static String namesrvaddress&#x3D;&quot;192.168.211.143:9876;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws MQClientException &#123;</span><br><span class="line">        &#x2F;&#x2F;创建DefaultMQConsumer</span><br><span class="line">        DefaultMQPushConsumer consumer &#x3D; new DefaultMQPushConsumer(&quot;broadcasting_consumer_group&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;指定nameserver地址</span><br><span class="line">        consumer.setNamesrvAddr(namesrvaddress);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;指定要消费的消息主体</span><br><span class="line">        consumer.subscribe(&quot;Topic_broadcasting&quot;,&quot;*&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;指定消费顺序</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;指定一次拉取条数</span><br><span class="line">        consumer.setConsumeMessageBatchMaxSize(2);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;指定消费模式    集群模式&#x2F;广播模式</span><br><span class="line">        consumer.setMessageModel(MessageModel.BROADCASTING);</span><br><span class="line">        &#x2F;&#x2F;创建监听，监听消息</span><br><span class="line">        consumer.setMessageListener(new MessageListenerConcurrently() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">                for (MessageExt msg : msgs) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        String topic &#x3D; msg.getTopic();</span><br><span class="line">                        String tags &#x3D; msg.getTags();</span><br><span class="line">                        String keys &#x3D; msg.getKeys();</span><br><span class="line">                        String body &#x3D; new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);</span><br><span class="line">                        System.out.println(&quot;demo1        topic:&quot;+topic+&quot;,tags:&quot;+tags+&quot;,keys:&quot;+keys+&quot;,body:&quot;+body);</span><br><span class="line">                    &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;启动</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息广播 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringTask</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/8%E3%80%81%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/SpringTask/SpringTask/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/8%E3%80%81%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/SpringTask/SpringTask/</url>
      
        <content type="html"><![CDATA[<p>定时任务的几种实现：</p><ul><li>java自带的Timer</li><li>Quartz</li><li>轻量级的Quartz：Spring Task</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Timer().schedule(new TimerTask() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">&#x2F;&#x2F;业务实现</span><br><span class="line">&#125;</span><br><span class="line">&#125;, date, long);</span><br></pre></td></tr></table></figure><h3 id="1、添加定时任务"><a href="#1、添加定时任务" class="headerlink" title="1、添加定时任务"></a>1、添加定时任务</h3><ul><li>1、启动类中开启定时任务：@EnableScheduling</li><li>2、新建任务类，加入spring.在方法上添加注解：@Scheduled</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class TestJob &#123;</span><br><span class="line">    private static final Logger log &#x3D; LoggerFactory.getLogger(TestJob.class);</span><br><span class="line">    private static int count;</span><br><span class="line"></span><br><span class="line">    @Scheduled(cron &#x3D; &quot;0&#x2F;10 * * * * ?&quot;)</span><br><span class="line">    public void cron() &#123;</span><br><span class="line">        log.info(&quot;spring anno task execute times &#123;&#125;&quot;, count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Scheduled所支持的参数：</p><ul><li>cron：cron表达式，指定任务在特定时间执行；</li><li>fixedDelay：表示上一次任务执行完成后多久再次执行，参数类型为long，单位ms；</li><li>fixedDelayString：与fixedDelay含义一样，只是参数类型变为String；</li><li>fixedRate：表示按一定的频率执行任务，参数类型为long，单位ms；</li><li>fixedRateString: 与fixedRate的含义一样，只是将参数类型变为String；</li><li>initialDelay：表示延迟多久再第一次执行任务，参数类型为long，单位ms；</li><li>initialDelayString：与initialDelay的含义一样，只是将参数类型变为String；</li><li>zone：时区，默认为当前时区，一般没有用到。</li></ul><h3 id="2、动态修改cron-参数："><a href="#2、动态修改cron-参数：" class="headerlink" title="2、动态修改cron 参数："></a>2、动态修改cron 参数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class TaskCronChange implements SchedulingConfigurer &#123;</span><br><span class="line">    &#x2F;&#x2F;原cron</span><br><span class="line">    private String expression &#x3D; &quot;* * * * * *&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;动态修改</span><br><span class="line">    @RequestMapping(&quot;changeExpression&quot;)</span><br><span class="line">    public void changeExpression() &#123;</span><br><span class="line">        expression &#x3D; &quot;0&#x2F;10 * * * * *&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123;</span><br><span class="line"></span><br><span class="line">        taskRegistrar.addTriggerTask(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F;执行的任务</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, new Trigger() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Date nextExecutionTime(TriggerContext triggerContext) &#123;</span><br><span class="line">                CronTrigger trigger &#x3D; new CronTrigger(expression);</span><br><span class="line">                return trigger.nextExecutionTime(triggerContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、动态添加-删除定时任务"><a href="#3、动态添加-删除定时任务" class="headerlink" title="3、动态添加 删除定时任务"></a>3、动态添加 删除定时任务</h3><ul><li>ThreadPoolTaskScheduler，线程任务调度类，能开启线程池进行任务调度。</li><li>ThreadPoolTaskScheduler.Schedule()方法会创建一个定时计划ScheduledFuture。这个计划可以停止定时任务。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@EnableScheduling</span><br><span class="line">@RequestMapping(&quot;&#x2F;DynamicTask&quot;)</span><br><span class="line">public class DynamicTask &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    ThreadPoolTaskScheduler poolTaskScheduler;</span><br><span class="line">    private ScheduledFuture&lt;?&gt; schedule;</span><br><span class="line">    private String cron &#x3D; &quot;* * * * * *&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    private ThreadPoolTaskScheduler poolTaskScheduler() &#123;</span><br><span class="line">        return new ThreadPoolTaskScheduler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;startTask&quot;)</span><br><span class="line">    private String startTask() &#123;</span><br><span class="line">        schedule &#x3D;poolTaskScheduler.schedule(new MyRunnable(), new CronTrigger(cron));</span><br><span class="line">        return &quot;startTask&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;stopTask&quot;)</span><br><span class="line">    private String stopTask() &#123;</span><br><span class="line">        if (schedule !&#x3D; null) &#123;</span><br><span class="line">            schedule.cancel(true);</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;stopTask&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;changeCron&quot;)</span><br><span class="line">    private String changeCron() &#123;</span><br><span class="line">        stopTask();</span><br><span class="line">        cron &#x3D; &quot;0&#x2F;5 * * * * *&quot;;</span><br><span class="line">        startTask();</span><br><span class="line">        return &quot;change Cron&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class MyRunnable implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.err.println(&quot;DynamicTask run&quot; + new Date());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringTask </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringTask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring事务原理</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/4%E3%80%81spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/4%E3%80%81spring%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>==Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。事务管理建立在AOP之上的。对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。==</p><p>对于纯JDBC操作数据库，想要用到事务，可以按照以下步骤进行</p><ul><li>1.获取连接 Connection con = DriverManager.getConnection() 2.开启事务con.setAutoCommit(true/false); </li><li>3.执行CRUD </li><li>4.提交事务/回滚事务 con.commit() / con.rollback();</li><li>5.关闭连接 conn.close();</li></ul><p>使用Spring的事务管理功能后，我们可以不再写步骤 2 和 4 的代码，而是由Spirng 自动完成</p><p>并发下事务会产生的问题:</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读:"></a>脏读:</h3><p>==事务A读到了事务B还没有提交的数据:==</p><p>比如银行取钱，事务A开启事务，此时切换到事务B，事务B开启事务–&gt;取走100元，此时切换回事务A，事务A读取的肯定是数据库里面的原始数据，因为事务B取走了100块钱，并没有提交，数据库里面的账务余额肯定还是原始余额，这就是脏读。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>==在一个事务里面读取了两次某个数据，读出来的数据不一致==</p><p>还是以银行取钱为例，事务A开启事务–&gt;查出银行卡余额为1000元，此时切换到事务B事务B开启事务–&gt;事务B取走100元–&gt;提交，数据库里面余额变为900元，此时切换回事务A，事务A再查一次查出账户余额为900元，这样对事务A而言，在同一个事务内两次读取账户余额数据不一致，这就是不可重复读</p><h3 id="幻读："><a href="#幻读：" class="headerlink" title="幻读："></a>幻读：</h3><p>==在一个事务里面的操作中发现了未被操作的数据==。</p><p>比如学生信息，事务A开启事务–&gt;修改所有学生当天签到状况为false，此时切换到事务B，事务B开启事务–&gt;事务B插入了一条学生数据，此时切换回事务A，事务A提交的时候发现了一条自己没有修改过的数据，这就是幻读，就好像发生了幻觉一样。幻读出现的前提是并发的事务中有事务发生了插入、删除操作。</p><h2 id="事务隔离级别，"><a href="#事务隔离级别，" class="headerlink" title="事务隔离级别，"></a>事务隔离级别，</h2><p>就是为了解决上面几种问题而诞生的。为什么要有事务隔离级别，因为事务隔离级别越高，在并发下会产生的问题就越少，但同时付出的性能消耗也将越大，因此很多时候必须在并发性和性能之间做一个权衡</p><ul><li><h3 id="读未提交-Read-uncommitted："><a href="#读未提交-Read-uncommitted：" class="headerlink" title="读未提交 Read uncommitted："></a>读未提交 Read uncommitted：</h3>就是一个事务可以读取另一个未提交事务的数据。这个级别的隔离机制无法解决脏读、不可重复读、幻读中的任何一种，因此很少使用</li><li><h3 id="读已提交-READ-COMMITED"><a href="#读已提交-READ-COMMITED" class="headerlink" title="读已提交 READ_COMMITED"></a>读已提交 READ_COMMITED</h3></li></ul><p>就是一个事务要等另一个事务提交后才能读取数据。锁定正在读取的行</p><p>防止脏读，但是无法限制不可重复读和幻读</p><ul><li><h3 id="重复读取：REPEATABLE-READ"><a href="#重复读取：REPEATABLE-READ" class="headerlink" title="重复读取：REPEATABLE_READ"></a>重复读取：REPEATABLE_READ</h3></li></ul><p>即在数据读出来之后加锁，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决，锁定所读取的所有行</p><ul><li><h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3>最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务。解决所有事务并发问题。但是效率最低。锁表</li></ul>]]></content>
      
      
      <categories>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring事务原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户管理</title>
      <link href="2020/06/21/Study%20notes/7%E3%80%81linux/linux/2%E3%80%81%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/7%E3%80%81linux/linux/2%E3%80%81%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><h5 id="添加账号"><a href="#添加账号" class="headerlink" title="添加账号"></a>添加账号</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd 选项 用户名</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">选项:</span><br><span class="line">-c comment 指定一段注释性描述。</span><br><span class="line">-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</span><br><span class="line">-g 用户组 指定用户所属的用户组。</span><br><span class="line">-G 用户组，用户组 指定用户所属的附加组。</span><br><span class="line">-s Shell文件 指定用户的登录Shell。</span><br><span class="line">-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># useradd appuser</span><br><span class="line"># useradd –d  &#x2F;home&#x2F;appuser -m sam</span><br><span class="line"># useradd -s &#x2F;bin&#x2F;sh -g group –G adm,root appuser</span><br></pre></td></tr></table></figure><h5 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">passwd 选项 用户名</span><br><span class="line"></span><br><span class="line">选项</span><br><span class="line">-l 锁定口令，即禁用账号。</span><br><span class="line">-u 口令解锁。</span><br><span class="line">-d 使账号无口令。</span><br><span class="line">-f 强迫用户下次登录时修改口令。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># passwd appuser </span><br><span class="line">New password:******* </span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure><h5 id="删除帐号"><a href="#删除帐号" class="headerlink" title="删除帐号"></a>删除帐号</h5><p>删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># userdel -r appuser</span><br><span class="line"></span><br><span class="line">#选项 -r，它的作用是否需要把用户的主目录一起删除。</span><br></pre></td></tr></table></figure><h5 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usermod 选项 用户名</span><br><span class="line">#选项与添加账户的一致</span><br></pre></td></tr></table></figure><h5 id="查询用户："><a href="#查询用户：" class="headerlink" title="查询用户："></a>查询用户：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id appuser</span><br></pre></td></tr></table></figure><h5 id="切换用户："><a href="#切换用户：" class="headerlink" title="切换用户："></a>切换用户：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - appuser</span><br></pre></td></tr></table></figure><h5 id="添加用户组"><a href="#添加用户组" class="headerlink" title="添加用户组"></a>添加用户组</h5><p>每个用户都必须属于一个用户组，不能独立于组外。系统可以对一个用户组中的所有用户进行集中管理</p><p>groupadd 选项 用户组</p><p>g GID 指定新用户组的组标识号（GID）。<br>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># groupadd -g 101 appuserGroup</span><br></pre></td></tr></table></figure><h5 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel appuserGroup</span><br></pre></td></tr></table></figure><h5 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">groupmod 选项 用户组</span><br><span class="line"></span><br><span class="line">选项</span><br><span class="line">-g GID 为用户组指定新的组标识号。</span><br><span class="line">-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</span><br><span class="line">-n新用户组 将用户组的名字改为新名字</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#组appuserGroup的标识号改为10000，组名修改为appuserGroupNew</span><br><span class="line"># groupmod –g 10000 -n appuserGroup appuserGroupNew</span><br></pre></td></tr></table></figure><h5 id="linux找回root密码"><a href="#linux找回root密码" class="headerlink" title="linux找回root密码"></a>linux找回root密码</h5><p>首先需要知道linux的运行级别：</p><p>linux的init进程就是根据/etc/inittab这个文件来在不同的运行级别启动相应的进程或执行相应的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id：runlevels：action：process</span><br></pre></td></tr></table></figure><ul><li>id：它是每个登记项的标识符，用于唯一标识每个登记项，不能重复</li><li>runlevels：系统的运行级别，表示process的action要在哪个级别下运行，该段中可以定义多个运行级别，各级别之间直接写不用分隔符；如果为空，表示在所有的运行级别运行。Linux的运行级别有：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0：表示关机</span><br><span class="line">1：表示单用户模式，在这个模式中，用户登录不需要密码，默认网卡驱动是不被加载，一些服务不能用。</span><br><span class="line">2：表示多用户模式，NFS服务不开启</span><br><span class="line">3，表示命令行模式（常用）</span><br><span class="line">4，这个模式保留未用</span><br><span class="line">5，表示图形用户模式（常用）</span><br><span class="line">6，表示重启系统</span><br></pre></td></tr></table></figure><p>切换到指定的运行级别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init 1</span><br></pre></td></tr></table></figure><p>进入单用户模式，使用passwd指令修改root密码</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用户管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组练习</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1%E3%80%81%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84%E7%BB%83%E4%B9%A0/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1%E3%80%81%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>在一个数组长度为n的数组里，所有数字都在 0 ~ n-1 范围内，数组中某些数字是重复的，但不知道几个数字重复了，也不知道每个数字重复了多少次，请找出数组中重复的数字。</p><p>时间复杂度为O（n）</p><p>1、把当前序列当成是一个下标和下标对应值是相同的数组；</p><p>2、遍历数组，判断当前位的值和下标是否相等： </p><ul><li>若相等，则遍历下一位； </li><li>若不等，则将当前位置i上的元素和a[i]位置上的元素比较：若它们相等，则成功！若不等，则将它们两交换。换完之后a[i]位置上的值和它的下标是对应的，但i位置上的元素和下标并不一定对应；重复2.2的操作，直到当前位置i的值也为i，将i向后移一位，再重复2.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public boolean duplicate(int array[],int length,int [] duplication) &#123;</span><br><span class="line">    if ( array&#x3D;&#x3D;null ) return false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 判断数组是否合法（每个数都在0~n-1之间）</span><br><span class="line">    for ( int i&#x3D;0; i&lt;length; i++ ) &#123;</span><br><span class="line">        if ( array[i]&lt;0 || array[i]&gt;length-1 ) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; key step</span><br><span class="line">    for( int i&#x3D;0; i&lt;length; i++ )&#123;</span><br><span class="line">        while( i!&#x3D;array[i] )&#123;</span><br><span class="line">            if ( array[i] &#x3D;&#x3D; array[array[i]] ) &#123;</span><br><span class="line">                duplication[0] &#x3D; array[i];</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int temp &#x3D; array[i];</span><br><span class="line">            array[i] &#x3D; array[array[i]];</span><br><span class="line">            array[array[i]] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不修改原数组顺序解法（分割统计）"><a href="#不修改原数组顺序解法（分割统计）" class="headerlink" title="不修改原数组顺序解法（分割统计）"></a>不修改原数组顺序解法（分割统计）</h3></li></ul><p>首先将数组一分为二，假设数组有8个元素。那么元素大小都在 0 ~ 7 之间。一分为二，如果没有重复，四个元素在 0 ~ 3 之间，四个在 4 ~ 7 之间。假设数组为arr[8] = {1, 0, 2, 3, 3, 4, 5, 6}，统计0 ~ 3 之间的元素有5个， 统计 4 ~ 7 之间的元素有3个。说明，在 0 ~ 3 之间肯定有重复元素。接下来划分 0 ~ 3的5个元素{1， 0， 2， 3， 3}。 0 ~ 1 之间有两个元素， 2~3之间有三个元素。再划分2 ~ 3之间的元素，2有一个，3有两个，所以重复的是元素3。</p><h3 id="二维数组中的查找："><a href="#二维数组中的查找：" class="headerlink" title="二维数组中的查找："></a>二维数组中的查找：</h3><p>在一个二维数组中，每一行都按照从左到右，递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输出这样的一个二维数组和一个整数，判断数组中是否包含该整数。</p><p>首先我们我们选取数组右上角的数字9.由于9大于7，并且9还是第4列的第一个（也是最小的），因此7不可能出现在数字9所在的列。于是我们把这一列从需要考虑的区域去除掉，之后只需要分析剩下的3列。在剩下的矩阵中，位于右上角的数字是8.同样大于7，因此8所在的列我们也可以去除。接下来继续分析。</p><p>在剩余的俩列中，位于右上角的数字2小于7，那么要查找的7可能在2的右边，也可能在2的下边。在前面的过程中，已经将2右边的列都给去除掉了，也就是说7不可能出现在2的右边，因此7只能出现在2的下边，于是把2所在的行去除。在剩下的数字中，数字4位于右上角，同2.最后剩下俩行俩列数字。</p><p>在剩下的俩行俩列数字中，位于右上角的刚好是7，于是查找的过程就结束了。<br><img src="https://img-blog.csdn.net/20180521180544813" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。就是通过复制生成实例</p><p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p><h3 id="步骤-1：创建一个实现了-Clonable-接口的抽象类。"><a href="#步骤-1：创建一个实现了-Clonable-接口的抽象类。" class="headerlink" title="步骤 1：创建一个实现了 Clonable 接口的抽象类。"></a>步骤 1：创建一个实现了 Clonable 接口的抽象类。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Shape implements Cloneable &#123;</span><br><span class="line">   </span><br><span class="line">   private String id;</span><br><span class="line">   protected String type;</span><br><span class="line">   &#x2F;&#x2F;get set方法</span><br><span class="line">   </span><br><span class="line">   abstract void draw();</span><br><span class="line">   </span><br><span class="line">   public Object clone() &#123;</span><br><span class="line">      Object clone &#x3D; null;</span><br><span class="line">      try &#123;</span><br><span class="line">         clone &#x3D; super.clone();</span><br><span class="line">      &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      return clone;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2：创建扩展了上面抽象类的实体类。"><a href="#步骤-2：创建扩展了上面抽象类的实体类。" class="headerlink" title="步骤 2：创建扩展了上面抽象类的实体类。"></a>步骤 2：创建扩展了上面抽象类的实体类。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle extends Shape &#123;</span><br><span class="line"> </span><br><span class="line">   public Rectangle()&#123;</span><br><span class="line">     type &#x3D; &quot;Rectangle&quot;;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Square extends Shape &#123;</span><br><span class="line"> </span><br><span class="line">   public Square()&#123;</span><br><span class="line">     type &#x3D; &quot;Square&quot;;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Square::draw() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Circle extends Shape &#123;</span><br><span class="line"> </span><br><span class="line">   public Circle()&#123;</span><br><span class="line">     type &#x3D; &quot;Circle&quot;;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Inside Circle::draw() method.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-3：创建一个类，从数据库获取实体类，并把它们存储在一个-Hashtable-中。"><a href="#步骤-3：创建一个类，从数据库获取实体类，并把它们存储在一个-Hashtable-中。" class="headerlink" title="步骤 3：创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中。"></a>步骤 3：创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Hashtable;</span><br><span class="line"> </span><br><span class="line">public class ShapeCache &#123;</span><br><span class="line">    </span><br><span class="line">   private static Hashtable&lt;String, Shape&gt; shapeMap </span><br><span class="line">      &#x3D; new Hashtable&lt;String, Shape&gt;();</span><br><span class="line"> </span><br><span class="line">   public static Shape getShape(String shapeId) &#123;</span><br><span class="line">      Shape cachedShape &#x3D; shapeMap.get(shapeId);</span><br><span class="line">      return (Shape) cachedShape.clone();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 对每种形状都运行数据库查询，并创建该形状</span><br><span class="line">   &#x2F;&#x2F; shapeMap.put(shapeKey, shape);</span><br><span class="line">   &#x2F;&#x2F; 例如，我们要添加三种形状</span><br><span class="line">   public static void loadCache() &#123;</span><br><span class="line">      Circle circle &#x3D; new Circle();</span><br><span class="line">      circle.setId(&quot;1&quot;);</span><br><span class="line">      shapeMap.put(circle.getId(),circle);</span><br><span class="line"> </span><br><span class="line">      Square square &#x3D; new Square();</span><br><span class="line">      square.setId(&quot;2&quot;);</span><br><span class="line">      shapeMap.put(square.getId(),square);</span><br><span class="line"> </span><br><span class="line">      Rectangle rectangle &#x3D; new Rectangle();</span><br><span class="line">      rectangle.setId(&quot;3&quot;);</span><br><span class="line">      shapeMap.put(rectangle.getId(),rectangle);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-4：PrototypePatternDemo-使用-ShapeCache-类来获取存储在-Hashtable-中的形状的克隆。"><a href="#步骤-4：PrototypePatternDemo-使用-ShapeCache-类来获取存储在-Hashtable-中的形状的克隆。" class="headerlink" title="步骤 4：PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆。"></a>步骤 4：PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class PrototypePatternDemo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ShapeCache.loadCache();</span><br><span class="line"> </span><br><span class="line">      Shape clonedShape &#x3D; (Shape) ShapeCache.getShape(&quot;1&quot;);</span><br><span class="line">      System.out.println(&quot;Shape : &quot; + clonedShape.getType());        </span><br><span class="line"> </span><br><span class="line">      Shape clonedShape2 &#x3D; (Shape) ShapeCache.getShape(&quot;2&quot;);</span><br><span class="line">      System.out.println(&quot;Shape : &quot; + clonedShape2.getType());        </span><br><span class="line"> </span><br><span class="line">      Shape clonedShape3 &#x3D; (Shape) ShapeCache.getShape(&quot;3&quot;);</span><br><span class="line">      System.out.println(&quot;Shape : &quot; + clonedShape3.getType());        </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存架构设计vs问题解决方案</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F/%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1vs%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F/%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1vs%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h3 id="2、更新缓存两种方式："><a href="#2、更新缓存两种方式：" class="headerlink" title="2、更新缓存两种方式："></a>2、更新缓存两种方式：</h3><p>lazy计算的思想，先删除缓存，然后再更新数据库。不要每次都重新做复杂的计算得出缓存值，不管它会不会用到，而是让它到需要被使用的时候再重新计算。</p><h3 id="大型缓存全量更新问题的解决方案"><a href="#大型缓存全量更新问题的解决方案" class="headerlink" title="大型缓存全量更新问题的解决方案"></a>大型缓存全量更新问题的解决方案</h3><p>问题：缓存数据很大时，可能导致redis的吞吐量就会急剧下降，网络耗费的资源大。如果不维度化，就导致多个维度的数据混合在一个缓存value中。而且不同维度的数据，可能更新的频率都大不一样。拿商品详情页来说，如果现在只是将1000个商品的分类批量调整了一下，但是如果商品分类的数据和商品本身的数据混杂在一起。那么可能导致需要将包括商品在内的大缓存value取出来，进行更新，再写回去，就会很坑爹，耗费大量的资源，redis压力也很大</p><p>方案：缓存维度化。举个例子：商品详情页分三个维度：商品维度，商品分类维度，商品店铺维度。将每个维度的数据都存一份，比如说商品维度的数据存一份，商品分类的数据存一份，商品店铺的数据存一份。那么在不同的维度数据更新的时候，只要去更新对应的维度就可以了。大大减轻了redis的压力。</p><h3 id="缓存冷启动的问题的解决方案"><a href="#缓存冷启动的问题的解决方案" class="headerlink" title="缓存冷启动的问题的解决方案"></a>缓存冷启动的问题的解决方案</h3><p>问题：新系统第一次上线，此时在缓存里可能是没有数据的。或者redis缓存全盘崩溃了，数据也丢了。导致所有请求打到了mysql。导致mysql直接挂掉。</p><p>方案：缓存预热。</p><p>提前给redis中灌入部分数据，再提供服务</p><p>肯定不可能将所有数据都写入redis，因为数据量太大了，第一耗费的时间太长了，第二根本redis容纳不下所有的数据，需要根据当天的具体访问情况，实时统计出访问频率较高的热数据，然后将访问频率较高的热数据写入redis中，肯定是热数据也比较多，我们也得多个服务并行读取数据去写，并行的分布式的缓存预热。</p><h3 id="分布式并发缓存重建的冲突问题的解决方案（分布式锁）"><a href="#分布式并发缓存重建的冲突问题的解决方案（分布式锁）" class="headerlink" title="分布式并发缓存重建的冲突问题的解决方案（分布式锁）"></a>分布式并发缓存重建的冲突问题的解决方案（分布式锁）</h3><p>问题：假如数据在所有的缓存中都不存在了（LRU算法弄掉了），就需要重新查询数据写入缓存。对于分布式的重建缓存，在不同的机器上，不同的服务实例中，去做上面的事情，就会出现多个机器分布式重建去读取相同的数据，然后写入缓存中。</p><p>方案：分布式锁：如果你有多个机器在访问同一个共享资源，那么这个时候，如果你需要加个锁，让多个分布式的机器在访问共享资源的时候串行起来。分布式锁当然有很多种不同的实现方案，redis分布式锁，zookeeper分布式锁。</p><p>zookeeper分布式锁的解决并发冲突的方案</p><p>（1）变更缓存重建以及空缓存请求重建，更新redis之前，都需要先获取对应商品id的分布式锁</p><p>（2）拿到分布式锁之后，需要根据时间版本去比较一下，如果自己的版本新于redis中的版本，那么就更新，否则就不更新</p><p>（3）如果拿不到分布式锁，那么就等待，不断轮询等待，直到自己获取到分布式的锁</p>]]></content>
      
      
      <categories>
          
          <category> 缓存系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存架构设计vs问题解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC配置及扩展</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-boot/2%E3%80%81SpringMVC%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%89%A9%E5%B1%95/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-boot/2%E3%80%81SpringMVC%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<p>结合源码和文档分析：SpringBoot对SpringMVC做了哪些配置，哪些封装，以及如何扩展?</p><p>首先要掌握springmvc的原理。</p><p>文档：<a href="https://docs.spring.io/spring-boot/docs/2.0.0.RELEASE/reference/htmlsingle/#boot-features-spring-mvc">https://docs.spring.io/spring-boot/docs/2.0.0.RELEASE/reference/htmlsingle/#boot-features-spring-mvc</a></p><p>springboot对springmvc的配置的精髓：原文翻译</p><p>1、Spring Boot provides auto-configuration for Spring MVC that works well with most applications.<br>(springboot自动配置好了springmvc)</p><p>2、The auto-configuration adds the following features on top of Spring’s defaults:(以下是springboot对springmvc的默认配置：)</p><p>3、Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.</p><p>//自动配置视图解析器ViewResolver<br>//ContentNegotiatingViewResolver 所有视图解析器的组合。<br>//如何定制?：自己配置一个视图解析器，ContentNegotiatingViewResolver 就会将其注册到容器列表中</p><p>4、Support for serving static resources, including support for WebJars (covered later in this document)).<br>//静态资源的支持 WebJars 的支持</p><p>5、Automatic registration of Converter, GenericConverter, and Formatter beans.<br>//自动注册了参数转换器，Formatter 格式化器  在spring.mvc.date-format可以指定<br>//如何定制?创建一个参数或者日期类型转化器注册到spring容器中</p><p>6、Support for HttpMessageConverters (covered later in this document).<br>//SpringMVC用来转换http请求和响应。<br>eg:返回user对象，要用json返回到前端。</p><p>定制：自己添加一个HttpMessageConverters ，注册到spring容器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyConfiguration &#123;</span><br><span class="line">@Bean</span><br><span class="line">public HttpMessageConverters customConverters() &#123;</span><br><span class="line">HttpMessageConverter&lt;?&gt; additional &#x3D; ...</span><br><span class="line">HttpMessageConverter&lt;?&gt; another &#x3D; ...</span><br><span class="line">return new HttpMessageConverters(additional, another);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、Automatic registration of MessageCodesResolver (covered later in this document).<br>//定义错误代码生成规则</p><p>8、Static index.html support.<br>//静态资源支持</p><p>9、Custom Favicon support (covered later in this document).<br>//自定义标签图片支持</p><p>10、Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).<br>//web数据绑订器</p><p>Springboot如何扩展MVC配置:编写一个配置类 MyApplicationConfig 是WebMvcConfigurerAdapter 类型 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">&#x2F;&#x2F;@EnableWebMvc &#x2F;&#x2F;添加了该注解后，则表示完全抛弃springboot的mvc配置，完全采用自己的配置。</span><br><span class="line">springboot2.0使用的是spring5.0 WebMvcConfigurerAdapter在spring5.0中被标记为已过时，可以用 WebMvcConfigurationSupport代替</span><br><span class="line">public class MyApplicationConfig extends WebMvcConfigurationSupport&#123;</span><br><span class="line">    &#x2F;&#x2F;添加日期类型转换</span><br><span class="line">    @Override</span><br><span class="line">    public void addFormatters(FormatterRegistry registry) &#123;</span><br><span class="line">        super.addFormatters(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加拦截器</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        super.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring-boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC配置及扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8%E3%80%81%E5%9B%BE/1%E3%80%81%E5%9B%BE/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8%E3%80%81%E5%9B%BE/1%E3%80%81%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h5 id="相关术语："><a href="#相关术语：" class="headerlink" title="相关术语："></a>相关术语：</h5><ul><li>顶点：树中的元素我们称为节点，图中的元素我们就叫作顶点。例如微博中的一个用户</li><li>边：顶点可以与任意其他顶点建立连接关系。我们把这种建立的关系叫作边。例如微博用户 A 关注了用户 B</li><li>无向图（图的边无方向）：单纯的A与B相连：例如微信用户A与B为好有关系</li><li>有向图（图的边有方向）：顶点A指向B，例如微博用户A关注了B，但B未关注A</li><li>度（degree）：顶点相连接的边的条数。有向图中分。入度（In-degree）：有多少边的箭头指向自己，出度（Out-degree）：有多少边的箭头，从自己指向他人</li><li>带权图（weighted graph）：每条边都有一个权重，例如QQ用户A与B为好有关系有亲密度值</li></ul><h4 id="图的存储方式"><a href="#图的存储方式" class="headerlink" title="图的存储方式"></a>图的存储方式</h4><h5 id="邻接矩阵："><a href="#邻接矩阵：" class="headerlink" title="邻接矩阵："></a>邻接矩阵：</h5><p>邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j]和 A[j][i]标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j]标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i]标记为 1。对于带权图，数组中就存储相应的权重</p><p>缺点：浪费存储空间</p><p>对于无向图来说，如果 A[i][j]等于 1，那 A[j][i]也肯定等于 1。实际上，我们只需要存储一个就可以了。也就是说，无向图的二维数组中，如果我们将其用对角线划分为上下两部分，那我们只需要利用上面或者下面这样一半的空间就足够了，另外一半白白浪费掉了。<br>如何优化：稀疏数组。前面提到的二维数组存储替代方案就是稀疏数组</p><p>优点：简单、直观、方便计算</p><p>因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。比如求解最短路径问题<br>可以利用矩阵循环相乘若干次得到结果。<br>例如：查询否存在一条从顶点 2 到顶点 4 的边，<br>而采用邻接矩阵则只需要看二维数据[2][3]是否存在值即可<br>采用邻接表则要遍历顶点 2 对应的那条链表，看链表中是否存在顶点 4</p><h5 id="邻接表存储"><a href="#邻接表存储" class="headerlink" title="邻接表存储"></a>邻接表存储</h5><p>每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。</p><p>优点:节省存储空间</p><p>缺点:查询否存在一条从顶点 2 到顶点 4 的边，<br>采用邻接表则要遍历顶点 2 对应的那条链表，看链表中是否存在顶点 4<br>而采用邻接矩阵则只需要看二维数据[2][3]是否存在值即可</p><p>优化版:链表换成更加高效的动态数据结构，比如平衡二叉查找树、跳表、散列表等</p><p>逆邻接表:</p><p>微博为有向图，采用邻接表存储，我们去查找某个用户关注了哪些用户非常容易，但是如果要想知道某个用户都被哪些用户关注了，也就是用户的粉丝列表，是非常困难的。</p><p>邻接表中存储了用户的关注关系，逆邻接表中存储的是用户的被关注关系。</p>]]></content>
      
      
      <categories>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtomicInteger</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/11%E3%80%81AtomicInteger/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/11%E3%80%81AtomicInteger/</url>
      
        <content type="html"><![CDATA[<p>jdk5之后 java.util.concurrent.atomic下提供了很多常用原子变量</p><ul><li>AtomicBoolean 、AtomicInteger 、AtomicLong 、 AtomicReference</li><li>AtomicIntegerArray 、AtomicLongArray </li><li>AtomicMarkableReference </li><li>AtomicReferenceArray </li><li>AtomicStampedReference</li></ul><p>底层线程安全原理：</p><ul><li><p>1、volatile修饰保证内存可见性（可见性和有序性）</p></li><li><p>2、CAS算法保证数据的原子性</p><p>  CAS： 当且仅当内存值等于预估值时，将更新值赋给内存值，否则什么操作都不做。</p></li></ul><p>AtomicInteger为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicInteger extends Number implements java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 6214790243416807050L;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    *调用指针类Unsafe</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private static final Unsafe unsafe &#x3D; Unsafe.getUnsafe();</span><br><span class="line">    &#x2F;*</span><br><span class="line">    *变量value的内存偏移量</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line">    </span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            valueOffset &#x3D; unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    *volatile修饰的int变量value</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private volatile int value;</span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *带参数的构造函数</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public AtomicInteger(int initialValue) &#123;</span><br><span class="line">        value &#x3D; initialValue;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    *不带参数的构造函数</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public AtomicInteger() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *获取当前最新值</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final int get() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *设置当前值</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final void set(int newValue) &#123;</span><br><span class="line">        value &#x3D; newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *最终把值设置为newValue，使用该方法后，其他线程在一段时间内还会获取到旧值</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final void lazySet(int newValue) &#123;</span><br><span class="line">        unsafe.putOrderedInt(this, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *设置新值并返回旧值</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final int getAndSet(int newValue) &#123;</span><br><span class="line">        return unsafe.getAndSetInt(this, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    *如果当前值为expect，则设置为update</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *当前值加1返回旧值</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final int getAndIncrement() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *当前值减1返回旧值</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final int getAndDecrement() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, -1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *当前值增加delta，返回旧值</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final int getAndAdd(int delta) &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, delta);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *当前值增加1返回新值</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final int incrementAndGet() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *当前值减1，返回新值</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final int decrementAndGet() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, -1) - 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AtomicInteger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ集群</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/3%E3%80%81RocketMQ/9%E3%80%81RocketMQ%E9%9B%86%E7%BE%A4/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/3%E3%80%81RocketMQ/9%E3%80%81RocketMQ%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<p>3.1 RocketMQ集群模式</p><p>1 单个Master</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一种风险比较大的集群方式，因为一旦Borker重启或宕机期间，将会导致这个服务不可用，因此是不建议线上环境去使用的。</span><br></pre></td></tr></table></figure><p>2 多个Master</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个集群全部都是Master，没有Slave,它的优点和缺点如下：</span><br><span class="line"></span><br><span class="line">优点：配置简单，单个Master宕机或者是重启维护对应用没有什么影响的，在磁盘配置为RAID10时，即使机器宕机不可恢复的情况下，消息也不会丢失（异步刷盘丢失少量消息，同步刷盘则是一条都不会丢失），性能最高</span><br><span class="line"></span><br><span class="line">缺点：当单个Broker宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息的实时性会受到影响。</span><br></pre></td></tr></table></figure><p>3 多Master多Slave模式-异步复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每个Master配置一个Slave,有多对的Master-Slave，HA采用的是异步复制方式，主备有短暂的消息延迟，毫秒级别的（Master收到消息之后立刻向应用返回成功标识，同时向Slave写入消息）。优缺点如下：</span><br><span class="line"></span><br><span class="line">　　优点：即使是磁盘损坏了，消息丢失的非常少，且消息实时性不会受到影响，因为Master宕机之后，消费者仍然可以从Slave消费，此过程对应用透明，不需要人工干预，性能同多个Master模式机会一样。</span><br><span class="line"></span><br><span class="line">　　缺点：Master宕机，磁盘损坏的情况下，会丢失少量的消息。</span><br></pre></td></tr></table></figure><p>4 多Master多Slave模式-同步双写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每个Master配置一个Slave,有多对的Master-Slave，HA采用的是同步双写模式，主备都写成功，才会向应用返回成功。</span><br><span class="line"></span><br><span class="line">　　优点：数据与服务都无单点，Master宕机的情况下，消息无延迟，服务可用性与数据可用性都非常高</span><br><span class="line"></span><br><span class="line">　　缺点：性能比异步复制模式略低，大约低10%左右，发送单个Master的RT会略高，目前主机宕机后，Slave不能自动切换为主机，后续会支持自动切换功能。</span><br></pre></td></tr></table></figure><h2 id="一：主从："><a href="#一：主从：" class="headerlink" title="一：主从："></a>一：主从：</h2><p>1、修改主机器的RocketMQ配置文件:broker-a.properties，主要增加了从节点的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namesrvAddr&#x3D;rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br></pre></td></tr></table></figure><p>2、修改主机器的RocketMQ配置文件:broker-a-s.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brokerId&#x3D;1</span><br><span class="line">brokerRole&#x3D;SLAVE</span><br></pre></td></tr></table></figure><p>3、将主节点的broker-a.properties和broker-a-s.properties配置文件复制到从节点上</p><p>4、先后启动主、从的namesrv：nohup sh mqnamesrv &amp;<br>再先后启动主节点的broker  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh mqbroker -c &#x2F;usr&#x2F;local&#x2F;server&#x2F;mq&#x2F;rocketmq&#x2F;conf&#x2F;2m-2s-async&#x2F;broker-a.properties &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>5、启动从节点的broker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh mqbroker -c &#x2F;usr&#x2F;local&#x2F;server&#x2F;mq&#x2F;rocketmq&#x2F;conf&#x2F;2m-2s-async&#x2F;broker-a-s.properties &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>6、修改控制台的application.properties配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rocketmq.config.namesrvAddr&#x3D;192.168.211.143:9876;192.168.211.142:9876</span><br></pre></td></tr></table></figure><p>主从模式，即使Master宕机之后，消费者仍然可以从Slave消费，但不能接收新的消息</p><h2 id="二：RocketMQ集群搭建-双主双从"><a href="#二：RocketMQ集群搭建-双主双从" class="headerlink" title="二：RocketMQ集群搭建-双主双从"></a>二：RocketMQ集群搭建-双主双从</h2>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis发布与订阅</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/10%E3%80%81Redis%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/10%E3%80%81Redis%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/</url>
      
        <content type="html"><![CDATA[<p>Redis发布与订阅是最简易版的消息中间件MQ。<br>不支持AMQP，MQTT，Stomp等消息协议、消息也不支持持久化、事务等。</p><p>Redis提供了发布订阅频道和发布订阅模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#订阅一个或多个频道的信息</span><br><span class="line">SUBSCRIBE channel [channel ...]</span><br><span class="line"></span><br><span class="line">#退订一个或多个频道的信息</span><br><span class="line">UNSUBSCRIBE channel [channel ...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#订阅一个或多个符合给定模式的频道。</span><br><span class="line">PSUBSCRIBE pattern [pattern ...]</span><br><span class="line"></span><br><span class="line">#退订所有给定模式的频道。</span><br><span class="line">PUNSUBSCRIBE [pattern [pattern ...]]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">#将信息发送到指定的频道。</span><br><span class="line">PUBLISH channel message</span><br><span class="line"></span><br><span class="line">#Pubsub 命令用于查看订阅与发布系统状态，它由数个不同格式的子命令组成。</span><br><span class="line">PUBSUB &lt;subcommand&gt; [argument [argument ...]]</span><br></pre></td></tr></table></figure><p>场景：</p><ul><li>client-1、client-2、client-3、client-4订阅了channel-2。</li><li>某客户端client-n 将信息testMessage发送到指定的频道channel-2</li><li>client-1、client-2、client-3、client-4会收到消息</li></ul><p>当有信息发送到 tweet.shop.kindle 频道时， 信息除了发送给 clientX 和 clientY 之外， 还会发送给订阅 tweet.shop.* 模式的 client123 和 client256 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct pubsubPattern &#123;</span><br><span class="line">    redisClient *client;</span><br><span class="line">    robj *pattern;</span><br><span class="line">&#125; pubsubPattern;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 获取Jedis客户端工具</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JedisUtils &#123;</span><br><span class="line"></span><br><span class="line">    private static JedisPool pool &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取redis连接配置</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static JedisPoolConfig getJedisPoolConfig() &#123;</span><br><span class="line">        JedisPoolConfig config &#x3D; new JedisPoolConfig();</span><br><span class="line">        config.setMaxIdle(0);</span><br><span class="line">        config.setMaxWaitMillis(1000);</span><br><span class="line">        return config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过连接池获取Jedis客户端</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Jedis getJedis() &#123;</span><br><span class="line">        if (pool &#x3D;&#x3D; null) &#123;</span><br><span class="line">            pool &#x3D; new JedisPool(getJedisPoolConfig(), &quot;localhost&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Jedis jedis &#x3D; pool.getResource();</span><br><span class="line">        return jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 消息订阅者</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Consumer extends JedisPubSub &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发布订阅模式 订阅消息处理</span><br><span class="line">     * @param pattern</span><br><span class="line">     * @param channel</span><br><span class="line">     * @param message</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void onPMessage(String pattern, String channel, String message) &#123;</span><br><span class="line">        System.out.println(&quot;发布订阅模式:&quot; + pattern + &quot;&#x3D;&quot; + channel + &quot;&#x3D;&quot;</span><br><span class="line">                + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发布订阅频道 订阅消息处理</span><br><span class="line">     * @param channel</span><br><span class="line">     * @param message</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(String channel, String message) &#123;</span><br><span class="line">        System.out.println(&quot;发布订阅频道:&quot; + channel + &quot;&#x3D;&quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Consumer consumer &#x3D; new Consumer();</span><br><span class="line">        &#x2F;&#x2F;订阅模式</span><br><span class="line">        JedisUtils.getJedis().psubscribe(consumer, new String[]&#123;&quot;chan*&quot;&#125;);</span><br><span class="line">        &#x2F;&#x2F;订阅频道</span><br><span class="line">        JedisUtils.getJedis().subscribe(consumer, &quot;channel1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 消息发布者</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Producer &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Jedis jedis &#x3D; JedisUtils.getJedis();</span><br><span class="line">jedis.publish(&quot;channel1&quot;, &quot;message from channel11&quot;);</span><br><span class="line">jedis.publish(&quot;channel2&quot;, &quot;message from channel22&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis发布与订阅 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>baen的生命周期</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/IOC/9%E3%80%81baen%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/IOC/9%E3%80%81baen%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="baen的生命周期："><a href="#baen的生命周期：" class="headerlink" title="baen的生命周期："></a>baen的生命周期：</h3><p>在传统的 Java 应用中， bean 的生命周期很简单。使用 Java 关键字 new 进行 bean<br>实例化，然后该 bean 就可以使用了。 一旦 bean 不再被使用，则由 Java 自动进行<br>垃圾回收。</p><p><img src="https://oscimg.oschina.net/oscnet/74682d1a5610db1905cdb223087c5da04f2.jpg" alt="image"></p><p>每—阶段都可以针对 Spring 如何管理 bean 进行个性化定制</p><ul><li>Spring对bean进行实例化，默认bean是单例；</li><li>Spring对bean进行依赖注入；</li><li>如果bean实现了BeanNameAware接口，spring将bean的id传给setBeanName()方法；</li><li>如果bean实现了BeanFactoryAware接口，spring将调用setBeanFactory方法，将BeanFactory实例传进来；</li><li>如果bean实现了ApplicationContextAware接口，它的setApplicationContext()方法将被调用，将应用上下文的引用传入到bean中；</li><li>如果bean实现了BeanPostProcessor接口，它的postProcessBeforeInitialization方法将被调用；</li><li>如果bean实现了InitializingBean接口，spring将调用它的afterPropertiesSet接口方法，类似的如果bean使用了init-method属性声明了初始化方法，该方法也会被调用；</li><li>如果bean实现了BeanPostProcessor接口，它的postProcessAfterInitialization接口方法将被调用；</li><li>此时bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁；</li><li>若bean实现了DisposableBean接口，spring将调用它的distroy()接口方法。同样的，如果bean使用了destroy-method属性声明了销毁方法，则该方法被调用；</li><li></li></ul><p>spring模块：</p><p><img src="https://images2017.cnblogs.com/blog/1219227/201709/1219227-20170930225010356-45057485.gif" alt="image"></p><ul><li><p>1，Spring Core<br>Core模块是Spring的核心类库，Spring的所有功能都依赖于该类库，Core主要实现IOC功能，Sprign的所有功能都是借助IOC实现的。</p></li><li><p>2，AOP<br>面向切面（方面）编程<br>主要的功能是：日志记录，性能统计，安全控制，事务处理，异常处理等等</p></li><li><p>3，ORM<br>Spring 的ORM模块提供对常用的ORM框架的管理和辅助支持，Spring支持常用的Hibernate，ibtas，jdao等框架的支持，Spring本身并不对ORM进行实现，仅对常见的ORM框架进行封装，并对其进行管理。</p></li><li><p>4，DAO模块<br>Spring 提供对JDBC的支持，对JDBC进行封装，允许JDBC使用Spring资源，并能统一管理JDBC事物，并不对JDBC进行实现。</p></li><li><p>5，WEB模块<br>WEB模块提供对常见框架如Struts1，WEBWORK（Struts 2），JSF的支持，Spring能够管理这些框架，将Spring的资源注入给框架，也能在这些框架的前后插入拦截器。</p></li><li><p>6，Context模块<br>Context模块提供框架式的Bean访问方式，其他程序可以通过Context访问Spring的Bean资源，相当于资源注入。</p></li><li><p>7，MVC模块<br>WEB MVC模块为Spring提供了一套轻量级的MVC实现，在Spring的开发中，我们既可以用Struts也可以用Spring自己的MVC框架，相对于Struts，Spring自己的MVC框架更加简洁和方便。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> IOC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> baen的生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一致性HASH算法</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E4%B8%80%E8%87%B4%E6%80%A7HASH%E7%AE%97%E6%B3%95/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E4%B8%80%E8%87%B4%E6%80%A7HASH%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>分布式数据库数据分区规则有</p><p>【节点取余分区】</p><p>【一致性哈希分区】</p><p>【虚拟hash槽分区】</p><p>一致性HASH原理：在处理负载策略时：<br>一个hash环，从0到正整数<br>四个服务器ip计算的hash值肯定会落到这个hash环上的某一个点<br>根据hash(用户id)计算路由规则（hash值），然后看hash值落到了hash环的那个地方，根据hash值在hash环上的位置顺时针找距离最近的ip作为路由ip</p><p>user1的请求会落到服务器ip1进行处理<br>user2,user3的请求会落到服务器ip3进行处理<br>user4的请求会落到服务器ip4进行处理<br><img src="https://img-blog.csdnimg.cn/20190906214038520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzMwMTMwNzgz,size_16,color_FFFFFF,t_70" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class IdenticalHash &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;服务器列表</span><br><span class="line">    public static String[] serverIps &#x3D; &#123;&quot;192.168.0.1&quot;,</span><br><span class="line">            &quot;88.89.90.91&quot;, &quot;77.78.79.80&quot;, &quot;127.0.0.1&quot;&#125;;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;key表示服务器的hash值，value表示服务器</span><br><span class="line">    public static TreeMap&lt;Integer, String&gt; hashRing &#x3D; new TreeMap&lt;Integer, String&gt;();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;通过用户ip得到处理该ip的服务器地址</span><br><span class="line">    public static String getServerByIdHash(String userId) &#123;</span><br><span class="line">        int hash &#x3D; hash(userId);</span><br><span class="line">        &#x2F;&#x2F;得到大于该Hash值的所有Map</span><br><span class="line">        SortedMap&lt;Integer, String&gt; moreThanIpMap &#x3D; hashRing.tailMap(hash);</span><br><span class="line">        if (moreThanIpMap.isEmpty()) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果没有比该key的hash值大的，则从第一个node开始</span><br><span class="line">            return hashRing.get(hashRing.firstKey());</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;第一个Key就是顺时针过去离node最近的那个结点</span><br><span class="line">        return moreThanIpMap.get(moreThanIpMap.firstKey());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;根据key获取hash值(复用hashmap中的hash算法)</span><br><span class="line">    public static int hash(String str) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (str &#x3D;&#x3D; null) ? 0 : (h &#x3D; str.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;将服务器ip放到hash环中</span><br><span class="line">    public static void putHashRing() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; serverIps.length; i++) &#123;</span><br><span class="line">            int hash &#x3D; hash(serverIps[i]);</span><br><span class="line">            hashRing.put(hash, serverIps[i]);</span><br><span class="line">            System.err.println(serverIps[i] + &quot; 在hash环中的位置：&quot; + hash);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        putHashRing();</span><br><span class="line">        String[] userIds &#x3D; &#123;&quot;1241414&quot;, &quot;42452356&quot;, &quot;4214&quot;, &quot;777789&quot;&#125;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; userIds.length; i++) &#123;</span><br><span class="line">            System.out.println(&quot;用户id:&quot; + userIds[i] + &quot; 的hash值为&quot; + hash(userIds[i])</span><br><span class="line">                    + &quot;, 交由服务器:&quot; + getServerByIdHash(userIds[i]) + &quot; 处理&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上诉hash环中的服务器ip分配不均。也可能会导致某服务器处理大量的请求，有服务器会闲置</p><p>均匀一致性hash<br>均匀一致性hash的目标是如果服务器有N台，客户端的hash值有M个，那么每个服务器应该处理大概M/N个用户的。也就是每台服务器负载尽量均衡.</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一致性HASH算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka监控</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/4%E3%80%81kafka/8%E3%80%81kafka%E7%9B%91%E6%8E%A7/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/4%E3%80%81kafka/8%E3%80%81kafka%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<p>JMXTool</p><p>Burrow</p><p>Confluent Control Center</p><h2 id="Kafka-Eagle"><a href="#Kafka-Eagle" class="headerlink" title="Kafka Eagle"></a>Kafka Eagle</h2><p>1、下载并解压</p><p>下载地址：<a href="http://download.kafka-eagle.org/">http://download.kafka-eagle.org/</a></p><p>2、配置环境变量：</p><p>export KE_HOME=/usr/local/eagle<br>export PATH=$PATH:$KE_HOME/bin<br>source /etc/profile</p><p>3、进入kafka-eagle的conf目录下修改配置文件</p><p>vim system-config.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#kafkazookeeper节点配置属性多个可以添加一个，cluster1 </span><br><span class="line">kafka.eagle.zk.cluster.alias&#x3D;cluster1</span><br><span class="line">cluster1.zk.list&#x3D;127.0.0.1:2181</span><br><span class="line">######################################</span><br><span class="line"># zk 线程数量</span><br><span class="line">######################################</span><br><span class="line">kafka.zk.limit.size&#x3D;25</span><br><span class="line"> </span><br><span class="line">######################################</span><br><span class="line"># kafka eagle 的端口</span><br><span class="line">######################################</span><br><span class="line">kafka.eagle.webui.port&#x3D;8048</span><br><span class="line"> </span><br><span class="line">######################################</span><br><span class="line"># kafka offset storage</span><br><span class="line">######################################</span><br><span class="line">cluster1.kafka.eagle.offset.storage&#x3D;kafka</span><br><span class="line"> </span><br><span class="line">######################################</span><br><span class="line"># enable kafka 开启图表</span><br><span class="line"># 及开始sql查询</span><br><span class="line">######################################</span><br><span class="line">kafka.eagle.metrics.charts&#x3D;true</span><br><span class="line"> </span><br><span class="line">kafka.eagle.sql.fix.error&#x3D;true</span><br><span class="line">######################################</span><br><span class="line"># 提醒的email</span><br><span class="line">######################################</span><br><span class="line">kafka.eagle.mail.enable&#x3D;true</span><br><span class="line">kafka.eagle.mail.sa&#x3D;alert_sa</span><br><span class="line">kafka.eagle.mail.username&#x3D;alert_sa@163.com</span><br><span class="line">kafka.eagle.mail.password&#x3D;mqslimczkdqabbbh</span><br><span class="line">kafka.eagle.mail.server.host&#x3D;smtp.163.com</span><br><span class="line">kafka.eagle.mail.server.port&#x3D;25</span><br><span class="line"> </span><br><span class="line">######################################</span><br><span class="line"># 删除kafka topic 的token</span><br><span class="line">######################################</span><br><span class="line">kafka.eagle.topic.token&#x3D;keadmin</span><br><span class="line"> </span><br><span class="line">######################################</span><br><span class="line"># kafka sasl authenticate</span><br><span class="line">######################################</span><br><span class="line">kafka.eagle.sasl.enable&#x3D;false</span><br><span class="line">kafka.eagle.sasl.protocol&#x3D;SASL_PLAINTEXT</span><br><span class="line">kafka.eagle.sasl.mechanism&#x3D;PLAIN</span><br><span class="line"> </span><br><span class="line">######################################</span><br><span class="line"># kafka jdbc 地址注意可以自己安装数据mysql也可以自带的</span><br><span class="line">######################################</span><br><span class="line">kafka.eagle.driver&#x3D;org.sqlite.JDBC</span><br><span class="line">kafka.eagle.url&#x3D;jdbc:sqlite:&#x2F;kafka&#x2F;kafka-eagle-bin-1.2.4&#x2F;kafka-eagle-web-1.2.4&#x2F;db&#x2F;ke.db</span><br><span class="line">kafka.eagle.username&#x3D;root</span><br><span class="line">kafka.eagle.password&#x3D;123456</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、进入bin目录，授权启动脚本文件ke.sh，并启动（启动之前需要先启动 zookeeper 以及 kafka）</p><p>chmod 777 ke.sh</p><p>./ke.sh start</p><p>5、查看主界面</p><p><a href="http://127.1.0.1:8048/ke">http://127.1.0.1:8048/ke</a></p><h2 id="kafka-manager"><a href="#kafka-manager" class="headerlink" title="kafka manager"></a>kafka manager</h2><p>1、下载解压、进入解压目录构建项目：./sbt clean dist</p><p>2、进入conf下的application.conf的kafka-manager.zkhosts属性指向kafka集群的zookeeper地址，进行监控：</p><p>kafka-manager.zkhosts=”localhost:2181”</p><p>3、启动kafka manager:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka-manager -Dconfig.file&#x3D;conf&#x2F;application.conf -Dhttp.port&#x3D;8080</span><br></pre></td></tr></table></figure><p>要勾选上 Enable JMX Polling，这样你才能监控 Kafka 的各种 JMX 指标。</p><p>4、将kafka manager作为纯监控工具，而不至于生产环境中每个能访问kafka manager都能对kafka集群做相关的操作</p><p>还是修改conf下的application.conf文件</p><p>删除application.features的值。<br>例如禁止Preferred Leader 选举功能,只需删除KMPreferredReplicaElectionFeature,后重启kafka manager</p>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一致性hash</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/5.1%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7hash/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/5.1%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7hash/</url>
      
        <content type="html"><![CDATA[<p>分布式数据库数据分区规则有</p><p>【节点取余分区】</p><p>【一致性哈希分区】</p><p>【虚拟hash槽分区】</p><h5 id="一致性HASH原理：在处理负载策略时："><a href="#一致性HASH原理：在处理负载策略时：" class="headerlink" title="一致性HASH原理：在处理负载策略时："></a>一致性HASH原理：在处理负载策略时：</h5><ul><li>一个hash环，从0到正整数</li><li>四个服务器ip计算的hash值肯定会落到这个hash环上的某一个点</li><li>根据hash(用户id)计算路由规则（hash值），然后看hash值落到了hash环的那个地方，根据hash值在hash环上的位置顺时针找距离最近的ip作为路由ip</li></ul><p>如图：</p><ul><li>user1的请求会落到服务器ip1进行处理</li><li>user2,user3的请求会落到服务器ip3进行处理</li><li>user4的请求会落到服务器ip4进行处理</li></ul><p><img src="https://img-blog.csdnimg.cn/20190906214038520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzMwMTMwNzgz,size_16,color_FFFFFF,t_70" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class IdenticalHash &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;服务器列表</span><br><span class="line">    public static String[] serverIps &#x3D; &#123;&quot;192.168.0.1&quot;,</span><br><span class="line">            &quot;88.89.90.91&quot;, &quot;77.78.79.80&quot;, &quot;127.0.0.1&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;key表示服务器的hash值，value表示服务器</span><br><span class="line">    public static TreeMap&lt;Integer, String&gt; hashRing &#x3D; new TreeMap&lt;Integer, String&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过用户ip得到处理该ip的服务器地址</span><br><span class="line">    public static String getServerByIdHash(String userId) &#123;</span><br><span class="line">        int hash &#x3D; hash(userId);</span><br><span class="line">        &#x2F;&#x2F;得到大于该Hash值的所有Map</span><br><span class="line">        SortedMap&lt;Integer, String&gt; moreThanIpMap &#x3D; hashRing.tailMap(hash);</span><br><span class="line">        if (moreThanIpMap.isEmpty()) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果没有比该key的hash值大的，则从第一个node开始</span><br><span class="line">            return hashRing.get(hashRing.firstKey());</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;第一个Key就是顺时针过去离node最近的那个结点</span><br><span class="line">        return moreThanIpMap.get(moreThanIpMap.firstKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据key获取hash值(复用hashmap中的hash算法)</span><br><span class="line">    public static int hash(String str) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (str &#x3D;&#x3D; null) ? 0 : (h &#x3D; str.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将服务器ip放到hash环中</span><br><span class="line">    public static void putHashRing() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; serverIps.length; i++) &#123;</span><br><span class="line">            int hash &#x3D; hash(serverIps[i]);</span><br><span class="line">            hashRing.put(hash, serverIps[i]);</span><br><span class="line">            System.err.println(serverIps[i] + &quot; 在hash环中的位置：&quot; + hash);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        putHashRing();</span><br><span class="line">        String[] userIds &#x3D; &#123;&quot;1241414&quot;, &quot;42452356&quot;, &quot;4214&quot;, &quot;777789&quot;&#125;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; userIds.length; i++) &#123;</span><br><span class="line">            System.out.println(&quot;用户id:&quot; + userIds[i] + &quot; 的hash值为&quot; + hash(userIds[i])</span><br><span class="line">                    + &quot;, 交由服务器:&quot; + getServerByIdHash(userIds[i]) + &quot; 处理&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上诉hash环中的服务器ip分配不均。也可能会导致某服务器处理大量的请求，有服务器会闲置</p><h3 id="均匀一致性hash"><a href="#均匀一致性hash" class="headerlink" title="均匀一致性hash"></a>均匀一致性hash</h3><p>均匀一致性hash的目标是如果服务器有N台，客户端的hash值有M个，那么每个服务器应该处理大概M/N个用户的。也就是每台服务器负载尽量均衡.</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一致性hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>try-with-resources 优先于try -finally</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/8%E3%80%81%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/3%E3%80%81try-with-resources%20%E4%BC%98%E5%85%88%E4%BA%8Etry%20-finally/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/8%E3%80%81%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/3%E3%80%81try-with-resources%20%E4%BC%98%E5%85%88%E4%BA%8Etry%20-finally/</url>
      
        <content type="html"><![CDATA[<p>传统try catch写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    FileInputStream inputStream &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        inputStream &#x3D; new FileInputStream(new File(&quot;test&quot;));</span><br><span class="line">        System.out.println(inputStream.read());</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new RuntimeException(e.getMessage(), e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (inputStream !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                throw new RuntimeException(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考问题：</p><p>因为在try块和finally块中的代码，都会抛出异常。。在这种情况下，第二个异常完全抹除了第一个异常。在异常堆<br>栈轨迹中，完全没有关于第一个异常的记录，这在现实的系统中会导致调试变得非常复杂</p><p>当Java7引入try-with-resources语句时[JLS, 14. 20. 3],所有这些问题一下子就全部解决了。</p><p>要使用这个构造的资源，必须先实现Autocloseable接口，<br>其中包含了单个返回void的close方法。</p><p>==如果编写了一个类，它代表的是必须被关闭的资源，那么这个类也应该实现Autocloseable。==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try (FileInputStream inputStream &#x3D; new FileInputStream(new File(&quot;test&quot;))) &#123;</span><br><span class="line">        System.out.println(inputStream.read());</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new RuntimeException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将外部资源的句柄对象的创建放在try关键字后面的括号中，当这个try-catch代码块执行完毕后，Java会确保外部资源的close方法被调用。代码是不是瞬间简洁许多！</p><p>实现原理:</p><p>try-with-resource并不是JVM虚拟机的新增功能，只是JDK实现了一个语法糖，当你将上面代码反编译后会发现，其实对JVM虚拟机而言，它看到的依然是之前的写法：（异常抑制）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        FileInputStream inputStream &#x3D; new FileInputStream(new File(&quot;test&quot;));</span><br><span class="line">        Throwable var2 &#x3D; null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(inputStream.read());</span><br><span class="line">        &#125; catch (Throwable var12) &#123;</span><br><span class="line">            var2 &#x3D; var12;</span><br><span class="line">            throw var12;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (inputStream !&#x3D; null) &#123;</span><br><span class="line">                if (var2 !&#x3D; null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        inputStream.close();</span><br><span class="line">                    &#125; catch (Throwable var11) &#123;</span><br><span class="line">                   &#x2F;&#x2F; 这里使用的是异常抑制</span><br><span class="line">                    &#x2F;&#x2F;关闭资源时遭遇的异常将被“抑制”但不是丢弃，</span><br><span class="line">                    &#x2F;&#x2F;通过异常的getSuppressed方法，可以提取出被抑制的异常。</span><br><span class="line">                        var2.addSuppressed(var11);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (IOException var14) &#123;</span><br><span class="line">        throw new RuntimeException(var14.getMessage(), var14);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 异常体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> try-with-resources 优先于try -finally </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列的高频问题</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/4%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/4%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>消息队列的本质：</p><p>1、为什么要用消息队列，你的项目中具体时怎么用的<br>解耦、异步、削峰</p><p>2、消息队列的比较<br>技术选型</p><p>3、消息队列的优缺点</p><p>系统可用性降低，系统的可用性增加的MQ服务的因素。<br>系统复杂度提高<br>一致性问题。A将消息发给MQ、B、C系统依次消费。若C处理失败，数据如何保证一致，回滚？</p><p>4、消息队列的高可用：集群</p><p>5、消息如何保证不丢失</p><p>消息丢失的环节：（1）生产者未成功的将消息发给MQ<br>（2）MQ宕机，内存存储的消息未持久化导致丢失<br>（3）消费者拿到消息后，还没成功消费。MQ认为消费者拿到了就想消息删除，导致丢失</p><p>解决方案：（1）生产者将消息发送给MQ，MQ给生产者一个confirm一个反馈，生产者未收到反馈可以选择重新发送<br>（2）MQ收到消息后进行持久化处理<br>（3）消费者消费完消息后给MQ一个ack确认反馈，MQ收到反馈后在删除持久化的消息</p><p>6、如何保证消息消费的幂等性</p><p>重复消息产生的原因：（1）发送消息的时候重复，例如生产者因为网络原因未收到MQ返回的confirm反馈，生产者认为未发送成功，就重复发送了<br>（2）消费时消息重复，例如：MQ因为网络原因未收到消费者的ack确认，认为消费者还未消费，所以MQ选择重新投递消息给消费者</p><p>解决方案：（1）发送消息时携带全局唯一id标识<br>（2）消费者将消费的消息记录存储到redis/db中，消费前从redis/db中查询到记录，则该消息就直接舍弃</p><p>7、如何保证消息的顺序性。</p><p>需要保证消息发送的有序性、存储的有序性、消费的有序性</p><p>8、基于消息队列的分布式事务实现</p><p>9、消费者故障，导致消息迟迟不能消费，造成消息的MQ中积压,如何处理</p><p>就算紧急修复consumer的问题，让他恢复消费速度，也不能傻傻的等待几个小时消费完毕。</p><p>只能操作临时紧急扩容。</p><ul><li>先修复consumer的问题，确保其恢复消费速度，然后将现有cnosumer都停掉。</li><li>新建一个topic，partition是原来的10倍，临时建立好原先10倍或者20倍的queue数量。</li><li>然后写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue。</li><li>接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据。</li><li>这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消费数据。</li><li>等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的consumer机器来消费消息</li></ul><p>10、消息积压超过消息的过期时间就会被mq给清理掉，导致消息丢失</p><p>这个硬办法，查询对比生产和消费的消息记录，将丢失的消息重新灌入MQ。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列的高频问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper常用命令</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/7%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/zookeeper/4%E3%80%81zookeeper%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/7%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/zookeeper/4%E3%80%81zookeeper%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>用给定的路径创建一个znode。flag参数指定创建的znode是临时的，持久的还是顺序的。节点创建后临时和永久特性不能被更改</p><ul><li><p>默认情况下，所有znode都是持久的。</p></li><li><p>临时节点：当会话过期或客户端断开连接时，临时节点（flag：-e）将被自动删除。所以临时节点下不允许创建子节点</p></li><li><p>顺序节点保证znode路径将是唯一的。<br>ZooKeeper集合将向znode路径填充10位序列号。例如，znode路径 /myapp 将转换为/myapp0000000001，下一个序列号将为/myapp0000000002。如果没有指定flag，则znode被认为是持久的。</p></li></ul><h3 id="1、创建znode"><a href="#1、创建znode" class="headerlink" title="1、创建znode"></a>1、创建znode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create &#x2F;FirstZnode “Myfirstzookeeper-app&quot;</span><br></pre></td></tr></table></figure><p>要创建顺序节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -s &#x2F;FirstZnode “second-data&quot;</span><br></pre></td></tr></table></figure><p>创建临时节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -e &#x2F;SecondZnode “Ephemeral-data&quot;</span><br></pre></td></tr></table></figure><p>创建znode的子节点</p><p>创建子节点类似于创建新的znode。唯一的区别是，子znode的路径也将具有父路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create &#x2F;FirstZnode&#x2F;Child1 “firstchildren&quot;</span><br></pre></td></tr></table></figure><h3 id="2、查询节点"><a href="#2、查询节点" class="headerlink" title="2、查询节点"></a>2、查询节点</h3><p>cZxid和mZxid</p><p>ephemeralOwner </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">get &#x2F;FirstZnode</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] get &#x2F;FirstZnode</span><br><span class="line">“Myfirstzookeeper-app&quot;</span><br><span class="line"></span><br><span class="line">#czxid-创建节点的事务id</span><br><span class="line">cZxid &#x3D; 0x7f</span><br><span class="line"></span><br><span class="line">#ctime - znode被创建的毫秒数(从1970年开始)</span><br><span class="line">ctime &#x3D; Tue Sep 29 16:15:47 IST 2015</span><br><span class="line"></span><br><span class="line">#znode最后更新的事务id</span><br><span class="line">mZxid &#x3D; 0x7f</span><br><span class="line"></span><br><span class="line">#znode最后修改的毫秒数(从1970年开始)</span><br><span class="line">mtime &#x3D; Tue Sep 29 16:15:47 IST 2015</span><br><span class="line"></span><br><span class="line">#znode最后更新的子节点zxid</span><br><span class="line">pZxid &#x3D; 0x7f</span><br><span class="line"></span><br><span class="line">#znode子节点变化号，znode子节点修改次数</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line"></span><br><span class="line"># znode数据变化号   </span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line"></span><br><span class="line">#znode访问控制列表的变化号</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line"></span><br><span class="line"># 如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0。</span><br><span class="line">ephemeralOwner &#x3D; 0x0</span><br><span class="line"></span><br><span class="line">#znode的数据长度</span><br><span class="line">dataLength &#x3D; 22</span><br><span class="line"></span><br><span class="line">#znode子节点数量</span><br><span class="line">numChildren &#x3D; 0</span><br></pre></td></tr></table></figure><p>要访问顺序节点，必须输入znode的完整路径。：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get &#x2F;FirstZnode0000000023</span><br></pre></td></tr></table></figure><p>列出znode的子节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &#x2F;path</span><br></pre></td></tr></table></figure><h3 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set &#x2F;FirstZnode Data-updated</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 删除空节点，节点下不能有节点</span><br><span class="line">delete &#x2F;FirstZnode&#x2F;Child1</span><br><span class="line"></span><br><span class="line"># 递归删除节点</span><br><span class="line">rmr &#x2F;FirstZnode</span><br></pre></td></tr></table></figure><h3 id="监视znode的变化"><a href="#监视znode的变化" class="headerlink" title="监视znode的变化"></a>监视znode的变化</h3><p>当指定的znode或znode的子数据更改时，监视器会显示通知。你只能在 get 命令中设置watch。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：get &#x2F;path [watch] 1</span><br><span class="line">示例：get &#x2F;FirstZnode 1</span><br></pre></td></tr></table></figure><h3 id="检查状态"><a href="#检查状态" class="headerlink" title="检查状态"></a>检查状态</h3><p>状态描述指定的znode的元数据。它包含时间戳，版本号，ACL，数据长度和子znode等细项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">stat &#x2F;path</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] stat &#x2F;FirstZnode</span><br><span class="line">cZxid &#x3D; 0x7f</span><br><span class="line">ctime &#x3D; Tue Sep 29 16:15:47 IST 2015</span><br><span class="line">mZxid &#x3D; 0x7f</span><br><span class="line">mtime &#x3D; Tue Sep 29 17:14:24 IST 2015</span><br><span class="line">pZxid &#x3D; 0x7f</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 1</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x0</span><br><span class="line">dataLength &#x3D; 23</span><br><span class="line">numChildren &#x3D; 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stack</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/6%E3%80%81stack/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/6%E3%80%81stack/</url>
      
        <content type="html"><![CDATA[<p>Stack是栈（目前已不推荐使用）。它的特性是：==先进后出==(FILO, First In Last Out)。</p><p>Stack是继承于Vector(矢量队列)的，由于Vector是通过数组实现的，这就意味着，Stack也是通过数组实现的，而非链表。</p><p>Stack的继承关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">↳     java.util.AbstractCollection&lt;E&gt;</span><br><span class="line">   ↳     java.util.AbstractList&lt;E&gt;</span><br><span class="line">       ↳     java.util.Vector&lt;E&gt;</span><br><span class="line">           ↳     java.util.Stack&lt;E&gt;</span><br><span class="line"></span><br><span class="line">public class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>Stack只有一个默认无参构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Stack() &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="所有方法"><a href="#所有方法" class="headerlink" title="所有方法"></a>所有方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; push函数：将元素存入栈顶</span><br><span class="line">public E push(E item) &#123;</span><br><span class="line">        addElement(item);</span><br><span class="line">        return item;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; pop函数：返回栈顶元素，并将其从栈中删除</span><br><span class="line">    public synchronized E pop() &#123;</span><br><span class="line">        E       obj;</span><br><span class="line">        int     len &#x3D; size();</span><br><span class="line"></span><br><span class="line">        obj &#x3D; peek();</span><br><span class="line">        removeElementAt(len - 1);</span><br><span class="line"></span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; peek函数：返回栈顶元素，不执行删除操作   </span><br><span class="line">    public synchronized E peek() &#123;</span><br><span class="line">        int     len &#x3D; size();</span><br><span class="line"></span><br><span class="line">        if (len &#x3D;&#x3D; 0)</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        return elementAt(len - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 栈是否为空</span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return size() &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"> &#x2F;&#x2F; 查找“元素o”在栈中的位置：由栈底向栈顶方向数</span><br><span class="line">    public synchronized int search(Object o) &#123;</span><br><span class="line">        int i &#x3D; lastIndexOf(o);</span><br><span class="line"></span><br><span class="line">        if (i &gt;&#x3D; 0) &#123;</span><br><span class="line">            return size() - i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Stack实际上也是通过数组去实现<br>扩容方式一致：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void addElement(E obj) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + 1);</span><br><span class="line">    elementData[elementCount++] &#x3D; obj;</span><br><span class="line">&#125;</span><br><span class="line"> private void ensureCapacityHelper(int minCapacity) &#123;</span><br><span class="line">    &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">     grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> private void grow(int minCapacity) &#123;</span><br><span class="line">    &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">    int oldCapacity &#x3D; elementData.length;</span><br><span class="line">    int newCapacity &#x3D; oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity &#x3D; minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(01) Stack实际上也是通过数组去实现的。</span><br><span class="line">       执行push时(即，将元素推入栈中)，是通过将元素追加的数组的末尾中。</span><br><span class="line">       执行peek时(即，取出栈顶元素，不执行删除)，是返回数组末尾的元素。</span><br><span class="line">       执行pop时(即，取出栈顶元素，并将该元素从栈中删除)，是取出数组末尾的元素，然后将该元素从数组中删除。</span><br><span class="line">(02) Stack继承于Vector，意味着Vector拥有的属性和功能，Stack都拥有。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB容器</title>
      <link href="2020/06/21/Study%20notes/6%E3%80%81server/tomcat/WEB%E5%AE%B9%E5%99%A8/"/>
      <url>2020/06/21/Study%20notes/6%E3%80%81server/tomcat/WEB%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>Servlet 没有 main() 方法。它们受控于另一个 Java 应用，这个 Java 应用称为容器。例如 Tomcat。</p><p>如果 Web 服务器应用得到一个指向某 servlet 的请求，此时服务器不会把这个请求交给 servlet 本身，而是交给部署该 servlet 的容器。由容器向 servlet 提供 HTTP 请求和响应，而且由容器调用 servlet 的方法</p><p>使用容器管理和运行 servlet 的原因：</p><ul><li><p>通信支持：使 servlet 与 Web 服务器对话，无需自己建立 ServerSocket. 监听端口. 创建流等</p></li><li><p>生命周期管理：负责加载类. 实例化和初始化 Servlet. 调用 servlet 方法. 并使 servlet 实例能够被垃圾回收（servlet是单例，所以也是线程不安全的）</p></li><li><p>多线程支持：自动为接收的每个 servlet 对象创建一个新的 Java 线程（Tomcat从线程池中取出一个线程）</p></li><li><p>声明方式实现安全：使用 XML 部署描述文件来配置 ( 和修改 ) 安全性，而不必将其硬编码写到 servlet ( 或其他 ) 类代码中</p></li><li><p>JSP 支持：负责把 JSP 代码翻译为 Java</p></li></ul><h3 id="处理过程："><a href="#处理过程：" class="headerlink" title="处理过程："></a>处理过程：</h3><ul><li><p>用户点击一个链接，其 URL 指向一个 servlet 而不是静态页面</p></li><li><p>容器看出这个 “请求” 是一个 servlet，容器会创建两个对象</p></li></ul><p>HttpServletResponse<br>HttpServletRequest</p><ul><li><p>根据请求的 URL 找到正确的 Servlet，为这个请求创建或分配一个线程，并把请求和响应对象传递给这个 Servlet 线程</p></li><li><p>容器调用 servlet 的 service() 方法，根据请求的不同类型， service() 方法会调用 doGet() 或 doPost() 方法</p></li><li><p>doGet() 或 doPost() 方法会生成动态页面，并把这个页面填入响应对象</p></li><li><p>线程结束，容器把响应对象转换为一个 HTTP 响应，把它发回给客户，然后删除请求和响应对象</p></li></ul><p>servlet的映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置DispatcherServlet --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">&lt;param-value&gt;classpath:dispatcher-servlet.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;init-param&gt;</span><br><span class="line">&lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line">&lt;!-- Servlet拦截配置 --&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一个 servlet 有三个名字:公共 URL 名、部署名、实际的文件名。这种映射有助于改善应用的灵活性和安全性。用户只能知道URL名。运维知道部署名，开发知道实际的文件名。</p><h3 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h3><ul><li>被创建：执行init方法，只执行一次</li></ul><p>默认情况下，第一次被访问时，Servlet被创建，然后执行init方法（也可以配置执行Servlet的创建时机）</p><ul><li><p>2.提供服务：执行service方法，执行多次</p></li><li><p>3.被销毁：当Servlet服务器正常关闭时，执行destroy方法，只执行一次。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具构建线程池</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E5%B7%A5%E5%85%B7%E6%9E%84%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E5%B7%A5%E5%85%B7%E6%9E%84%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>通过Executor框架的工具类Executors，可以创建3种类型的ThreadPoolExecutor</p><ul><li>FixedThreadPool</li><li>SingleThreadExecutor</li><li>CachedThreadPool</li></ul><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>FixedThreadPool被称为可重用固定线程数的线程池。下面是FixedThreadPool的源代码实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads。</p><p>当线程池中的线程数大于corePoolSize时，keepAliveTime设置为0L，意味着多余<br>的空闲线程会被立即终止。</p><ul><li>1）如果当前运行的线程数少于corePoolSize，则创建新线程来执行任务。</li><li>2）在线程池完成预热之后（当前运行的线程数等于corePoolSize），将任务加入LinkedBlockingQueue。</li><li>3）线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行。<br>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。使用无界队列作为工作队列会对线程池带来如下影响。</li></ul><ol><li>当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。</li><li>由于1，使用无界队列时maximumPoolSize将是一个无效参数。</li><li>由于1和2，使用无界队列时keepAliveTime将是一个无效参数。</li><li>由于使用无界队列，运行中的FixedThreadPool（未执行方法shutdown()或<br>shutdownNow()）不会拒绝任务（不会调用RejectedExecutionHandler.rejectedExecution方法）。</li></ol><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>SingleThreadExecutor等价于new FixedThreadPool(1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>CachedThreadPool是一个会根据需要创建新线程的线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运<br>行任务，或者定期执行任务。ScheduledThreadPoolExecutor的功能与Timer类似，Timer对应的是单个后台线程，而<br>ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。</p>]]></content>
      
      
      <categories>
          
          <category> 线程池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具构建线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>批处理</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/JDBC/%E6%89%B9%E5%A4%84%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/JDBC/%E6%89%B9%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>需要进行批量增删改的操作</p><ul><li>拼接SQL的方式：sql长度有限制，clob类型不能这样使用，只能用于insert语句</li><li>JDBC批处理：</li></ul><p>可以向数据库发送多条不同的ＳＱＬ语句。<br>使用数据库自增主键则无法获得返回的主键<br>增删改操作无法返回影响行数，因为batchExecutor中update方法默认返回的是一个int常量。(其原因都是因为此时sql尚未在数据库执行，所以无法获得这些信息)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcBatchHandleByPrepareStatement &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testJdbcBatchHandleByPrepareStatement()&#123;</span><br><span class="line">        long starttime &#x3D; System.currentTimeMillis();</span><br><span class="line">        Connection conn &#x3D; null;</span><br><span class="line">        PreparedStatement st &#x3D; null;</span><br><span class="line">        ResultSet rs &#x3D; null;</span><br><span class="line">        </span><br><span class="line">        try&#123;</span><br><span class="line">            conn &#x3D; JdbcUtils.getConnection();</span><br><span class="line">            String sql &#x3D; &quot;insert into testbatch(id,name) values(?,?)&quot;;</span><br><span class="line">            st &#x3D; conn.prepareStatement(sql);</span><br><span class="line">            for(int i&#x3D;1;i&lt;1000008;i++)&#123;  &#x2F;&#x2F;i&#x3D;1000  2000</span><br><span class="line">                st.setInt(1, i);</span><br><span class="line">                st.setString(2, &quot;aa&quot; + i);</span><br><span class="line">                st.addBatch();</span><br><span class="line">                if(i%1000&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    st.executeBatch();</span><br><span class="line">                    st.clearBatch();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            st.executeBatch();</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            JdbcUtils.release(conn, st, rs);</span><br><span class="line">        &#125;</span><br><span class="line">        long endtime &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;程序花费时间：&quot; + (endtime-starttime)&#x2F;1000 + &quot;秒！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring和mybatis集成后的批处理方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private SqlSessionTemplate sqlSession;</span><br><span class="line">public void saveBatch(List&lt;TBsImpNews&gt; modelList) &#123;</span><br><span class="line">     SqlSession session &#x3D;sqlSession.getSqlSessionFactory().openSession(ExecutorType.BATCH, false);</span><br><span class="line">     try&#123;</span><br><span class="line">       &#x2F;&#x2F;批量生成新闻主键</span><br><span class="line">       for(TBsImpNews tBsImpNews : modelList)&#123;</span><br><span class="line">         &#x2F;&#x2F;批量生成新闻主键</span><br><span class="line">         String impnewsId &#x3D;String.valueOf(Long.valueOf(getSequenceNextId(SEQ_T_BS_IMP_NEWS)));</span><br><span class="line">         tBsImpNews.setImpnewsId(impnewsId);</span><br><span class="line">         sqlSession.insert(&quot;com.rocktrue.fastdev.wvsp.impnews.TBsImpNewsMapper.insertTBsImpNews&quot;, tBsImpNews);</span><br><span class="line">         for(String url:tBsImpNews.getImgList())&#123;</span><br><span class="line">            &#x2F;&#x2F;批量生成新闻图片主键</span><br><span class="line">            String imniId &#x3D;String.valueOf(Long.valueOf(getSequenceNextId(SEQ_T_BS_IMP_NEWS_IMG)));</span><br><span class="line">            TBsImpNewsImg tBsImpNewsImg&#x3D;new TBsImpNewsImg();</span><br><span class="line">            tBsImpNewsImg.setImniId(imniId);</span><br><span class="line">            tBsImpNewsImg.setImpnewsId(impnewsId);</span><br><span class="line">            tBsImpNewsImg.setImniSrc(url);</span><br><span class="line">            sqlSession.insert(&quot;com.rocktrue.fastdev.wvsp.impnews.TBsImpNewsImgMapper.insertTBsImpNewsImg&quot;, tBsImpNewsImg);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     session.commit();</span><br><span class="line">     &#x2F;&#x2F;清理缓存，防止溢出</span><br><span class="line">     session.clearCache();</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">       session.rollback();</span><br><span class="line">     &#125;finally &#123;</span><br><span class="line">      session.close();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 批处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TreeMap</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/14%E3%80%81TreeMap/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/14%E3%80%81TreeMap/</url>
      
        <content type="html"><![CDATA[<p>TreeMap的实现是红黑树算法的实现</p><p> 红黑树又称红-黑二叉树，它首先是一颗二叉树，。同时红黑树更是一颗自平衡的排序二叉树。</p><p> 二叉树他们都需要满足一个基本性质–即树中的任何节点的值大于它的左子节点，且小于它的右子节点。按照这个基本性质使得树的检索效率大大提高。我们知道在生成二叉树的过程是非常容易失衡的，最坏的情况就是一边倒（只有右/左子树），这样势必会导致二叉树的检索效率大大降低（O(n)）<br> <img src="https://img-blog.csdn.net/20140523092231125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbnNzeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><p> 平衡二叉树必须具备如下特性：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个等等子节点，其左右子树的高度都相近。</p><p>  红黑树顾名思义就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持着二叉树的平衡</p><p>  <img src="https://img-blog.csdn.net/20140523092244406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbnNzeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><p>  红黑二叉树的特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、每个节点都只能是红色或者黑色</span><br><span class="line"></span><br><span class="line">2、根节点是黑色</span><br><span class="line"></span><br><span class="line">3、每个叶节点（NIL节点，空节点）是黑色的。</span><br><span class="line"></span><br><span class="line">4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。</span><br><span class="line"></span><br><span class="line">5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</span><br></pre></td></tr></table></figure><p>TreeMap:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class TreeMap&lt;K,V&gt;</span><br><span class="line">    extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>成员属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;比较器，因为TreeMap是有序的，通过comparator接口我们可以对TreeMap的内部排序进行精密的控制</span><br><span class="line">        private final Comparator&lt;? super K&gt; comparator;</span><br><span class="line">        &#x2F;&#x2F;TreeMap红-黑节点，为TreeMap的内部类</span><br><span class="line">        private transient Entry&lt;K,V&gt; root &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;容器大小</span><br><span class="line">        private transient int size &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;TreeMap修改次数</span><br><span class="line">        private transient int modCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;红黑树的节点颜色--红色</span><br><span class="line">        private static final boolean RED &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F;红黑树的节点颜色--黑色</span><br><span class="line">        private static final boolean BLACK &#x3D; true;</span><br></pre></td></tr></table></figure><p>TreeMap的内部类叶子节点Entry的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;键</span><br><span class="line">K key;</span><br><span class="line">&#x2F;&#x2F;值</span><br><span class="line">V value;</span><br><span class="line">&#x2F;&#x2F;左孩子</span><br><span class="line">Entry&lt;K,V&gt; left &#x3D; null;</span><br><span class="line">&#x2F;&#x2F;右孩子</span><br><span class="line">Entry&lt;K,V&gt; right &#x3D; null;</span><br><span class="line">&#x2F;&#x2F;父亲</span><br><span class="line">Entry&lt;K,V&gt; parent;</span><br><span class="line">&#x2F;&#x2F;颜色</span><br><span class="line">boolean color &#x3D; BLACK;</span><br></pre></td></tr></table></figure><p>treeMap的put()、delete()方法。通过这两个方法我们会了解红黑树增加、删除节点的核心算法。</p>]]></content>
      
      
      <categories>
          
          <category> java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TreeMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM介绍</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/1%E3%80%81JVM%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/1%E3%80%81JVM%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/leesf456/p/5338951.html">https://www.cnblogs.com/leesf456/p/5338951.html</a></p><h2 id="1-什么是jvm"><a href="#1-什么是jvm" class="headerlink" title="1.什么是jvm?"></a>1.什么是jvm?</h2><ul><li>（1）jvm是一种用于计算设备的规范，它是一个虚构出来的机器，是通过在实际的计算机上仿真模拟各种功能实现的。</li><li>（2）jvm包含一套字节码指令集，一组寄存器，一个栈，一个垃圾回收堆和一个存储方法域。</li><li>（3）JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。<br>JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</li></ul><p>==Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果==</p><p>JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。</p><p>JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><h2 id="2、JVM的内部体系结构分为三部分，"><a href="#2、JVM的内部体系结构分为三部分，" class="headerlink" title="2、JVM的内部体系结构分为三部分，"></a>2、JVM的内部体系结构分为三部分，</h2><ul><li>（1）类装载器（ClassLoader）子系统： 用来装载.class文件</li><li>（2）执行引擎：执行字节码，或者执行本地方法</li><li>（3）运行时数据区：<br>方法区，堆，java栈，PC寄存器，本地方法栈</li></ul><p><img src="https://images2015.cnblogs.com/blog/724399/201610/724399-20161018224805045-165730412.jpg" alt="image"></p><h2 id="2、JVM原理"><a href="#2、JVM原理" class="headerlink" title="2、JVM原理"></a>2、JVM原理</h2><ul><li>（1）jvm是java的核心和基础，在java编译器和os平台之间的虚拟处理器，可在上面执行字节码程序。</li><li>（2）java编译器只要面向jvm，生成jvm能理解的字节码文件。java源文件经编译成字节码程序，通过jvm将每条指令翻译成不同的机器码<br>，通过特定平台运行。</li></ul><h2 id="3、JVM的生命周期"><a href="#3、JVM的生命周期" class="headerlink" title="3、JVM的生命周期"></a>3、JVM的生命周期</h2><ul><li>1、 JVM实例对应了一个独立运行的java程序它是进程级别 </li><li>a) 启动。启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void<br>main(String[] args)函数的class都可以作为JVM实例运行的起点 </li><li>b) 运行。main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以表明自己创建的线程是守护线程 </li><li>c) 消亡。当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出 </li><li>2、 JVM执行引擎实例则对应了属于用户运行程序的线程它是线程级别的</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的搜索方式</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8%E3%80%81%E5%9B%BE/2%E3%80%81%E5%9B%BE%E7%9A%84%E6%90%9C%E7%B4%A2%E6%96%B9%E5%BC%8F/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8%E3%80%81%E5%9B%BE/2%E3%80%81%E5%9B%BE%E7%9A%84%E6%90%9C%E7%B4%A2%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>图中找出从一个顶点出发，到另一个顶点的路径</p><p>广度优先、深度优先、A<em>搜索、IDA</em>搜索</p><h4 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先:"></a>广度优先:</h4><p>先查找离起始顶点最近的，然后是次近的，依次往外搜索。类似于地震薄扩散</p><p>代码实现：搜索一条从 s 到 t 的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void bfs(int s, int t) &#123;</span><br><span class="line">  if (s &#x3D;&#x3D; t) return;</span><br><span class="line">  boolean[] visited &#x3D; new boolean[v];</span><br><span class="line">  visited[s]&#x3D;true;</span><br><span class="line">  Queue&lt;Integer&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">  queue.add(s);</span><br><span class="line">  int[] prev &#x3D; new int[v];</span><br><span class="line">  for (int i &#x3D; 0; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] &#x3D; -1;</span><br><span class="line">  &#125;</span><br><span class="line">  while (queue.size() !&#x3D; 0) &#123;</span><br><span class="line">    int w &#x3D; queue.poll();</span><br><span class="line">   for (int i &#x3D; 0; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">      int q &#x3D; adj[w].get(i);</span><br><span class="line">      if (!visited[q]) &#123;</span><br><span class="line">        prev[q] &#x3D; w;</span><br><span class="line">        if (q &#x3D;&#x3D; t) &#123;</span><br><span class="line">          print(prev, s, t);</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[q] &#x3D; true;</span><br><span class="line">        queue.add(q);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void print(int[] prev, int s, int t) &#123; &#x2F;&#x2F; 递归打印s-&gt;t的路径</span><br><span class="line">  if (prev[t] !&#x3D; -1 &amp;&amp; t !&#x3D; s) &#123;</span><br><span class="line">    print(prev, s, prev[t]);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.print(t + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：最坏情况下，终止顶点 t 离起始顶点 s 很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是 O(V+E)，其中，V 表示顶点的个数，E 表示边的个数。O(E)</p><p>空间复杂度：广度优先搜索的空间消耗主要在几个辅助变量 visited 数组、queue 队列、prev 数组上。这三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是 O(V)。</p><h4 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h4><p>类似走迷宫，从一个顶点出发，一直走到末尾顶点，不是出口再折回起点，走另一条路，依次类推</p><p>代码实现：搜索一条从 s 到 t 的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">boolean found &#x3D; false; &#x2F;&#x2F; 全局变量或者类成员变量</span><br><span class="line"></span><br><span class="line">public void dfs(int s, int t) &#123;</span><br><span class="line">  found &#x3D; false;</span><br><span class="line">  boolean[] visited &#x3D; new boolean[v];</span><br><span class="line">  int[] prev &#x3D; new int[v];</span><br><span class="line">  for (int i &#x3D; 0; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] &#x3D; -1;</span><br><span class="line">  &#125;</span><br><span class="line">  recurDfs(s, t, visited, prev);</span><br><span class="line">  print(prev, s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void recurDfs(int w, int t, boolean[] visited, int[] prev) &#123;</span><br><span class="line">  if (found &#x3D;&#x3D; true) return;</span><br><span class="line">  visited[w] &#x3D; true;</span><br><span class="line">  if (w &#x3D;&#x3D; t) &#123;</span><br><span class="line">    found &#x3D; true;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">    int q &#x3D; adj[w].get(i);</span><br><span class="line">    if (!visited[q]) &#123;</span><br><span class="line">      prev[q] &#x3D; w;</span><br><span class="line">      recurDfs(q, t, visited, prev);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的时间复杂度是 O(E)，E 表示边的个数</p><p>空间复杂度:消耗内存主要是 visited、prev 数组和递归调用栈。visited、prev 数组的大小跟顶点的个数 V 成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度就是 O(V)。</p>]]></content>
      
      
      <categories>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图的搜索方式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传统JDBC编程</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/1%E3%80%81%E4%BC%A0%E7%BB%9FJDBC%E7%BC%96%E7%A8%8B/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/1%E3%80%81%E4%BC%A0%E7%BB%9FJDBC%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="传统JDBC编程"><a href="#传统JDBC编程" class="headerlink" title="传统JDBC编程"></a>传统JDBC编程</h3><ul><li>1、加载数据库驱动</li><li>2、创建并获取数据库链接</li><li>3、创建jdbc statement对象</li><li>4、设置sql语句</li><li>5、设置sql语句中的参数(使用preparedStatement)</li><li>6、通过statement执行sql并获取结果</li><li>7、对sql执行结果进行解析处理</li><li>8、释放资源(resultSet、preparedstatement、connection)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">    Connection connection &#x3D; null;</span><br><span class="line">    PreparedStatement preparedStatement &#x3D; null;</span><br><span class="line">    ResultSet resultSet &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">       &#x2F;&#x2F; 加载数据库驱动</span><br><span class="line">       Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">       &#x2F;&#x2F; 通过驱动管理类获取数据库链接</span><br><span class="line">       connection &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?characterEncoding&#x3D;utf-8&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">       &#x2F;&#x2F; 定义sql语句 ?表示占位符</span><br><span class="line">       String sql &#x3D; &quot;select * from user where username &#x3D; ?&quot;;</span><br><span class="line">       &#x2F;&#x2F; 获取预处理statement</span><br><span class="line">       preparedStatement &#x3D; connection.prepareStatement(sql);</span><br><span class="line">       &#x2F;&#x2F; 设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值</span><br><span class="line">       preparedStatement.setString(1, &quot;王五&quot;);</span><br><span class="line">       &#x2F;&#x2F; 向数据库发出sql执行查询，查询出结果集</span><br><span class="line">       resultSet &#x3D; preparedStatement.executeQuery();</span><br><span class="line">       &#x2F;&#x2F; 遍历查询结果集</span><br><span class="line">       while (resultSet.next()) &#123;</span><br><span class="line">           System.out.println(resultSet.getString(&quot;id&quot;) + &quot;  &quot; + resultSet.getString(&quot;username&quot;));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">       &#x2F;&#x2F; 释放资源</span><br><span class="line">       if (resultSet !&#x3D; null) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">              resultSet.close();</span><br><span class="line">           &#125; catch (SQLException e) &#123;</span><br><span class="line">              &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (preparedStatement !&#x3D; null) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">              preparedStatement.close();</span><br><span class="line">           &#125; catch (SQLException e) &#123;</span><br><span class="line">              &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (connection !&#x3D; null) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">              connection.close();</span><br><span class="line">           &#125; catch (SQLException e) &#123;</span><br><span class="line">              &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>数据库连接频繁创建、释放频繁造成系统资源浪费如果使用数据库连接池可解决此问题。</li><li>Sql语句在代码中硬编码</li><li>对结果集解析存在硬编码（查询列名）</li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 传统JDBC编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治算法</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/7%E3%80%81%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/7%E3%80%81%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>分治算法是一种处理问题的思想，递归是一种编程技巧</p><p>问题：给 10GB 的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有 10GB，而我们的机器的内存可能只有 2、3GB 这样子，无法一次性加载到内存，也就无法通过单纯地使用快排、归并等基础算法来解决了？</p><h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><p>分治算法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分<br>成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题<br>可以简单的直接求解，==子问题的解的合并得到最终的解==</p><p>==分治算法解决思路：分解、解决、合并。==</p><p>分治算法解决经典问题：</p><ul><li>二分搜索</li><li>大整数乘法</li><li>棋盘覆盖</li><li>合并排序</li><li>快速排序</li><li>线性时间选择</li><li>最接近点对问题</li><li>循环赛日程表</li><li>汉诺塔传说</li></ul><h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔:"></a>汉诺塔:</h3><p>汉诺塔（又称河内塔）问题是源于印度一个<br>古老传说的益智玩具。大梵天创造世界的时候做了三<br>根金刚石柱子，在一根柱子上从下往上按照大小顺序<br>摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面<br>开始按大小顺序重新摆放在另一根柱子上。并且规定，<br>在小圆盘上不能放大圆盘，在三根柱子之间一次只能<br>移动一个圆盘。<br>假如每秒钟一次，共需多长时间呢？移完这些金片需<br>要5845.54亿年以上，太阳系的预期寿命据说也就是数<br>百亿年。真的过了5845.54亿年，地球上的一切生命，<br>连同梵塔、庙宇等，都早已经灰飞烟灭。<img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1244036268,2866187087&fm=26&gp=0.jpg" alt="image"></p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><ul><li>如果是有一个盘， A-&gt;C</li><li>如果我们有n个盘 （n &gt;= 2） 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘</li><li><ol><li>先把 最上面的盘 A-&gt;B</li></ol></li><li><ol start="2"><li>把最下边的盘 A-&gt;C</li></ol></li><li><ol start="3"><li>把B塔的所有盘 从 B-&gt;C</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Hanoitower &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">hanoiTower(10, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;汉诺塔的移动的方法</span><br><span class="line">&#x2F;&#x2F;使用分治算法</span><br><span class="line">public static void hanoiTower(int num, char a, char b, char c) &#123;</span><br><span class="line">&#x2F;&#x2F;如果只有一个盘</span><br><span class="line">if(num &#x3D;&#x3D; 1) &#123;</span><br><span class="line">System.out.println(&quot;第1个盘从 &quot; + a + &quot;-&gt;&quot; + c);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;如果我们有 n &gt;&#x3D; 2 情况，我们总是可以看做是两个盘 1.最下边的一个盘 2. 上面的所有盘</span><br><span class="line">&#x2F;&#x2F;1. 先把 最上面的所有盘 A-&gt;B， 移动过程会使用到 c</span><br><span class="line">hanoiTower(num - 1, a, c, b);</span><br><span class="line">&#x2F;&#x2F;2. 把最下边的盘 A-&gt;C</span><br><span class="line">System.out.println(&quot;第&quot; + num + &quot;个盘从 &quot; + a + &quot;-&gt;&quot; + c);</span><br><span class="line">&#x2F;&#x2F;3. 把B塔的所有盘 从 B-&gt;C , 移动过程使用到 a塔  </span><br><span class="line">hanoiTower(num - 1, b, a, c);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6%E3%80%81%E6%A0%91/1%E3%80%81%E6%A0%91/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6%E3%80%81%E6%A0%91/1%E3%80%81%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>数组和链表的特点：</p><ul><li><p>数组因为有下标，所以查询快，但是增删慢，因为增删数据时其他数据的位置也相应的移动。</p></li><li><p>链表的插入和删除很快，我们只需要改变一些指针的指向就行了<br>但是查找数据却很慢了，因为不管我们查找什么数据，都需要从链表的第一个或最后一个数据项开始查询，遍历到找到所需数据项为止，这个查找也是平均需要比较N/2次。</p></li></ul><h2 id="树："><a href="#树：" class="headerlink" title="树："></a>树：</h2><p>因此希望有一种数据结构能同时具备数组查找快的优点以及链表插入和删除快的优点，就是   树</p><p>从树的根到任意节点有且只有一条路径可以到达。</p><p><img src="https://img2018.cnblogs.com/blog/1120165/201903/1120165-20190317103508280-1532806856.png" alt="image"></p><p>①、路径：顺着节点的边从一个节点走到另一个节点，所经过的节点的顺序排列就称为“路径”。</p><p>　　②、根：树顶端的节点称为根。==<strong>一棵树只有一个根</strong>==，如果要把一个节点和边的集合称为树，那么从根到其他任何一个节点都必须有且只有一条路径。A是根节点。</p><p>　　③、父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；B是D的父节点。</p><p>　　④、子节点：一个节点含有的子树的根节点称为该节点的子节点；D是B的子节点。</p><p>　　⑤、兄弟节点：具有相同父节点的节点互称为兄弟节点；比如上图的D和E就互称为兄弟节点。</p><p>　　⑥、叶节点：没有子节点的节点称为叶节点，也叫叶子节点，比如上图的H、E、F、G都是叶子节点。</p><p>　　⑦、子树：每个节点都可以作为子树的根，它和它所有的子节点、子节点的子节点等都包含在子树中。</p><p>　　⑧、节点的层次：从根开始定义，根为第一层，根的子节点为第二层，以此类推。</p><p>　　⑨、深度：“深度”这个概念在生活中是从上往下度量的，比如水中鱼的深度，是从水平面开始度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是 0。</p><p>　　⑩、高度：“高度”这个概念，其实就是从下往上度量，比如我们要度量第 10 层楼的高度、第 13 层楼的高度，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是 0。　　　　</p><p>“层数”跟深度的计算类似，不过，计数起点是 1，也就是说根节点的位于第 1 层。　　　　</p><p>　　</p><p><img src="https://static001.geekbang.org/resource/image/50/b4/50f89510ad1f7570791dd12f4e9adeb4.jpg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器模式</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。<br>我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。</p><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><p>InputStream类是以抽象组件的形式存在，而FileInputStream就是具体组件，它实现了抽象接口的所有方法，并且持有InputStream对象的引用。FileInputStream就是一个装饰类，而BufferInputStream是这个装饰类的具体实现者，它给InputStream加入了新的功能，使得InputStream读取的数据保存在内存中，从而提高读取性能。</p><h3 id="步骤-1：创建一个接口："><a href="#步骤-1：创建一个接口：" class="headerlink" title="步骤 1：创建一个接口："></a>步骤 1：创建一个接口：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">   void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2：创建实现接口的实体类。"><a href="#步骤-2：创建实现接口的实体类。" class="headerlink" title="步骤 2：创建实现接口的实体类。"></a>步骤 2：创建实现接口的实体类。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle implements Shape &#123;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Shape: Rectangle&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Circle implements Shape &#123;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println(&quot;Shape: Circle&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-3：创建实现了-Shape-接口的抽象装饰类。"><a href="#步骤-3：创建实现了-Shape-接口的抽象装饰类。" class="headerlink" title="步骤 3：创建实现了 Shape 接口的抽象装饰类。"></a>步骤 3：创建实现了 Shape 接口的抽象装饰类。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ShapeDecorator implements Shape &#123;</span><br><span class="line">   protected Shape decoratedShape;</span><br><span class="line"> </span><br><span class="line">   public ShapeDecorator(Shape decoratedShape)&#123;</span><br><span class="line">      this.decoratedShape &#x3D; decoratedShape;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void draw()&#123;</span><br><span class="line">      decoratedShape.draw();</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-4：创建扩展了-ShapeDecorator-类的实体装饰类。"><a href="#步骤-4：创建扩展了-ShapeDecorator-类的实体装饰类。" class="headerlink" title="步骤 4：创建扩展了 ShapeDecorator 类的实体装饰类。"></a>步骤 4：创建扩展了 ShapeDecorator 类的实体装饰类。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class RedShapeDecorator extends ShapeDecorator &#123;</span><br><span class="line"> </span><br><span class="line">   public RedShapeDecorator(Shape decoratedShape) &#123;</span><br><span class="line">      super(decoratedShape);     </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      decoratedShape.draw();         </span><br><span class="line">      setRedBorder(decoratedShape);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   private void setRedBorder(Shape decoratedShape)&#123;</span><br><span class="line">      System.out.println(&quot;Border Color: Red&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-5：使用-RedShapeDecorator-来装饰-Shape-对象。"><a href="#步骤-5：使用-RedShapeDecorator-来装饰-Shape-对象。" class="headerlink" title="### 步骤 5：使用 RedShapeDecorator 来装饰 Shape 对象。"></a>### 步骤 5：使用 RedShapeDecorator 来装饰 Shape 对象。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class DecoratorPatternDemo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">      Shape circle &#x3D; new Circle();</span><br><span class="line"> </span><br><span class="line">      Shape redCircle &#x3D; new RedShapeDecorator(new Circle());</span><br><span class="line"> </span><br><span class="line">      Shape redRectangle &#x3D; new RedShapeDecorator(new Rectangle());</span><br><span class="line">      System.out.println(&quot;Circle with normal border&quot;);</span><br><span class="line">      circle.draw();</span><br><span class="line"> </span><br><span class="line">      System.out.println(&quot;\nCircle of red border&quot;);</span><br><span class="line">      redCircle.draw();</span><br><span class="line"> </span><br><span class="line">      System.out.println(&quot;\nRectangle of red border&quot;);</span><br><span class="line">      redRectangle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装饰器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springmvc和struts2的区别</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/5%E3%80%81springmvc%E5%92%8Cstruts2%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/5%E3%80%81springmvc%E5%92%8Cstruts2%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="一、框架机制"><a href="#一、框架机制" class="headerlink" title="一、框架机制"></a>一、框架机制</h3><p>1、Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。<br>2、Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。</p><h3 id="二、拦截机制"><a href="#二、拦截机制" class="headerlink" title="二、拦截机制"></a>二、拦截机制</h3><p>1、Struts2</p><p>a、Struts2框架是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype（否则会出现线程并发问题），然后通过setter，getter吧request数据注入到属性。<br>b、Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。<br>c、Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了</p><p>2、SpringMVC<br>a、SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。<br>b、在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。</p><h3 id="三、性能方面"><a href="#三、性能方面" class="headerlink" title="三、性能方面"></a>三、性能方面</h3><p>SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。而Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，所以，SpringMVC开发效率和性能高于Struts2。</p><h3 id="四、拦截机制"><a href="#四、拦截机制" class="headerlink" title="四、拦截机制"></a>四、拦截机制</h3><p>Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。</p><h3 id="五、配置方面"><a href="#五、配置方面" class="headerlink" title="五、配置方面"></a>五、配置方面</h3><p>spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高（当然Struts2也可以通过不同的目录结构和相关配置做到SpringMVC一样的效果，但是需要xml配置的地方不少）。<br>SpringMVC可以认为已经100%零配置。</p><h3 id="六、设计思想"><a href="#六、设计思想" class="headerlink" title="六、设计思想"></a>六、设计思想</h3><p>Struts2更加符合OOP的编程思想， SpringMVC就比较谨慎，在servlet上扩展。</p><h3 id="七、集成方面"><a href="#七、集成方面" class="headerlink" title="七、集成方面"></a>七、集成方面</h3><p>SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。</p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springmvc和struts2的区别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper分布式锁</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/7%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/zookeeper/6%E3%80%81zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/7%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/zookeeper/6%E3%80%81zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<ul><li>有序节点：假如当前有一个父节点为/lock，我们可以在这个父节点下面创建子节点；zookeeper提供了一个可选的有序特性，例如我们可以创建子节点“/lock/node-”并且指明有序，那么zookeeper在生成子节点时会根据当前的子节点数量自动添加整数序号，也就是说如果是第一个创建的子节点，那么生成的子节点为/lock/node-0000000000，下一个节点则为/lock/node-0000000001，依次类推。</li><li>临时节点：客户端可以建立一个临时节点，在会话结束或者会话超时后，zookeeper会自动删除该节点。</li><li>事件监听：在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，zookeeper会通知客户端。当前zookeeper有如下四种事件：1）节点创建；2）节点删除；3）节点数据修改；4）子节点变更。</li></ul><p>zookeeper实现分布式锁的算法流程</p><ul><li>客户端连接zookeeper，并在/lock下创建临时的且有序的子节点，第一个客户端对应的子节点为/lock/lock-0000000000，第二个为/lock/lock-0000000001，以此类推。</li><li>客户端获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听/lock的子节点变更消息，获得子节点变更通知后重复此步骤直至获得锁；</li><li>执行业务代码；</li><li>完成业务流程后，删除对应的子节点释放锁。</li></ul><p>虽然zookeeper原生客户端暴露的API已经非常简洁了，但是实现一个分布式锁还是比较麻烦.</p><p>直接使用curator这个开源项目提供的zookeeper分布式锁实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-recipes&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> public int lock() &#123;</span><br><span class="line">    &#x2F;&#x2F;创建zookeeper的客户端</span><br><span class="line">    RetryPolicy retryPolicy &#x3D; new ExponentialBackoffRetry(1000, 3);</span><br><span class="line">    CuratorFramework client &#x3D; CuratorFrameworkFactory.newClient(&quot;127.0.0.1:2181&quot;, retryPolicy);</span><br><span class="line">    client.start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建分布式锁, 锁空间的根节点路径为&#x2F;curator&#x2F;lock</span><br><span class="line">    InterProcessMutex mutex &#x3D; new InterProcessMutex(client, &quot;&#x2F;curator&#x2F;lock&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        mutex.acquire();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取分布式锁失败</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取分布式锁成功, 进行业务流程</span><br><span class="line">    System.err.println(&quot;执行业务。。。。&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;释放分布式锁</span><br><span class="line">        mutex.release();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        &#x2F;&#x2F;释放分布式锁失败</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;关闭客户端</span><br><span class="line">    client.close();</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络模型</title>
      <link href="2020/06/21/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/1%E3%80%81%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
      <url>2020/06/21/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/1%E3%80%81%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>以太网OSI参考模型。</p><p> OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，就能互联了。</p><p> 每一层实现的协议和对应不同的设备</p><ol><li><p>物理层：实现计算机系统与网络间的物理连接</p></li><li><p>数据链路层：进行数据打包与解包，形成信息帧</p></li><li><p>网络层：提供数据通过的路由</p></li><li><p>传输层：提供传输顺序信息与响应</p></li><li><p>会话层：建立和中止连接</p></li><li><p>表示层：数据转换、确认数据格式</p></li><li><p>应用层：提供用户程序接口</p><p><img src="https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234827195-1493107425.png" alt="image"></p></li></ol><h3 id="HTTP和TCP协议"><a href="#HTTP和TCP协议" class="headerlink" title="HTTP和TCP协议"></a>HTTP和TCP协议</h3><p>TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http是用来收发数据，即实际应用上来的。</p><p>TCP是有状态的长连接，而HTTP是基于TCP的，HTTP却成了无状态的短连接？</p><p>在 HTTP/1.0 中因为每个Http请求，Http会通过TCP建立起一个连接通道，但请求结束后Http会立即将TCP连接断开。（每次都是一个建立新的TCP连接，所以无法内存中记录信息所以也是无状态的）代价过大。</p><p>响应中Keep-Alive首部是可选的，但只有在提供Connection：Keep-Alive时才能使用它。</p><p>Connection:Keep-Alive<br>Keep-Alive:max=5,timeout=120<br>这个例子说明了服务器最多还会为另外5个事务保持连接的打开状态，或者将打开状态保持到连接空闲了2分钟以后。</p><p>==HTTP/1.1（持久连接）==<br>，HTTP/1.1 把 Connection 头写进标准，并且默认开启持久连接。除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。</p><p>而通过Socket编程使用TCP协议的时候,可以通过代码区控制什么时候打开连接什么时候关闭连接。（Socket只是使得程序员更方便地使用TCP/IP协议）</p><h5 id="浏览器对同一-Host-建立-TCP-连接到数量有没有限制？"><a href="#浏览器对同一-Host-建立-TCP-连接到数量有没有限制？" class="headerlink" title="浏览器对同一 Host 建立 TCP 连接到数量有没有限制？"></a>浏览器对同一 Host 建立 TCP 连接到数量有没有限制？</h5><p>假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？</p><p>肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受</p><p>但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了</p><p>要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。</p><p>所以答案是：有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。</p>]]></content>
      
      
      <categories>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC回收二：回收算法</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/9%E3%80%81GC%E5%9B%9E%E6%94%B6%E4%BA%8C%EF%BC%9A%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/9%E3%80%81GC%E5%9B%9E%E6%94%B6%E4%BA%8C%EF%BC%9A%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="二、如何回收（回收算法）"><a href="#二、如何回收（回收算法）" class="headerlink" title="二、如何回收（回收算法）"></a>二、如何回收（回收算法）</h3><p> 判断了对象存活的状态，就需要通过gc回收算法，将垃圾回收</p><h4 id="2-1、标记-清除算法"><a href="#2-1、标记-清除算法" class="headerlink" title="2.1、标记-清除算法"></a>2.1、标记-清除算法</h4><p>  该算法先标记，后清除，将所有需要==回收的对象进行标==记，然后清除；这种算法的缺点是：效率比较低（标记和清楚的效率都不高）；标记清除后会出现大量不连续的内存空间碎片，这些碎片太多将来到需要分配较大对象时，无法找到连续的内存，而不得再次触发GC，造成内存浪费以及时间的消耗。（记忆：唐太宗标记需要杀掉的功臣，掌权后进行清除）</p><h4 id="2-2、复制算法"><a href="#2-2、复制算法" class="headerlink" title="2.2、复制算法"></a>2.2、复制算法</h4><p>复制算法先将可用内存按容量划分为大小相等的AB两块，每次只使用其中的一半。</p><p>当A的内存用完了需要垃圾回收的时候，就将还存活着的对象复制到另外一块B上面，然后就把A一次清洗完。</p><p>后续当B用完了需要回收的时候再将还存活着的对象复制到另外一块A上面 如此循环。</p><p>这种算法适用于对象存活率低的场景，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p><p>但是这种算法代价过高，不会产生内存碎片，但需要将可用内存缩小一半，浪费空间。对象存活率较高时，需要持续的复制工作，效率比较低。</p><h4 id="2-3、标记整理算法"><a href="#2-3、标记整理算法" class="headerlink" title="2.3、标记整理算法"></a>2.3、标记整理算法</h4><p>在标记-清除算法基础上，不直接清理，而是使存活对象往一端游走，然后清除一端边界以外的内存，这样既可以避免内存碎片，还可以避免对象存活率较高时的持续复制。这种算法可以避免100%对象存活的极端状况，因此==老年代不能直接使用该算法。==</p><ul><li>标记整理算法与标记-清除算法区别：<br>标记清除算法不进行对象的移动，并且仅对不存活的对象进行处理；而标记整理算法会将所有的存活对象移动到一端，并对不存活对象进行处理，因此其不会产生内存碎片。</li></ul><p>效率比复制算法低，因为内存整理很耗资源</p><p>2.4、分代收集算法（以上算法的集合选择使用）</p><p> 分代收集算法就是目前虚拟机使用的回收算法，它解决了标记整理不适用于老年代的问题，将内存分为各个年代，在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率搞，没有额外空间对它进行分配担保，所以只能使用标记清除或者标记整理算法。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC回收二：回收算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口幂等性五种解决方案</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E4%BA%94%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E4%BA%94%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>例如在电商系统下单支付过程中，点击支付按钮由于网络等原因导致请求结果未及时返回，这时用户又重复点击，导致最后在用户同一订单支付两次。为了防止重试对数据状态的改变，需要将接口的设计为幂等的。</p><h5 id="保证幂等策略"><a href="#保证幂等策略" class="headerlink" title="保证幂等策略"></a>保证幂等策略</h5><p>==幂等需要通过唯一的业务单号来保证==。先检查，后操作。实现幂等很简单：<br>先检查订单是否已经支付过，②如果已经支付过，则返回支付成功；<br>如果没有支付，进行支付流程<br>但上述先检查后更新为非原子性操作有线程安全问题。剩下就是解决线程安全的问题了。</p><h5 id="【推荐】分布式锁"><a href="#【推荐】分布式锁" class="headerlink" title="- 【推荐】分布式锁"></a>- 【推荐】分布式锁</h5><p>Redis分布式锁。使用唯一业务单号进行加锁，</p><p>请求加锁成功：则说明订单未支付，然后去支付，支付结果成功/失败、异常都释放锁。</p><p>请求加锁失败：说明订单处于支付过程中，返回请勿重复支付</p><p>==注意：==<br>其实这里还会涉及到减库存问题。因为支付结果通知通常是异步。所以加锁最多加到发起支付成功回流便要释放锁，等不到支付结果。</p><p>会导致正在三方支付的过程中，业务代码释放锁，这时用户重复提交。还是会传该单号，这里三方支付都会处理，会校验重复单号支付问题。所以这个不用考虑。</p><h5 id="【推荐】数据库乐观锁"><a href="#【推荐】数据库乐观锁" class="headerlink" title="- 【推荐】数据库乐观锁"></a>- 【推荐】数据库乐观锁</h5><ul><li>（特殊情况下乐观锁存在失效的情况ABA问题）</li></ul><p>如果只是更新已有的数据，没有必要对业务进行加锁，设计表结构时使用乐观锁，一般通过version来做乐观锁，这样既能保证执行效率，又能保证幂等。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE tab1 SET col1&#x3D;1,version&#x3D;version+1 WHERE version&#x3D;#version#</span><br></pre></td></tr></table></figure><p>不过，乐观锁存在失效的情况，就是常说的ABA问题，不过如果version版本一直是自增的就不会出现ABA的情况。</p><h5 id="数据库悲观锁"><a href="#数据库悲观锁" class="headerlink" title="- 数据库悲观锁"></a>- 数据库悲观锁</h5><p>不推荐，会造成锁表的情况）</p><h5 id="利用数据库的唯一索引来保证幂"><a href="#利用数据库的唯一索引来保证幂" class="headerlink" title="利用数据库的唯一索引来保证幂"></a>利用数据库的唯一索引来保证幂</h5><p>使用业务订单号orderNo做为去重表的唯一索引，利用数据库的唯一索引添加记录成功与否，来判断是否为重复支付</p><h5 id="token令牌"><a href="#token令牌" class="headerlink" title="token令牌"></a>token令牌</h5><p>这种方式分成两个阶段：申请token阶段和支付阶段。</p><p>第一步：在支付之前，需要订单系统根据用户信息向支付系统发起一次申请token的请求，支付系统将token保存到Redis缓存中，为第二阶段支付使用。</p><p>第二步：订单系统拿着申请到的token发起支付请求，支付系统会检查Redis中是否存在该token，如果存在，表示第一次发起支付请求，删除缓存中token后开始支付逻辑处理；如果缓存中不存在，表示非法请求。</p>]]></content>
      
      
      <categories>
          
          <category> 高频点问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 接口幂等性五种解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux的crond调度</title>
      <link href="2020/06/21/Study%20notes/7%E3%80%81linux/linux/5%E3%80%81linux%E7%9A%84crond%E8%B0%83%E5%BA%A6/"/>
      <url>2020/06/21/Study%20notes/7%E3%80%81linux/linux/5%E3%80%81linux%E7%9A%84crond%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>linux的任务调度：linux系统在某个特定的时间执行指定的命令或程序。</p><h5 id="用户任务调度："><a href="#用户任务调度：" class="headerlink" title="用户任务调度："></a>用户任务调度：</h5><p>配置文件在 /var/spool/cron目录中。其文件名与用户名一致</p><p>例如：</p><ul><li>定期mysql的备份</li><li>定时邮件提醒</li></ul><h5 id="系统任务调度："><a href="#系统任务调度：" class="headerlink" title="系统任务调度："></a>系统任务调度：</h5><p>配置文件在/etc/crontab文件<br>例如：</p><ul><li>定期病毒扫描</li><li>日志清理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;crontab</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#前四行是用来配置crond任务运行的环境变量</span><br><span class="line"></span><br><span class="line">#第一行SHELL变量指定了系统要使用哪个shell，这里是bash</span><br><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">#第二行PATH变量指定了系统执行命令的路径</span><br><span class="line">PATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin</span><br><span class="line"></span><br><span class="line">#第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，为空则表示不发送任务执行信息给用户</span><br><span class="line">MAILTO&#x3D;root</span><br><span class="line"></span><br><span class="line">#第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。</span><br><span class="line">#星号（*）：代表所有可能的值，如month字段为星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</span><br><span class="line">#逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</span><br><span class="line">#中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</span><br><span class="line">#正斜线（&#x2F;）：可以用正斜线指定时间的间隔频率，例如“0-23&#x2F;2”表示每两小时执行一次。</span><br><span class="line">HOME&#x3D;&#x2F;</span><br><span class="line"></span><br><span class="line"># For details see man 4 crontabs</span><br><span class="line"></span><br><span class="line"># Example of job definition:</span><br><span class="line"># .---------------- minute (0 - 59)</span><br><span class="line"># |  .------------- hour (0 - 23)</span><br><span class="line"># |  |  .---------- day of month (1 - 31)</span><br><span class="line"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line"># |  |  |  |  .---- day of week (0 - 6) (Sunday&#x3D;0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line"># |  |  |  |  |</span><br><span class="line"># *  *  *  *  * user-name  command to be executed</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="crontab任务维护"><a href="#crontab任务维护" class="headerlink" title="crontab任务维护"></a>crontab任务维护</h5><p>安装crontab服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install crontabs</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;sbin&#x2F;service crond start &#x2F;&#x2F;启动服务</span><br><span class="line"> </span><br><span class="line">&#x2F;sbin&#x2F;service crond stop &#x2F;&#x2F;关闭服务</span><br><span class="line"> </span><br><span class="line">&#x2F;sbin&#x2F;service crond restart &#x2F;&#x2F;重启服务</span><br><span class="line"> </span><br><span class="line">&#x2F;sbin&#x2F;service crond reload &#x2F;&#x2F;重新载入配置</span><br><span class="line"></span><br><span class="line">chkconfig –level 35 crond on &#x2F;&#x2F;开机自启动</span><br><span class="line"></span><br><span class="line">service crond status &#x2F;&#x2F;查看crontab服务状态</span><br></pre></td></tr></table></figure><p>查看定时任务列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure><p>编辑/新增 定时任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root</span><br><span class="line">#每隔2分钟输出时间到文件</span><br><span class="line">*&#x2F;2 * * * * echo &#96;date&#96; &gt;&gt; $HOME&gt;test.txt</span><br></pre></td></tr></table></figure><p>删除定时任务<br>crontab -r </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从&#x2F;var&#x2F;spool&#x2F;cron目录中删除用户的crontab文件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux的crond调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT的实现原理</title>
      <link href="2020/06/21/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/JWT/JWT%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/JWT/JWT%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="传统的-session-流程"><a href="#传统的-session-流程" class="headerlink" title="传统的 session 流程"></a>传统的 session 流程</h4><ul><li>浏览器发起请求登陆</li><li>服务端验证身份，生成身份验证信息，存储在服务端，并且告诉浏览器写入 Cookie</li><li>浏览器发起请求获取用户资料，此时 Cookie 内容也跟随这发送到服务器</li><li>服务器发现 Cookie 中有身份信息，验明正身</li><li>服务器返回该用户的用户资料</li></ul><h4 id="JWT-流程"><a href="#JWT-流程" class="headerlink" title="JWT 流程"></a>JWT 流程</h4><ul><li>浏览器发起请求登陆</li><li>服务端验证身份，根据算法，将用户标识符打包生成 token, 并且返回给浏览器</li><li>浏览器发起请求获取用户资料，把刚刚拿到的 token 一起发送给服务器</li><li>服务器发现数据中有 token，验明正身</li><li>服务器返回该用户的用户资料</li></ul><h4 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h4><ul><li>session 存储在服务端占用服务器资源，而 JWT 存储在客户端</li><li>session 存储在 Cookie 中，存在伪造跨站请求伪造攻击的风险</li><li>session 只存在一台服务器上，那么下次请求就必须请求这台服务器，不利于分布式应用</li><li>存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性</li></ul><p>JWT token数据格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpcCI6IjEyNy4wLjAuMSIsInV1aWQiOiJmZjEyMTJmNS1kOGQxLTQ0OTYtYmY0MS1kMmRkYTczZGUxOWEiLCJpYXQiOjE1Mjc1MjMwMTd9.1C01cpOf1N3M9YAYvQjfcLbDGHZ4iPVncCGIoG-lpO0jHOIAZHtSMDvK1nzArLpGK5syQSwExsZJz2FJsd2W2TUiHQYtzmQTU8OBXX6mfSZRlkts675W5WhIiOEwz69GFSD0AKXZifCRgIpKLC0n273MRMr0wJnuBi9ScfJ7YjSiqCr7qyQ5iXeOdS3ObT3wdjjk-Wu9wbWM7R25TFb-7PEZY7re8jmczPCVcNbOYegedu73T4d30kRn2jKufTGntD5hR6T9AQsgAMwVR1edEFflWb772TmrHI7WZOAivsBCN9sr4YiyYMvE8lczmBsgsunugGiHA3DGxB2ORbjIC8NPm8FI25zGOh9JIM2rjFFTIm9GiuKtC8Ck8N3-eWi9u1NgBxwLdgN5JyCORnIOlciQEsScg-3SdCTM5LHj6CeqQNwJxT4-oENzqLSTDJbP-SOj9nnx8HnJ5wh3n64rAvtc89CeTk7PhWFjksHDifngN-cnaszl5lqoF1enz5i9FYYELSjM-G7jns2SyY1MQeLRjuEDriPZtFaGmTW-RLH3gJfQXtbdpEo0nHBqXEohwoNFLKo4BNrEwshpyA7vkBpCQC0QALKyC1_L1Q5qduR6dDcqRozAo2VqJXmAKN0rvhLuIEHZkicOZY0Ds4So4GCcleqvFcxm1HQ</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据格式是这样的 header.payload.signature：</p><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;alg&quot;:&quot;RS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>alg: 声明加密的算法<br>typ: 声明类型</p><p>对这个头部信息进行 base64，即可得到 header 部分：eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9</p><h4 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h4><p>payload 是主体部分，意为载体，承载着有效的 JWT 数据包，它包含三个部分</p><p>标准声明<br>公共声明<br>私有声明</p><h4 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h4><p>signature 是签证信息，该签证信息是通过header和payload，加上secret，通过算法加密生成。</p>]]></content>
      
      
      <categories>
          
          <category> JWT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT的实现原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈：应用</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E3%80%81%E6%A0%88/%E6%A0%88%EF%BC%9A%E5%BA%94%E7%94%A8/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E3%80%81%E6%A0%88/%E6%A0%88%EF%BC%9A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1、如何实现浏览器的前进和后退功能"><a href="#1、如何实现浏览器的前进和后退功能" class="headerlink" title="1、如何实现浏览器的前进和后退功能"></a>1、如何实现浏览器的前进和后退功能</h3><h3 id="2、两个栈实现一个队列"><a href="#2、两个栈实现一个队列" class="headerlink" title="2、两个栈实现一个队列"></a>2、两个栈实现一个队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class StackToQueue&lt;T&gt; &#123;</span><br><span class="line">    Stack&lt;T&gt; stackOne &#x3D; new Stack&lt;T&gt;();</span><br><span class="line">    Stack&lt;T&gt; stackTwo &#x3D; new Stack&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    private void push(T data) &#123;</span><br><span class="line">        stackOne.push(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private T pop() &#123;</span><br><span class="line">        while (!stackOne.isEmpty()) &#123;</span><br><span class="line">            stackTwo.push(stackOne.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        T first &#x3D; stackTwo.pop();</span><br><span class="line">        while (!stackTwo.isEmpty()) &#123;</span><br><span class="line">            stackOne.push(stackTwo.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return first;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、两个队列实现一个栈"><a href="#3、两个队列实现一个栈" class="headerlink" title="3、两个队列实现一个栈"></a>3、两个队列实现一个栈</h3><p>入栈操作，我们固定把元素压入queue1<br>出栈操作，如果队列1不为空，就把队列1中q1.size()-1个元素poll出来，添加到队列2中，再把队列中那个最后的元素poll出来<br>这两个队列中始终有一个是空的。另一个非空。push添加元素到非空队列中，pop把非空队列中前面的元素都转移到另一个队列中，只剩最后一个元素，再把最后一个元素pop出来。这样这一个队列是空的，另一个队列又非空了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class QueueToStack&lt;T&gt; &#123;</span><br><span class="line">    private ArrayDeque&lt;T&gt; queueOne &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line">    private ArrayDeque&lt;T&gt; queueTwo &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private void push(T t) &#123;</span><br><span class="line">        queueOne.offer(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private T pop() &#123;</span><br><span class="line">        if (!queueOne.isEmpty() || !queueTwo.isEmpty()) &#123;</span><br><span class="line">            if (!queueOne.isEmpty()) &#123;</span><br><span class="line">                while (queueOne.size() &gt; 1) &#123;</span><br><span class="line">                    queueTwo.offer(queueOne.poll());</span><br><span class="line">                &#125;</span><br><span class="line">                return queueOne.poll();</span><br><span class="line">            &#125; else if (!queueTwo.isEmpty()) &#123;</span><br><span class="line">                while (queueTwo.size() &gt; 1) &#123;</span><br><span class="line">                    queueOne.offer(queueTwo.poll());</span><br><span class="line">                &#125;</span><br><span class="line">                return queueTwo.poll();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private T top() &#123;</span><br><span class="line">        T top &#x3D; null;</span><br><span class="line">        if (!isEmpty()) &#123;</span><br><span class="line">            if (!queueOne.isEmpty()) &#123;</span><br><span class="line">                while (queueOne.size() &gt; 1) &#123;</span><br><span class="line">                    queueTwo.offer(queueOne.poll());</span><br><span class="line">                &#125;</span><br><span class="line">                top &#x3D; queueOne.peek();</span><br><span class="line">                queueTwo.offer(queueOne.poll());</span><br><span class="line">            &#125; else if (!queueTwo.isEmpty()) &#123;</span><br><span class="line">                while (queueTwo.size() &gt; 1) &#123;</span><br><span class="line">                    queueOne.offer(queueTwo.poll());</span><br><span class="line">                &#125;</span><br><span class="line">                top &#x3D; queueTwo.peek();</span><br><span class="line">                queueOne.offer(queueTwo.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            return top;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isEmpty() &#123;</span><br><span class="line">        return queueOne.isEmpty() &amp;&amp; queueTwo.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈：应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>happens-before</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/happens-before/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/happens-before/</url>
      
        <content type="html"><![CDATA[<p>Java内存模型中所有的有序性都仅仅靠volatile和synchronized来完成，那么有一些操作将会变得很烦琐，但是我们在编写Java并发代码的时候并没有感觉到这一点，这是因为Java语言中有一个“先行发生”（happens-before）的原则。 这个原则非常重要，它是判断数据是否存在竞争、 线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p><h1 id="前面一个操作的结果对后续操作是可见的"><a href="#前面一个操作的结果对后续操作是可见的" class="headerlink" title="==前面一个操作的结果对后续操作是可见的=="></a>==前面一个操作的结果对后续操作是可见的==</h1><p>happens-before和程序员相关的规则有6项：</p><h3 id="1-程序的顺序性规则"><a href="#1-程序的顺序性规则" class="headerlink" title="1. 程序的顺序性规则"></a>1. 程序的顺序性规则</h3><p>这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class VolatileExample &#123;</span><br><span class="line">  int x &#x3D; 0;</span><br><span class="line">  volatile boolean v &#x3D; false;</span><br><span class="line">  public void writer() &#123;</span><br><span class="line">    x &#x3D; 42;</span><br><span class="line">    v &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line">  public void reader() &#123;</span><br><span class="line">    if (v &#x3D;&#x3D; true) &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里 x 会是多少呢？</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这还是比较容易理解的，按照程序的顺序，第 6 行代码 “x = 42;” Happens-Before 于第 7 行代码 “v = true;”，这就是规则 1 的内容，也比较符合单线程里面的思维：程序前面对某个变量的修改一定是对后续操作可见的。</p><h3 id="2-volatile-变量规则"><a href="#2-volatile-变量规则" class="headerlink" title="2. volatile 变量规则"></a>2. volatile 变量规则</h3><p>这条规则是指对一个 volatile 变量的写操作，相对于后续对这个 volatile 变量的读操作可见</p><h3 id="3-传递性"><a href="#3-传递性" class="headerlink" title="3. 传递性"></a>3. 传递性</h3><p>这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。</p><h3 id="4、管程中锁的规则："><a href="#4、管程中锁的规则：" class="headerlink" title="4、管程中锁的规则："></a>4、管程中锁的规则：</h3><p>指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。</p><h3 id="5-线程-start-规则"><a href="#5-线程-start-规则" class="headerlink" title="5. 线程 start() 规则"></a>5. 线程 start() 规则</h3><p>这条是关于线程启动的。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。</p><p>换句话说就是，如果线程 A 调用线程 B 的 start() 方法（即在线程 A 中启动线程 B），那么该 start() 操作 Happens-Before 于线程 B 中的任意操作。</p><h3 id="6-线程-join-规则"><a href="#6-线程-join-规则" class="headerlink" title="6. 线程 join() 规则"></a>6. 线程 join() 规则</h3><p>这条是关于线程等待的。它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作。</p><p>换句话说就是，如果在线程 A 中，调用线程 B 的 join()并成功返回，那么线程 B 中的任意操作 Happens-Before 于该 join() 操作的返回。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> happens-before </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/8%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/8%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在一组可能的解中，搜索满足期望的解。回溯算法非常适合用递归代码实现。</p><p>八皇后问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int[] result &#x3D; new int[8];&#x2F;&#x2F; 全局或成员变量, 下标表示行, 值表示 queen 存储在哪一列</span><br><span class="line">public void cal8queens(int row) &#123; &#x2F;&#x2F; 调用方式：cal8queens(0);</span><br><span class="line">  if (row &#x3D;&#x3D; 8) &#123; &#x2F;&#x2F; 8 个棋子都放置好了，打印结果</span><br><span class="line">    printQueens(result);</span><br><span class="line">    return; &#x2F;&#x2F; 8 行棋子都放好了，已经没法再往下递归了，所以就 return</span><br><span class="line">  &#125;</span><br><span class="line">  for (int column &#x3D; 0; column &lt; 8; ++column) &#123; &#x2F;&#x2F; 每一行都有 8 中放法</span><br><span class="line">    if (isOk(row, column)) &#123; &#x2F;&#x2F; 有些放法不满足要求</span><br><span class="line">      result[row] &#x3D; column; &#x2F;&#x2F; 第 row 行的棋子放到了 column 列</span><br><span class="line">      cal8queens(row+1); &#x2F;&#x2F; 考察下一行</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean isOk(int row, int column) &#123;&#x2F;&#x2F; 判断 row 行 column 列放置是否合适</span><br><span class="line">  int leftup &#x3D; column - 1, rightup &#x3D; column + 1;</span><br><span class="line">  for (int i &#x3D; row-1; i &gt;&#x3D; 0; --i) &#123; &#x2F;&#x2F; 逐行往上考察每一行</span><br><span class="line">    if (result[i] &#x3D;&#x3D; column) return false; &#x2F;&#x2F; 第 i 行的 column 列有棋子吗？</span><br><span class="line">    if (leftup &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 考察左上对角线：第 i 行 leftup 列有棋子吗？</span><br><span class="line">      if (result[i] &#x3D;&#x3D; leftup) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (rightup &lt; 8) &#123; &#x2F;&#x2F; 考察右上对角线：第 i 行 rightup 列有棋子吗？</span><br><span class="line">      if (result[i] &#x3D;&#x3D; rightup) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    --leftup; ++rightup;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void printQueens(int[] result) &#123; &#x2F;&#x2F; 打印出一个二维矩阵</span><br><span class="line">  for (int row &#x3D; 0; row &lt; 8; ++row) &#123;</span><br><span class="line">    for (int column &#x3D; 0; column &lt; 8; ++column) &#123;</span><br><span class="line">      if (result[row] &#x3D;&#x3D; column) System.out.print(&quot;Q &quot;);</span><br><span class="line">      else System.out.print(&quot;* &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>0-1 背包问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int maxW &#x3D; Integer.MIN_VALUE; &#x2F;&#x2F; 存储背包中物品总重量的最大值</span><br><span class="line">&#x2F;&#x2F; cw 表示当前已经装进去的物品的重量和；i 表示考察到哪个物品了；</span><br><span class="line">&#x2F;&#x2F; w 背包重量；items 表示每个物品的重量；n 表示物品个数</span><br><span class="line">&#x2F;&#x2F; 假设背包可承受重量 100，物品个数 10，物品重量存储在数组 a 中，那可以这样调用函数：</span><br><span class="line">&#x2F;&#x2F; f(0, 0, a, 10, 100)</span><br><span class="line">public void f(int i, int cw, int[] items, int n, int w) &#123;</span><br><span class="line">  if (cw &#x3D;&#x3D; w || i &#x3D;&#x3D; n) &#123; &#x2F;&#x2F; cw&#x3D;&#x3D;w 表示装满了 ;i&#x3D;&#x3D;n 表示已经考察完所有的物品</span><br><span class="line">    if (cw &gt; maxW) maxW &#x3D; cw;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  f(i+1, cw, items, n, w);</span><br><span class="line">  if (cw + items[i] &lt;&#x3D; w) &#123;&#x2F;&#x2F; 已经超过可以背包承受的重量的时候，就不要再装了</span><br><span class="line">    f(i+1,cw + items[i], items, n, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie和session区别</title>
      <link href="2020/06/21/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/3%E3%80%81cookie%E5%92%8Csession%E5%8C%BA%E5%88%AB/"/>
      <url>2020/06/21/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/3%E3%80%81cookie%E5%92%8Csession%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h4 id="HTTP的无状态性"><a href="#HTTP的无状态性" class="headerlink" title="HTTP的无状态性"></a>HTTP的无状态性</h4><p>HTTP 协议自身不对请求和响应之间的通信状态进行保存。</p><p>因为每个Http请求，Http会通过TCP建立起一个连接通道，但请求结束后Http会立即将TCP连接断开。（每次都是一个新的连接，所以无法内存中记录信息所以也是无状态的）</p><p>而通过Socket编程使用TCP协议的时候,可以通过代码区控制什么时候打开连接什么时候关闭连接。（Socket只是使得程序员更方便地使用TCP/IP协议）。</p><p>==cookie和session，而且都是为了解决HTTP的无状态性。记录用户的身份==</p><h5 id="cookie和session是如何保持请求的状态（工作原理）"><a href="#cookie和session是如何保持请求的状态（工作原理）" class="headerlink" title="cookie和session是如何保持请求的状态（工作原理）"></a>cookie和session是如何保持请求的状态（工作原理）</h5><p>(1)当有Session启动时，服务器生成一个唯一值，称为Session ID（好像是通过取进程ID的方式取得的）。</p><p>(2)服务器开辟一块内存，对应于该Session ID。</p><p>(3)服务器再将该Session ID写入浏览器的cookie。</p><p>(4)服务器内有一进程，监视所有Session的活动状况，如果有Session超时或是主动关闭，服务器就释放改内存块。</p><p>(5)当浏览器再次请求服务器时，带上cookie信息，IIS就读浏览器Cookie中的Session ID。</p><p>(6)然后，服务检查该Session ID所对应的内存是否有效。有效，就读出内存中的值。无效，就建立新的Session</p><h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><p>Cookies就是服务器暂存放在你的电脑里的数据（的key value）。简单来说Cookie是一段不超过4KB的小型文本数据</p><h5 id="cookie存储方式"><a href="#cookie存储方式" class="headerlink" title="cookie存储方式"></a>cookie存储方式</h5><ul><li>未设置过期时间<br>①浏览器：我们常见的方式是将cookie存放在浏览器，也就是用户自己的浏览器，当浏览器关闭时cookie数据随着消失，为什么会消失呢？这里就要用到系统的任务了，在浏览器关闭以后操作系统就行内存回收，会将cookie的数据删除，释放内存。</li></ul><ul><li>设置过期时间<br>②磁盘：指存储在用户的磁盘，而且能支持永久存储，但是这需要自己设置存储时间，也就是过期时间。只要你在设置的时间内打开此浏览器，那么自己设置的时间会自动延续。</li></ul><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>cookie的数量有限（chrome和safri没有限制，IE和Firefox有限制50个）</li><li>潜在的安全风险，cookie泄露</li><li>受用户是否禁用cookie限制，禁晶用，则不能使用该功能</li></ul><h5 id="session"><a href="#session" class="headerlink" title="session"></a>session</h5><p>保存在服务器端的用户数据。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>session过期后可以实现自动清除，必须自己设定回收机制</li><li>增加服务器的开销</li><li>集群时需要单独处理</li></ul>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie和session区别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整合MyBatis</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-boot/%E6%95%B4%E5%90%88MyBatis/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-boot/%E6%95%B4%E5%90%88MyBatis/</url>
      
        <content type="html"><![CDATA[<p>1、先添加mybatis的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.mybatis.spring.boot&#x2F;mybatis-spring-boot-starter --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、还是使用阿里的druid的数据源</p><p>3、注解版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * mybatis的配置类</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">public class MyBatisConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public ConfigurationCustomizer configurationCustomizer()&#123;</span><br><span class="line">        return new ConfigurationCustomizer() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void customize(org.apache.ibatis.session.Configuration configuration) </span><br><span class="line">                &#x2F;&#x2F;开启驼峰映射</span><br><span class="line">                configuration.setMapUnderscoreToCamelCase(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要创建一个Mapper接口 添加mapper注解，直接在serviceImp中@Autowire即可使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface IcaoMapper &#123;</span><br><span class="line">    @Select(&quot;SELECT * FROM lxtd_cca_icao_with_flight LIMIT 1&quot;)</span><br><span class="line">    public MapEntity getData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、配置版（推荐使用）<br>maper太多，每个Mapper接口都添加@Mapper注解，比较麻烦，可以使用mapperScan批量扫描。<br>在springboot启动类添加扫描位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@MapperScan(&quot;com.example.springbootdatajdbc.mapper&quot;)。</span><br></pre></td></tr></table></figure><p>在配置文件中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#添加mybatis的配置文件</span><br><span class="line">mybatis.config-location&#x3D;classpath:mybatis&#x2F;mybatis-config.xml</span><br><span class="line">#添加mybatis的映射文件</span><br><span class="line">mybatis.mapper-locations&#x3D;classpath:mybatis&#x2F;mapper&#x2F;*.xml</span><br><span class="line">#t添加映射包名</span><br><span class="line">mybatis.type-aliases-package&#x3D;com.wangping.springcloudtest01.entity</span><br></pre></td></tr></table></figure><p>IcaoMapper.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.example.springbootdatajdbc.mapper.IcaoMapper&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id&#x3D;&quot;getData&quot; resultType&#x3D;&quot;com.example.springbootdatajdbc.entity.MapEntity&quot;&gt;</span><br><span class="line">    SELECT * FROM lxtd_cca_icao_with_flight LIMIT 1</span><br><span class="line">  &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure><p>mybatis-config.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;settings&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring-boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整合MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CGLIB动态代理</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/3%E3%80%81CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/3%E3%80%81CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>JDK动态代理的缺点：需要目标对象实现一个或多个接口。假如你想代理没有接口的类呢？可以使用CGLIB库。==Cglib可以直接对实现类进行代理==。</p><p>==原理：<br>CGLIB库是基于ASM的上层应用，Cglib使用的继承机制（JDK时委托机制），本质上来，对于需要被代理的类，它只是动态生成一个子类以覆盖非final的方法，同时绑定钩子回调自定义的拦截器。值得说的是，它比JDK动态代理还要快。==</p><p>应用场景：</p><ul><li>SpringAOP同时使用CGLIB和JDK动态代（默认使用）理来满足需要</li><li>Hibernate作为最流行的ORM工具使用CGLIB库来代理单端关联（集合懒加载除外，它使用另外一种机制）。</li><li>EasyMock和jMock作为流行的Java测试库，它们提供Mock对象的方式来支持测试，使用了CGLIB来对没有接口的类进行代理。</li></ul><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class UserServiceCglib implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public Object getInstance(Object target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">        Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(this.target.getClass());</span><br><span class="line">        &#x2F;&#x2F; 设置回调方法</span><br><span class="line">        enhancer.setCallback(this);</span><br><span class="line">        &#x2F;&#x2F; 创建代理对象</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 实现MethodInterceptor接口中重写的方法</span><br><span class="line">     * 回调方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object object, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;事务开始。。。&quot;);</span><br><span class="line">        Object result &#x3D; proxy.invokeSuper(object, args);</span><br><span class="line">        System.out.println(&quot;事务结束。。。&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TestCglib &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserServiceCglib cglib &#x3D; new UserServiceCglib();</span><br><span class="line">        UserServiceImpl bookFacedImpl &#x3D; (UserServiceImpl) cglib.getInstance(new UserServiceImpl());</span><br><span class="line">        bookFacedImpl.addUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h3><ul><li>net.sf.cglib.core：底层字节码操作类；大部分与ASP相关。</li><li>net.sf.cglib.transform：编译期、运行期的class文件转换类。</li><li>net.sf.cglib.proxy：代理创建类、方法拦截类。</li><li>net.sf.cglib.reflect：更快的反射类、C#风格的代理类。</li><li>net.sf.cglib.util：集合排序工具类</li><li>net.sf.cglib.beans：JavaBean相关的工具类<br>对于创建动态代理，大部分情况下只需要使用proxy包的一部分API即可。</li></ul>]]></content>
      
      
      <categories>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CGLIB动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL优化</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/MySQL%E4%BC%98%E5%8C%96/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/MySQL%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>谈谈你对数据库的优化：从以下几个方面入手：</p><h3 id="1、sql语句的优化"><a href="#1、sql语句的优化" class="headerlink" title="1、sql语句的优化"></a>1、sql语句的优化</h3><p>一：sql语句的优化（索引的使用）</p><p>再实际项目中 如何分析mysql的哪些查询语句的效率比较低？</p><p>1、首先再mysql配置文件中，开启慢查询日志，设置阕值，只要查询时间大于设置的阕值，该语句就会被记录到慢查询日志中。</p><p>2、使用expln工具逐条分析该语句<br>语法：explain select * from tb1</p><p>属性解释：</p><ul><li>id:sql的执行顺序 越大就越先执行 相同表示同级</li><li>select_type:  simple表示简单查询</li><li>primary:最外面的select,在有子查询的语句中，最外面的select查询就是primary,</li><li>table:输出的行所用的表</li><li>==type: system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all 性能从最佳到最差==</li><li>–system:表仅有一行，这是const类型的特列，平时不会出现，这个也可以忽略不计</li><li>–const:表最多有一个匹配行，const用于比较primary key 或者unique索引。因为只匹配一行数据  记住一定是用到primary key 或者unique</li><li>possible_keys:可能用到的索引</li><li>key：实际用到的索引</li><li>key_len:用到的索引的长度</li><li>ref: ref列显示使用哪个列或常数与key一起从表中选择行。</li><li>==rows:mysql执行查询的行数，越多越差，说明没好索引==</li><li>Extra:该列包含MySQL解决查询的详细信息。</li><li>-using filesort    :字段排列</li><li>-using temporary：临时表</li><li>-using index：用到索引</li></ul><h3 id="2、存储引擎的优化"><a href="#2、存储引擎的优化" class="headerlink" title="2、存储引擎的优化"></a>2、存储引擎的优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyISAM和InnoDB等存储引擎的选择。</span><br><span class="line">MyISAM：非事务的引擎</span><br><span class="line">InnoDB是事务的引擎</span><br><span class="line">MySQL中MyISAM与InnoDB的区别，面试题：至少五点</span><br><span class="line">1.InnoDB支持事务，MyISAM不支持事务。</span><br><span class="line">2.InnoDB支持行级锁，MyISAM支持表级锁。</span><br><span class="line">3.InnoDB支持MVCC, MyISAM不支持。</span><br><span class="line">4.InnoDB支持外键，MyISAM不支持。</span><br><span class="line">5.InnoDB不支持全文索引，MyISAM支持。</span><br></pre></td></tr></table></figure><h3 id="3、数据库结构优化，"><a href="#3、数据库结构优化，" class="headerlink" title="3、数据库结构优化，"></a>3、数据库结构优化，</h3><p>字段类型的合适选择，字段的冗余、分区、分库、分表（水平拆分和垂直拆分）、读写分离。数据库集群</p><p>水平拆分：设计的问题是两表的事务问题，字段冗余解决</p><p>垂直拆分：拆分后去那张表处理业务。可以使用动态数据源、mycat解决</p><h3 id="4、数据库缓存"><a href="#4、数据库缓存" class="headerlink" title="4、数据库缓存"></a>4、数据库缓存</h3><p>根据业务是否开启数据查询的缓存。（看业务更新数据的频率）</p><h3 id="5、硬件的优化"><a href="#5、硬件的优化" class="headerlink" title="5、硬件的优化"></a>5、硬件的优化</h3><p>配置内存、CPU等参数</p><h3 id="6、服务器参数"><a href="#6、服务器参数" class="headerlink" title="6、服务器参数"></a>6、服务器参数</h3>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件权限管理</title>
      <link href="2020/06/21/Study%20notes/7%E3%80%81linux/linux/4%E3%80%81%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/7%E3%80%81linux/linux/4%E3%80%81%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>明确：</p><ul><li>linux中每个用户都必须属于一个用户组，不能独立于组外。</li><li>linux中的每个文件都有所有者，所在组，其他组的概念</li></ul><p>1、所有者：一般为文件的创建者，谁创建了该文件自然就成了该文件的所有者</p><h5 id="查看文件的所有者："><a href="#查看文件的所有者：" class="headerlink" title="查看文件的所有者："></a>查看文件的所有者：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls –l</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-rw------- 1 root  root   28077480 Dec 12 15:34 heap-dump1212.bin</span><br><span class="line">drwxr-xr-x 2 root  root       4096 Dec 12 15:29 mp-demo</span><br><span class="line">-rwxr-xr-x 1 mysql mysql 644930593 Nov 28 10:30 mysql-5.7.24-linux-glibc2.12-x86_64.tar.gz</span><br><span class="line">-rw-r--r-- 1 root  root    3432673 Jan  8 15:21 rocketmq-all-4.6.0-source-release.zip</span><br><span class="line">drwxr-xr-x 2 root  root       4096 Nov 27 19:19 xxljobadmin</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/363003_1227493859FdXT.png" alt="image"></p><h5 id="修改文件的所有者"><a href="#修改文件的所有者" class="headerlink" title="修改文件的所有者"></a>修改文件的所有者</h5><p>1、chgrp：更改文件属组</p><p>2、chown：更改文件属主，也可以同时更改文件属组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown [–R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure><h5 id="修改文件与文件夹权"><a href="#修改文件与文件夹权" class="headerlink" title="修改文件与文件夹权"></a>修改文件与文件夹权</h5><p>3、==chmod命令修改文件与文件夹权限==<br>语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod [who] [操作符] [mode] 文件名</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">chmod 777 index.html</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>who:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u 表示“用户（user）”，即文件或目录的所有者。</span><br><span class="line">g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。</span><br><span class="line">o 表示“其他（others）用户”。</span><br><span class="line">a 表示“所有（all）用户”。它是系统默认值。</span><br></pre></td></tr></table></figure><p>操作符号可以是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ 添加某个权限。</span><br><span class="line">- 取消某个权限。</span><br><span class="line">&#x3D; 赋予给定权限并取消其他所有权限（如果有的话）。</span><br></pre></td></tr></table></figure><p>设置mode所表示的权限可用下述字母的任意组合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r 可读。</span><br><span class="line">w 可写。</span><br><span class="line">x 可执行。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#eg: 给所有用户添加index.html文件的可读权限</span><br><span class="line">chmod a + r index.html</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-rw——- (600) 只有所有者才有读和写的权限</span><br><span class="line">-rw-r–r– (644) 只有所有者才有读和写的权限，组群和其他人只有读的权限</span><br><span class="line">-rwx—— (700) 只有所有者才有读，写，执行的权限</span><br><span class="line">-rwxr-xr-x (755) 只有所有者才有读，写，执行的权限，组群和其他人只有读和执行的权限</span><br><span class="line">-rwx–x–x (711) 只有所有者才有读，写，执行的权限，组群和其他人只有执行的权限</span><br><span class="line">-rw-rw-rw- (666) 每个人都有读写的权限</span><br><span class="line">-rwxrwxrwx (777) 每个人都有读写和执行的权限</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">chmod 777 index.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件权限管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>junit-DEMO</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/11%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2%E3%80%81junit-DEMO/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/11%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2%E3%80%81junit-DEMO/</url>
      
        <content type="html"><![CDATA[<p>JUnit4 Annotation的使用</p><p>1、@Test: 测试方法<br>//捕获异常<br>a)(expected=XXException.class)<br>//超时<br>b)(timeout=xxx)</p><p>2、@Ignore: 被忽略的测试方法，假如有个模块，未开发完成，先不测试该模块，忽略方法</p><p>3、@Before: ==每一个测试方法==之前运行</p><p>4、@After: ==每一个测试方法==之后运行</p><p>5、@BeforeClass: 所有测试开始之前运行，比如在测试之前，要与数据建立连接</p><p>6、@AfterClass: 所有测试结束之后运行，，比如在测试之后，释放与数据库的连接</p><p>jdk1.5之后可静态导入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;静态导入</span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line">import org.junit.Assert;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class TestOneTest &#123;</span><br><span class="line">@Test  &#x2F;&#x2F;一个类的多个Test方法，是同时测试，这点main方法做不到</span><br><span class="line">public void test() &#123;</span><br><span class="line">fail(&quot;Not yet implemented&quot;);&#x2F;&#x2F;上面的静态导入，所以可直接使用该方法</span><br><span class="line">Assert.fail(&quot;Not yet implemented&quot;);</span><br><span class="line">int result&#x3D;new TestOne().add(1, 2);</span><br><span class="line">&#x2F;&#x2F;junit核心：断言-检测期望值与测试实际结果值是否一致。</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(4, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;捕获异常</span><br><span class="line">@Test@Test(expected&#x3D;Exception.class)</span><br><span class="line">public void test() &#123;</span><br><span class="line"></span><br><span class="line">int result&#x3D;new TestOne().div(1, 2);</span><br><span class="line">Assert.assertEquals(4, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>断言语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a)assertThat( n, allOf( greaterThan(1), lessThan(15) ) ); &#x2F;&#x2F;满足所有条件</span><br><span class="line">assertThat( n, anyOf( greaterThan(16), lessThan(8) ) ); &#x2F;&#x2F;满足任意一个条件</span><br><span class="line">assertThat( n, anything() ); &#x2F;&#x2F;任何值都行</span><br><span class="line">assertThat( str, is( &quot;bjsxt&quot; ) );</span><br><span class="line">assertThat( str, not( &quot;bjxxt&quot; ) );</span><br><span class="line"></span><br><span class="line">b)assertThat( str, containsString( &quot;bjsxt&quot; ) );</span><br><span class="line">assertThat( str, endsWith(&quot;bjsxt&quot; ) ); </span><br><span class="line">assertThat( str, startsWith( &quot;bjsxt&quot; ) ); </span><br><span class="line">assertThat( n, equalTo( nExpected ) ); </span><br><span class="line">assertThat( str, equalToIgnoringCase( &quot;bjsxt&quot; ) ); </span><br><span class="line">assertThat( str, equalToIgnoringWhiteSpace( &quot;bjsxt&quot; ) );</span><br><span class="line"></span><br><span class="line">c)assertThat( d, closeTo( 3.0, 0.3 ) ); &#x2F;&#x2F;接近3  误差在0.3</span><br><span class="line">assertThat( d, greaterThan(3.0) );</span><br><span class="line">assertThat( d, lessThan (10.0) );</span><br><span class="line">assertThat( d, greaterThanOrEqualTo (5.0) );</span><br><span class="line">assertThat( d, lessThanOrEqualTo (16.0) );</span><br><span class="line"></span><br><span class="line">d)assertThat( map, hasEntry( &quot;bjsxt&quot;, &quot;bjsxt&quot; ) );</span><br><span class="line">assertThat( iterable, hasItem ( &quot;bjsxt&quot; ) );</span><br><span class="line">assertThat( map, hasKey ( &quot;bjsxt&quot; ) );</span><br><span class="line">assertThat( map, hasValue ( &quot;bjsxt&quot; ) );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 单元测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> junit-DEMO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis核心组件</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/2%E3%80%81mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/2%E3%80%81mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1、SqlSessionFactoryBuilder："><a href="#1、SqlSessionFactoryBuilder：" class="headerlink" title="1、SqlSessionFactoryBuilder："></a>1、SqlSessionFactoryBuilder：</h2><p>作用：根据配置信息或者代码来，通过建造者模式创建SqlSessionFactory。SqlSessionFactoryBuilder的生命周期存在与方法局部</p><p>主要有三个构造器方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) </span><br><span class="line">public SqlSessionFactory build(Reader reader, String environment, Properties properties)</span><br><span class="line">public SqlSessionFactory build(Configuration config)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2、SqlSessionFactory"><a href="#2、SqlSessionFactory" class="headerlink" title="2、SqlSessionFactory"></a>2、SqlSessionFactory</h2><ul><li>作用：依靠工厂来生成SqlSession（会话）</li><li>实例代码：sqlSession = sqlSessionFactory.openSession(); </li><li>生命周期在mybatis整个应用之中，每个数据库只对应一个SqlSessionFactoty（单例模式）,管理好数据库资源的分配，避免造成过多的connection消耗</li></ul><h2 id="3、SqlSession"><a href="#3、SqlSession" class="headerlink" title="3、SqlSession"></a>3、SqlSession</h2><p>  SqlSession相当于JDBC的connection连接（既然是连接，则用完应该释放），SqlSession是一个接口类，我们只需关心</p><ul><li>要给SqlSession什么信息（功能和参数）</li><li>美SqlSession返回什么结果（Result）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession &#x3D;null;</span><br><span class="line">try &#123;</span><br><span class="line">    sqlSession &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    &#x2F;&#x2F;some code</span><br><span class="line">    sqlSession.commit();</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">    sqlSession.rollback();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    if(sqlSession!&#x3D;null)&#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SqlSession的用途主要有两种：</p><ul><li>获取映射器，让映射器通过命名空间和方法名称找到对应的SQL，发送给数据库后返回结果。</li><li>直接通过命名信息去执行SQL</li></ul><p>==sqlsession生命周期是在请求数据库处理事务的过程中，是线程不安全的，涉及多线程时，需要注意数据库隔离级别和锁的特性==</p><h2 id="4、映射器（SQL-Mapper）"><a href="#4、映射器（SQL-Mapper）" class="headerlink" title="4、映射器（SQL Mapper）"></a>4、映射器（SQL Mapper）</h2><p>映射器是由Java接口和Xml文件共同组成的。映射器的实现方式有两种：</p><p>1、 一种就是通过代码来实现（使用java注解在Configuration中注册mapper接口）</p><ul><li>（1）Java注释是受限的，功能较少，而MyBatis的内容相当多，而且相当复杂，功能强大。</li><li>（2）如果你的SQL很复杂，条件很多，尤其是存在动态SQL时，写在Java里可读性差，增加了维护成本。</li></ul><p>2、通过Xml方式 (推荐方式)</p><p>xml注解方式实现映射器：<br>java注解方式实现映射器</p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis核心组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java对象引用四个级别（强、软、弱、虚）</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/6%E3%80%81Java%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E5%9B%9B%E4%B8%AA%E7%BA%A7%E5%88%AB%EF%BC%88%E5%BC%BA%E3%80%81%E8%BD%AF%E3%80%81%E5%BC%B1%E3%80%81%E8%99%9A%EF%BC%89/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/6%E3%80%81Java%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E5%9B%9B%E4%B8%AA%E7%BA%A7%E5%88%AB%EF%BC%88%E5%BC%BA%E3%80%81%E8%BD%AF%E3%80%81%E5%BC%B1%E3%80%81%E8%99%9A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Java对象引用四个级别别由高到低依次为：</p><h4 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h4><p>强引用就是我们平常最基本的对象引用，如果是强引用，那回收器不会回收带有强引用的对象。即使内存不足抛出OutOfMemoryError异常也不会回收强引用对象，存在即合理吧。<br>如：</p><ol><li>User user = new User(“Java技术栈”);<br>这就是强引用，user持有了这个对象的存储地址的引用。<h4 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h4>一个对象只有软引用，如果内存空间足够情况下垃圾回收器就不会回收它，如果内存空间不够了就会对这些只有软引用的对象进行回收。只要垃圾回收器没有回收，该软引用对象就可以继续被程序使用。</li></ol><p>所以软引用一般用来实现一些内存敏感的缓存，只要内存空间足够，对象就会保持不被回收掉。</p><h4 id="弱引用（WeakReference）软引用就是加载当中"><a href="#弱引用（WeakReference）软引用就是加载当中" class="headerlink" title="弱引用（WeakReference）软引用就是加载当中"></a>弱引用（WeakReference）软引用就是加载当中</h4><p>弱引用的对象具有更短暂的生命周期，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以用来实现一些规范化映射，如WeakHashMap，当key或者value不再被引用时可以自动被回收。</p><h4 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h4><p>虚引用顾名思义就是形同虚设，虚引用并不决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><p>虚引用主要用来跟踪对象被垃圾回收器回收的活动，虚引用必须和引用队列（ReferenceQueue）联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>强引用永不回收普通对象引用</p><p>软引用内在不足回收缓存对象</p><p>弱引用垃圾回收时缓存对象</p><p>虚引用不确定不确定</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java对象引用四个级别（强、软、弱、虚） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整合druid</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-boot/%E6%95%B4%E5%90%88druid/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-boot/%E6%95%B4%E5%90%88druid/</url>
      
        <content type="html"><![CDATA[<p>1、引入druid的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.alibaba&#x2F;druid --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.8&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、在配置文件中 指定使用druid数据源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username&#x3D;root</span><br><span class="line">spring.datasource.password&#x3D;1234</span><br><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;map</span><br><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">#指定使用druid的数据源</span><br><span class="line">spring.datasource.type&#x3D;com.alibaba.druid.pool.DruidDataSource</span><br></pre></td></tr></table></figure><p>3、添加druid的配置类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *druid的配置</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">public class DruidConfig &#123;</span><br><span class="line"></span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource&quot;)</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource druid() &#123;</span><br><span class="line">        return new DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;配置druid的管理后台</span><br><span class="line">    &#x2F;&#x2F;1、配置一个servlet的管理入口</span><br><span class="line">    @Bean</span><br><span class="line">    public ServletRegistrationBean statViewServlet() &#123;</span><br><span class="line">        ServletRegistrationBean bean &#x3D; new ServletRegistrationBean(new StatViewServlet(), &quot;&#x2F;druid&#x2F;*&quot;);</span><br><span class="line">        &#x2F;&#x2F;设置初始化参数</span><br><span class="line">        Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;drurid的后台管理相关参数</span><br><span class="line">        &#x2F;&#x2F;eg:登录后台的用户名 密码等</span><br><span class="line">        map.put(&quot;loginUsername&quot;, &quot;admin&quot;);</span><br><span class="line">        map.put(&quot;loginPassword&quot;, &quot;123456&quot;);</span><br><span class="line">        map.put(&quot;allow&quot;, &quot;&quot;);&#x2F;&#x2F;默认allow 为null,   允许所有地址访问</span><br><span class="line">        map.put(&quot;deny&quot;, &quot;192.168.1.122&quot;);&#x2F;&#x2F;拒绝该地址访问</span><br><span class="line">        bean.setInitParameters(map);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;配置一个web监控的filter(哪些请求进入druid的监控)</span><br><span class="line">    @Bean</span><br><span class="line">    public FilterRegistrationBean webStatFilter() &#123;</span><br><span class="line">        FilterRegistrationBean bean &#x3D; new FilterRegistrationBean();</span><br><span class="line">        bean.setFilter(new WebStatFilter());</span><br><span class="line">        &#x2F;&#x2F;设置相关初始化参数</span><br><span class="line">        Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;不监控静态资源</span><br><span class="line">        map.put(&quot;exclusions&quot;,&quot;*.js，*.css,&#x2F;druid&#x2F;*&quot;);</span><br><span class="line">        bean.setInitParameters(map);</span><br><span class="line">        bean.setUrlPatterns(Arrays.asList(&quot;&#x2F;*&quot;));</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入druid的后台管理，进行数据监控<br>localhost:8080/druid/login.html<br>admin<br>amdin</p>]]></content>
      
      
      <categories>
          
          <category> spring-boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整合druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类初始化顺序</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3%E3%80%81%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3%E3%80%81%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>类、变量、块、构造器、继承初始化顺序，终极解答</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class LifeCycle &#123;</span><br><span class="line">    &#x2F;&#x2F; 静态属性</span><br><span class="line">    private static String staticField &#x3D; getStaticField();</span><br><span class="line">    &#x2F;&#x2F; 静态方法块</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(staticField);</span><br><span class="line">        System.out.println(&quot;静态方法块初始化&quot;);</span><br><span class="line">        System.out.println(&quot;Static Patch Initial&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 普通属性</span><br><span class="line">    private String field &#x3D; getField();</span><br><span class="line">    &#x2F;&#x2F; 普通方法块</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(field);</span><br><span class="line">        System.out.println(&quot;普通方法块初始化&quot;);</span><br><span class="line">        System.out.println(&quot;Field Patch Initial&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 构造函数</span><br><span class="line">    public LifeCycle() &#123;</span><br><span class="line">        System.out.println(&quot;构造函数初始化&quot;);</span><br><span class="line">        System.out.println(&quot;Structure Initial &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getStaticField() &#123;</span><br><span class="line">        String statiFiled &#x3D; &quot;Static Field Initial&quot;;</span><br><span class="line">        System.out.println(&quot;静态属性初始化&quot;);</span><br><span class="line">        return statiFiled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getField() &#123;</span><br><span class="line">        String filed &#x3D; &quot;Field Initial&quot;;</span><br><span class="line">        System.out.println(&quot;普通属性初始化&quot;);</span><br><span class="line">        return filed;</span><br><span class="line">    &#125;   </span><br><span class="line">    &#x2F;&#x2F; 主函数</span><br><span class="line">    public static void main(String[] argc) &#123;</span><br><span class="line">        new LifeCycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">静态属性初始化</span><br><span class="line">Static Field Initial</span><br><span class="line">静态方法块初始化</span><br><span class="line">Static Patch Initial</span><br><span class="line">普通属性初始化</span><br><span class="line">Field Initial</span><br><span class="line">普通方法块初始化</span><br><span class="line">Field Patch Initial</span><br><span class="line">构造函数初始化</span><br><span class="line">Structure Initial</span><br></pre></td></tr></table></figure><h3 id="普通类："><a href="#普通类：" class="headerlink" title="普通类："></a>普通类：</h3><ul><li>静态变量</li><li>静态代码块</li><li>普通变量</li><li>普通代码块</li><li>构造函数<h3 id="继承的子类："><a href="#继承的子类：" class="headerlink" title="继承的子类："></a>继承的子类：</h3></li><li>父类静态变量</li><li>父类静态代码块</li><li>子类静态变量</li><li>子类静态代码块</li><li>父类普通变量</li><li>父类普通代码块</li><li>父类构造函数</li><li>子类普通变量</li><li>子类普通代码块</li><li>子类构造函数<h3 id="抽象的实现子类-接口-抽线类-实现类"><a href="#抽象的实现子类-接口-抽线类-实现类" class="headerlink" title="抽象的实现子类: 接口 - 抽线类 - 实现类"></a>抽象的实现子类: 接口 - 抽线类 - 实现类</h3></li><li>接口静态变量</li><li>抽象类静态变量</li><li>抽象类静态代码块</li><li>实现类静态变量</li><li>实习类静态代码块</li><li>抽象类普通变量</li><li>抽象类普通代码块</li><li>抽象类构造函数</li><li>实现类普通变量</li><li>实现类普通代码块</li><li>实现类构造函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类初始化顺序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper搭建</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/7%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/zookeeper/3%E3%80%81zookeeper%E6%90%AD%E5%BB%BA/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/7%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/zookeeper/3%E3%80%81zookeeper%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="1、安装zookeeper"><a href="#1、安装zookeeper" class="headerlink" title="1、安装zookeeper"></a>1、安装zookeeper</h3><p>下载并解压zookeeper</p><p>进入conf目录，cp conf/zoo_sample.cfg conf/zoo.cfg</p><h3 id="2、配置zoo-cfg（不集群）"><a href="#2、配置zoo-cfg（不集群）" class="headerlink" title="2、配置zoo.cfg（不集群）"></a>2、配置zoo.cfg（不集群）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#用于计算的单元时间 服务器有服务器之间维持心跳的时间间隔</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line">#用于集群，集群中的follower服务器(F)与leader服务器(L)之间初始连接时能容忍的最多心跳数 值为:10倍的tickTime</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line">#用于集群，集群中的follower服务器与leader服务器之间请求和应答之间能容忍的最多心跳数  值为:5倍的tickTime</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line">#zookeeper存储数据的目录 不建议放在tmp下（要修改的地方）</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;local&#x2F;zookeeper-3.3.3&#x2F;data</span><br><span class="line">#默认端口</span><br><span class="line">clientPort&#x3D;2181</span><br></pre></td></tr></table></figure><h3 id="2、配置zoo-cfg（集群）"><a href="#2、配置zoo-cfg（集群）" class="headerlink" title="2、配置zoo.cfg（集群）"></a>2、配置zoo.cfg（集群）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#用于计算的单元时间 服务器有服务器之间维持心跳的时间间隔</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line">#用于集群，集群中的follower服务器(F)与leader服务器(L)之间初始连接时能容忍的最多心跳数 值为:10倍的tickTime</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line">#用于集群，集群中的follower服务器与leader服务器之间请求和应答之间能容忍的最多心跳数  值为:5倍的tickTime</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line">#zookeeper存储数据的目录 不建议放在tmp下（要修改的地方）</span><br><span class="line">dataDir&#x3D;&#x2F;home&#x2F;dubbo&#x2F;zookeeper-3.3.3&#x2F;data</span><br><span class="line">#默认端口</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line">#server.服务器编号（随便取 不可重复）&#x3D;服务器的ip(或映射地址localhost等)：心跳端口：选举端口（要修改的地方）</span><br><span class="line">server.1&#x3D;192.168.0.1:2555:3555</span><br><span class="line">server.2&#x3D;192.168.0.2:2555:3555</span><br></pre></td></tr></table></figure><p>在上面指定的data目录下放置 myid 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir data</span><br><span class="line">vi myid</span><br></pre></td></tr></table></figure><p>myid文件 指明自己的 id，对应上面 zoo.cfg 中 server. 后的数字，第一台的内容为 1，第二台的内容为 2</p><h3 id="3、启动zookeeper"><a href="#3、启动zookeeper" class="headerlink" title="3、启动zookeeper:"></a>3、启动zookeeper:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#启动zk</span><br><span class="line">.&#x2F;bin&#x2F;zkServer.sh start</span><br><span class="line"></span><br><span class="line">#调试启动</span><br><span class="line">.&#x2F;zkServer.sh start-foreground</span><br><span class="line"></span><br><span class="line">#停止</span><br><span class="line">.&#x2F;bin&#x2F;zkServer.sh stop</span><br><span class="line"></span><br><span class="line">#查看状态</span><br><span class="line">.&#x2F;zkServer.sh status</span><br><span class="line"></span><br><span class="line">#：连接zk</span><br><span class="line">启动命令：sh zkCli.sh</span><br><span class="line"></span><br><span class="line">#连接其他地址zk:</span><br><span class="line">.&#x2F;zkCli.sh -server ip:port</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程让步yield()</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/%E7%BA%BF%E7%A8%8B%E8%AE%A9%E6%AD%A5yield()/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/%E7%BA%BF%E7%A8%8B%E8%AE%A9%E6%AD%A5yield()/</url>
      
        <content type="html"><![CDATA[<p>yield()介绍</p><p>yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; YieldTest.java的源码</span><br><span class="line">class ThreadA extends Thread&#123;</span><br><span class="line">    public ThreadA(String name)&#123; </span><br><span class="line">        super(name); </span><br><span class="line">    &#125; </span><br><span class="line">    public synchronized void run()&#123; </span><br><span class="line">        for(int i&#x3D;0; i &lt;10; i++)&#123; </span><br><span class="line">            System.out.printf(&quot;%s [%d]:%d\n&quot;, this.getName(), this.getPriority(), i); </span><br><span class="line">            &#x2F;&#x2F; i整除4时，调用yield</span><br><span class="line">            if (i%4 &#x3D;&#x3D; 0)</span><br><span class="line">                Thread.yield();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public class YieldTest&#123; </span><br><span class="line">    public static void main(String[] args)&#123; </span><br><span class="line">        ThreadA t1 &#x3D; new ThreadA(&quot;t1&quot;); </span><br><span class="line">        ThreadA t2 &#x3D; new ThreadA(&quot;t2&quot;); </span><br><span class="line">        t1.start(); </span><br><span class="line">        t2.start();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yield() 与 wait()的比较:</p><p>wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。</p><p>wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。</p><p>示例演示yield()是不会释放锁的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; YieldLockTest.java 的源码</span><br><span class="line">public class YieldLockTest&#123; </span><br><span class="line"></span><br><span class="line">    private static Object obj &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123; </span><br><span class="line">        ThreadA t1 &#x3D; new ThreadA(&quot;t1&quot;); </span><br><span class="line">        ThreadA t2 &#x3D; new ThreadA(&quot;t2&quot;); </span><br><span class="line">        t1.start(); </span><br><span class="line">        t2.start();</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    static class ThreadA extends Thread&#123;</span><br><span class="line">        public ThreadA(String name)&#123; </span><br><span class="line">            super(name); </span><br><span class="line">        &#125; </span><br><span class="line">        public void run()&#123; </span><br><span class="line">            &#x2F;&#x2F; 获取obj对象的同步锁</span><br><span class="line">            synchronized (obj) &#123;</span><br><span class="line">                for(int i&#x3D;0; i &lt;10; i++)&#123; </span><br><span class="line">                    System.out.printf(&quot;%s [%d]:%d\n&quot;, this.getName(), this.getPriority(), i); </span><br><span class="line">                    &#x2F;&#x2F; i整除4时，调用yield</span><br><span class="line">                    if (i%4 &#x3D;&#x3D; 0)</span><br><span class="line">                        Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 常用方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程让步yield() </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/1%E3%80%81AOP/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/1%E3%80%81AOP/</url>
      
        <content type="html"><![CDATA[<p>==1、AOP面向切面编程，与传统OOP（面向对象）相比，功能拓展OOP是自上而下的纵向抽取（继承），这样会产生很多与业务关系不大的冗余代码。AOP的编程思想就是将功能拓展的代码与主业务逻辑分离，达到解耦。==</p><ul><li>Aspect（切面）： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。</li><li>Joint point（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。</li><li>Pointcut（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。</li><li>Advice（增强）：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。</li><li>Target（目标对象）：织入 Advice 的目标对象.。</li><li>Weaving（织入）：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程</li></ul><p>Advice 的类型</p><ul><li>1前置通知：<a href="aop:before">aop:before</a>先执行方面逻辑，再执行目标方法；</li><li>2后置通知：<a href="aop:after-returning">aop:after-returning</a>先执行目标方法，如果不出现异常，再执行方面逻辑；</li><li>3异常通知：<a href="aop:after-throwing">aop:after-throwing</a>先执行目标方法，如果出现异常，再执行方面逻辑；</li><li>4最终通知：<a href="aop:after">aop:after</a>先执行目标方法，有无异常都再执行方面逻辑；（类似于finally的作用）</li><li>5环绕通知（around advice）：前置+后置，先执行方面的前一部分，再执行目标方法，最后执行方面的剩余部分。</li></ul><p>在Spring中，通过动态代理和动态字节码技术实现了AOP.</p><ul><li>如果代理类实现的接口：则是用jdk动态代理技术</li><li>如果代理类未实现的接口：则是cglib动态代理技术</li></ul><p>什么时候被代理的？在spring容器初始化对象的时候。debug源码验证</p>]]></content>
      
      
      <categories>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bus消息总线</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/7%E3%80%81bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/Bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/7%E3%80%81bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/Bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>使用bus构建一个主题,所有服务都连接到这个主题上去，当我们向该主题发送消息时，所有订阅该主题的服务都会收到消息并进行消费.Spring Cloud Bus 配合 Spring Cloud Config 使用可以实现配置的动态刷新。目前 Spring Cloud Bus 支持两种消息代理：RabbitMQ 和 Kafka</p><h4 id="动态刷新配置"><a href="#动态刷新配置" class="headerlink" title="动态刷新配置"></a>动态刷新配置</h4><p>使用 Spring Cloud Bus 动态刷新配置需要配合 Spring Cloud Config 一起使用</p><p>config-server添加消息总线支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8904</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-server</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https:&#x2F;&#x2F;gitee.com&#x2F;macrozheng&#x2F;springcloud-config.git</span><br><span class="line">          username: macro</span><br><span class="line">          password: 123456</span><br><span class="line">          clone-on-start: true # 开启启动时直接从git获取配置</span><br><span class="line">  rabbitmq: #rabbitmq相关配置</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 5672</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8001&#x2F;eureka&#x2F;</span><br><span class="line">management:</span><br><span class="line">  endpoints: #暴露bus刷新配置的端点</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#39;bus-refresh&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给config-client添加消息总线支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9004</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-client</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      profile: dev #启用环境名称</span><br><span class="line">      label: dev #分支名称</span><br><span class="line">      name: config #配置文件名称</span><br><span class="line">      discovery:</span><br><span class="line">        enabled: true</span><br><span class="line">        service-id: config-server</span><br><span class="line">  rabbitmq: #rabbitmq相关配置</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 5672</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8001&#x2F;eureka&#x2F;</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#39;refresh&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> bus消息总线 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bus消息总线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法执行效率分析</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>如何分析一个“排序算法”？</p><h3 id="1-最好情况、最坏情况、平均情况时间复杂度"><a href="#1-最好情况、最坏情况、平均情况时间复杂度" class="headerlink" title="1. 最好情况、最坏情况、平均情况时间复杂度"></a>1. 最好情况、最坏情况、平均情况时间复杂度</h3><p>我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。</p><ul><li>有些排序算法会区分，为了好对比，都做一下区分。</li><li>对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。</li></ul><h3 id="2-时间复杂度的系数、常数-、低阶"><a href="#2-时间复杂度的系数、常数-、低阶" class="headerlink" title="2. 时间复杂度的系数、常数 、低阶"></a>2. 时间复杂度的系数、常数 、低阶</h3><p>实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。</p><h3 id="3-比较次数和交换（或移动）次数"><a href="#3-比较次数和交换（或移动）次数" class="headerlink" title="3. 比较次数和交换（或移动）次数"></a>3. 比较次数和交换（或移动）次数</h3><p>基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。</p><h3 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h3><p>原地排序（Sorted in place）。==原地排序算法，就是特指空间复杂度是 O(1)== 的排序算法。</p><h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><p>稳定性：==如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。==</p><p>我通过一个例子来解释一下。比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。</p><p>这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法；如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。</p>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法执行效率分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx原理</title>
      <link href="2020/06/21/Study%20notes/6%E3%80%81server/nginx/Nginx%E5%8E%9F%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/6%E3%80%81server/nginx/Nginx%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>nginx启动后，在后台其实启动了一个master进程和多个worker进程</p><ul><li>master只做任务分配给worker</li><li>worker是负责处理nginx部分的请求。</li></ul><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>客户端发送请求到nginx的master,master将任务分配给地下的各个worker,分配方式为各个worker争抢模式，某worker争取到任务后，走代理等到对应的tomcat请求数据逼格返回。</p><h3 id="master-workers的设计优点："><a href="#master-workers的设计优点：" class="headerlink" title="master-workers的设计优点："></a>master-workers的设计优点：</h3><p>首先，对于每个 worker 进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，且某worker进程异常退出后，<br>只会导致当前 worker 上的所有请求失败，其余worker上的请求是可以正常处理的，索引nginx服务还是可用的。</p><h3 id="合理配置worker"><a href="#合理配置worker" class="headerlink" title="合理配置worker"></a>合理配置worker</h3><p>Nginx 同 redis 类似都采用了 io 多路复用机制，每个 worker 都是一个独立的进程，但每个进<br>程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话<br>下。</p><p>==每个 worker 的线程可以把一个 cpu 的性能发挥到极致。所以 worker 数和服务器的 cpu<br>数相等是最为适宜的==。设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗。</p><h3 id="合理配置worker-connection"><a href="#合理配置worker-connection" class="headerlink" title="合理配置worker_connection"></a>合理配置worker_connection</h3><p>这个值是表示每个worker进程所能建立连接的最大值，所以，一个 nginx 能建立的最大连接数，应该是 worker_connections * worker_processes。</p><ul><li><p>对于HTTP 请 求 本 地 资 源 来 说 ， 能 够 支 持 的 最 大 并 发 数 量 是 worker_connections *<br>worker_processes</p></li><li><p>http1.1 的浏览器每次访问要占两个连接，所以普通的静态访<br>问最大并发数是： worker_connections * worker_processes /2，</p></li><li><p>而如果是 HTTP 作 为反向代<br>理来说，最大并发数量应该是 worker_connections *<br>worker_processes/4。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服<br>务的连接，会占用两个连接。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux安装neo4j</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/5%E3%80%81%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/Neo4j/2%E3%80%81linux%E5%AE%89%E8%A3%85neo4j/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/5%E3%80%81%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/Neo4j/2%E3%80%81linux%E5%AE%89%E8%A3%85neo4j/</url>
      
        <content type="html"><![CDATA[<p>curl -O <a href="http://dist.neo4j.org/neo4j-community-3.4.5-unix.tar.gz">http://dist.neo4j.org/neo4j-community-3.4.5-unix.tar.gz</a></p><p>解压：<br>tar -zxvf neo4j-community-3.4.5-unix.tar.gz -C /usr/local/java</p><p>在安装目录下找到conf目录下的neo4j.conf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 修改35行和36行，设置JVM初始堆内存和JVM最大堆内存</span><br><span class="line"># 生产环境给的JVM最大堆内存越大越好，但是要小于机器的物理内存</span><br><span class="line">#dbms.memory.heap.initial_size&#x3D;5g</span><br><span class="line">#dbms.memory.heap.max_size&#x3D;10g</span><br><span class="line"></span><br><span class="line"># 修改54行，去掉改行的#，可以远程通过ip访问neo4j数据库</span><br><span class="line">dbms.connectors.default_listen_address&#x3D;0.0.0.0</span><br><span class="line"></span><br><span class="line"># 默认 bolt端口是7687，http端口是7474，https关口是7473，不修改下面3项也可以</span><br><span class="line"># 修改71行，去掉#，设置http端口为7687，端口可以自定义，只要不和其他端口冲突就行</span><br><span class="line">#dbms.connector.bolt.listen_address&#x3D;:7687</span><br><span class="line"></span><br><span class="line"># 修改75行，去掉#，设置http端口为7474，端口可以自定义，只要不和其他端口冲突就行</span><br><span class="line">dbms.connector.http.listen_address&#x3D;:7474</span><br><span class="line"></span><br><span class="line"># 修改79行，去掉#，设置http端口为7473，端口可以自定义，只要不和其他端口冲突就行</span><br><span class="line">dbms.connector.https.listen_address&#x3D;:7473</span><br><span class="line"></span><br><span class="line"># 修改227行，去掉#，允许从远程url来load csv</span><br><span class="line">dbms.security.allow_csv_import_from_file_urls&#x3D;true</span><br><span class="line"></span><br><span class="line"># 修改246行，允许使用neo4j-shell，类似于mysql 命令行之类的</span><br><span class="line">dbms.shell.enabled&#x3D;true</span><br><span class="line"></span><br><span class="line"># 修改248行，去掉#，设置连接neo4j-shell的端口，一般都是localhost或者127.0.0.1，这样安全，其他地址的话，一般使用https就行</span><br><span class="line">dbms.shell.host&#x3D;127.0.0.1</span><br><span class="line"></span><br><span class="line"># 修改250行，去掉#，设置neo4j-shell端口，端口可以自定义，只要不和其他端口冲突就行</span><br><span class="line">dbms.shell.port&#x3D;1337</span><br><span class="line"></span><br><span class="line"># 修改254行，设置neo4j可读可写</span><br><span class="line">dbms.read_only&#x3D;false</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相关命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">进入bin目录：</span><br><span class="line"></span><br><span class="line">启动neo4j(后台启动):  .&#x2F;neo4j start</span><br><span class="line"></span><br><span class="line">控制台显示日志方式启动：.&#x2F;neo4j console</span><br><span class="line"></span><br><span class="line">停止：.&#x2F;neo4j stop</span><br><span class="line"></span><br><span class="line">查看状态：.&#x2F;neo4j status</span><br></pre></td></tr></table></figure><p>启动后 访问：<a href="http://ip:7474/browser/">http://ip:7474/browser/</a><br>默认数据库用户名和密码：neo4j，neo4j</p>]]></content>
      
      
      <categories>
          
          <category> Neo4j </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux安装neo4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建对象的方式</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Java中创建对象的几种方式</p><h3 id="1、使用构造器（new-关键字）"><a href="#1、使用构造器（new-关键字）" class="headerlink" title="1、使用构造器（new 关键字）"></a>1、使用构造器（new 关键字）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectName obj &#x3D; new ObjectName();</span><br></pre></td></tr></table></figure><p>将构造器封装成静态工厂，获取对象的实例：（推荐使用代替构造器）<br>使用静态工厂的优势：</p><ul><li>静态工厂有名称，当有多个构造器方法重载时，静态工厂可确切描述返回的对象，提高可读性</li><li>可以使用单例，不必每次都创建对象</li><li>可返回原来类型的任何子类</li><li>在创建参数化类型实例的时候，它们使代码变得更加简<br>洁。如：</li></ul><p>随着类型参数变得越来越长，越来越复杂，这一冗长的说明也很快变得痛苦起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;string, list&lt;string&gt;&gt;m m</span><br><span class="line">new Hashmap&lt;string, list&lt;string&gt;&gt;();</span><br></pre></td></tr></table></figure><p>静态工厂:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static&lt;k, V&gt; Hashmap&lt;k, V&gt; newinstance() &#123;</span><br><span class="line">return new Hashmap&lt;k, V&gt;();</span><br></pre></td></tr></table></figure><p>使用静态工厂的缺点：</p><ul><li>类如果不含有公有的，或受保护的构造器，就不能被实例化</li><li>与其他静态方法实际上并无区别（严格遵守命令规范，可弥补这个缺点） 如：String.valueOf()  静态工厂的getType()  与实际类的getType不易区分</li></ul><h3 id="2、使用Class类的newInstance方法"><a href="#2、使用Class类的newInstance方法" class="headerlink" title="2、使用Class类的newInstance方法"></a>2、使用Class类的newInstance方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student stu &#x3D; Student.class.newInstance();</span><br><span class="line">&#x2F;&#x2F;Class类的内部调用Constructor的newInstance方法</span><br></pre></td></tr></table></figure><h3 id="3、使用Constructor类的newInstance方法："><a href="#3、使用Constructor类的newInstance方法：" class="headerlink" title="3、使用Constructor类的newInstance方法："></a>3、使用Constructor类的newInstance方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;Student&gt; constructor &#x3D; Student.class.getInstance(); Student stu &#x3D; constructor.newInstance();　</span><br></pre></td></tr></table></figure><h3 id="4、使用Clone的方法"><a href="#4、使用Clone的方法" class="headerlink" title="4、使用Clone的方法"></a>4、使用Clone的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectName obj &#x3D; obj.clone();&#x2F;&#x2F;这也是原型模式的应用    </span><br></pre></td></tr></table></figure><h3 id="5、使用反序列化："><a href="#5、使用反序列化：" class="headerlink" title="5、使用反序列化："></a>5、使用反序列化：</h3><p>当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象，在反序列化时，JVM创建对象并不会调用任何构造函数。为了反序列化一个对象，我们需要让我们的类实现Serializable接口。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream in &#x3D; new ObjectInputStream (new FileInputStream(&quot;data.obj&quot;)); </span><br><span class="line">Student stu3 &#x3D; (Student)in.readObject();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建对象的方式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC</title>
      <link href="2020/06/21/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RPC/RPC/"/>
      <url>2020/06/21/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RPC/RPC/</url>
      
        <content type="html"><![CDATA[<p>RPC的目的是让你在本地调用远程的方法，而对你来说这个调用是透明的，你并不知道这个调用的方法是部署哪里。通过RPC能解耦服务，这才是使用RPC的真正目的。RPC的原理主要用到了动态代理模式。</p><p>RPC 的作用就是体现在这样两个方面：</p><ul><li>屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法；</li><li>隐藏底层网络通信的复杂性，让我们更专注于业务逻辑。</li></ul><p>在一个典型 RPC 的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件</p><p>涉及技术</p><p>序列化、Socket通信、Java动态代理技术，反射机制</p><p>RPC 框架的重要组成：</p><ul><li>客户端(Client)：服务调用方。</li><li>客户端存根(Client Stub)：存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端。</li><li>服务端存根(Server Stub)：接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。</li><li>服务端(Server)：服务的真正提供者。</li><li>Network Service：底层传输，可以是 TCP 或 HTTP。</li></ul><h4 id="常见RPC框架："><a href="#常见RPC框架：" class="headerlink" title="常见RPC框架："></a>常见RPC框架：</h4><ul><li>Google 的gRPC</li><li>facebook的thrift</li><li>Twitter 的 Finagle</li><li>brpc</li><li>阿里的Dubbo</li></ul><p>自己实现一个 RPC，最简单的方式要实现三个技术点，分别是：</p><ul><li>服务寻址：Call ID 映射：可以直接使用函数字符串，也可以使用整数</li><li>数据流的序列化和反序列化：：可以自己写，也可以使用 Protobuf 或者 FlatBuffers 之类的。</li><li>网络传输：可以自己写 Socket，或者用 Asio，ZeroMQ，Netty、MINA 之类。</li></ul><h4 id="服务寻址"><a href="#服务寻址" class="headerlink" title="服务寻址"></a>服务寻址</h4><p>实现方式：服务注册中心。要调用服务，首先你需要一个服务注册中心去查询对方服务都有哪些实例</p>]]></content>
      
      
      <categories>
          
          <category> RPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nignx 负载均衡的几种算法介绍</title>
      <link href="2020/06/21/Study%20notes/6%E3%80%81server/nginx/2%E3%80%81nignx%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/06/21/Study%20notes/6%E3%80%81server/nginx/2%E3%80%81nignx%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>一、Nginx负载均衡算法</p><pre><code>1、轮询（默认）    每个请求按时间顺序逐一分配到不同的后端服务，如果后端某台服务器死机，自动剔除故障系统，使用户访问不受影响。2、weight（轮询权值）    weight的值越大分配到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。或者仅仅为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。    upstream bakend &#123;      server 192.168.0.14 weight=10;      server 192.168.0.15 weight=10;      &#125;3、ip_hash    每个请求按访问IP的哈希结果分配，使来自同一个IP的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的session共享问题。    upstream bakend &#123;      ip_hash;      server 192.168.0.14:88;      server 192.168.0.15:80;      &#125; 4、fair    比 weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间 来分配请求，响应时间短的优先分配。Nginx本身不支持fair，如果需要这种调度算法，则必须安装upstream_fair模块。    upstream backend &#123;      server server1;      server server2;      fair;      &#125;5、url_hash    按访问的URL的哈希结果来分配请求，使每个URL定向到一台后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身不支持url_hash，如果需要这种调度算法，则必须安装Nginx的hash软件包。    upstream backend &#123;      server squid1:3128;      server squid2:3128;      hash $request_uri;      hash_method crc32;</code></pre>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nignx 负载均衡的几种算法介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot打war包</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-boot/5%E3%80%81SpringBoot%E6%89%93war%E5%8C%85/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-boot/5%E3%80%81SpringBoot%E6%89%93war%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h3 id="1、修改Spring-Boot启动类"><a href="#1、修改Spring-Boot启动类" class="headerlink" title="1、修改Spring Boot启动类"></a>1、修改Spring Boot启动类</h3><p>启动类继承SpringBootServletInitializer类，并覆盖configure方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Application extends SpringBootServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;</span><br><span class="line">return application.sources(Application.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">SpringApplication.run(Application.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、修改jar为war包形式"><a href="#2、修改jar为war包形式" class="headerlink" title="2、修改jar为war包形式"></a>2、修改jar为war包形式</h3><p>在pom文件中，添加war包配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;packaging&gt;war&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、去除Spring Boot内置Tomcat：修改自带tomcat依赖范围为provided，防止与外部tomcat发生冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>4、添加war包打包插件：如果你用的是继承spring-boot-starter-parent的形式使用Spring Boot，那可以跳过，因为它已经帮你配置好了。如果你使用的依赖spring-boot-dependencies形式，你需要添加以下插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-war-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;failOnMissingWebXml&gt;false&lt;&#x2F;failOnMissingWebXml&gt;</span><br><span class="line">    &lt;&#x2F;configuration&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--failOnMissingWebXml需要开启为false，不然打包会报没有web.xml错误。--&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5、使用maven命令：<br>mvn clean package</p><p>==6、jar包转war包有什么影响？==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、application配置文件中的server.xx等关于容器的配置就无效了，改配置需要在外部tomcat中进行。</span><br><span class="line"></span><br><span class="line">2、Spring Boot的升级是否需要Tomcat跟着升级？需要观察。</span><br><span class="line"></span><br><span class="line">3、打war包比打jar明显要变慢好多。。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring-boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot打war包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>simple-queue</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/2%E3%80%81RabbitMQ/3%E3%80%81simple-queue/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/2%E3%80%81RabbitMQ/3%E3%80%81simple-queue/</url>
      
        <content type="html"><![CDATA[<p>简单消息队列：</p><h1 id="消息生产者："><a href="#消息生产者：" class="headerlink" title="消息生产者："></a>消息生产者：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Send &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消息队列 名称</span><br><span class="line">private static final String QUEUE_NAME&#x3D;&quot;queue_02&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取连接</span><br><span class="line">Connection connection &#x3D; ConnectionUtils.getConnection();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取通道</span><br><span class="line">Channel channel &#x3D; connection.createChannel();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生命消息队列</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">String msg&#x3D;&quot;workQueue消息&quot;+i;</span><br><span class="line">&#x2F;&#x2F;发送消息到队列中</span><br><span class="line">channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes());</span><br><span class="line">System.err.println(&quot;send:&quot;+msg);</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;关闭连接 释放资源</span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消费者："><a href="#消费者：" class="headerlink" title="消费者："></a>消费者：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Receiver &#123;</span><br><span class="line">&#x2F;&#x2F;消息队列 名称</span><br><span class="line">private static final String QUEUE_NAME&#x3D;&quot;queue_02&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取连接</span><br><span class="line">Connection connection &#x3D; ConnectionUtils.getConnection();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取通道</span><br><span class="line">Channel channel &#x3D; connection.createChannel();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生命队列</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消费者监听器</span><br><span class="line">DefaultConsumer consumer&#x3D;new DefaultConsumer(channel)&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body)</span><br><span class="line">throws IOException &#123;</span><br><span class="line">System.err.println(&quot;消费者1：&quot;+new String(body));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;添加监听</span><br><span class="line">channel.basicConsume(QUEUE_NAME, true,consumer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单消息队列模型是：点对点，生产者将消息发送到队列中，消费者消费掉消息之后，该消息就不存在了。简单消息队列模型中，如果有多个消费者，默认采用轮询分发消息给多个消费者。</p><p>公平分发：</p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> simple-queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性排序O(n)</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8FO(n)/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8FO(n)/</url>
      
        <content type="html"><![CDATA[<h3 id="桶排序（Bucket-sort）"><a href="#桶排序（Bucket-sort）" class="headerlink" title="桶排序（Bucket sort）"></a>桶排序（Bucket sort）</h3><p>桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p><p>时间复杂度：</p><p>如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p><p>比如说我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？借助桶排序的处理思想来解决这个问题。</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序其实是桶排序的一种特殊情况。    </p><p>如果你所在的省有 50 万考生，如何通过成绩快速排序得出名次呢？考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。</p><h3 id="基数排序（Radix-sort）"><a href="#基数排序（Radix-sort）" class="headerlink" title="基数排序（Radix sort）"></a>基数排序（Radix sort）</h3>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性排序O(n) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式面试</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h4 id="1、原型设计"><a href="#1、原型设计" class="headerlink" title="1、原型设计"></a>1、原型设计</h4><ol><li>请使用UML类图画出原型模式核心角色</li><li>原型设计模式的深拷贝和浅拷贝是什么，并写出深拷贝的两种方式的源码(重写<br>clone方法实现深拷贝、使用序列化来实现深拷贝)</li><li>在Spring框架中哪里使用到原型模式，并对源码进行分析<br>beans.xml<bean id="id01" class="com.atguigu.spring.bean.Monster" scope="prototype"/></li></ol><h4 id="2、解释器设计模式"><a href="#2、解释器设计模式" class="headerlink" title="2、解释器设计模式"></a>2、解释器设计模式</h4><ol><li>介绍解释器设计模式是什么?</li><li>画出解释器设计模式的UML类图,<br>分析设计模式中的各个角色是什<br>么?</li><li>请说明Spring的框架中，哪里<br>使用到了解释器设计模式，并<br>做源码级别的分析</li></ol><h4 id="3、单例设计模式"><a href="#3、单例设计模式" class="headerlink" title="3、单例设计模式"></a>3、单例设计模式</h4><p>单例设计模式一共有几种实现方式？请分别用代码实现，并说明各个实现方式的<br>优点和缺点?</p><h4 id="4、综合："><a href="#4、综合：" class="headerlink" title="4、综合："></a>4、综合：</h4><p>一线IT公司(大厂)，都会问你在实际项目中使用过什么<br>设计模式，怎样使用的，解决了什么问题。</p><p>注意：设计模式是站在项目稳定性，拓展性的至高点，去解决问题。不是为实现某一个功能而做的。所以不要觉得实现某功能用个设计模式反而很麻烦。</p><p>设计模式分为三种类型，共23种</p><ol><li>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。</li><li>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享<br>元模式、代理模式。</li><li>行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者<br>模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模<br>式、策略模式、职责链模式(责任链模式)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式原则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>objectFactory</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/5%E3%80%81objectFactory/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/5%E3%80%81objectFactory/</url>
      
        <content type="html"><![CDATA[<p>在 MyBatis 中，当其 sql 映射配置文件中的 sql 语句所得到的查询结果，被动态映射到 resultType 或其他处理结果集的参数配置对应的 Java 类型，其中就有 JavaBean 等封装类。而 objectFactory 对象工厂的作用就是通过目标类的默认构造/有参构造器来创建实体对象的类。</p><p>有时候在 new 一个新对象（默认构造器或者有参构造器），在得到对象之前需要处理一些逻辑，或者在执行该类的有参构造方法时，在传入参数之前，要对参数进行一些处理，这时就可以创建自己的 objectFactory 来加载该类型的对象。</p><p>自定义ObjectFactory，要求实现ObjectFactory接口（这里DefaultObjectFactory里面及实现了该接口）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MyObjectFactory extends DefaultObjectFactory &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;处理默认构造方法</span><br><span class="line">    public Object create(Class type)&#123;</span><br><span class="line">        return super.create(type);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;处理有参构造方法</span><br><span class="line">    public Object create(Class type, List&lt;Class&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)&#123;</span><br><span class="line">        &#x2F;&#x2F;使用定制工厂的create方法构建单个对象</span><br><span class="line">        return super.create(type, constructorArgTypes, constructorArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;处理参数</span><br><span class="line">    public void setProperties(Properties properties)&#123;</span><br><span class="line">       &#x2F;&#x2F;定制属性</span><br><span class="line">        super.setProperties(properties);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;判断集合类型参数</span><br><span class="line">    public &lt;T&gt; boolean isCollection(Class&lt;T&gt; type)&#123;</span><br><span class="line">        return Collection&lt;E&gt;.class.isAssignableFrom(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 MyBatis 的全局配置文件 SqlMapConfig.xml 中添加配置使其生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;objectFactory type&#x3D;&quot;org.mybatis.example.MyObjectFactory&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;MyObjectFactory&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;objectFactory&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> objectFactory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mq介绍</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/3%E3%80%81RocketMQ/1%E3%80%81mq%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/3%E3%80%81RocketMQ/1%E3%80%81mq%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p><a href="http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/">http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/</a></p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/data-communication/RocketMQ-Questions.md">https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/data-communication/RocketMQ-Questions.md</a></p><p>kafka</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Apache下的一个子项目，使用scala实现的一个高性能分布式Publish&#x2F;Subscribe消息队列系统。</span><br><span class="line">1.快速持久化：通过磁盘顺序读写与零拷贝机制，可以在O(1)的系统开销下进行消息持久化；</span><br><span class="line">2.高吞吐：在一台普通的服务器上既可以达到10W&#x2F;s的吞吐速率；</span><br><span class="line">3.高堆积：支持topic下消费者较长时间离线，消息堆积量大；</span><br><span class="line">4.完全的分布式系统：Broker、Producer、Consumer都原生自动支持分布式，依赖zookeeper自动实现复杂均衡；</span><br><span class="line">5.支持Hadoop数据并行加载：对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。</span><br></pre></td></tr></table></figure><p>roceket</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RocketMQ是一款分布式、队列模型的消息中间件，具有以下特点 ：</span><br><span class="line">1.能够保证严格的消息顺序</span><br><span class="line"> 2.提供丰富的消息拉取模式</span><br><span class="line"> 3.高效的订阅者水平扩展能力</span><br><span class="line"> 4.实时的消息订阅机制</span><br><span class="line"> 5.支持事务消息</span><br><span class="line"> 6.亿级消息堆积能力</span><br></pre></td></tr></table></figure><p>RocketMQ</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP,STOMP，</span><br><span class="line">也正是如此，使的它变的非常重量级，更适合于企业级的开发。同时实现了Broker架构，核心思想是生产者不会将消息直接发送给队列，消息在发送给客户端时先在中心队列排队。</span><br><span class="line">对路由(Routing)，负载均衡(Load balance)、数据持久化都有很好的支持。多用于进行企业级的ESB整合。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mq介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cors跨域配置</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/12%E3%80%81javaWeb/%E8%B7%A8%E5%9F%9F/2%E3%80%81cors%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/12%E3%80%81javaWeb/%E8%B7%A8%E5%9F%9F/2%E3%80%81cors%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>由于浏览器的同源策略（浏览器对js施加的安全限制）。导致浏览器不能执行其他网站的脚本。就是跨域。</p><p>协议，域名，端口的不同会造成跨域。</p><p>如何解决：==cors 资源共享（主流解决方案）==</p><h3 id="简单请求："><a href="#简单请求：" class="headerlink" title="简单请求："></a>简单请求：</h3><p>只要同时满足以下两大条件，就属于简单请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（1) 请求方法是以下三种方法之一：</span><br><span class="line">HEAD</span><br><span class="line">GET</span><br><span class="line">POST</span><br><span class="line">（2）HTTP的头信息不超出以下几种字段：</span><br><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type：只限于三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain</span><br></pre></td></tr></table></figure><h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>非简单请求的就是复杂请求：</p><p>浏览器先doOptions请求，得到服务器授权之后，再发第二次的真是请求。</p><p>1、服务器重写doOptions方法、在doOptions方法添加响应消息头，保证第一次请求成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin:*</span><br><span class="line">Access-Control-Allow-Headers：xxx  &#x2F;&#x2F;允许客户端添加自定义消息头。</span><br></pre></td></tr></table></figure><p>2、在第二次的真实请求doPots/doGet方法也添加头，保证第二次请求成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin:*</span><br><span class="line">Access-Control-Allow-Headers：xxx &#x2F;&#x2F;允许客户端添加自定义消息头。</span><br></pre></td></tr></table></figure><h3 id="跨域的解决方案："><a href="#跨域的解决方案：" class="headerlink" title="跨域的解决方案："></a>跨域的解决方案：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CorsConfig implements WebMvcConfigurer &#123;</span><br><span class="line">@Override</span><br><span class="line">public void addCorsMappings(CorsRegistry registry) &#123; &#x2F;&#x2F; 设置允许跨域的路径</span><br><span class="line">registry.addMapping(&quot;&#x2F;**&quot;) &#x2F;&#x2F; 设置允许跨域请求的域名</span><br><span class="line">.allowedOrigins(&quot;*&quot;) &#x2F;&#x2F; 是否允许证书 不再默认开启</span><br><span class="line">.allowCredentials(true) &#x2F;&#x2F; 设置允许的方法</span><br><span class="line">.allowedMethods(&quot;*&quot;) &#x2F;&#x2F; 跨域允许时间</span><br><span class="line">.maxAge(3600);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 跨域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cors跨域配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>roceketmq消息机制</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/3%E3%80%81RocketMQ/4%E3%80%81roceketmq%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/3%E3%80%81RocketMQ/4%E3%80%81roceketmq%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>RocketMQ有2种常见的消费模式,分别是DefaultMQPushConsumer和DefaultMQPullConsumer模式。这里有个误区，其实无论是Push还是Pull，其本质都是拉取消息，只是实现机制不一样</p><h3 id="DefaultMQPushConsumer模式"><a href="#DefaultMQPushConsumer模式" class="headerlink" title="DefaultMQPushConsumer模式"></a>DefaultMQPushConsumer模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">其实并不是broker主动向consumer推送消息，</span><br><span class="line">而是consumer向broker发出请求，保持了一种长链接，</span><br><span class="line">broker会每5秒会检测一次是否有消息，</span><br><span class="line">如果有消息，则将消息推送给consumer。</span><br><span class="line">使用DefaultMQPushConsumer实现消息消费，broker会主动记录消息消费的偏移量。</span><br></pre></td></tr></table></figure><h3 id="DefaultMQPullConsumer模式"><a href="#DefaultMQPullConsumer模式" class="headerlink" title="DefaultMQPullConsumer模式"></a>DefaultMQPullConsumer模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">消费方主动去broker拉取数据，一般会在本地使用定时任务实现，</span><br><span class="line">使用它获得消息状态方便、负载均衡性能可控 ，但消息的及时性差,而且需要手动记录消息消费的偏移量信息 ，</span><br><span class="line">所以在工作中多数情况推荐使用Push模式</span><br></pre></td></tr></table></figure><p>==RocketMQ发送的消息默认会存储到4个队列中，当然创建几个队列存储数据，可以自己定义==</p><p>RocketMQ作为MQ消息中间件，ack机制必不可少，在RocketMQ中常见的应答状态如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalTransactionState:主要针对事务消息的应答状态</span><br><span class="line"></span><br><span class="line">public enum LocalTransactionState &#123;</span><br><span class="line">    COMMIT_MESSAGE,&#x2F;&#x2F;消息提交</span><br><span class="line">    ROLLBACK_MESSAGE,&#x2F;&#x2F;消息回滚</span><br><span class="line">    UNKNOW,   &#x2F;&#x2F;未知状态，一般用于处理超时等现象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ConsumeConcurrentlyStatus:主要针对消息消费的应答状态</span><br><span class="line"></span><br><span class="line">public enum ConsumeConcurrentlyStatus &#123;</span><br><span class="line">    &#x2F;&#x2F;消息消费成功</span><br><span class="line">    CONSUME_SUCCESS,</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;消息重试，一般消息消费失败后，RocketMQ为了保证数据的可靠性，具有重试机制</span><br><span class="line">    RECONSUME_LATER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> roceketmq消息机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/4%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/4%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>假设我们有 1000 万个整数数据，每个数据占 8 个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？ 我们希望这个功能不要占用太多的内存空间，最多不要超过 100MB，你会怎么做呢？带着这个问题，让我们进入今天的内容吧！</p><p>==二分查找针对的是一个有序数组集合==，不能是链表，因为要根据下标随机取值。</p><p>数据量太小不适合二分查找。顺序遍历即可<br>数据量太大也不适合二分查找。要求内存空间连续，对内存的要求比较苛刻</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int bsearch(int[] a, int n, int value) &#123;</span><br><span class="line">  int low &#x3D; 0;</span><br><span class="line">  int high &#x3D; n - 1;</span><br><span class="line"></span><br><span class="line">  while (low &lt;&#x3D; high) &#123;</span><br><span class="line">    int mid &#x3D; (low + high) &#x2F; 2;</span><br><span class="line">    if (a[mid] &#x3D;&#x3D; value) &#123;</span><br><span class="line">      return mid;</span><br><span class="line">    &#125; else if (a[mid] &lt; value) &#123;</span><br><span class="line">      low &#x3D; mid + 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      high &#x3D; mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 二分查找的递归实现</span><br><span class="line">public int bsearch(int[] a, int n, int val) &#123;</span><br><span class="line">  return bsearchInternally(a, 0, n - 1, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int bsearchInternally(int[] a, int low, int high, int value) &#123;</span><br><span class="line">  if (low &gt; high) return -1;</span><br><span class="line"></span><br><span class="line">  int mid &#x3D;  low + ((high - low) &gt;&gt; 1);</span><br><span class="line">  if (a[mid] &#x3D;&#x3D; value) &#123;</span><br><span class="line">    return mid;</span><br><span class="line">  &#125; else if (a[mid] &lt; value) &#123;</span><br><span class="line">    return bsearchInternally(a, mid+1, high, value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return bsearchInternally(a, low, mid-1, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>应用：</p><p>1、最简单模型：有序数据集合中不存在重复的数据，我们在其中查找值等于某个给定值的数据</p><p>2、查找第一个值等于给定值的元素</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序链表</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2%E3%80%81%E9%93%BE%E8%A1%A8/5%E3%80%81%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2%E3%80%81%E9%93%BE%E8%A1%A8/5%E3%80%81%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>前面的链表实现插入数据都是无序的，在有些应用中需要链表中的数据有序，这称为有序链表。</p><p>　　在有序链表中，数据是按照关键值有序排列的。一般在大多数需要使用有序数组的场合也可以使用有序链表。有序链表优于有序数组的地方是插入的速度（因为元素不需要移动），另外链表可以扩展到全部有效的使用内存，而数组只能局限于一个固定的大小中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.ys.datastructure;</span><br><span class="line"></span><br><span class="line">public class OrderLinkedList &#123;</span><br><span class="line">    private Node head;</span><br><span class="line">    </span><br><span class="line">    private class Node&#123;</span><br><span class="line">        private int data;</span><br><span class="line">        private Node next;</span><br><span class="line">        </span><br><span class="line">        public Node(int data)&#123;</span><br><span class="line">            this.data &#x3D; data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public OrderLinkedList()&#123;</span><br><span class="line">        head &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;插入节点，并按照从小打到的顺序排列</span><br><span class="line">    public void insert(int value)&#123;</span><br><span class="line">        Node node &#x3D; new Node(value);</span><br><span class="line">        Node pre &#x3D; null;</span><br><span class="line">        Node current &#x3D; head;</span><br><span class="line">        while(current !&#x3D; null &amp;&amp; value &gt; current.data)&#123;</span><br><span class="line">            pre &#x3D; current;</span><br><span class="line">            current &#x3D; current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre &#x3D;&#x3D; null)&#123;</span><br><span class="line">            head &#x3D; node;</span><br><span class="line">            head.next &#x3D; current;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            pre.next &#x3D; node;</span><br><span class="line">            node.next &#x3D; current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;删除头节点</span><br><span class="line">    public void deleteHead()&#123;</span><br><span class="line">        head &#x3D; head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void display()&#123;</span><br><span class="line">        Node current &#x3D; head;</span><br><span class="line">        while(current !&#x3D; null)&#123;</span><br><span class="line">            System.out.print(current.data+&quot; &quot;);</span><br><span class="line">            current &#x3D; current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有序链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监听器</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/12%E3%80%81javaWeb/servlet/7%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/12%E3%80%81javaWeb/servlet/7%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>1、在web.xml文件中配置监听器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置应用监听器  --&gt;     </span><br><span class="line">&lt;listener&gt;     </span><br><span class="line">    &lt;listener-class&gt;com.ycq.ListenerTest&lt;&#x2F;listener-class&gt;     </span><br><span class="line">&lt;&#x2F;listener&gt;</span><br></pre></td></tr></table></figure><ul><li>现在来说说Servlet的监听器Listener，它是实现了javax.servlet.ServletContextListener 接口的 </li><li>服务器端程序，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。主要作用是：做一些初始化 </li><li>的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等。 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ListenerTest implements ServletContextListener&#123;       </span><br><span class="line">   &#x2F;&#x2F; 应用监听器的销毁方法     </span><br><span class="line">   public void contextDestroyed(ServletContextEvent servletContextEvent) &#123;     </span><br><span class="line">        ServletContext servletContext &#x3D; servletContextEvent.getServletContext();  </span><br><span class="line">        &#x2F;&#x2F; 在整个web应用销毁之前调用，将所有应用空间所设置的内容清空  </span><br><span class="line">        System.out.println(&quot;销毁工作完成...&quot;);    </span><br><span class="line">   &#125;     </span><br><span class="line">    &#x2F;&#x2F; 应用监听器的初始化方法     </span><br><span class="line">    public void contextInitialized(ServletContextEvent servletContextEvent) &#123;     </span><br><span class="line">        &#x2F;&#x2F; 通过这个事件可以获取整个应用的空间     </span><br><span class="line">        &#x2F;&#x2F; 在整个web应用下面启动的时候做一些初始化的内容添加工作     </span><br><span class="line">        ServletContext servletContext &#x3D; servletContextEvent.getServletContext();    </span><br><span class="line">        &#x2F;&#x2F; 设置一些基本的内容；比如一些参数或者是一些固定的对象     </span><br><span class="line">        System.out.println(&quot;应用监听器初始化工作完成...&quot;);     </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> servlet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 监听器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 部署jar</title>
      <link href="2020/06/21/Study%20notes/7%E3%80%81linux/linux%20%E9%83%A8%E7%BD%B2jar/"/>
      <url>2020/06/21/Study%20notes/7%E3%80%81linux/linux%20%E9%83%A8%E7%BD%B2jar/</url>
      
        <content type="html"><![CDATA[<h3 id="1、启动脚本"><a href="#1、启动脚本" class="headerlink" title="1、启动脚本"></a>1、启动脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nohup &#x2F;usr&#x2F;local&#x2F;jdk1.8.0_191&#x2F;bin&#x2F;java -Xmx256m -Xms256m -XX:MetaspaceSize&#x3D;64m -XX:MaxMetaspaceSize&#x3D;128m -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC  -jar &#x2F;runtime&#x2F;gaoRun&#x2F;gao.jar  &gt;&gt; &#x2F;runtime&#x2F;gaoRun&#x2F;feifeiNohup.out &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1、-Xms ：表示java虚拟机堆区内存初始内存分配的大小，通常为操作系统可用内存的1/64大小即可，但仍需按照实际情况进行分配。有可能真的按照这样的一个规则分配时，设计出的软件还没有能够运行得起来就挂了。</p><p>2、-Xmx： 表示java虚拟机堆区内存可被分配的最大上限，通常为操作系统可用内存的1/4大小。但是开发过程中，通常会将 -Xms 与 -Xmx两个参数的配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</p><p>3、-XX:newSize：表示新生代初始内存的大小，应该小于 -Xms的值；</p><p>4、-XX:MaxnewSize：表示新生代可被分配的内存的最大上限；当然这个值应该小于 -Xmx的值；</p><p>5、-Xmn：至于这个参数则是对 -XX:newSize、-XX:MaxnewSize两个参数的同时配置，也就是说如果通过-Xmn来配置新生代的内存大小，那么-XX:newSize = -XX:MaxnewSize = -Xmn，虽然会很方便，但需要注意的是这个参数是在JDK1.4版本以后才使用的</p><p>6、-XX:PermSize：表示非堆区初始内存分配大小，其缩写为permanent size（持久化内存）</p><p>7、-XX:MaxPermSize：表示对非堆区分配的内存的最大上限。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux 部署jar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>端口和防火墙</title>
      <link href="2020/06/21/Study%20notes/7%E3%80%81linux/%E7%AB%AF%E5%8F%A3%E5%92%8C%E9%98%B2%E7%81%AB%E5%A2%99/"/>
      <url>2020/06/21/Study%20notes/7%E3%80%81linux/%E7%AB%AF%E5%8F%A3%E5%92%8C%E9%98%B2%E7%81%AB%E5%A2%99/</url>
      
        <content type="html"><![CDATA[<p>关闭防火墙，就可以外部访问了。不受端口限制。生产环境，最好开启防火墙，开启部分端口。</p><h4 id="查看防火墙状态：service方式"><a href="#查看防火墙状态：service方式" class="headerlink" title="查看防火墙状态：service方式"></a>查看防火墙状态：service方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables status</span><br></pre></td></tr></table></figure><h4 id="开启-关闭防火墙【永久有效】"><a href="#开启-关闭防火墙【永久有效】" class="headerlink" title="开启/关闭防火墙【永久有效】"></a>开启/关闭防火墙【永久有效】</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启： chkconfig iptables on </span><br><span class="line">关闭： chkconfig iptables off</span><br></pre></td></tr></table></figure><h5 id="开启-关闭防火墙【临时生效】"><a href="#开启-关闭防火墙【临时生效】" class="headerlink" title="开启/关闭防火墙【临时生效】"></a>开启/关闭防火墙【临时生效】</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启： service iptables start </span><br><span class="line">关闭： service iptables stop </span><br></pre></td></tr></table></figure><h5 id="查看防火墙状态：iptables方式"><a href="#查看防火墙状态：iptables方式" class="headerlink" title="查看防火墙状态：iptables方式"></a>查看防火墙状态：iptables方式</h5><p>先进入init.d目录，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;init.d&#x2F;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#查看防火墙状态：</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;iptables status</span><br><span class="line"></span><br><span class="line">#暂时关闭防火墙</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;iptables stop</span><br><span class="line"></span><br><span class="line">#暂时开启防火墙</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;iptables start</span><br><span class="line"></span><br><span class="line">#重启iptables：</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;iptables restart</span><br></pre></td></tr></table></figure><h4 id="3-开启部分端口"><a href="#3-开启部分端口" class="headerlink" title="3.开启部分端口"></a>3.开启部分端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;iptables</span><br><span class="line"></span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 6379 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 8081 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 8082 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables restart </span><br></pre></td></tr></table></figure><h4 id="4、查看开放端口"><a href="#4、查看开放端口" class="headerlink" title="4、查看开放端口"></a>4、查看开放端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">netstat -nupl (UDP类型的端口)</span><br><span class="line">netstat -ntpl (TCP类型的端口)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">a 表示所有</span><br><span class="line"></span><br><span class="line">n表示不查询dns</span><br><span class="line"></span><br><span class="line">t表示tcp协议</span><br><span class="line"></span><br><span class="line">u表示udp协议</span><br><span class="line"></span><br><span class="line">p表示查询占用的程序</span><br><span class="line"></span><br><span class="line">l表示查询正在监听的程序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">netstat -nuplf|grep 3306   &#x2F;&#x2F;这个表示查找处于监听状态的，端口号为3306的进程</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 端口和防火墙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>下单减库存防止超卖现象</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E4%B8%8B%E5%8D%95%E5%87%8F%E5%BA%93%E5%AD%98%E9%98%B2%E6%AD%A2%E8%B6%85%E5%8D%96%E7%8E%B0%E8%B1%A1/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E4%B8%8B%E5%8D%95%E5%87%8F%E5%BA%93%E5%AD%98%E9%98%B2%E6%AD%A2%E8%B6%85%E5%8D%96%E7%8E%B0%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>对于一个电商系统来说，库存管理才是精髓，影响到电商履约环节。</p><p>==各种解决方案的都存在优缺点，所以依据场景选择解决方案就尤为重要了。==</p><h5 id="一、扣减库存的两种方案"><a href="#一、扣减库存的两种方案" class="headerlink" title="一、扣减库存的两种方案"></a>一、扣减库存的两种方案</h5><h6 id="1、下单–减库存–支付"><a href="#1、下单–减库存–支付" class="headerlink" title="1、下单–减库存–支付"></a>1、下单–减库存–支付</h6><p>订单取消、支付失败、超时未支付（例如设置10/15分钟）数据都回仓【将查库存，下单，减库存加锁为原子性操作】</p><p>优点：下单成功，则肯定能购买成功，不会出现超卖情况。</p><p>缺点：需要通过业务方式（例如买家黑名单）防止恶意下单占库存但就是支付的买家，导致真正需要的用户买不到。</p><p>【使用场景】<br>适用于库存数量敏感的场景，比如秒杀，或者库存数量不是特别多。这个时候，库存一定要在下单的时候就锁住，否则出现超卖，订单履约困难</p><h6 id="（2）下单–支付成功–减库存"><a href="#（2）下单–支付成功–减库存" class="headerlink" title="（2）下单–支付成功–减库存"></a>（2）下单–支付成功–减库存</h6><p>　　优点：只有真正支付了才减库存，防止恶意买家大量下单用光库存，避免下单减库存的缺点</p><p>　　缺点：下单页面不是显示真实的库存， 因第三方支付异步回调存在时差，同一时间多个用户同时付款成功，会导致下单数目超过库存，商家库存不足容易引发断货和投诉，成本增加。<br>　　<br>【使用场景】<br>适用于库存数量不敏感的场景，比如团购，或者库存数量充足。就算超卖了，也不太可能超卖太多</p><p>电商优惠均摊:<br><a href="https://www.jianshu.com/p/d1f18987525c">https://www.jianshu.com/p/d1f18987525c</a></p>]]></content>
      
      
      <categories>
          
          <category> 高频点问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 下单减库存防止超卖现象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final域的重排序规则(未完)</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/final%E5%9F%9F%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99(%E6%9C%AA%E5%AE%8C)/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/final%E5%9F%9F%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99(%E6%9C%AA%E5%AE%8C)/</url>
      
        <content type="html"><![CDATA[<p>线程安全产生的原因是，多线程访问可变状态的共享变量。如果共享变量的状态不可变为final.则不会引发线程安全问题。</p><p>final是如何保证状态不可变的？</p><h3 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h3><p>对于final域，编译器和处理器要遵守两个重排序规则。</p><ul><li>1）在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用<br>变量，这两个操作之间不能重排序。</li><li>2）初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class FinalExample &#123;</span><br><span class="line">    int i; &#x2F;&#x2F; 普通变量</span><br><span class="line">    final int j; &#x2F;&#x2F; final变量</span><br><span class="line">    static FinalExample obj;</span><br><span class="line"></span><br><span class="line">    public FinalExample() &#123; &#x2F;&#x2F; 构造函数</span><br><span class="line">        i &#x3D; 1; &#x2F;&#x2F; 写普通域</span><br><span class="line">        j &#x3D; 2; &#x2F;&#x2F; 写final域</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writer() &#123; &#x2F;&#x2F; 写线程A执行</span><br><span class="line">        obj &#x3D; new FinalExample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void reader() &#123; &#x2F;&#x2F; 读线程B执行</span><br><span class="line">        FinalExample object &#x3D; obj; &#x2F;&#x2F; 读对象引用</span><br><span class="line">        int a &#x3D; object.i; &#x2F;&#x2F; 读普通域</span><br><span class="line">        int b &#x3D; object.j; &#x2F;&#x2F; 读final域</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>写final域的重排序规则禁止把final域的写重排序到构造函数之外。</li><li>1）JMM禁止编译器把final域的写重排序到构造函数之外。</li><li>2）编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障<br>禁止处理器把final域的写重排序到构造函数之外。</li></ul><h3 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h3>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> final域的重排序规则(未完) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lasticsearch介绍</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/5%E3%80%81%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/3%E3%80%81elasticsearch/1%E3%80%81lasticsearch%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/5%E3%80%81%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/3%E3%80%81elasticsearch/1%E3%80%81lasticsearch%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="Elasticsearch使用案例"><a href="#Elasticsearch使用案例" class="headerlink" title="Elasticsearch使用案例"></a>Elasticsearch使用案例</h3><ul><li><p>（1）2013年初，GitHub抛弃了Solr，采取ElasticSearch 来做PB级的搜索。 “GitHub使用ElasticSearch搜索20TB的数据，包括13亿文件和1300亿行代码”</p></li><li><p>（2）维基百科：启动以elasticsearch为基础的核心搜索架构SoundCloud：“SoundCloud使用ElasticSearch为1.8亿用户提供即时而精准的音乐搜索服务”</p></li><li><p>（3）百度：百度目前广泛使用ElasticSearch作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部20多个业务线（包括casio、云分析、网盟、预测、文库、直达号、钱包、风控等），单集群最大100台机器，200个ES节点，每天导入30TB+数据</p></li><li><p>（4）新浪使用ES 分析处理32亿条实时日志</p></li><li><p>（5）阿里使用ES 构建挖财自己的日志采集和分析体系</p></li></ul><h3 id="Solr、ES区别"><a href="#Solr、ES区别" class="headerlink" title="Solr、ES区别"></a>Solr、ES区别</h3><p>solr和es都基于lucene</p><ol><li><p>Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能;</p></li><li><p>Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式；</p></li><li><p>Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；</p></li><li><p>Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch—–附近的人</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lasticsearch介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Feign中的服务降级</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/3%E3%80%81feign/Feign%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/3%E3%80%81feign/Feign%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>Feign中的服务降级使用起来非常方便，只需要为Feign客户端定义的接口添加一个服务降级处理的实现类即可，下面我们为UserService接口添加一个服务降级实现类。</p><p>需要注意的是它实现了UserService接口，并且对接口中的每个实现方法进行了服务降级逻辑的实现    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by macro on 2019&#x2F;9&#x2F;5.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class UserFallbackService implements UserService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public CommonResult create(User user) &#123;</span><br><span class="line">        User defaultUser &#x3D; new User(-1L, &quot;defaultUser&quot;, &quot;123456&quot;);</span><br><span class="line">        return new CommonResult&lt;&gt;(defaultUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CommonResult&lt;User&gt; getUser(Long id) &#123;</span><br><span class="line">        User defaultUser &#x3D; new User(-1L, &quot;defaultUser&quot;, &quot;123456&quot;);</span><br><span class="line">        return new CommonResult&lt;&gt;(defaultUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改UserService接口，设置服务降级处理类为UserFallbackService</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value &#x3D; &quot;user-service&quot;,fallback &#x3D; UserFallbackService.class)</span><br><span class="line">public interface UserService &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启Hystrix功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: true #在Feign中开启Hystrix</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Feign的常用配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: true #在Feign中开启Hystrix</span><br><span class="line">  compression:</span><br><span class="line">    request:</span><br><span class="line">      enabled: false #是否对请求进行GZIP压缩</span><br><span class="line">      mime-types: text&#x2F;xml,application&#x2F;xml,application&#x2F;json #指定压缩的请求数据类型</span><br><span class="line">      min-request-size: 2048 #超过该大小的请求会被压缩</span><br><span class="line">    response:</span><br><span class="line">      enabled: false #是否对响应进行GZIP压缩</span><br><span class="line">logging:</span><br><span class="line">  level: #修改日志级别</span><br><span class="line">    com.macro.cloud.service.UserService: debug</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> feign </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Feign中的服务降级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker介绍</title>
      <link href="2020/06/21/Study%20notes/9%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/docker/1%E3%80%81docker%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/06/21/Study%20notes/9%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/docker/1%E3%80%81docker%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>docker：</p><ul><li>虚拟机是模拟一整套硬件，在其基础上运行的一个完整的操作系统</li><li>docker容器是直接运行在宿主内核中的，没有进行硬件虚拟，也没有自己的内容。只是将需要软件配置等统一打包</li></ul><p>docker官网：<a href="http://www.docker.com/">http://www.docker.com</a><br>docker中文网站：<a href="https://www.docker-cn.com/">https://www.docker-cn.com/</a><br>Docker Hub官网: <a href="https://hub.docker.com/">https://hub.docker.com/</a><br>Docker的架构图：</p><h3 id="docker安装："><a href="#docker安装：" class="headerlink" title="docker安装："></a>docker安装：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#先安装docker依赖：</span><br><span class="line">yum install -y epel-release</span><br><span class="line">#安装docker:</span><br><span class="line">yum install -y docker-io</span><br><span class="line"></span><br><span class="line">#安装后的配置文件：</span><br><span class="line">&#x2F;etc&#x2F;sysconfig&#x2F;docker</span><br><span class="line"></span><br><span class="line">#检测安装成功，查看版本：</span><br><span class="line">docker version</span><br><span class="line">#docker信息</span><br><span class="line">docker info</span><br><span class="line">#docker帮助命令</span><br><span class="line">docker --help</span><br><span class="line"></span><br><span class="line">#启动Docker后台服务：</span><br><span class="line">service docker start</span><br><span class="line">或</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">#设置开机自起</span><br><span class="line">systemctl  enable docker</span><br></pre></td></tr></table></figure><h3 id="配置镜像加速："><a href="#配置镜像加速：" class="headerlink" title="配置镜像加速："></a>配置镜像加速：</h3><p>docker镜像文件仓库默认是docker.hub ,配置切换至国内的阿里云</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">进入阿里云的镜像管理中心：</span><br><span class="line">https:&#x2F;&#x2F;cr.console.aliyun.com&#x2F;?spm&#x3D;5176.1971733.0.2.6c045aaamyGClV#&#x2F;accelerator</span><br><span class="line"></span><br><span class="line">复制加速地址：https:&#x2F;&#x2F;c24l0xe6.mirror.aliyuncs.com</span><br><span class="line"></span><br><span class="line">配置到docker的配置文件</span><br><span class="line">mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;c24l0xe6.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#重加载</span><br><span class="line">systemctl daemon-reload </span><br><span class="line">#重启</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="卸载docker："><a href="#卸载docker：" class="headerlink" title="卸载docker："></a>卸载docker：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker </span><br><span class="line">yum -y remove docker-ce</span><br><span class="line">rm -rf &#x2F;var&#x2F;lib&#x2F;docker</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CopyOnWriteArraySet</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/3%E3%80%81CopyOnWriteArraySet/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/3%E3%80%81CopyOnWriteArraySet/</url>
      
        <content type="html"><![CDATA[<p>==CopyOnWriteArraySet由于是基于CopyOnWriteArrayList==的，所以对其操作都是基于CopyOnWriteArrayList的，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。</p><p>CopyOnWriteArraySet的元素不允许重复，这是和CopyOnWriteArrayList不相同的地方</p><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性　　"></a>类的属性　　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class CopyOnWriteArraySet&lt;E&gt; extends AbstractSet&lt;E&gt;</span><br><span class="line">        implements java.io.Serializable &#123;</span><br><span class="line">    &#x2F;&#x2F; 版本序列号</span><br><span class="line">    private static final long serialVersionUID &#x3D; 5457747651344034263L;</span><br><span class="line">    &#x2F;&#x2F; 由其对CopyOnWriteArraySet提供支持</span><br><span class="line">    private final CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public CopyOnWriteArraySet() &#123;</span><br><span class="line">       &#x2F;&#x2F; 初始化al</span><br><span class="line">       al &#x3D; new CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">   &#125;</span><br><span class="line">   public CopyOnWriteArraySet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">       if (c.getClass() &#x3D;&#x3D; CopyOnWriteArraySet.class) &#123; &#x2F;&#x2F; c集合为CopyOnWriteArraySet类型</span><br><span class="line">           &#x2F;&#x2F; 初始化al</span><br><span class="line">           @SuppressWarnings(&quot;unchecked&quot;) CopyOnWriteArraySet&lt;E&gt; cc &#x3D;</span><br><span class="line">               (CopyOnWriteArraySet&lt;E&gt;)c;</span><br><span class="line">           al &#x3D; new CopyOnWriteArrayList&lt;E&gt;(cc.al);</span><br><span class="line">       &#125;</span><br><span class="line">       else &#123; &#x2F;&#x2F; c集合不为CopyOnWriteArraySet类型</span><br><span class="line">           &#x2F;&#x2F; 初始化al</span><br><span class="line">           al &#x3D; new CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">           &#x2F;&#x2F; 添加c集合(c集合的元素在al中部存在时，才会添加)</span><br><span class="line">           al.addAllAbsent(c);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>对CopyOnWriteArraySet的操作（如add、remove、clear等）都转化为对CopyOnWriteArrayList的操作</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CopyOnWriteArraySet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>feign介绍</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/3%E3%80%81feign/1%E3%80%81feign%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/3%E3%80%81feign/1%E3%80%81feign%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>feign官网介绍：</p><p><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-feign">https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-feign</a></p><p>翻译：feign是声明式的web服务客户端，是的编写web服务客户端变得很容易。只需要创建一个接口，添加上一个注解即可。</p><p>思考：之前使用ribbon已经可以在客户端实现负载均衡，而且可以自定义ribbon的访问算法，可以说是很强大了。feign负载均衡怎么出来的？</p><p>之前调用微服务的方式：</p><p>单eureka服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ribbon的负载均衡是通过微服务名称访问到的 而不是微服务的本身直接的地址</span><br><span class="line">&#x2F;&#x2F;微服务的本身地址：</span><br><span class="line">&#x2F;&#x2F; String url&#x3D;&quot;http:&#x2F;&#x2F;localhost:8001&#x2F;springcloudtest01-provider&#x2F;getData&quot;;</span><br></pre></td></tr></table></figure><p>eureka服务器集群：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过微服务的名称访问：CLOUD-SERVICE-PROVIDER-01 服务名称，cloud-service-provider-01 &#x2F;&#x2F;微服务的映射路径（再微服务的server.context-path&#x3D;&#x2F;cloud-service-provider-01配置） &#x2F;&#x2F;getData 地址</span><br><span class="line">        String url&#x3D;&quot;http:&#x2F;&#x2F;CLOUD-SERVICE-PROVIDER-01&#x2F;cloud-service-provider-01&#x2F;getData&quot;;</span><br></pre></td></tr></table></figure><p>为了统一的面向对象编程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public class DeptDao&#123;</span><br><span class="line">   Dept getDeptByName()；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是通过接口+注解的方式调用数据库。</p><p>feign就是通过同样的方式调用微服务而已。</p><p>前面使用Ribbon+RestTemplate地址调用服务。feign就是通过接口+注解调用服务。feign集成了ribbon 默认采用轮询的方式做负载均衡</p>]]></content>
      
      
      <categories>
          
          <category> feign </category>
          
      </categories>
      
      
        <tags>
            
            <tag> feign介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串练习</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81String/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%83%E4%B9%A0/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81String/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><ul><li>遍历一次字符串，统计空格的总数，计算出替换后字符串总长度。</li><li>从字符串后面开始复制和替换，首先准备两个指针，p1，p2，p1指向原始字符串末尾，p2指向替换后字符串末尾，p1指向的字符不为空，复制到p2所在的位置，之后两者向前移动一个位置。</li><li>为空时，p2插入字符串%20，向前移动三个位置，p1向前移动一个位置，直到p1p2指向同一个位置或者p1遍历了所有的字符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void replaceSpace(char *str,int length) &#123;</span><br><span class="line">        int i, pastlength &#x3D; 0, afterlength, k, spacelength &#x3D; 0;</span><br><span class="line">        i &#x3D; 0;</span><br><span class="line">        while(str[i] !&#x3D; &#39;\0&#39;)</span><br><span class="line">        &#123;</span><br><span class="line">            pastlength++;&#x2F;&#x2F;替换前长度</span><br><span class="line">            if(str[i] &#x3D;&#x3D; &#39; &#39;)</span><br><span class="line">                spacelength++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        afterlength &#x3D; pastlength + spacelength * 2; &#x2F;&#x2F;替换之后字符串的长度</span><br><span class="line">        if(afterlength&gt;length)  </span><br><span class="line">            return;  </span><br><span class="line">        int j&#x3D;afterlength;  </span><br><span class="line">        for(i&#x3D;pastlength;i&gt;&#x3D;0 &amp;&amp; j &gt; i;i--)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if(str[i]!&#x3D;&#39; &#39;)  </span><br><span class="line">                str[j--]&#x3D;str[i];  </span><br><span class="line">            else  </span><br><span class="line">            &#123;  </span><br><span class="line">                str[j--]&#x3D;&#39;0&#39;;  </span><br><span class="line">                str[j--]&#x3D;&#39;2&#39;;  </span><br><span class="line">                str[j--]&#x3D;&#39;%&#39;;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AVL树</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6%E3%80%81%E6%A0%91/4%E3%80%81AVL%E6%A0%91/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6%E3%80%81%E6%A0%91/4%E3%80%81AVL%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>平衡二叉树也叫平衡二叉搜索树又叫AVL树（它的发明者G.M. Adelson-Velsky和E.M. Landis的名字缩写） ==它是一棵空树或它任何节点的两个子树的最大高度差为1==，并且左右两个子树都是一棵平衡二叉树(都是建立在二叉排序树基础上)</p><p><img src="https://img-blog.csdnimg.cn/20181116141602804.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIxNTI2MTk=,size_16,color_FFFFFF,t_70" alt="image"></p><p>平衡二叉树的实现方式：<br>红黑树、AVL算法、替罪羊树、Treap、伸展树等</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><ul><li>根节点是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据（为了简化红黑树的代码实现而设置的）；</li><li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的</li><li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点<br><img src="https://static001.geekbang.org/resource/image/90/9a/903ee0dcb62bce2f5b47819541f9069a.jpg" alt="image"></li></ul><p>二叉查找树很多操作的性能都跟树的高度成正比。一棵极其平衡的二叉树（满二叉树或完全二叉树）的高度大约是 log2n，所以如果要证明红黑树是近似平衡的，我们只需要分析，红黑树的高度是否比较稳定地趋近 log2n 就好了。</p>]]></content>
      
      
      <categories>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AVL树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis的几种传参方式</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/10%E3%80%81mybatis%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/10%E3%80%81mybatis%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="1、方法1：顺序传参法"><a href="#1、方法1：顺序传参法" class="headerlink" title="1、方法1：顺序传参法"></a>1、方法1：顺序传参法</h3><p>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public User selectUser(String name, int deptId);</span><br><span class="line">&lt;select id&#x3D;&quot;selectUser&quot; resultMap&#x3D;&quot;UserResultMap&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    where user_name &#x3D; #&#123;0&#125; and dept_id &#x3D; #&#123;1&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><h3 id="方法2：-Param注解传参法"><a href="#方法2：-Param注解传参法" class="headerlink" title="方法2：@Param注解传参法"></a>方法2：@Param注解传参法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public User selectUser(@Param(&quot;userName&quot;) String name, int @Param(&quot;deptId&quot;) deptId);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;select id&#x3D;&quot;selectUser&quot; resultMap&#x3D;&quot;UserResultMap&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    where user_name &#x3D; #&#123;userName&#125; and dept_id &#x3D; #&#123;deptId&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#{}里面的名称对应的是注解 @Param括号里面修饰的名称。<br>这种方法在参数不多的情况还是比较直观的，推荐使用</p><h3 id="方法3：Map传参法"><a href="#方法3：Map传参法" class="headerlink" title="方法3：Map传参法"></a>方法3：Map传参法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public User selectUser(Map&lt;String, Object&gt; params);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;select id&#x3D;&quot;selectUser&quot; parameterType&#x3D;&quot;java.util.Map&quot; resultMap&#x3D;&quot;UserResultMap&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    where user_name &#x3D; #&#123;userName&#125; and dept_id &#x3D; #&#123;deptId&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种方法适合传递多个参数，且参数易变能灵活传递的情况</p><h3 id="方法4：Java-Bean传参法"><a href="#方法4：Java-Bean传参法" class="headerlink" title="方法4：Java Bean传参法"></a>方法4：Java Bean传参法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public User selectUser(Map&lt;String, Object&gt; params);</span><br><span class="line">&lt;select id&#x3D;&quot;selectUser&quot; parameterType&#x3D;&quot;com.test.User&quot; resultMap&#x3D;&quot;UserResultMap&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    where user_name &#x3D; #&#123;userName&#125; and dept_id &#x3D; #&#123;deptId&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种方法很直观，但需要建一个实体类，扩展不容易，需要加属性，看情况使用。</p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis的几种传参方式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB的地址位置索引</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/2%E3%80%81mongodb/4%E3%80%81MongoDB%E7%9A%84%E5%9C%B0%E5%9D%80%E4%BD%8D%E7%BD%AE%E7%B4%A2%E5%BC%95/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/2%E3%80%81mongodb/4%E3%80%81MongoDB%E7%9A%84%E5%9C%B0%E5%9D%80%E4%BD%8D%E7%BD%AE%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p>示例：</p><p>一张门店表shop_list，表结构字段包括shop_id，shop_name，lng，lat （门店id，门店名称，以及门店的经纬度等）。</p><p>　　现收集到当前用户的所处位置的经纬度是，经度116.30759，纬度40.05748。获取距离用户1000m以内的100家门店，按照距离从近到远排序。　　</p><p>mysql:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT shop_id,shop_name,lng,lat, ROUND(6378.138*2*ASIN(SQRT(POW(SIN((40.05748*PI()&#x2F;180-lat*PI()&#x2F;180)&#x2F;2),2)+COS(40.05748*PI()&#x2F;180)*COS(lat*PI()&#x2F;180)*POW(SIN((116.30759*PI()&#x2F;180-lng*PI()&#x2F;180)&#x2F;2),2)))*1000) AS distance</span><br><span class="line">FROM shop_list</span><br><span class="line">HAVING distance &lt; 1000</span><br><span class="line">ORDER BY distance LIMIT 100;</span><br></pre></td></tr></table></figure><p>一个这样的计算方法，显然mysql性能比较差。</p><p>mongodb:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#39;point&#39; : &#123;</span><br><span class="line">    &#39;lng&#39; : 116.299,</span><br><span class="line">    &#39;lat&#39; : 40.053</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后给经纬度的point做一个2dSphere索引。具体参考官方文档：　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.shop_list.createIndex(&#123;&quot;point&quot;:&quot;2dsphere&quot;&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#这个点的附近</span><br><span class="line">db.shop_list.find(&#123;&#39;point&#39;:&#123;$nearSphere: [116.30759, 40.05748]&#125;&#125;) </span><br><span class="line"></span><br><span class="line">#这个点的附近1000米</span><br><span class="line">db.shop_list.find(&#123;point: &#123; $geoWithin: &#123; $centerSphere: [ [ 116.30759, 40.05748 ], 1000&#x2F;6378137 ] &#125; &#125; &#125;) </span><br><span class="line"></span><br><span class="line">#这个点的附近1000米的10个门店，并且有距离计算值</span><br><span class="line">db.runCommand(&#123; geoNear : &quot;shop_list&quot; , near : [ 116.30759, 40.05748], num : 10 , spherical:true, distanceMultiplier: 6378137, maxDistance:1000&#x2F;6378137&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mongodb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB的地址位置索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>storm</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/6%E3%80%81%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%AE%9E%E6%97%B6%E6%B5%81%E8%AE%A1%E7%AE%97/Storm/storm/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/6%E3%80%81%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%AE%9E%E6%97%B6%E6%B5%81%E8%AE%A1%E7%AE%97/Storm/storm/</url>
      
        <content type="html"><![CDATA[<p>Storm 集群的输入流由名为spout 的组件负责。Spout 将数据传递给名为 bolt 的组件，后者将以某种方式处理这些数据，然后交由下一个bolt组件继续处理。依次类推。形成bolt链。构成处理整个数据过程</p><p>storm 集群想象成一条由 bolt 组件组成的链，每个 bolt 对 spout 暴露出来的数据做某种方式的处理。</p><p>示例：统计播音员提到的人名中，每个名字被提及了相同的次数，或者提到的次数是否有偏重。</p><p>spout 来从一个文件(或者套接字，通过HTTP，或者一些其他方法)读取输入。</p><p>当文本行到达时，spout 将它们交给一个 bolt，将文本行流分隔成单词</p><p>单词流被传递到另一个 bolt，每个单词会<br>被与一个预先定义好的政治家名单列表作比较。每作一次比较，第二个 bolt 会在数据库中增加一次那个名字的计数</p><p>查看结果时，你只要查询数据库，该数据库在数据到达时<br>被会实时更新</p><ul><li>spout： 读取原始数据为bolt提供数据。</li><li>bolt： 从spout或其它bolt接收数据，并处理数据，处理结果可作为其它bolt的数据源或最终结果。</li><li>nimbus： 主节点的守护进程，负责为工作节点分发任务。</li><li>topology： 拓扑结构，Storm的一个任务单元。</li><li>define field(s)： 定义域，由spout或bolt提供，被bolt接收。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Storm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> storm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-3树</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6%E3%80%81%E6%A0%91/3%E3%80%812-3%E6%A0%91/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6%E3%80%81%E6%A0%91/3%E3%80%812-3%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>为什么会有2-3树这种数据结构呢？是因为他的查询复杂度比平衡二叉树还高吗？</p><p>实际上2-3树的查询时间复杂度也是为 O(logN) ，而出现这种多路查找树，因为内存IO的速度比磁盘IO要快的多的多，但是同样空间大小的内存比硬盘要贵的多的多。如果用平衡二叉树这种数据结构，在大数据量的情况下，树肯定会很高，此时查个数据对磁盘读个几千上万次那肯定是不行的。</p><p>所以用多路查找树这种数据结构，高阶的情况下，树不用很高就可以标识很大的数据量了，检索次数就大大减少了，用这种数据结构去磁盘中存取数据，磁盘IO次数的次数也会很少。</p><p>为了解决二叉查找树的不平衡，2-3树孕育而生，2-3树能够很好的实现树的平衡。2-3树的节点不再是单一的2节点，节点可能是2节点、3节点。</p><p>2节点：有一个值，两个子节点<br>3节点：有两个值，三个子节点。</p><p><img src="https://github.com/longjiangxue/blogImage/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/3%E8%8A%82%E7%82%B9.png?raw=true" alt="image"></p><p>在二叉树中，每个节点有一个数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树</p>]]></content>
      
      
      <categories>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2-3树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>始终要覆盖toString</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/4%E3%80%81Object%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/2%E3%80%81%E5%A7%8B%E7%BB%88%E8%A6%81%E8%A6%86%E7%9B%96toString/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/4%E3%80%81Object%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/2%E3%80%81%E5%A7%8B%E7%BB%88%E8%A6%81%E8%A6%86%E7%9B%96toString/</url>
      
        <content type="html"><![CDATA[<p>java.lang.Object提供了toString方法的一个实现，但他返回的字符串通常并不是类的用户所期望看到的。它包含类的名称，以及一个“@”符号，接着是散列码的无符号十六进制表示法，例如“PhoneNumber@163b91”</p><h4 id="约定："><a href="#约定：" class="headerlink" title="约定："></a>约定：</h4><p>toString的通用约定指出，被返回的字符串应该是一个“简洁地，但信息丰富，并且易于阅读的表达形式”==建议所有的子类都覆盖这个方法。==</p><p>在实现toString的时候，文档中指定返回值的格式</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>他可以被用做一种标准的、明确地、适合人约定的对象表示法。这种表示法可以用于输入和输出，以及用在永久的适合于人类阅读的数据对象中，例如XML文档。</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>如果这个类已经被广泛使用，一旦指定格式，就必须始终如一地坚持这种格式。程序员将会编写相应的代码来解析这种字符串表示法，产生字符串表示法，以及把字符串表示法嵌入到持久的数据库中。如果将来发型版本中改变了这种表示法，就会破坏他们的代码和数据</p><p>所以无论是否决定指定格式，都应该在文档中明确的表明你的意图。如果你要指定格式，则应该严格地这样去做（写注释）</p>]]></content>
      
      
      <categories>
          
          <category> Object中的方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 始终要覆盖toString </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存架构设计常见问题</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F/1%E3%80%81%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F/1%E3%80%81%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1、缓存穿透"><a href="#1、缓存穿透" class="headerlink" title="1、缓存穿透"></a>1、缓存穿透</h3><p>大量请求一条缓存和数据库都不存在的数据，请求都会穿过缓存查询数据库。并发请求数据库由于压力过大而宕掉。</p><p>1、为key设置空值（适合有限的key），让缓存存在这条数据就只会返回结果。无非这个结果是null,就不用请求数据库了。</p><p>2、BloomFilter </p><p>在缓存层之前再加一个布隆过滤器 BloomFilter ，先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再去查缓存查 DB。</p><h3 id="2、缓存击穿："><a href="#2、缓存击穿：" class="headerlink" title="2、缓存击穿："></a>2、缓存击穿：</h3><p>和缓存穿透的区别在于key本身是存在的只是过期了而已</p><p>缓存击穿是查询数据库和缓存都存在的数据。只是缓存的key失效。导致请求直接查询数据库</p><p>解决方案：加互斥锁</p><p>并发条件下，获取到锁的线程才去查询数据库，其他线程处于等待，做到流量肖锋。当数据库查询完后，便将数据加入缓存中，其他线程就直接查缓存了。</p><h3 id="3、缓存雪崩"><a href="#3、缓存雪崩" class="headerlink" title="3、缓存雪崩"></a>3、缓存雪崩</h3><p>缓存服务宕机后，会有大量的请求直接查询数据库。导致数据库宕机</p><p>解决方案：</p><p>1、缓存集群，让缓存做到高可用</p><p>2、加本地缓存</p><p>3、使用 Hystrix进行限流和服务降级</p><p>4、Redis持久化，让Redis恢复后能正常使用</p>]]></content>
      
      
      <categories>
          
          <category> 缓存系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存架构设计常见问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口和抽象类</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>1.接口可以多继承，抽象类不能实现多继承。</p><p>2.接口只能定义抽象规则，抽象类既能定义抽象规则也可以提供已经实现的成员。</p><p>3.==接口是一组行为规范==，抽象类是一个不完全的类，着重于族的概念。</p><p>4.接口支持回调，抽象类不能实现回调，因为继承不支持。</p><p>5.接口只包含方法，属性，索引器，事件的签名，但不能定义字段和包含实现的方法，抽象类可以定义属性，字段，包含有实现的方法。</p><p>6.接口可以作用于值类型和引用类型，抽象类只能作用于引用类型（如：Struct只能继承接口）</p><p>7.抽象类应主要用于关系密切的对象，而接口则是适合为不相关的类提供通用功能。</p><p>8.接口着重于Can——Do关系类型，抽象类则偏重于IS——A式关系</p><p>9.接口多定义对象的行为，抽象类多定义对象的属性</p><p>10.如果要设计小而简练的功能块，则使用接口，如果要设计大的功能单元，则使用抽象类。</p><p>11.接口对应的是面向对象编程思想的重要原则：面向接口编程，</p><pre><code> 抽象类对应的则是设计模式的精髓：面向抽象编程</code></pre><p>PS：抽象类的子类继承可以推迟，而接口不可以。</p>]]></content>
      
      
      <categories>
          
          <category> 类和接口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 接口和抽象类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册组件：FactoryBean</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/spring%E6%B3%A8%E8%A7%A3/6%E3%80%81%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6%EF%BC%9AFactoryBean/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/spring%E6%B3%A8%E8%A7%A3/6%E3%80%81%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6%EF%BC%9AFactoryBean/</url>
      
        <content type="html"><![CDATA[<p>组件注册：FactoryBean </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyFactoryBean implements FactoryBean &#123;</span><br><span class="line">    &#x2F;&#x2F;返回一个对象，这个对象会被注册到容器中。</span><br><span class="line">    public Object getObject() throws Exception &#123;</span><br><span class="line">        return new Person();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回对象的类型</span><br><span class="line">    public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        return Person.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;是否为单例  true单实例  false 多例</span><br><span class="line">    public boolean isSingleton() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration &#x2F;&#x2F;告诉spring这是一个配置类  相当于是一个配置文件</span><br><span class="line">public class PersonTwoConfig &#123;</span><br><span class="line">    &#x2F;&#x2F;看着是将MyFactoryBean 注册到容器中。</span><br><span class="line">    &#x2F;&#x2F; 其实是注册的MyFactoryBean的getObject()返回的对象 com.cloud.spring.anntation.test.Person</span><br><span class="line">    @Bean</span><br><span class="line">    public MyFactoryBean myFactoryBean() &#123;</span><br><span class="line">        return new MyFactoryBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext contextBean &#x3D; new AnnotationConfigApplicationContext(PersonConfig.class,PersonTwoConfig.class);</span><br><span class="line">Object obj &#x3D;  contextBean.getBean(&quot;myFactoryBean&quot;);</span><br><span class="line">System.err.println(obj.getClass());</span><br><span class="line">&#x2F;&#x2F;打印：com.cloud.spring.anntation.test.Person</span><br><span class="line">&#x2F;&#x2F;myFactoryBean--&gt; &amp;myFactoryBean 可以获取工厂Bean myFactoryBean本身</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring注解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注册组件：FactoryBean </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册中心服务下线的方式</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/1%E3%80%81Eureka/3%E3%80%81%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/1%E3%80%81Eureka/3%E3%80%81%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="1-直接停掉服务。"><a href="#1-直接停掉服务。" class="headerlink" title="1. 直接停掉服务。"></a>1. 直接停掉服务。</h3><p>默认情况下，如果EurekaServer在90秒没有收到Eureka客户的心跳，注册中心便会将该服务从注册列表中剔除。但这种做法的不好之处在于， 停服小于90s时，客户端已经停止了运行，但仍然在注册中心的列表中。 </p><p>注册中心不及时。虽然通过一定的负载均衡策略或使用熔断器可以让服务正常进行</p><h3 id="2、通过接口请求【推荐】"><a href="#2、通过接口请求【推荐】" class="headerlink" title="2、通过接口请求【推荐】"></a>2、通过接口请求【推荐】</h3><p>注册中心马上知道服务的状态<br>请求接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;eureka&#x2F;apps&#x2F;appID&#x2F;instanceID&#x2F;status?value&#x3D;OUT_OF_SERVICE</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT &quot;http:&#x2F;&#x2F;120.0.0.1:8080&#x2F;eureka&#x2F;apps&#x2F;myApplicationName&#x2F;10.66.39.139:7010&#x2F;status?value&#x3D;OUT_OF_SERVICE&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下线：DOWN</span><br><span class="line">优雅下线：OUT_OF_SERVICE</span><br><span class="line">上线：UP</span><br></pre></td></tr></table></figure><h3 id="3-客户端主动通知注册中心下线"><a href="#3-客户端主动通知注册中心下线" class="headerlink" title="3. 客户端主动通知注册中心下线"></a>3. 客户端主动通知注册中心下线</h3><p>eureka客户端是是一个spring boot应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DiscoveryManager.getInstance().shutdownComponent();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class InstanceStatusController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DiscoveryClient client;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;offline&quot;)</span><br><span class="line">    public void offline()&#123;</span><br><span class="line">    DiscoveryManager.getInstance().shutdownComponent();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Eureka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注册中心服务下线的方式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的main方法必须是public static void？</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/Java%E7%9A%84main%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E6%98%AFpublic%20static%20void%EF%BC%9F/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/Java%E7%9A%84main%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E6%98%AFpublic%20static%20void%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>在 java 核心编程中，JVM 会查找类中的 public static void main(String[]args)，如果找不到该方法就抛出错误 NoSuchMethodError:main 程序终止。</p><p>如果是 Java1.5 及以后的版本还可以使用可变参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String... args)</span><br></pre></td></tr></table></figure><p>1、 为什么main方法是公有的（public） ？</p><p>Java 指定了一些可访问的修饰符如：private、protected、public，任何方法或变量都可以声明为 public，Java 可以从该类之外的地方访问。因为 main 方法是公共的，JVM 就可以轻松的访问执行它。</p><p>2、为什么 main 方法是静态的（static）？</p><p>1、正因为 main 方法是静态的，JVM 调用这个方法就不需要创建任何包含这个 main 方法的实例。</p><p>2、因为 C 和 C++ 同样有类似的 main 方法作为程序执行的入口。</p><p>3、如果 main 方法不声明为静态的，JVM 就必须创建 main 类的实例，因为构造器可以被重载，JVM 就没法确定调用哪个 main 方法。</p><p>4、为什么 main 方法没有返回值（Void）？</p><p>因为 main 返回任何值对程序都没任何意义，所以设计成 void，意味着 main 不会有任何值返回。</p>]]></content>
      
      
      <categories>
          
          <category> java基础篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java的main方法必须是public static void？ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jenkins搭建</title>
      <link href="2020/06/21/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/4%E3%80%81%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%B7%A5%E5%85%B7jenkins/2%E3%80%81jenkins%E6%90%AD%E5%BB%BA/"/>
      <url>2020/06/21/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/4%E3%80%81%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%B7%A5%E5%85%B7jenkins/2%E3%80%81jenkins%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>Jenkins部署码云SpringBoot项目</p><p>服务器环境准备：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdk</span><br><span class="line">maven</span><br><span class="line">git&#x2F;svn</span><br></pre></td></tr></table></figure><p>下载安装jenkins</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;jenkins.repo http:&#x2F;&#x2F;pkg.jenkins-ci.org&#x2F;redhat&#x2F;jenkins.repo</span><br><span class="line">sudo rpm --import https:&#x2F;&#x2F;jenkins-ci.org&#x2F;redhat&#x2F;jenkins-ci.org.key</span><br><span class="line">sudo yum install jenkins</span><br></pre></td></tr></table></figure><p>启动jenkins</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service jenkins start</span><br></pre></td></tr></table></figure><p>报错误信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Starting jenkins (via systemctl):  Job for jenkins.service failed because the control process exited with error code. See &quot;systemctl status jenkins.service&quot; and &quot;journalctl -xe&quot; for details.</span><br><span class="line">                                                           [FAILED]</span><br></pre></td></tr></table></figure><p>原因：找不到jdk路径<br>vim /etc/init.d/jenkins</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">修改配置文件：</span><br><span class="line"></span><br><span class="line">candidates&#x3D;&quot;</span><br><span class="line"></span><br><span class="line">#&#x2F;etc&#x2F;alternatives&#x2F;java</span><br><span class="line"></span><br><span class="line">#&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0&#x2F;bin&#x2F;java</span><br><span class="line"></span><br><span class="line">#&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;jre-1.8.0&#x2F;bin&#x2F;java</span><br><span class="line"></span><br><span class="line">#&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.7.0&#x2F;bin&#x2F;java</span><br><span class="line"></span><br><span class="line">#&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;jre-1.7.0&#x2F;bin&#x2F;java</span><br><span class="line"></span><br><span class="line">#&#x2F;usr&#x2F;bin&#x2F;java</span><br><span class="line"></span><br><span class="line">#&#x2F;usr&#x2F;jdk1.8</span><br><span class="line"></span><br><span class="line">&#x2F;usr&#x2F;jdk1.8&#x2F;bin&#x2F;java</span><br><span class="line"></span><br><span class="line">&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在candidates里插入自己的jdk java路径，其他的全部注释掉<br>（bin/java级）</p><p>然后访问http://${ip}/8080 输入密码cat /var/lib/jenkins/secrets/initialAdminPassword</p>]]></content>
      
      
      <categories>
          
          <category> 持续集成工具jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口好处</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/1%E3%80%81%E6%8E%A5%E5%8F%A3%E5%A5%BD%E5%A4%84/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/1%E3%80%81%E6%8E%A5%E5%8F%A3%E5%A5%BD%E5%A4%84/</url>
      
        <content type="html"><![CDATA[<p>区分一个组件设计得好不好，唯一重要的因素在于，它对于外部的其他组件而言，是否隐藏了其内部数据和其他实现细节</p><p>它可以有效解除组成系统的各组件之的藕合关系，即解放耦合，使得这些组件可以独立地开发、测试、优化、使用、理解和修改。</p><p>java协助隐藏信息的机制：访问控制</p><h4 id="私有的-private"><a href="#私有的-private" class="headerlink" title="私有的:private"></a>私有的:private</h4><p>只有在声明该成员的顶层类内部才可以访问这个成员</p><h4 id="包级私有的-package-private"><a href="#包级私有的-package-private" class="headerlink" title="包级私有的 package-private"></a>包级私有的 package-private</h4><p>声明该成员的包内部的任何类都可以访问这个<br>成员 从技术上讲，它被称为“缺省”（ default ）访问级别，如果没有为成员指定访<br>问修饰符，就采用这个访问级别（当然，接口成员除外，它们默认的访问级别是公有的）</p><h4 id="受保护的-protected"><a href="#受保护的-protected" class="headerlink" title="受保护的:protected"></a>受保护的:protected</h4><p>声明该成员的类的子类可以访问这个成员，并且声明该成员的包内部的任何类也可以访问这个成员</p><h4 id="公有的-public"><a href="#公有的-public" class="headerlink" title="公有的:public"></a>公有的:public</h4><p>在任何地方都可以访问该成员</p><p>==总而言之：尽可能降低可访问性==</p>]]></content>
      
      
      <categories>
          
          <category> 类和接口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 接口好处 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册组件：@Configuration、@Bean</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/spring%E6%B3%A8%E8%A7%A3/1%E3%80%81%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6%EF%BC%9A@Configuration%E3%80%81@Bean/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/spring%E6%B3%A8%E8%A7%A3/1%E3%80%81%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6%EF%BC%9A@Configuration%E3%80%81@Bean/</url>
      
        <content type="html"><![CDATA[<p>spring所有的组件都应该放在spring容器中。</p><p>1、传统通过配置文件注入bean到spring容器的步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;person&quot; class&#x3D;&quot;com.cloud.spring.anntation.test.Person&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;zhangsan&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>获取bean:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;加载配置文件</span><br><span class="line">ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">Person person &#x3D; (Person) context.getBean(&quot;person&quot;);</span><br><span class="line">System.err.println(person);</span><br></pre></td></tr></table></figure><p>2、通过配置类注入bean的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration &#x2F;&#x2F;告诉spring这是一个配置类  相当于是一个配置文件</span><br><span class="line">public class PersonConfig &#123;</span><br><span class="line">&#x2F;&#x2F;给容器中注册一个bean,等价于&lt;bean id&#x3D;&quot;person&quot; class&#x3D;&quot;com.cloud.spring.anntation.test.Person&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;zhangsan&quot;&#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F;        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;18&quot;&#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F;    &lt;&#x2F;bean&gt;</span><br><span class="line">    @Bean</span><br><span class="line">    public Person person()&#123;</span><br><span class="line">       return  new Person(&quot;zhangsan&quot;,18);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、加载配置类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext  contextBean&#x3D;new AnnotationConfigApplicationContext(PersonConfig.class);</span><br><span class="line">Person person2 &#x3D; (Person) context.getBean(Person.class);</span><br><span class="line">System.err.println(person2);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring注解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注册组件：@Configuration、@Bean </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>count实现</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%9E%B6%E6%9E%84/count%E5%AE%9E%E7%8E%B0/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%9E%B6%E6%9E%84/count%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>在不同的引擎中，count(*) 有不同的实现方式</p><ul><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；(语句没加where条件)</li><li>而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li></ul><h4 id="为什么-InnoDB-不跟-MyISAM-一样，也把总数存起来呢？"><a href="#为什么-InnoDB-不跟-MyISAM-一样，也把总数存起来呢？" class="headerlink" title="为什么 InnoDB 不跟 MyISAM 一样，也把总数存起来呢？"></a>为什么 InnoDB 不跟 MyISAM 一样，也把总数存起来呢？</h4><p>因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的<img src="https://static001.geekbang.org/resource/image/5e/97/5e716ba1d464c8224c1c1f36135d0e97.png" alt="image"></p><p>三个会话 A、B、C 会同时查询表 t 的总行数，但拿到的结果却不同。</p><p>这和 InnoDB 的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是 MVCC 来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于 count(*) 请求来说，InnoDB 只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</p>]]></content>
      
      
      <categories>
          
          <category> mysql架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> count实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>世界上最难的事有两件：一是让人心甘情愿地把钱掏出来给你，二是把自己的思想灌输 到别人的脑子里。设计模式就属于第二种。</p><p>它不是一种具体的技术，不像Struts、Spring、 Hibernate等框架。一个工具用久了可以熟能生巧。所有框架和工具只是一个合格的程序员应该具备的基本能力。</p><p>设计模式就是一把刀，极致的境界就是心中无设计模式，代码亦无 设计模式——设计模式随处可见，俯拾皆是，已经融入软件设计的灵魂中，这才是高手中的 高手，简称高高手</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1、单例模式 </span><br><span class="line">2、工厂方法模式 </span><br><span class="line">3、抽象工厂模式 </span><br><span class="line">4、模板方法模式 </span><br><span class="line">5、建造者模式 </span><br><span class="line">6、代理模式 </span><br><span class="line">7、原型模式 </span><br><span class="line">8、中介者模式 </span><br><span class="line">9、命令模式 </span><br><span class="line">10、责任链模式 </span><br><span class="line">11、装饰模式 </span><br><span class="line">12、策略模式 </span><br><span class="line">13、适配器模式 </span><br><span class="line">14、迭代器模式 </span><br><span class="line">15、组合模式 </span><br><span class="line">16、观察者模式 </span><br><span class="line">17、门面模式 </span><br><span class="line">18、备忘录模式 </span><br><span class="line">19、访问者模式 </span><br><span class="line">20、状态模式 </span><br><span class="line">21、解释器模式</span><br><span class="line">22、享元模式 </span><br><span class="line">23、桥梁模式</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式原则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/4%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/4%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>缓存导致的可见性问题</li><li>线程切换带来的原子性问题，</li><li>指令重排带来的有序性问题。</li><li><h4 id="线程安全产生原因："><a href="#线程安全产生原因：" class="headerlink" title="线程安全产生原因："></a>线程安全产生原因：</h4><h3 id="多线程操作共享可变状态数据"><a href="#多线程操作共享可变状态数据" class="headerlink" title="==多线程操作共享可变状态数据=="></a>==多线程操作共享可变状态数据==</h3></li></ul><p>解决线程安全的方式：</p><p>==解决原子性，可见性，有序性==</p><h3 id="1、不在线程之间共享该状态变量"><a href="#1、不在线程之间共享该状态变量" class="headerlink" title="1、不在线程之间共享该状态变量"></a>1、不在线程之间共享该状态变量</h3><p>如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭（Thread Confinement），它是实现线程安全型的最简单方式之一。java提供的机制：例如局部变量和 ThreadLocal 类等</p><h3 id="2、将状态变量修改为不可变状态的变量"><a href="#2、将状态变量修改为不可变状态的变量" class="headerlink" title="2、将状态变量修改为不可变状态的变量"></a>2、将状态变量修改为不可变状态的变量</h3><p>不可变对象一定是线程安全的，如何保证对象状态不可变</p><ul><li>1、对象的创建是正确的，不会出现对象溢出</li><li>2、对象创建以后其状态就不可修改</li><li>3、对象所有的域都是final类型</li><li>4、确保可见性，volatile</li></ul><h3 id="3、互斥同步（加锁）"><a href="#3、互斥同步（加锁）" class="headerlink" title="3、互斥同步（加锁）"></a>3、互斥同步（加锁）</h3><p>synchronized与Lock</p><h3 id="4、非阻塞同步（CAS算法）"><a href="#4、非阻塞同步（CAS算法）" class="headerlink" title="4、非阻塞同步（CAS算法）"></a>4、非阻塞同步（CAS算法）</h3>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/9%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/9%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>有一个背包，容量为4磅 ， 现有如下物品</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">物品 重量 价格</span><br><span class="line">吉他(G) 1 1500</span><br><span class="line">音响(S) 4 3000</span><br><span class="line">电脑(L) 3 2000</span><br></pre></td></tr></table></figure><ul><li>要求达到的目标为装入的背包的总价值最大，并且重量不超出</li><li>要求装入的物品不能重复</li></ul><h3 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a>动态规划：</h3><p>动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进<br>行解决，从而一步步获取最优解的处理算法</p><p>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子<br>问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p><p>==适合于用动态规划求解的问题，经分解得到子问题往往不<br>是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，<br>进行进一步的求解 )==</p><h4 id="动态规划可以通过填表的方式来逐步推进，得到最优解"><a href="#动态规划可以通过填表的方式来逐步推进，得到最优解" class="headerlink" title="动态规划可以通过填表的方式来逐步推进，得到最优解"></a>动态规划可以通过填表的方式来逐步推进，得到最优解</h4>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 相关命令</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/4%E3%80%81kafka/3%E3%80%81Kafka%20%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/4%E3%80%81kafka/3%E3%80%81Kafka%20%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>1、创建 topic</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka-topics.sh --zookeeper </span><br><span class="line">127.0.0.1:2181 --create --replication-factor 3 --partitions 1 --</span><br><span class="line">topic MyTopicName</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--topic 定义 topic 名</span><br><span class="line">--replication-factor 定义副本数</span><br><span class="line">--partitions 定义分区数</span><br></pre></td></tr></table></figure><p>2、删除Topic</p><p>server.properties中的属性delete.topic.enable=true 否则只是标记删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka-topics.sh --zookeeper </span><br><span class="line">127.0.0.1:2181 --delete --topic MyTopicName</span><br></pre></td></tr></table></figure><p>3、查看Topic</p><p>查看当前服务器中的所有 topic</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka-topics.sh --zookeeper </span><br><span class="line">127.0.0.1:2181 --list</span><br></pre></td></tr></table></figure><p>查看某个 Topic 的详情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka-topics.sh --zookeeper </span><br><span class="line">127.0.0.1:2181 --describe --topic MyTopicName</span><br></pre></td></tr></table></figure><p>发送消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka-console-producer.sh --broker-list 127.0.0.1:9092 --topic MyTopicName</span><br></pre></td></tr></table></figure><p>消费消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka-console-consumer.sh --zookeeper 127.0.0.1:2181 --topic MyTopicName</span><br></pre></td></tr></table></figure><p>修改分区数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka-topics.sh --zookeeper </span><br><span class="line">127.0.0.1:2181 --alter --topic MyTopicName --partitions 6</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka 相关命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitlab安装</title>
      <link href="2020/06/21/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/2%E3%80%81%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/git/gitlab%E5%AE%89%E8%A3%85/"/>
      <url>2020/06/21/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/2%E3%80%81%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/git/gitlab%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>rpm下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#国内下载镜像地址(https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gitlab-ce&#x2F;yum&#x2F;),在这里同学们根据自己的系统是6还是7进行选择，我的系统是7，我这里选择下载10.2.7版本，执行如下命令进行下载</span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gitlab-ce&#x2F;yum&#x2F;el7&#x2F;gitlab-ce-10.2.7-ce.0.el7.x86_64.rpm</span><br><span class="line">#执行rpm(此步骤大概会卡顿10来分钟，请各位同学耐心等待)，执行完成后如下图所示</span><br><span class="line">rpm -i gitlab-ce-10.2.7-ce.0.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>若提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: Failed dependencies:</span><br><span class="line">        policycoreutils-python is needed by gitlab-..</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">则：yum install policycoreutils-python</span><br></pre></td></tr></table></figure><p>继续安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -i gitlab-ce-10.2.7-ce.0.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>安装成功后 启动gitlab：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#启动配置gitlab(配置时间较长，稍安勿躁)</span><br><span class="line">sudo gitlab-ctl reconfigure </span><br><span class="line"></span><br><span class="line">#启动 gitlab 服务</span><br><span class="line">gitlab-ctl start </span><br><span class="line">#停止 gitlab 服务</span><br><span class="line">gitlab-ctl st</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cypher语法</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/5%E3%80%81%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/Neo4j/5%E3%80%81Cypher%E8%AF%AD%E6%B3%95/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/5%E3%80%81%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/Neo4j/5%E3%80%81Cypher%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Cypher是一种声明式图数据库查询语言，它具有丰富的表现力，能高效地查询和更新图数据。</p><p>Cypher借鉴了SQL语言的结构——查询可由各种各样的语句组合。</p><h2 id="节点语法"><a href="#节点语法" class="headerlink" title="节点语法"></a>节点语法</h2><p>Cypher采用一对圆括号来表示节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">()</span><br><span class="line">(matrix)</span><br><span class="line">(:Movie)</span><br><span class="line">(matrix:Movie)</span><br><span class="line">(matrix:Movie &#123;title: &quot;The Matrix&quot;&#125;)</span><br><span class="line">(matrix:Movie &#123;title: &quot;The Matrix&quot;, released: 1997&#125;)</span><br></pre></td></tr></table></figure><h2 id="关系语法"><a href="#关系语法" class="headerlink" title="关系语法"></a>关系语法</h2><p>Cypher使用一对短横线(即“–”)表示：一个无方向关系。有方向的关系在其中一段加上一个箭头(即“&lt;–”或“–&gt;”)。方括号表达式[…]可用于添加详情。里面可以包含变量、属性和或者类型信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--</span><br><span class="line">--&gt;</span><br><span class="line">-[role]-&gt;</span><br><span class="line">-[:ACTED_IN]-&gt;</span><br><span class="line">-[role:ACTED_IN]-&gt;</span><br><span class="line">-[role:ACTED_IN &#123;roles: [&quot;Neo&quot;]&#125;]-&gt;</span><br><span class="line"></span><br><span class="line">Match (n)-[role]-&gt;(m) return n, role ,m</span><br><span class="line"></span><br><span class="line">(keanu:Person:Actor &#123;name: &quot;Keanu Reeves&quot;&#125;)-[role:ACTED_IN &#123;roles: [&quot;Neo&quot;]&#125;]-&gt;</span><br><span class="line">(matrix:Movie &#123;title: &quot;The Matrix&quot;&#125; )</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Neo4j </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cypher语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux发送HTTP</title>
      <link href="2020/06/21/Study%20notes/7%E3%80%81linux/linux%E5%8F%91%E9%80%81HTTP/"/>
      <url>2020/06/21/Study%20notes/7%E3%80%81linux/linux%E5%8F%91%E9%80%81HTTP/</url>
      
        <content type="html"><![CDATA[<h5 id="get请求："><a href="#get请求：" class="headerlink" title="get请求："></a>get请求：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl &quot;http:&#x2F;&#x2F;www.baidu.com&quot;  如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地</span><br><span class="line">curl -i &quot;http:&#x2F;&#x2F;www.baidu.com&quot;  显示全部信息</span><br><span class="line">curl -I &quot;http:&#x2F;&#x2F;www.baidu.com&quot;  只显示头部信息</span><br><span class="line">curl -v &quot;http:&#x2F;&#x2F;www.baidu.com&quot;   显示get请求全过程解析</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -v http:&#x2F;&#x2F;127.0.0.1:80&#x2F;xcloud&#x2F;test?version&#x3D;1\&amp;client_version&#x3D;1.1.0\&amp;seq&#x3D;1001\&amp;host&#x3D;aaa.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="post请求："><a href="#post请求：" class="headerlink" title="post请求："></a>post请求：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d &quot;username&#x3D;user1&amp;password&#x3D;123&quot; &quot;www.test.com&#x2F;login&quot;</span><br></pre></td></tr></table></figure><p>发送json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -k  -H &quot;Content-type: application&#x2F;json&quot; -X POST -d &#39;&#123;&quot;body&quot;:&#123;&quot;contractIds&quot;:[&quot;301&quot;]&#125;,&quot;head&quot;:&#123;&quot;channel&quot;:&quot;&quot;,&quot;secretKey&quot;:&quot;&quot;,&quot;sysCode&quot;:&quot;00134&quot;,&quot;transCode&quot;:&quot;CTPR01&quot;,&quot;transDate&quot;:&quot;20191202&quot;,&quot;transSerialNo&quot;:&quot;Q001342019120204252721491028&quot;,&quot;transTime&quot;:&quot;042527&quot;,&quot;transType&quot;:&quot;Q&quot;&#125;&#125;&#39; http:&#x2F;&#x2F;loanbefore.9fbank.com&#x2F;contract&#x2F;intf&#x2F;external&#x2F;trans\!server.intf -v</span><br></pre></td></tr></table></figure><p>curl -g ‘’ -v</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux发送HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见java数据结构</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1%E3%80%81%E5%B8%B8%E8%A7%81java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1%E3%80%81%E5%B8%B8%E8%A7%81java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="数据的逻辑结构："><a href="#数据的逻辑结构：" class="headerlink" title="数据的逻辑结构："></a>数据的逻辑结构：</h3><p>如果你不想永远都是代码工人,那就花时间来研究下数据结构和算法</p><p>分为线性结构、集合结构、树形结构和图形结构</p><p><img src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2647728071,20700480&fm=173&app=49&f=JPEG?w=640&h=323&s=88A35F309F8A4549147CB1CC000080B2" alt="image"></p><p>线性结构常见的有：数组、队列、链表和栈</p><p>非线性结构包括：二维数组，多维数组，广义表，树结构，图结构</p><h3 id="常用数据结构："><a href="#常用数据结构：" class="headerlink" title="常用数据结构："></a>常用数据结构：</h3><p><img src="https://images2018.cnblogs.com/blog/1120165/201711/1120165-20171124223229656-408723583.png" alt="image"></p><p>数据结构的基本功能</p><p>　　①、如何插入一条新的数据项</p><p>　　②、如何寻找某一特定的数据项</p><p>　　③、如何删除某一特定的数据项</p><p>　　④、如何迭代的访问各个数据项，以便进行显示或其他操作</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见java数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedHashSet</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/9%E3%80%81LinkedHashSet/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/9%E3%80%81LinkedHashSet/</url>
      
        <content type="html"><![CDATA[<p>LinkedHashSet 源码就这几行，所以可以看出其实现依赖于 LinkedHashMap，LinkedHashMap 较之 HashMap 内部多维护了一个双向链表用来维护元素的添加顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化 LinkedHashMap 的初始容量为诶 16 加载因子为 0.75f</span><br><span class="line">public LinkedHashSet() &#123;</span><br><span class="line">   super(16, .75f, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化 LinkedHashMap 的初始容量为 Math.max(2*c.size(), 11) 加载因子为 0.75f </span><br><span class="line">public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">   super(Math.max(2*c.size(), 11), .75f, true);</span><br><span class="line">   addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化 LinkedHashMap 的初始容量为参数指定值 加载因子为 0.75f </span><br><span class="line">public LinkedHashSet(int initialCapacity) &#123;</span><br><span class="line">   super(initialCapacity, .75f, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;初始化 LinkedHashMap 的初始容量,加载因子为参数指定值 </span><br><span class="line"> public LinkedHashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">   super(initialCapacity, loadFactor, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedHashSet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中间件的组件</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/3%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E7%BB%84%E4%BB%B6/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/3%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>消息中间件的组成</p><pre><code>  2.1 Broker</code></pre><p>消息服务器，作为server提供消息核心服务</p><pre><code>  2.2 Producer</code></pre><p>消息生产者，业务的发起方，负责生产消息传输给broker，</p><pre><code>  2.3 Consumer</code></pre><p>消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理</p><pre><code>  2.4 Topic</code></pre><p>主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的       广播</p><pre><code>  2.5 Queue</code></pre><p>队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收</p><pre><code>  2.6 Message</code></pre><p>消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件的组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>doubbo-入门DEMO(properties配置)</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/7%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/4%E3%80%81doubbo-%E5%85%A5%E9%97%A8DEMO(properties%E9%85%8D%E7%BD%AE)/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/7%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/4%E3%80%81doubbo-%E5%85%A5%E9%97%A8DEMO(properties%E9%85%8D%E7%BD%AE)/</url>
      
        <content type="html"><![CDATA[<p>准备三个工程</p><p>公共接口-api  存放java bean和接口（该工程也可以不用，放入服务提供者里面）官方推荐使用api</p><p>服务提供者：dubbo-provider</p><p>服务消费者：dubbo-consumser</p><p>1、Dubbo 将自动加载 classpath 根目录下的 dubbo.properties，可以通过JVM启动参数 -Ddubbo.properties.file=xxx.properties 改变缺省配置位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dubbo.application.name&#x3D;foo</span><br><span class="line">#等价于xml配置式：&lt;dubbo:application name&#x3D;&quot;foo&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>#等价于注解式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DubboConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean &#x2F;&#x2F;配置服务提供者的应用名称</span><br><span class="line">    public ApplicationConfig applicationConfig() &#123;</span><br><span class="line">        ApplicationConfig applicationConfig &#x3D; new ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(&quot;dubbo-provider01&quot;);</span><br><span class="line">        return applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doubbo-入门DEMO(properties配置) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无标题Markdown</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/IOC/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/IOC/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/</url>
      
        <content type="html"><![CDATA[<ol><li>控制反转实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</li></ol><ol start="2"><li>依赖注入依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用</li></ol>]]></content>
      
      
      <categories>
          
          <category> IOC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标题Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/MyBatis-Spring/%E4%BA%8B%E5%8A%A1/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/MyBatis-Spring/%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>MyBatis-Spring 借助了 Spring 中的 DataSourceTransactionManager 来实现事务管理。事务处理期间一个单独的 SqlSession 对象将会被创建和使用。当事务完成时，这个 session 会以合适的方式提交或回滚。</p><p>要开启 Spring 的事务处理功能，在 Spring 的配置文件中创建一个 DataSourceTransactionManager 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public DataSourceTransactionManager transactionManager() &#123;</span><br><span class="line">  return new DataSourceTransactionManager(dataSource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==为事务管理器指定的 DataSource 必须和用来创建 SqlSessionFactoryBean 的是同一个数据源，否则事务管理器就无法工作了。==</p><p>不能在 Spring 管理的 SqlSession 上调用 SqlSession.commit()，SqlSession.rollback() 或 SqlSession.close() 方法。如果这样做了，就会抛出 UnsupportedOperationException 异常</p>]]></content>
      
      
      <categories>
          
          <category> MyBatis-Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RESTful API</title>
      <link href="2020/06/21/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RPC/RESTful%20API/"/>
      <url>2020/06/21/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RPC/RESTful%20API/</url>
      
        <content type="html"><![CDATA[<p>RESTful API (http+json)</p><p>网站即软件，而且是一种新型的软件。</p><p>（1）每一个URI代表一种资源；<br>　　（2）客户端和服务器之间，传递这种资源的某种表现层，比如用JSON，XML，JPEG等；<br>　　（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p><p>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。<br>用HTTP协议里的动词来实现资源的添加，修改，删除等操作。即通过HTTP动词来实现资源的状态扭转：<br>　　GET 用来获取资源，<br>　　POST 用来新建资源（也可以用于更新资源），<br>　　PUT 用来更新资源，<br>　　DELETE 用来删除资源。</p>]]></content>
      
      
      <categories>
          
          <category> RPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RESTful API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vi快捷键</title>
      <link href="2020/06/21/Study%20notes/7%E3%80%81linux/linux/3%E3%80%81vi%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2020/06/21/Study%20notes/7%E3%80%81linux/linux/3%E3%80%81vi%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>vi（vim）是上Linux非常常用的编辑器，很多linux发行版都默认安装了vi(vim)。vi(vim)命令繁多但是如果使用灵活之后将会大大提高效率。</p><p>vi有3个模式：<br>1）正常模式：在命令行下#vi vim 进入<br>2）编辑模式：i或者 a进入编辑模式  esc退出到正常模式<br>3）命令模式：:wq :q :q!</p><ul><li>复制当前行：yy ,复制当前行向下的5行 5yy</li><li>删除当前行：dd ,删除当前行向下的5行  5dd</li><li>查找：/关键字，回车查找，输入n，查找下一个</li><li>设置行号：命令模式下输:set nu或者:set number。取消则输入:set nonu（都不会影响文本的内容）</li><li>正常模式下：G 到最末行  gg到最首行</li><li>将光标移至20行：（1）显示行号:set nu (2)输入20  （3）shift+g</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vi快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6%E3%80%81%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6%E3%80%81%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>哈夫曼树的目的是找出存放一串字符所需的最少的二进制编码， 原理是通过统计出每种字符出现的频率！不断地对其合并。</p><p>举个例子：有一串字符，现在把这些字符进行统计，频率表 A：60, B:45, C:13 D:69 E:14 F:5 G:3。现在要对这些字符进行编码，但是前提是使用最少的二进制编码。这时候怎么办呢？这就用到了我们的哈弗曼树。</p><p>我们需要构造一个哈弗曼树，构造赫夫曼树的算法是一个贪心算法，贪心的地方在于：总是选取当前频率(权值)最低的两个节点来进行合并，构造新节点。</p><p>构建哈夫曼树</p><p>哈夫曼编码：<br>哈夫曼编码的规则是，左边添加0，右边添加1</p>]]></content>
      
      
      <categories>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈夫曼树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<ul><li>内部类不能声明静态变量</li><li>内部类可以直接访问外部类的成员，包括私有</li><li>外部类要访问内部类的成员必须创建对象</li></ul><p>/**</p><ul><li><p>1.内部类可以直接访问外部类的成员，包括私有</p></li><li><p>2.外部类要访问内部类的成员必须创建对象</p></li><li><p>@author jjz</p></li><li></li><li><p>/<br>class outer1 {<br>  private int num = 10;<br>  class inner{</p><pre><code>  public void show()&#123;      System.out.println(num);  &#125;</code></pre><p>  }</p><p>  public void show1(){</p><pre><code>  //先创建内部类的对象  inner i = new inner();  i.show();</code></pre><p>  }</p></li></ul><p>}</p><p> public class outer {<br>    public static void main(String[] args) {<br>        outer1 o = new outer1();<br>        o.show1();<br>    }<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 类和接口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内部类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法： join()</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/%E6%96%B9%E6%B3%95%EF%BC%9A%20join()/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/%E6%96%B9%E6%B3%95%EF%BC%9A%20join()/</url>
      
        <content type="html"><![CDATA[<p>==如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。==</p><p>join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主线程</span><br><span class="line">public class Father extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Son s &#x3D; new Son();</span><br><span class="line">        s.start();</span><br><span class="line">        s.join();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子线程</span><br><span class="line">public class Son extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：<br>==在调用s.join()之后，Father主线程会一直等待，直到“子线程s”运行完毕；Father主线程才能接着运行。 这也就是我们所说的“join()的作用，是让主线程会等待子线程结束之后才能继续运行”！==</p>]]></content>
      
      
      <categories>
          
          <category> 常用方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法： join() </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>config-sever集群搭建</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/6%E3%80%81spring-config%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/3%E3%80%81config-sever%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/6%E3%80%81spring-config%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/3%E3%80%81config-sever%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>在微服务架构中，所有服务都从配置中心获取配置，配置中心一旦宕机，会发生很严重的问题，下面我们搭建一个双节点的配置中心集群来解决该问题。</p><p>启动两个config-server分别运行在8902和8903端口上；</p><p>添加config-client的配置文件bootstrap-cluster.yml，==主要是添加了从注册中心获取配置中心地址的配置并去除了配置中心uri的配置==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      profile: dev #启用环境名称</span><br><span class="line">      label: dev #分支名称</span><br><span class="line">      name: config #配置文件名称</span><br><span class="line">      discovery:</span><br><span class="line">        enabled: true</span><br><span class="line">        service-id: config-server</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8001&#x2F;eureka&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring-config配置中心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> config-sever集群搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rpm安装和卸载软件</title>
      <link href="2020/06/21/Study%20notes/7%E3%80%81linux/rpm%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6/"/>
      <url>2020/06/21/Study%20notes/7%E3%80%81linux/rpm%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、安装</span><br><span class="line"></span><br><span class="line">rpm -i 需要安装的包文件名</span><br><span class="line"></span><br><span class="line">举例如下：</span><br><span class="line"></span><br><span class="line">rpm -i example.rpm 安装 example.rpm 包；</span><br><span class="line"></span><br><span class="line">rpm -iv example.rpm 安装 example.rpm 包并在安装过程中显示正在安装的文件信息；</span><br><span class="line"></span><br><span class="line">rpm -ivh example.rpm 安装 example.rpm 包并在安装过程中显示正在安装的文件信息及安装进度；</span><br></pre></td></tr></table></figure><p>查看安装完成的软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@jacky zookeeper]# rpm -qa | grep jdk</span><br><span class="line">java-1.6.0-openjdk-1.6.0.0-1.66.1.13.0.el6.i686</span><br><span class="line">java-1.7.0-openjdk-1.7.0.45-2.4.3.3.el6.i686</span><br></pre></td></tr></table></figure><p>3、卸载软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps 要卸载的软件包</span><br><span class="line"></span><br><span class="line">root@jacky zookeeper]# rpm -e --nodeps java-1.6.0-openjdk-1.6.0.0-1.66.1.13.0.el6.i686</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rpm安装和卸载软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序算法</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="单轴快排"><a href="#单轴快排" class="headerlink" title="单轴快排"></a>单轴快排</h3><p>快速排序的基本思想就是从一个数组中任意挑选一个元素（通常来说会选择最左边的元素）作为中轴元素，将剩下的元素以中轴元素作为比较的标准，将小于等于中轴元素的放到中轴元素的左边，将大于中轴元素的放到中轴元素的右边，然后以当前中轴元素的位置为界，将左半部分子数组和右半部分子数组看成两个新的数组，重复上述操作，直到子数组的元素个数小于等于1（因为一个元素的数组必定是有序的）。</p><h3 id="双轴快速排序"><a href="#双轴快速排序" class="headerlink" title="双轴快速排序"></a>双轴快速排序</h3>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>导入spring源码</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring%E6%BA%90%E7%A0%81/1%E3%80%81%E5%AF%BC%E5%85%A5spring%E6%BA%90%E7%A0%81/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring%E6%BA%90%E7%A0%81/1%E3%80%81%E5%AF%BC%E5%85%A5spring%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<ul><li>1、导入spring源码前需安装gradle(因为源码是基于gradle构建的)，并且配置环境变量 输入gradle -version验证安装。</li><li>2、下载spring源码：<a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></li><li>3、 将源码转为eclipse可读取的形式。进入相应的目录 执行：gradle cleanidea eclipse<br>如：<br>D:\work4\springYuanMa\spring-framework-master\spring-tx&gt;gradle cleanidea eclipse</li><li>4、然后将该模块用idea打开，发现需要依赖其他模块。则同样操作将其他模块都编译下。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring-beans</span><br><span class="line">spring-core-coroutines</span><br><span class="line">spring-core</span><br><span class="line">spring-instrument</span><br><span class="line">spring-jcl</span><br><span class="line">spring-expression</span><br><span class="line">spring-aop</span><br><span class="line">spring-context</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 导入spring源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无标题Markdown</title>
      <link href="2020/06/21/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/8%E3%80%81Hutool/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/"/>
      <url>2020/06/21/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/8%E3%80%81Hutool/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/</url>
      
        <content type="html"><![CDATA[<pre><code>地址：https://gitee.com/loolly/hutool/</code></pre><p>Hutool的存在就是为了减少代码搜索成本，避免网络上参差不齐的代码出现导致的bug。</p><p>一个Java基础工具类，对文件、流、加密解密、转码、正则、线程、XML等JDK方法进行封装，组成各种Util工具类，同时提供以下组件</p><p>1、引入maven</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.4&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hutool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标题Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CocurrentHashMap1.7</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/5%E3%80%81CocurrentHashMap1.7/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/5%E3%80%81CocurrentHashMap1.7/</url>
      
        <content type="html"><![CDATA[<p>1.7采用Segment + HashEntry的方式进行实现</p><h3 id="ConcurrentHashMap结构："><a href="#ConcurrentHashMap结构：" class="headerlink" title="ConcurrentHashMap结构："></a>ConcurrentHashMap结构：</h3><ul><li><p>一个ConcurrentHashMap里包含一个Segment数组(是一种可重入锁ReentrantLock)，==Segment的结构和HashMap类似，是一种数组和链表结构==，</p></li><li><p>==一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，== </p></li><li><p>==当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。==</p></li></ul><p><img src="http://ifeve.com/wp-content/uploads/2012/12/ConcurrentHashMap%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocurrentHashMap1.7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis管道技术</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/11%E3%80%81redis%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/11%E3%80%81redis%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>Redis 的管道实质就是命令打包批量执行，多次网络交互减少到单次。提高运行效率。</p><p>Jedis对redis的管道进行操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取管道对象</span><br><span class="line">Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line">Pipeline pl &#x3D; jedis.pipelined();</span><br><span class="line"></span><br><span class="line">HashMap&lt;String, Response&lt;String&gt;&gt; commandMap &#x3D; new HashMap&lt;String,Response&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">commandMap.put(&quot;command1&quot;, pl.set(&quot;k1&quot;, &quot;v1&quot;));</span><br><span class="line">commandMap.put(&quot;command2&quot;, pl.sadd(&quot;k2&quot;, &quot;v2&quot;));</span><br><span class="line">commandMap.put(&quot;command3&quot;, pl.get(&quot;k1&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用管道批量执行命令</span><br><span class="line">pl.sync();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    &#x2F;&#x2F;关闭管道</span><br><span class="line">    pl.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis管道技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/5%E3%80%81vector/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/5%E3%80%81vector/</url>
      
        <content type="html"><![CDATA[<h3 id="Vector与ArrayList比较"><a href="#Vector与ArrayList比较" class="headerlink" title="Vector与ArrayList比较"></a>Vector与ArrayList比较</h3><ul><li><p>Vector与ArrayList的最大区别就是Vector是线程安全的，而ArrayList不是线程安全的(非复合操作)。==Vector 的方法都具有 synchronized 关键修饰。但对于复合操作，Vector 仍然需要进行同步处理。==</p></li><li><p>ArrayList不可以设置扩展的容量，默认1.5倍； Vector可以设置扩展的容量，，默认2倍</p></li><li><p>ArrayList的无参构造方法中初始容量为0（初次调用add()会更新为10）；Vector的无参构造方法中初始容量为10</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么阿里开发手册建议自定义线程池；</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E5%BB%BA%E8%AE%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9B/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E5%BB%BA%E8%AE%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9B/</url>
      
        <content type="html"><![CDATA[<p>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这<br>样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>说明：Executors 返回的线程池对象的弊端如下： </p><ul><li>1） FixedThreadPool 和 SingleThreadPool：<br>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 </li><li>2） CachedThreadPool：<br>允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 线程池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 为什么阿里开发手册建议自定义线程池； </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Comparable接口</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/4%E3%80%81Object%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/4%E3%80%81Comparable%E6%8E%A5%E5%8F%A3/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/4%E3%80%81Object%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/4%E3%80%81Comparable%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>compareTo 方法并没有在 Object 类中声明 相反，它是 Comparable 接口中唯一的方法compareTo方法不但允许进行简单的等同性比较，允许执行顺序比较，除此之外，它与Object的equals 方法具有相似的特征</p><p>如果你正在编写一个值类，它具有非<br>常明显的内在排序关系，比如按字母顺序、按数值顺序或者按年代顺序，那你就应该坚决考虑实现 Comparable 接口：<br>（未完）</p>]]></content>
      
      
      <categories>
          
          <category> Object中的方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Comparable接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重写批处理器</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/13%E3%80%81%E9%87%8D%E5%86%99%E6%89%B9%E5%A4%84%E7%90%86%E5%99%A8/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/13%E3%80%81%E9%87%8D%E5%86%99%E6%89%B9%E5%A4%84%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>mybatis在创建SqlSession的时候，去实例化executor时，就决定了执行sql的方式是不是batch方式。在实例化SImpleExector的时候，则表明该事务的所有增删改方法会立刻在数据库执行该语句，实例化BatchExector的时候，则表明该事务的所有增删改方法都是 以batch方式，不会立刻在数据库执行。即mybatis框架本身限制了你不能灵活的在一次事务中选择是否要以批处理的方式执行。</p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重写批处理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程debug</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/%E8%BF%9C%E7%A8%8Bdebug/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/%E8%BF%9C%E7%A8%8Bdebug/</url>
      
        <content type="html"><![CDATA[<p>当你的开发环境在Window，又在远端linux Server或者移动平台上运行Java应用程序，Java提供了一系列的接口和协议让本地Java文件于远端JVM建立联系和通信。</p><p>实质还是JVM，只要确保本地Java 源代码与目标应用程序一致，本地的Java源码就可以用socket连接到远端的JVM，进而执行调试。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务-最大努力通知</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/8%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/8%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>按规律进行通知，不保证数据一定能通知成功，但会提供可查询操作接口进行核对。这种方案主要用在与第三方系统通讯时，比如：调用微信或支付宝支付后的支付结果通知。这种方案也是结合MQ进行实现，例如：通过MQ发送http请求，设置最大通知次数。达到通知次数后即不再通知。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式事务解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务-最大努力通知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB逻辑存储结构</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%9E%B6%E6%9E%84/InnoDB%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%9E%B6%E6%9E%84/InnoDB%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>InnoDB存储引擎的逻辑存储结构和Oracle大致相同，所有数据都被逻辑地存放在一个空间中，我们称之为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。页在一些文档中有时也称为块（block），1 extent = 64 pages,InnoDB存储引擎的逻辑存储结构大致如图所示。</p>]]></content>
      
      
      <categories>
          
          <category> mysql架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> InnoDB逻辑存储结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux环境JDK环境搭建</title>
      <link href="2020/06/21/Study%20notes/7%E3%80%81linux/linux%E7%8E%AF%E5%A2%83JDK%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>2020/06/21/Study%20notes/7%E3%80%81linux/linux%E7%8E%AF%E5%A2%83JDK%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>jdk环境搭建</p><p>上传JDK 并解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#set java environment</span><br><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_121</span><br><span class="line">CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib.tools.jar</span><br><span class="line">PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line">export JAVA_HOME CLASSPATH PATH</span><br></pre></td></tr></table></figure><p> 然后重新加载配置文件profile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux环境JDK环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具类：Collections</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/18%E3%80%81%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9ACollections/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/18%E3%80%81%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9ACollections/</url>
      
        <content type="html"><![CDATA[<ul><li>1、sort 排序</li><li>2、binarySearch 二分查找(折半查找)</li><li>3、equals 比较</li><li>4、fill 填充</li><li>5、asList 转列表 记得一个toArray吗？</li><li>6、indexOf str首次出现的位置</li><li>6、hash 哈希(重点)</li><li>7、toString 重写Object中方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具类：Collections </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentSkipListSet</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/4%E3%80%81ConcurrentSkipListSet/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/4%E3%80%81ConcurrentSkipListSet/</url>
      
        <content type="html"><![CDATA[<p>ConcurrentSkipListSet一个==基于 ConcurrentSkipListMap== 的可缩放并发 NavigableSet 实现。set 的元素可以根据它们的自然顺序进行排序，也可以根据创建 set 时所提供的 Comparator 进行排序，具体取决于使用的构造方法。</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ConcurrentSkipListSet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cypher高级应用</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/5%E3%80%81%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/Neo4j/7%E3%80%81Cypher%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/5%E3%80%81%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/Neo4j/7%E3%80%81Cypher%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>neo4j集群搭建</p><ul><li>断言函数</li><li>标量函数</li><li>列表函数</li><li>数学函数</li><li>字符串函数</li><li>索引</li><li>约束</li><li>统计</li><li>查询调优</li><li>执行计划</li><li>管理 部署、配置、监控</li><li>管理 备份、恢复、转储、加载</li><li>数据导入、导出</li></ul>]]></content>
      
      
      <categories>
          
          <category> Neo4j </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cypher高级应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无标题Markdown</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/</url>
      
        <content type="html"><![CDATA[<p>线程间通信，同机器进程间通信，跨机器进程间通信</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标题Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx+Keepalived高可用集群</title>
      <link href="2020/06/21/Study%20notes/6%E3%80%81server/nginx/3%E3%80%81Nginx+Keepalived%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/"/>
      <url>2020/06/21/Study%20notes/6%E3%80%81server/nginx/3%E3%80%81Nginx+Keepalived%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_32447301/article/details/83656443">https://blog.csdn.net/qq_32447301/article/details/83656443</a></p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx+Keepalived高可用集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无标题Markdown</title>
      <link href="2020/06/21/Study%20notes/%E5%89%8D%E7%AB%AF/layui/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/"/>
      <url>2020/06/21/Study%20notes/%E5%89%8D%E7%AB%AF/layui/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/</url>
      
        <content type="html"><![CDATA[<p>vue环境搭建：<a href="https://www.cnblogs.com/winter92/p/7117057.html">https://www.cnblogs.com/winter92/p/7117057.html</a></p>]]></content>
      
      
      <categories>
          
          <category> layui </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标题Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日均百万级交易系统如何优化JVM</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98/%E6%97%A5%E5%9D%87%E7%99%BE%E4%B8%87%E7%BA%A7%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96JVM/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98/%E6%97%A5%E5%9D%87%E7%99%BE%E4%B8%87%E7%BA%A7%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96JVM/</url>
      
        <content type="html"><![CDATA[<p>1、每秒几十万并发的秒杀系统为什么会频繁发生GC</p><p>2、日均百万级交易系统如何优化JVM？</p>]]></content>
      
      
      <categories>
          
          <category> 热点问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日均百万级交易系统如何优化JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis设计模式</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/Mybatis%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/Mybatis%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/star1210644725/article/details/91882685">https://blog.csdn.net/star1210644725/article/details/91882685</a></p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从ACID到CAP再到BASE</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/7%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/zookeeper/%E4%BB%8EACID%E5%88%B0CAP%E5%86%8D%E5%88%B0BASE/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/7%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/zookeeper/%E4%BB%8EACID%E5%88%B0CAP%E5%86%8D%E5%88%B0BASE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/hxpjava1/article/details/79409395">https://blog.csdn.net/hxpjava1/article/details/79409395</a></p>]]></content>
      
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 从ACID到CAP再到BASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP1.0和1.1和2.0</title>
      <link href="2020/06/21/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/4%E3%80%81HTTP1.0%E5%92%8C1.1%E5%92%8C2.0/"/>
      <url>2020/06/21/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/4%E3%80%81HTTP1.0%E5%92%8C1.1%E5%92%8C2.0/</url>
      
        <content type="html"><![CDATA[<p>HTTP1.0和1.1</p><p>HTTP1.1和2.0</p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP1.0和1.1和2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elk</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/5%E3%80%81%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/3%E3%80%81elasticsearch/elk/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/5%E3%80%81%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/3%E3%80%81elasticsearch/elk/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/d66bfe7e9127">https://www.jianshu.com/p/d66bfe7e9127</a></p>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器的创建过程</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/spring-mvc/4%E3%80%81%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/spring-mvc/4%E3%80%81%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> spring-mvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器的创建过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mycat集群</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/MyCat/4%E3%80%81mycat%E9%9B%86%E7%BE%A4/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/MyCat/4%E3%80%81mycat%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="HaProxy-Keepalived-Mycat高可用集群配置"><a href="#HaProxy-Keepalived-Mycat高可用集群配置" class="headerlink" title="HaProxy+Keepalived+Mycat高可用集群配置"></a>HaProxy+Keepalived+Mycat高可用集群配置</h1>]]></content>
      
      
      <categories>
          
          <category> MyCat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mycat集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无标题Markdown</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/14%E3%80%81java%E6%96%B0%E7%89%B9%E6%80%A7/jdk9/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/14%E3%80%81java%E6%96%B0%E7%89%B9%E6%80%A7/jdk9/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/</url>
      
        <content type="html"><![CDATA[<p>jdk9对String的修改</p>]]></content>
      
      
      <categories>
          
          <category> jdk9 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标题Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exchanger</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/Exchanger/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/Exchanger/</url>
      
        <content type="html"><![CDATA[<p>线程间交换数据</p>]]></content>
      
      
      <categories>
          
          <category> JUC锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Exchanger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Semaphore</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/Semaphore/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/Semaphore/</url>
      
        <content type="html"><![CDATA[<p>控制并发线程数</p>]]></content>
      
      
      <categories>
          
          <category> JUC锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Semaphore </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
