<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>lasticsearch安装</title>
      <link href="2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/5%E3%80%81%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/3%E3%80%81elasticsearch/2%E3%80%81lasticsearch%E5%AE%89%E8%A3%85/"/>
      <url>2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/5%E3%80%81%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/3%E3%80%81elasticsearch/2%E3%80%81lasticsearch%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="Elasticsearch使用案例"><a href="#Elasticsearch使用案例" class="headerlink" title="Elasticsearch使用案例"></a>Elasticsearch使用案例</h3><ul><li><p>（1）2013年初，GitHub抛弃了Solr，采取ElasticSearch 来做PB级的搜索。 “GitHub使用ElasticSearch搜索20TB的数据，包括13亿文件和1300亿行代码”</p></li><li><p>（2）维基百科：启动以elasticsearch为基础的核心搜索架构SoundCloud：“SoundCloud使用ElasticSearch为1.8亿用户提供即时而精准的音乐搜索服务”</p></li><li><p>（3）百度：百度目前广泛使用ElasticSearch作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部20多个业务线（包括casio、云分析、网盟、预测、文库、直达号、钱包、风控等），单集群最大100台机器，200个ES节点，每天导入30TB+数据</p></li><li><p>（4）新浪使用ES 分析处理32亿条实时日志</p></li><li><p>（5）阿里使用ES 构建挖财自己的日志采集和分析体系</p></li></ul><h3 id="Solr、ES区别"><a href="#Solr、ES区别" class="headerlink" title="Solr、ES区别"></a>Solr、ES区别</h3><p>solr和es都基于lucene</p><ol><li><p>Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能;</p></li><li><p>Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式；</p></li><li><p>Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；</p></li><li><p>Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch—–附近的人</p></li></ol><p>ELK官网：<a href="https://www.elastic.co/">https://www.elastic.co/</a></p><p>ELK官网文档：<a href="https://www.elastic.co/guide/index.html">https://www.elastic.co/guide/index.html</a></p><p>ELK中文手册：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html">https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html</a></p><p>ELK中文社区：<a href="https://elasticsearch.cn/">https://elasticsearch.cn/</a></p><p>ELK API :<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/travelansport-client.html">https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/travelansport-client.html</a></p><p>1、下载并解压：</p><p>下载地址：<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p><p>2、安装Marvel插件（Marvel是Elasticsearch的管理和监控工具）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#安装监控：Marvel插件</span><br><span class="line">.&#x2F;bin&#x2F;plugin -i elasticsearch&#x2F;marvel&#x2F;latest</span><br><span class="line"></span><br><span class="line">#禁止监控：</span><br><span class="line">echo &#39;marvel.agent.enabled: false&#39; &gt;&gt; .&#x2F;config&#x2F;elasticsearch.yml</span><br></pre></td></tr></table></figure><p>3、修改配置文件：elasticsearch.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#允许所有ip访问</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;elasticsearch</span><br><span class="line"></span><br><span class="line">#后台启动</span><br><span class="line">.&#x2F;bin&#x2F;elasticsearch -d</span><br></pre></td></tr></table></figure><p>5、测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl &#39;http:&#x2F;&#x2F;localhost:9200&#x2F;?pretty&#39;</span><br></pre></td></tr></table></figure><p>返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;status&quot;: 200,</span><br><span class="line">   &quot;name&quot;: &quot;Shrunken Bones&quot;,</span><br><span class="line">   &quot;version&quot;: &#123;</span><br><span class="line">      &quot;number&quot;: &quot;1.4.0&quot;,</span><br><span class="line">      &quot;lucene_version&quot;: &quot;4.10&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;tagline&quot;: &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看Marvel和Sense</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:9200&#x2F;_plugin&#x2F;marvel&#x2F;</span><br></pre></td></tr></table></figure><h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建:"></a>集群搭建:</h3><p>修改elasticserach.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cluster.name: aubin-cluster#必须相同</span><br><span class="line"># 集群名称（不能重复）</span><br><span class="line">node.name: els1（必须不同）</span><br><span class="line"># 节点名称，仅仅是描述名称，用于在日志中区分（自定义）</span><br><span class="line">#指定了该节点可能成为 master 节点，还可以是数据节点</span><br><span class="line">node.master: true</span><br><span class="line">node.data: true</span><br><span class="line">path.data: &#x2F;var&#x2F;lib&#x2F;elasticsearch</span><br><span class="line"># 数据的默认存放路径（自定义）</span><br><span class="line">path.logs: &#x2F;var&#x2F;log&#x2F;elasticsearch </span><br><span class="line"># 日志的默认存放路径</span><br><span class="line">network.host: 192.168.0.1 </span><br><span class="line"># 当前节点的 IP 地址</span><br><span class="line">http.port: 9200 </span><br><span class="line"># 对外提供服务的端口</span><br><span class="line">transport.tcp.port: 9300</span><br><span class="line">#9300 为集群服务的端口</span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;172.18.68.11&quot;, &quot;172.18.68.12&quot;,&quot;172.18.68.13&quot;] </span><br><span class="line"># 集群个节点 IP 地址，也可以使用域名，需要各节点能够解析</span><br><span class="line">discovery.zen.minimum_master_nodes: 2 </span><br><span class="line"># 为了避免脑裂，集群节点数最少为 半数+1</span><br></pre></td></tr></table></figure><p>备注：配置文件详解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 集群的名字，以此作为是否同一集群的判断条件</span><br><span class="line">cluster.name: elasticsearch</span><br><span class="line"># 节点名字，以此作为集群中不同节点的区分条件</span><br><span class="line">node.name: node-1</span><br><span class="line">#设置当前节点既可以为主节点也可以为数据节点</span><br><span class="line">node.master: true</span><br><span class="line">node.data: true</span><br><span class="line"># 索引分片个数，默认为 5 片</span><br><span class="line">#index.number_of_shards: 5</span><br><span class="line"># 索引副本个数，默认为 1 个副本</span><br><span class="line">#index.number_of_replicas: 1</span><br><span class="line"># 数据存储目录（多个路径用逗号分隔）</span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;192.168.14.14&quot;,&quot;192.168.14.15&quot;]</span><br><span class="line">discovery.zen.minimum_master_nodes: 2</span><br><span class="line">#数据目录</span><br><span class="line">path.data: &#x2F;home&#x2F;elk1&#x2F;elasticserach&#x2F;data</span><br><span class="line"># 日志目录</span><br><span class="line">path.logs: &#x2F;home&#x2F;elk1&#x2F;elasticserach&#x2F;logs</span><br><span class="line"># 修改一下 ES 的监听地址，这样别的机器才可以访问</span><br><span class="line">network.host: 192.168.14.13</span><br><span class="line"># 设置节点间交互的 tcp 端口（集群）,默认是 9300</span><br><span class="line">transport.tcp.port: 9300</span><br><span class="line"># 监听端口（默认的就好）</span><br><span class="line">http.port: 9200</span><br><span class="line"># 增加新的参数，这样 head 插件才可以访问 es</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lasticsearch安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hystrix介绍</title>
      <link href="2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/4%E3%80%81hystrix%20%E6%96%AD%E8%B7%AF%E5%99%A8/1%E3%80%81hystrix%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/4%E3%80%81hystrix%20%E6%96%AD%E8%B7%AF%E5%99%A8/1%E3%80%81hystrix%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<ul><li>服务降级：系统整体资源不够，忍痛将一些服务关闭，待资源释放后，再开启回来</li><li>服务熔断金额服务降级的概念区分：</li><li>熔断：是单个服务故障或异常引起。当服务的发生异常，直接熔断整个服务，而不是一直等待此服务超时。</li><li>降级：是从整体负荷考虑，当某个服务熔断后，该服务器将不在调用。返回一个本地的fallback回调，返回一个缺省值<br>hystrix断路器：</li></ul><p><a href="https://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_clients">https://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_clients</a></p><p>就是一句话，保证单个服务调用出错，不会导致系统宕机。</p><p>在系统中 微服务A调用微服务B  微服务B调用微服务C 微服务C调用微服务D 。。。就是所谓的扇出<br>若微服务C连接超时或不可用时怎么办？</p><p>hystrix 是一个用于处理分布式系统的延迟和容错的开源库。Hystrix断路器 本身是一种开关装置（保险丝）。当一个微服务发生故障时，通过Hystrix的故障监控，会向调用方返回一个可预期，可处理的备选响应（fallBack）。而不是长时间的的等待或者抛出异常。保证服务调用方的线程不会长时间占用，从而避免故障在系统中的蔓延，乃至宕机。</p><h4 id="1、在服务提供者中添加hystrix的依赖"><a href="#1、在服务提供者中添加hystrix的依赖" class="headerlink" title="1、在服务提供者中添加hystrix的依赖"></a>1、在服务提供者中添加hystrix的依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.cloud&#x2F;spring-cloud-starter-hystrix --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4.5.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="2、再微服务中添加注解："><a href="#2、再微服务中添加注解：" class="headerlink" title="2、再微服务中添加注解："></a>2、再微服务中添加注解：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(fallbackMethod&#x3D;&quot;exceptionHandler&quot;)</span><br></pre></td></tr></table></figure><p>一旦微服务发生异常，就会调用fallbackMethod指定的方法</p><ul><li>fallbackMethod：指定服务降级处理方法；</li><li>ignoreExceptions：忽略某些异常，不发生服务降级；</li><li>commandKey：命令名称，用于区分不同的命令；</li><li>groupKey：分组名称，Hystrix会根据不同的分组来统计命令的告警及仪表盘信息；</li><li>threadPoolKey：线程池名称，用于划分线程池。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(fallbackMethod &#x3D; &quot;exceptionHandler&quot;)</span><br><span class="line">public CommonResult getUser(Long id) &#123;</span><br><span class="line">    return restTemplate.getForObject(userServiceUrl + &quot;&#x2F;user&#x2F;&#123;1&#125;&quot;, CommonResult.class, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public CommonResult exceptionHandler(@PathVariable Long id) &#123;</span><br><span class="line">    User defaultUser &#x3D; new User(-1L, &quot;defaultUser&quot;, &quot;123456&quot;);</span><br><span class="line">    return new CommonResult&lt;&gt;(defaultUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="3、在启动类中开启hystrix熔断器"><a href="#3、在启动类中开启hystrix熔断器" class="headerlink" title="3、在启动类中开启hystrix熔断器"></a>3、在启动类中开启hystrix熔断器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@EnableCircuitBreaker &#x2F;&#x2F;开启hysrtix熔断器</span><br><span class="line">@EnableDiscoveryClient &#x2F;&#x2F;服务发现</span><br></pre></td></tr></table></figure><h3 id="4、说明：上述方式的缺点："><a href="#4、说明：上述方式的缺点：" class="headerlink" title="4、说明：上述方式的缺点："></a>4、说明：上述方式的缺点：</h3><p>每个方法都添加上@HystrixCommand(fallbackMethod=”exceptionHandler”)造成代码的耦合性太高，和代码的冗余<br>可以将针对方法的注解，提取到针对类。原理就是AOP面向切面编程的异常通知。</p><p>4.1 在api moudle中针对service添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class DeptClientFallFactory implements FallbackFactory&lt;DeptService&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public DeptService create(Throwable throwable) &#123;</span><br><span class="line">        return new DeptService()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Dept getData() &#123;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;发送服务熔断时候的处理</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.2 再service中指定该DeptClientFallFactory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value &#x3D;&quot;CLOUD-SERVICE-PROVIDER-01&#x2F;cloud-service-provider-01&quot;)</span><br><span class="line">public interface DeptService &#123;</span><br><span class="line">    Dept getData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hystrix的请求缓存"><a href="#Hystrix的请求缓存" class="headerlink" title="Hystrix的请求缓存"></a>Hystrix的请求缓存</h3><p>当系统并发量越来越大时，我们需要使用缓存来优化系统，达到减轻并发请求线程数，提供响应速度的效果。</p><p>相关注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@CacheResult：开启缓存，默认所有参数作为缓存的key，cacheKeyMethod可以通过返回String类型的方法指定key；</span><br><span class="line">@CacheKey：指定缓存的key，可以指定参数或指定参数中的属性值为缓存key，cacheKeyMethod还可以通过返回String类型的方法指定；</span><br><span class="line">@CacheRemove：移除缓存，需要指定commandKey。</span><br></pre></td></tr></table></figure><p>注意：需要在每次使用缓存的请求前后对HystrixRequestContext进行初始化和关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: Request caching is not available. Maybe you need to initialize the HystrixRequestContext?</span><br></pre></td></tr></table></figure><p>使用过滤器，在每个请求前后初始化和关闭HystrixRequestContext来解决该问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by macro on 2019&#x2F;9&#x2F;4.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">@WebFilter(urlPatterns &#x3D; &quot;&#x2F;*&quot;,asyncSupported &#x3D; true)</span><br><span class="line">public class HystrixRequestContextFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        HystrixRequestContext context &#x3D; HystrixRequestContext.initializeContext();</span><br><span class="line">        try &#123;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            context.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Hystrix的常用配置"><a href="#Hystrix的常用配置" class="headerlink" title="Hystrix的常用配置"></a>Hystrix的常用配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">hystrix:</span><br><span class="line">  command: #用于控制HystrixCommand的行为</span><br><span class="line">    default:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          strategy: THREAD #控制HystrixCommand的隔离策略，THREAD-&gt;线程池隔离策略(默认)，SEMAPHORE-&gt;信号量隔离策略</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: 1000 #配置HystrixCommand执行的超时时间，执行超过该时间会进行服务降级处理</span><br><span class="line">            interruptOnTimeout: true #配置HystrixCommand执行超时的时候是否要中断</span><br><span class="line">            interruptOnCancel: true #配置HystrixCommand执行被取消的时候是否要中断</span><br><span class="line">          timeout:</span><br><span class="line">            enabled: true #配置HystrixCommand的执行是否启用超时时间</span><br><span class="line">          semaphore:</span><br><span class="line">            maxConcurrentRequests: 10 #当使用信号量隔离策略时，用来控制并发量的大小，超过该并发量的请求会被拒绝</span><br><span class="line">      fallback:</span><br><span class="line">        enabled: true #用于控制是否启用服务降级</span><br><span class="line">      circuitBreaker: #用于控制HystrixCircuitBreaker的行为</span><br><span class="line">        enabled: true #用于控制断路器是否跟踪健康状况以及熔断请求</span><br><span class="line">        requestVolumeThreshold: 20 #超过该请求数的请求会被拒绝</span><br><span class="line">        forceOpen: false #强制打开断路器，拒绝所有请求</span><br><span class="line">        forceClosed: false #强制关闭断路器，接收所有请求</span><br><span class="line">      requestCache:</span><br><span class="line">        enabled: true #用于控制是否开启请求缓存</span><br><span class="line">  collapser: #用于控制HystrixCollapser的执行行为</span><br><span class="line">    default:</span><br><span class="line">      maxRequestsInBatch: 100 #控制一次合并请求合并的最大请求数</span><br><span class="line">      timerDelayinMilliseconds: 10 #控制多少毫秒内的请求会被合并成一个</span><br><span class="line">      requestCache:</span><br><span class="line">        enabled: true #控制合并请求是否开启缓存</span><br><span class="line">  threadpool: #用于控制HystrixCommand执行所在线程池的行为</span><br><span class="line">    default:</span><br><span class="line">      coreSize: 10 #线程池的核心线程数</span><br><span class="line">      maximumSize: 10 #线程池的最大线程数，超过该线程数的请求会被拒绝</span><br><span class="line">      maxQueueSize: -1 #用于设置线程池的最大队列大小，-1采用SynchronousQueue，其他正数采用LinkedBlockingQueue</span><br><span class="line">      queueSizeRejectionThreshold: 5 #用于设置线程池队列的拒绝阀值，由于LinkedBlockingQueue不能动态改版大小，使用时需要用该参数来控制线程数</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hystrix 断路器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hystrix介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bean的注册</title>
      <link href="2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/IOC/1%E3%80%81bean%E7%9A%84%E6%B3%A8%E5%86%8C/"/>
      <url>2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/IOC/1%E3%80%81bean%E7%9A%84%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<ul><li><p>控制反转实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</p></li><li><p>依赖注入依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用</p></li></ul><p><a href="https://blog.csdn.net/songxinjianqwe/article/details/78824851">https://blog.csdn.net/songxinjianqwe/article/details/78824851</a></p><p>==IOC本质上是Spring管理一个容器，容器是BeanFactory的实现，容器中管理了所有用户指定的bean（xml或注解），最底层就是一个Map==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;bean的注册</span><br><span class="line">        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;bean的加载</span><br><span class="line">        UserService userService &#x3D; (UserService) applicationContext.getBean(&quot;userService&quot;);</span><br><span class="line">        userService.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bean注册"><a href="#bean注册" class="headerlink" title="bean注册"></a>bean注册</h3><p>==然后解析xml、注解中定义的bean。将bean信息解析存储到BeanDefinition相应的属性中，并将所有的benaName和对应的BeanDefinition存放到BeanFactory中成员变量的Map中。==</p><ul><li>BeanDefinition的保存的是Bean的类名、scope、属性、构造函数参数列表、依赖的bean、是否是单例类、是否是懒加载等，==后面对Bean的操作就直接对BeanDefinition进行==，例如拿到这个BeanDefinition后，可以根据里面的类名、构造函数、构造函数参数，使用反射进行对象创建。</li></ul><p><img src="https://img-blog.csdn.net/20171217162549343?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc29uZ3hpbmppYW5xd2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><p>在解析bean的过程中创建了BeanFactory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected DefaultListableBeanFactory createBeanFactory() &#123;</span><br><span class="line">    return new DefaultListableBeanFactory(this.getInternalParentBeanFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>且BeanFactory有成员变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap &#x3D; new ConcurrentHashMap(256);</span><br></pre></td></tr></table></figure><p>两个重要的方法：</p><ul><li>obtainFreshBeanFactory，读取到所有的beanDefinition（bean的定义，比如xml配置文件中的中定义的，或者@Component、@Service等标记的bean），并保存到beanFactroy中；</li><li>finishBeanFactoryInitialization，加载所有非延迟加载的、单例的bean <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">   synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">      &#x2F;&#x2F; 准备 刷新的上下文环境</span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 初始化BeanFactory，并进行XML文件的读取</span><br><span class="line">      ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 对BeanFactory进行各种功能填充</span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         &#x2F;&#x2F; 子类覆盖方法做额外的处理</span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 激活各种BeanFactory处理器</span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 注册拦截Bean创建的Bean处理器，这里只是注册，真正的调用是在getBean的时候</span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 为上下文初始化Message源，即不同语言的消息体，国际化处理</span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 初始化应用消息广播器，并放入applicationEventMulticaster bean中</span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 留给子类来初始化其他bean</span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 在所有注册的bean中查找Listener bean，注册到消息广播器中</span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 初始化剩下的单例实例（除了lazy-init）</span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 完成刷新过程，通知生命周期处理器lifecycleProcessor刷新过程，同时发出ContextRefreshEvent通知别人</span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      catch (BeansException ex) &#123;</span><br><span class="line">         if (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">                  &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; Destroy already created singletons to avoid dangling resources.</span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; Reset &#39;active&#39; flag.</span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; Propagate exception to caller.</span><br><span class="line">         throw ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      finally &#123;</span><br><span class="line">         &#x2F;&#x2F; Reset common introspection caches in Spring&#39;s core, since we</span><br><span class="line">         &#x2F;&#x2F; might not ever need metadata for singleton beans anymore...</span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>可跟踪代码，最后将解析到的beanName放入beanDefinitionMap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanDefinitionMap.put(beanName, beanDefinition);</span><br></pre></td></tr></table></figure><p>解析标签的时候，涉及到解析AOP标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;处理自定义标签</span><br><span class="line">public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) &#123;</span><br><span class="line">   String namespaceUri &#x3D; getNamespaceURI(ele);</span><br><span class="line">&#x2F;&#x2F; AopNamespaceHandler</span><br><span class="line">   NamespaceHandler handler &#x3D; this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">   if (handler &#x3D;&#x3D; null) &#123;</span><br><span class="line">      error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, ele);</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">   return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里返回的parser即为AspectJAutoProxyBeanDefinitionParser。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">   AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">   extendBeanDefinition(element, parserContext);</span><br><span class="line">   return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册这个creator</span><br><span class="line">public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">      ParserContext parserContext, Element sourceElement) &#123;</span><br><span class="line">   &#x2F;&#x2F; 注册或升级AutoProxyCreator定义beanName为internalAutoProxyCreator的BeanDefinition</span><br><span class="line">   BeanDefinition beanDefinition &#x3D; AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">         parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对于proxy-target-class以及expose-proxy属性的增强</span><br><span class="line">   useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">&#x2F;&#x2F; 注册组件并通知，便于监听器做进一步处理</span><br><span class="line">&#x2F;&#x2F; 其中beanDefinition的className为AnnotationAwareAspectJAutoProxyCreator</span><br><span class="line">   registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IOC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bean的注册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建SSM框架</title>
      <link href="2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/spring-mvc/%E6%90%AD%E5%BB%BASSM%E6%A1%86%E6%9E%B6/"/>
      <url>2020/09/19/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/spring-mvc/%E6%90%AD%E5%BB%BASSM%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>获取request的方式：</p><h2 id="方法1：Controller中加参数"><a href="#方法1：Controller中加参数" class="headerlink" title="方法1：Controller中加参数"></a>方法1：Controller中加参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController &#123;</span><br><span class="line">   @RequestMapping(&quot;&#x2F;test&quot;)</span><br><span class="line">   public void test(HttpServletRequest request) throws InterruptedException &#123;</span><br><span class="line">       &#x2F;&#x2F; 模拟程序执行了一段时间</span><br><span class="line">       Thread.sleep(1000);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法实现的原理是，在Controller方法开始处理请求时，Spring会将request对象赋值到方法参数中。除了request对象，可以通过这种方法获取的参数还有很多，具体可以参见：<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods</a><br>Controller中获取request对象后，如果要在其他方法中（如service方法、工具类方法等）使用request对象，需要在调用这些方法时将request对象作为参数传入。<br>此时request对象是方法参数，相当于局部变量，毫无疑问是线程安全的。<br>优缺点<br>这种方法的主要缺点是request对象写起来冗余太多，主要体现在两点：</p><ol><li>如果多个controller方法中都需要request对象，那么在每个方法中都需要添加一遍request参数</li><li>request对象的获取只能从controller开始，如果使用request对象的地方在函数调用层级比较深的地方，那么整个调用链上的所有方法都需要添加request参数</li></ol><p>实际上，在整个请求处理的过程中，request对象是贯穿始终的；也就是说，除了定时器等特殊情况，request对象相当于线程内部的一个全局变量。而该方法，相当于将这个全局变量，传来传去。</p><h2 id="方法2：自动注入-推荐使用"><a href="#方法2：自动注入-推荐使用" class="headerlink" title="方法2：自动注入(推荐使用)"></a>方法2：自动注入(推荐使用)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController&#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   private HttpServletRequest request; &#x2F;&#x2F;自动注入request</span><br><span class="line">   @RequestMapping(&quot;&#x2F;test&quot;)</span><br><span class="line">   public void test() throws InterruptedException&#123;</span><br><span class="line">       &#x2F;&#x2F;模拟程序执行了一段时间</span><br><span class="line">       Thread.sleep(1000);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：在Spring中，Controller的scope是singleton(单例)，也就是说在整个web系统中，只有一个TestController；但是其中注入的request却是线程安全的，原因在于：<br>使用这种方式，当Bean（本例的TestController）初始化时，Spring并没有注入一个request对象，而是注入了一个代理（proxy）；当Bean中需要使用request对象时，通过该代理获取request对象<br>该方法的主要优点：</p><ol><li>注入不局限于Controller中：在方法1中，只能在Controller中加入request参数。而对于方法2，不仅可以在Controller中注入，还可以在任何Bean中注入，包括Service、Repository及普通的Bean。</li><li>注入的对象不限于request：除了注入request对象，该方法还可以注入其他scope为request或session的对象，如response对象、session对象等；并保证线程安全。</li><li>减少代码冗余：只需要在需要request对象的Bean中注入request对象，便可以在该Bean的各个方法中使用，与方法1相比大大减少了代码冗余。<br>缺点:<br>方法也会存在代码冗余。考虑这样的场景：web系统中有很多controller，每个controller中都会使用request对象（这种场景实际上非常频繁），这时就需要写很多次注入request的代码；如果还需要注入response，代码就更繁琐了。下面说明自动注入方法的改进方法，并分析其线程安全性及优缺点。<h2 id="方法3：基类中自动注入-推荐使用-："><a href="#方法3：基类中自动注入-推荐使用-：" class="headerlink" title="方法3：基类中自动注入(推荐使用)："></a>方法3：基类中自动注入(推荐使用)：</h2></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class BaseController &#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   protected HttpServletRequest request;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：在理解了方法2的线程安全性的基础上，很容易理解方法3是线程安全的：当创建不同的派生类对象时，基类中的域（这里是注入的request）在不同的派生类对象中会占据不同的内存空间，也就是说将注入request的代码放在基类中对线程安全性没有任何影响；测试结果也证明了这一点。线程安全<br>优缺点<br>与方法2相比，避免了在不同的Controller中重复注入request；但是考虑到java只允许继承一个基类，所以如果Controller需要继承其他类时，该方法便不再好用。<br>无论是方法2和方法3，都只能在Bean中注入request；如果其他方法（如工具类中static方法）需要使用request对象，则需要在调用这些方法时将request参数传递进去。下面介绍的方法4，则可以直接在诸如工具类中的static方法中使用request对象（当然在各种Bean中也可以使用）。</p><h2 id="方法4：手动调用"><a href="#方法4：手动调用" class="headerlink" title="方法4：手动调用"></a>方法4：手动调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TestUtil &#123;</span><br><span class="line">   public void test() throws InterruptedException &#123; HttpServletRequest request &#x3D;((ServletRequestAttributes)(RequestContextHolder.currentRequestAttributes())).getRequest();</span><br><span class="line">       &#x2F;&#x2F; 模拟程序执行了一段时间</span><br><span class="line">       Thread.sleep(1000);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：线程安全<br>分析：该方法与方法2（自动注入）类似，只不过方法2中通过自动注入实现，本方法通过手动方法调用实现。因此本方法也是线程安全的<br>优缺点<br>优点：可以在非Bean中直接获取。缺点：如果使用的地方较多，代码非常繁琐；因此可以与其他方法配合使用。</p><h2 id="方法5：-ModelAttribute方法"><a href="#方法5：-ModelAttribute方法" class="headerlink" title="方法5：@ModelAttribute方法"></a>方法5：@ModelAttribute方法</h2>]]></content>
      
      
      <categories>
          
          <category> spring-mvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建SSM框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具构建线程池</title>
      <link href="2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E5%B7%A5%E5%85%B7%E6%9E%84%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E5%B7%A5%E5%85%B7%E6%9E%84%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>通过Executor框架的工具类Executors，可以创建3种类型的ThreadPoolExecutor</p><ul><li>FixedThreadPool</li><li>SingleThreadExecutor</li><li>CachedThreadPool</li></ul><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>FixedThreadPool被称为可重用固定线程数的线程池。下面是FixedThreadPool的源代码实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads。</p><p>当线程池中的线程数大于corePoolSize时，keepAliveTime设置为0L，意味着多余<br>的空闲线程会被立即终止。</p><ul><li>1）如果当前运行的线程数少于corePoolSize，则创建新线程来执行任务。</li><li>2）在线程池完成预热之后（当前运行的线程数等于corePoolSize），将任务加入LinkedBlockingQueue。</li><li>3）线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行。<br>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。使用无界队列作为工作队列会对线程池带来如下影响。</li></ul><ol><li>当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。</li><li>由于1，使用无界队列时maximumPoolSize将是一个无效参数。</li><li>由于1和2，使用无界队列时keepAliveTime将是一个无效参数。</li><li>由于使用无界队列，运行中的FixedThreadPool（未执行方法shutdown()或<br>shutdownNow()）不会拒绝任务（不会调用RejectedExecutionHandler.rejectedExecution方法）。</li></ol><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>SingleThreadExecutor等价于new FixedThreadPool(1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>CachedThreadPool是一个会根据需要创建新线程的线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运<br>行任务，或者定期执行任务。ScheduledThreadPoolExecutor的功能与Timer类似，Timer对应的是单个后台线程，而<br>ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。</p><h3 id="为什么阿里开发手册建议自定义线程池；"><a href="#为什么阿里开发手册建议自定义线程池；" class="headerlink" title="为什么阿里开发手册建议自定义线程池；"></a>为什么阿里开发手册建议自定义线程池；</h3><p>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这<br>样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>说明：Executors 返回的线程池对象的弊端如下： </p><ul><li>1） FixedThreadPool 和 SingleThreadPool：<br>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 </li><li>2） CachedThreadPool：<br>允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</li></ul><h3 id="线程池监控"><a href="#线程池监控" class="headerlink" title="线程池监控"></a>线程池监控</h3><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根<br>据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池的<br>时候可以使用以下属性。</p><ul><li>·taskCount：线程池需要执行的任务数量。</li><li>·completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</li><li>·largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是</li><li>否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</li><li>·getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销</li><li>毁，所以这个大小只增不减。</li><li>·getActiveCount：获取活动的线程数。</li><li>通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的</li><li>beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执<br>行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。<br>这几个方法在线程池里是空方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 线程池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具构建线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CocurrentHashMap1.8</title>
      <link href="2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/5%E3%80%81CocurrentHashMap1.8/"/>
      <url>2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/5%E3%80%81CocurrentHashMap1.8/</url>
      
        <content type="html"><![CDATA[<ul><li><p>　HashMap ：HashMap是线程不安全的，在并发环境下，可能会形成环状链表（扩容时可能造成），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的。</p></li><li><p>HashTable ： HashTable和HashMap的实现原理几乎一样，差别无非是</p></li></ul><ol><li>HashTable不允许key和value为null；</li><li>HashTable是线程安全的。但是HashTable线程安全的策略是在get/put所有相关操作都是synchronized的</li></ol><p>HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的”分段锁”思想。</p><h4 id="1-8中放弃了1-7的Segment臃肿的设计，取而代之的是采用Node-CAS-Synchronized来保证并发安全进行实现"><a href="#1-8中放弃了1-7的Segment臃肿的设计，取而代之的是采用Node-CAS-Synchronized来保证并发安全进行实现" class="headerlink" title="==1.8中放弃了1.7的Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现=="></a>==1.8中放弃了1.7的Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现==</h4><h3 id="ConcurrentHashMap源码分析："><a href="#ConcurrentHashMap源码分析：" class="headerlink" title="ConcurrentHashMap源码分析："></a>ConcurrentHashMap源码分析：</h3><ol><li>Node类</li></ol><p>　　Node类主要用于存储具体键值对，其子类有ForwardingNode、ReservationNode、TreeNode和TreeBin四个子类</p><ol start="2"><li>Traverser类</li></ol><p>　　Traverser类主要用于遍历操作，其子类有BaseIterator、KeySpliterator、ValueSpliterator、EntrySpliterator四个类，BaseIterator用于遍历操作。KeySplitertor、ValueSpliterator、EntrySpliterator则用于键、值、键值对的划分。</p><ol start="3"><li>CollectionView类</li></ol><p>　　CollectionView抽象类主要定义了视图操作，其子类KeySetView、ValueSetView、EntrySetView分别表示键视图、值视图、键值对视图。对视图均可以进行操作。</p><ol start="4"><li>Segment类</li></ol><p>　　Segment类在JDK1.8中与之前的版本的JDK作用存在很大的差别，JDK1.8下，其在普通的ConcurrentHashMap操作中已经没有失效，其在序列化与反序列化的时候会发挥作用。</p><ol start="5"><li>CounterCell</li></ol><p>CounterCell类主要用于对baseCount的计数。</p><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements ConcurrentMap&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 7249069246763182397L;</span><br><span class="line">    &#x2F;&#x2F; 表的最大容量</span><br><span class="line">    private static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line">    &#x2F;&#x2F; 默认表的大小</span><br><span class="line">    private static final int DEFAULT_CAPACITY &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 最大数组大小</span><br><span class="line">    static final int MAX_ARRAY_SIZE &#x3D; Integer.MAX_VALUE - 8;</span><br><span class="line">    &#x2F;&#x2F; 默认并发数</span><br><span class="line">    private static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 装载因子</span><br><span class="line">    private static final float LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">    &#x2F;&#x2F; 转化为红黑树的阈值</span><br><span class="line">    static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line">    &#x2F;&#x2F; 由红黑树转化为链表的阈值</span><br><span class="line">    static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line">    &#x2F;&#x2F; 转化为红黑树的表的最小容量</span><br><span class="line">    static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br><span class="line">    &#x2F;&#x2F; 每次进行转移的最小值</span><br><span class="line">    private static final int MIN_TRANSFER_STRIDE &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 生成sizeCtl所使用的bit位数</span><br><span class="line">    private static int RESIZE_STAMP_BITS &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 进行扩容所允许的最大线程数</span><br><span class="line">    private static final int MAX_RESIZERS &#x3D; (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;</span><br><span class="line">    &#x2F;&#x2F; 记录sizeCtl中的大小所需要进行的偏移位数</span><br><span class="line">    private static final int RESIZE_STAMP_SHIFT &#x3D; 32 - RESIZE_STAMP_BITS;    </span><br><span class="line">    &#x2F;&#x2F; 一系列的标识</span><br><span class="line">    static final int MOVED     &#x3D; -1; &#x2F;&#x2F; hash for forwarding nodes</span><br><span class="line">    static final int TREEBIN   &#x3D; -2; &#x2F;&#x2F; hash for roots of trees</span><br><span class="line">    static final int RESERVED  &#x3D; -3; &#x2F;&#x2F; hash for transient reservations</span><br><span class="line">    static final int HASH_BITS &#x3D; 0x7fffffff; &#x2F;&#x2F; usable bits of normal node hash</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    &#x2F;** Number of CPUS, to place bounds on some sizings *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 获取可用的CPU个数</span><br><span class="line">    static final int NCPU &#x3D; Runtime.getRuntime().availableProcessors();</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    &#x2F;** For serialization compatibility. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 进行序列化的属性</span><br><span class="line">    private static final ObjectStreamField[] serialPersistentFields &#x3D; &#123;</span><br><span class="line">        new ObjectStreamField(&quot;segments&quot;, Segment[].class),</span><br><span class="line">        new ObjectStreamField(&quot;segmentMask&quot;, Integer.TYPE),</span><br><span class="line">        new ObjectStreamField(&quot;segmentShift&quot;, Integer.TYPE)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 表</span><br><span class="line">    transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line">    &#x2F;&#x2F; 下一个表</span><br><span class="line">    private transient volatile Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Base counter value, used mainly when there is no contention,</span><br><span class="line">     * but also as a fallback during table initialization</span><br><span class="line">     * races. Updated via CAS.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 基本计数</span><br><span class="line">    private transient volatile long baseCount;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Table initialization and resizing control.  When negative, the</span><br><span class="line">     * table is being initialized or resized: -1 for initialization,</span><br><span class="line">     * else -(1 + the number of active resizing threads).  Otherwise,</span><br><span class="line">     * when table is null, holds the initial table size to use upon</span><br><span class="line">     * creation, or 0 for default. After initialization, holds the</span><br><span class="line">     * next element count value upon which to resize the table.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 对表初始化和扩容控制</span><br><span class="line">    private transient volatile int sizeCtl;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The next table index (plus one) to split while resizing.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 扩容下另一个表的索引</span><br><span class="line">    private transient volatile int transferIndex;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Spinlock (locked via CAS) used when resizing and&#x2F;or creating CounterCells.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 旋转锁</span><br><span class="line">    private transient volatile int cellsBusy;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Table of counter cells. When non-null, size is a power of 2.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; counterCell表</span><br><span class="line">    private transient volatile CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; views</span><br><span class="line">    &#x2F;&#x2F; 视图</span><br><span class="line">    private transient KeySetView&lt;K,V&gt; keySet;</span><br><span class="line">    private transient ValuesView&lt;K,V&gt; values;</span><br><span class="line">    private transient EntrySetView&lt;K,V&gt; entrySet;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Unsafe mechanics</span><br><span class="line">    private static final sun.misc.Unsafe U;</span><br><span class="line">    private static final long SIZECTL;</span><br><span class="line">    private static final long TRANSFERINDEX;</span><br><span class="line">    private static final long BASECOUNT;</span><br><span class="line">    private static final long CELLSBUSY;</span><br><span class="line">    private static final long CELLVALUE;</span><br><span class="line">    private static final long ABASE;</span><br><span class="line">    private static final int ASHIFT;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            U &#x3D; sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k &#x3D; ConcurrentHashMap.class;</span><br><span class="line">            SIZECTL &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;sizeCtl&quot;));</span><br><span class="line">            TRANSFERINDEX &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;transferIndex&quot;));</span><br><span class="line">            BASECOUNT &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;baseCount&quot;));</span><br><span class="line">            CELLSBUSY &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;cellsBusy&quot;));</span><br><span class="line">            Class&lt;?&gt; ck &#x3D; CounterCell.class;</span><br><span class="line">            CELLVALUE &#x3D; U.objectFieldOffset</span><br><span class="line">                (ck.getDeclaredField(&quot;value&quot;));</span><br><span class="line">            Class&lt;?&gt; ak &#x3D; Node[].class;</span><br><span class="line">            ABASE &#x3D; U.arrayBaseOffset(ak);</span><br><span class="line">            int scale &#x3D; U.arrayIndexScale(ak);</span><br><span class="line">            if ((scale &amp; (scale - 1)) !&#x3D; 0)</span><br><span class="line">                throw new Error(&quot;data type scale not a power of two&quot;);</span><br><span class="line">            ASHIFT &#x3D; 31 - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用于创建一个带有默认初始容量 (16)、加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。</span><br><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;创建一个带有指定初始容量、默认加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。</span><br><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity &lt; 0) &#x2F;&#x2F; 初始容量小于0，抛出异常</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        int cap &#x3D; ((initialCapacity &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); &#x2F;&#x2F; 找到最接近该容量的2的幂次方数</span><br><span class="line">        &#x2F;&#x2F; 初始化</span><br><span class="line">        this.sizeCtl &#x3D; cap;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;构造一个与给定映射具有相同映射关系的新映射。</span><br><span class="line">    public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this.sizeCtl &#x3D; DEFAULT_CAPACITY;</span><br><span class="line">        &#x2F;&#x2F; 将集合m的元素全部放入</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个带有指定初始容量、加载因子和默认 concurrencyLevel (1) 的新的空映射。</span><br><span class="line">     public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        this(initialCapacity, loadFactor, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个带有指定初始容量、加载因子和并发级别的新的空映射。</span><br><span class="line">    public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                             float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">        if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0) &#x2F;&#x2F; 合法性判断</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (initialCapacity &lt; concurrencyLevel)   &#x2F;&#x2F; Use at least as many bins</span><br><span class="line">            initialCapacity &#x3D; concurrencyLevel;   &#x2F;&#x2F; as estimated threads</span><br><span class="line">        long size &#x3D; (long)(1.0 + (long)initialCapacity &#x2F; loadFactor);</span><br><span class="line">        int cap &#x3D; (size &gt;&#x3D; (long)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((int)size);</span><br><span class="line">        this.sizeCtl &#x3D; cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="putVal函数"><a href="#putVal函数" class="headerlink" title="putVal函数"></a>putVal函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">        if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException(); &#x2F;&#x2F; 键或值为空，抛出异常</span><br><span class="line">        &#x2F;&#x2F; 键的hash值经过计算获得hash值</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        int binCount &#x3D; 0;</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) &#x2F;&#x2F; 表为空或者表的长度为0</span><br><span class="line">                &#x2F;&#x2F; 初始化表</span><br><span class="line">                tab &#x3D; initTable();</span><br><span class="line">            else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 表不为空并且表的长度大于0，并且该桶不为空</span><br><span class="line">                if (casTabAt(tab, i, null,</span><br><span class="line">                             new Node&lt;K,V&gt;(hash, key, value, null))) &#x2F;&#x2F; 比较并且交换值，如tab的第i项为空则用新生成的node替换</span><br><span class="line">                    break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED) &#x2F;&#x2F; 该结点的hash值为MOVED</span><br><span class="line">                &#x2F;&#x2F; 进行结点的转移（在扩容的过程中）</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                synchronized (f) &#123; &#x2F;&#x2F; 加锁同步</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123; &#x2F;&#x2F; 找到table表下标为i的节点</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 该table表中该结点的hash值大于0</span><br><span class="line">                            &#x2F;&#x2F; binCount赋值为1</span><br><span class="line">                            binCount &#x3D; 1;</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123; &#x2F;&#x2F; 结点的hash值相等并且key也相等</span><br><span class="line">                                    &#x2F;&#x2F; 保存该结点的val值</span><br><span class="line">                                    oldVal &#x3D; e.val;</span><br><span class="line">                                    if (!onlyIfAbsent) &#x2F;&#x2F; 进行判断</span><br><span class="line">                                        &#x2F;&#x2F; 将指定的value保存至结点，即进行了结点值的更新</span><br><span class="line">                                        e.val &#x3D; value;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                &#x2F;&#x2F; 保存当前结点</span><br><span class="line">                                Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 当前结点的下一个结点为空，即为最后一个结点</span><br><span class="line">                                    &#x2F;&#x2F; 新生一个结点并且赋值给next域</span><br><span class="line">                                    pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, null);</span><br><span class="line">                                    &#x2F;&#x2F; 退出循环</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 结点为红黑树结点类型</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            &#x2F;&#x2F; binCount赋值为2</span><br><span class="line">                            binCount &#x3D; 2;</span><br><span class="line">                            if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) !&#x3D; null) &#123; &#x2F;&#x2F; 将hash、key、value放入红黑树</span><br><span class="line">                                &#x2F;&#x2F; 保存结点的val</span><br><span class="line">                                oldVal &#x3D; p.val;</span><br><span class="line">                                if (!onlyIfAbsent) &#x2F;&#x2F; 判断</span><br><span class="line">                                    &#x2F;&#x2F; 赋值结点value值</span><br><span class="line">                                    p.val &#x3D; value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (binCount !&#x3D; 0) &#123; &#x2F;&#x2F; binCount不为0</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD) &#x2F;&#x2F; 如果binCount大于等于转化为红黑树的阈值</span><br><span class="line">                        &#x2F;&#x2F; 进行转化</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    if (oldVal !&#x3D; null) &#x2F;&#x2F; 旧值不为空</span><br><span class="line">                        &#x2F;&#x2F; 返回旧值</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 增加binCount的数量</span><br><span class="line">        addCount(1L, binCount);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：put函数底层调用了putVal进行数据的插入，对于putVal函数的流程大体如下。</p><p>　　① 判断存储的key、value是否为空，若为空，则抛出异常，否则，进入步骤②</p><p>　　② 计算key的hash值，随后进入无限循环，该无限循环可以确保成功插入数据，若table表为空或者长度为0，则初始化table表，否则，进入步骤③</p><p>　　③ 根据key的hash值取出table表中的结点元素，若取出的结点为空（该桶为空），则使用CAS将key、value、hash值生成的结点放入桶中。否则，进入步骤④</p><p>　　④ 若该结点的的hash值为MOVED，则对该桶中的结点进行转移，否则，进入步骤⑤</p><p>　　⑤ 对桶中的第一个结点（即table表中的结点）进行加锁，对该桶进行遍历，桶中的结点的hash值与key值与给定的hash值和key值相等，则根据标识选择是否进行更新操作（用给定的value值替换该结点的value值），若遍历完桶仍没有找到hash值与key值和指定的hash值与key值相等的结点，则直接新生一个结点并赋值为之前最后一个结点的下一个结点。进入步骤⑥</p><p>　　⑥ 若binCount值达到红黑树转化的阈值，则将桶中的结构转化为红黑树存储，最后，增加binCount的值。</p><p>　　在putVal函数中会涉及到如下几个函数：initTable、tabAt、casTabAt、helpTransfer、putTreeVal、treeifyBin、addCount函数。下面对其中涉及到的函数进行分析。</p><h3 id="initTable"><a href="#initTable" class="headerlink" title="　　initTable"></a>　　initTable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">        while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            if ((sc &#x3D; sizeCtl) &lt; 0) &#x2F;&#x2F; sizeCtl小于0，则进行线程让步等待</span><br><span class="line">                Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin</span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; &#x2F;&#x2F; 比较sizeCtl的值与sc是否相等，相等则用-1替换</span><br><span class="line">                try &#123;</span><br><span class="line">                    if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; table表为空或者大小为0</span><br><span class="line">                        &#x2F;&#x2F; sc的值是否大于0，若是，则n为sc，否则，n为默认初始容量</span><br><span class="line">                        int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                        &#x2F;&#x2F; 新生结点数组</span><br><span class="line">                        Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                        &#x2F;&#x2F; 赋值给table</span><br><span class="line">                        table &#x3D; tab &#x3D; nt;</span><br><span class="line">                        &#x2F;&#x2F; sc为n * 3&#x2F;4</span><br><span class="line">                        sc &#x3D; n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    &#x2F;&#x2F; 设置sizeCtl的值</span><br><span class="line">                    sizeCtl &#x3D; sc;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 返回table表</span><br><span class="line">        return tab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于table的大小，会根据sizeCtl的值进行设置，如果没有设置szieCtl的值，那么默认生成的table大小为16，否则，会根据sizeCtl的大小设置table大小。</p><h3 id="tabAt函数"><a href="#tabAt函数" class="headerlink" title="tabAt函数"></a>tabAt函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</span><br><span class="line">        return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数返回table数组中下标为i的结点，可以看到是通过Unsafe对象通过反射获取的，getObjectVolatile的第二项参数为下标为i的偏移地址。</p><h3 id="casTabAt函数"><a href="#casTabAt函数" class="headerlink" title="casTabAt函数"></a>casTabAt函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,</span><br><span class="line">                                      Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</span><br><span class="line">      return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此函数用于比较table数组下标为i的结点是否为c，若为c，则用v交换操作。否则，不进行交换操作。</p><h3 id="helpTransfer函数"><a href="#helpTransfer函数" class="headerlink" title="helpTransfer函数"></a>helpTransfer函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">        if (tab !&#x3D; null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">            (nextTab &#x3D; ((ForwardingNode&lt;K,V&gt;)f).nextTable) !&#x3D; null) &#123; &#x2F;&#x2F; table表不为空并且结点类型使ForwardingNode类型，并且结点的nextTable不为空</span><br><span class="line">            int rs &#x3D; resizeStamp(tab.length);</span><br><span class="line">            while (nextTab &#x3D;&#x3D; nextTable &amp;&amp; table &#x3D;&#x3D; tab &amp;&amp;</span><br><span class="line">                   (sc &#x3D; sizeCtl) &lt; 0) &#123; &#x2F;&#x2F; 条件判断</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                    sc &#x3D;&#x3D; rs + MAX_RESIZERS || transferIndex &lt;&#x3D; 0) &#x2F;&#x2F; </span><br><span class="line">                    break;</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; &#x2F;&#x2F; 比较并交换</span><br><span class="line">                    &#x2F;&#x2F; 将table的结点转移到nextTab中</span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        return table;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此函数用于在扩容时将table表中的结点转移到nextTable中。</p><h3 id="putTreeVal函数"><a href="#putTreeVal函数" class="headerlink" title="putTreeVal函数"></a>putTreeVal函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">final TreeNode&lt;K,V&gt; putTreeVal(int h, K k, V v) &#123;</span><br><span class="line">            Class&lt;?&gt; kc &#x3D; null;</span><br><span class="line">            boolean searched &#x3D; false;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; p &#x3D; root;;) &#123;</span><br><span class="line">                int dir, ph; K pk;</span><br><span class="line">                if (p &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    first &#x3D; root &#x3D; new TreeNode&lt;K,V&gt;(h, k, v, null, null);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else if ((ph &#x3D; p.hash) &gt; h)</span><br><span class="line">                    dir &#x3D; -1;</span><br><span class="line">                else if (ph &lt; h)</span><br><span class="line">                    dir &#x3D; 1;</span><br><span class="line">                else if ((pk &#x3D; p.key) &#x3D;&#x3D; k || (pk !&#x3D; null &amp;&amp; k.equals(pk)))</span><br><span class="line">                    return p;</span><br><span class="line">                else if ((kc &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">                          (kc &#x3D; comparableClassFor(k)) &#x3D;&#x3D; null) ||</span><br><span class="line">                         (dir &#x3D; compareComparables(kc, k, pk)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    if (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched &#x3D; true;</span><br><span class="line">                        if (((ch &#x3D; p.left) !&#x3D; null &amp;&amp;</span><br><span class="line">                             (q &#x3D; ch.findTreeNode(h, k, kc)) !&#x3D; null) ||</span><br><span class="line">                            ((ch &#x3D; p.right) !&#x3D; null &amp;&amp;</span><br><span class="line">                             (q &#x3D; ch.findTreeNode(h, k, kc)) !&#x3D; null))</span><br><span class="line">                            return q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir &#x3D; tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp &#x3D; p;</span><br><span class="line">                if ((p &#x3D; (dir &lt;&#x3D; 0) ? p.left : p.right) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x, f &#x3D; first;</span><br><span class="line">                    first &#x3D; x &#x3D; new TreeNode&lt;K,V&gt;(h, k, v, f, xp);</span><br><span class="line">                    if (f !&#x3D; null)</span><br><span class="line">                        f.prev &#x3D; x;</span><br><span class="line">                    if (dir &lt;&#x3D; 0)</span><br><span class="line">                        xp.left &#x3D; x;</span><br><span class="line">                    else</span><br><span class="line">                        xp.right &#x3D; x;</span><br><span class="line">                    if (!xp.red)</span><br><span class="line">                        x.red &#x3D; true;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        lockRoot();</span><br><span class="line">                        try &#123;</span><br><span class="line">                            root &#x3D; balanceInsertion(root, x);</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            unlockRoot();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            assert checkInvariants(root);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>　说明：此函数用于将指定的hash、key、value值添加到红黑树中，若已经添加了，则返回null，否则返回该结点。</p><h3 id="treeifyBin函数"><a href="#treeifyBin函数" class="headerlink" title="　treeifyBin函数"></a>　treeifyBin函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</span><br><span class="line">        Node&lt;K,V&gt; b; int n, sc;</span><br><span class="line">        if (tab !&#x3D; null) &#123; &#x2F;&#x2F; 表不为空</span><br><span class="line">            if ((n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY) &#x2F;&#x2F; table表的长度小于最小的长度</span><br><span class="line">                &#x2F;&#x2F; 进行扩容，调整某个桶中结点数量过多的问题（由于某个桶中结点数量超出了阈值，则触发treeifyBin）</span><br><span class="line">                tryPresize(n &lt;&lt; 1);</span><br><span class="line">            else if ((b &#x3D; tabAt(tab, index)) !&#x3D; null &amp;&amp; b.hash &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 桶中存在结点并且结点的hash值大于等于0</span><br><span class="line">                synchronized (b) &#123; &#x2F;&#x2F; 对桶中第一个结点进行加锁</span><br><span class="line">                    if (tabAt(tab, index) &#x3D;&#x3D; b) &#123; &#x2F;&#x2F; 第一个结点没有变化</span><br><span class="line">                        TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;</span><br><span class="line">                        for (Node&lt;K,V&gt; e &#x3D; b; e !&#x3D; null; e &#x3D; e.next) &#123; &#x2F;&#x2F; 遍历桶中所有结点</span><br><span class="line">                            &#x2F;&#x2F; 新生一个TreeNode结点</span><br><span class="line">                            TreeNode&lt;K,V&gt; p &#x3D;</span><br><span class="line">                                new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                  null, null);</span><br><span class="line">                            if ((p.prev &#x3D; tl) &#x3D;&#x3D; null) &#x2F;&#x2F; 该结点前驱为空</span><br><span class="line">                                &#x2F;&#x2F; 设置p为头结点</span><br><span class="line">                                hd &#x3D; p;</span><br><span class="line">                            else</span><br><span class="line">                                &#x2F;&#x2F; 尾节点的next域赋值为p</span><br><span class="line">                                tl.next &#x3D; p;</span><br><span class="line">                            &#x2F;&#x2F; 尾节点赋值为p</span><br><span class="line">                            tl &#x3D; p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; 设置table表中下标为index的值为hd</span><br><span class="line">                        setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此函数用于将桶中的数据结构转化为红黑树，其中，值得注意的是，当table的长度未达到阈值时，会进行一次扩容操作，该操作会使得触发treeifyBin操作的某个桶中的所有元素进行一次重新分配，这样可以避免某个桶中的结点数量太大。</p><h3 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private final void addCount(long x, int check) &#123;</span><br><span class="line">        CounterCell[] as; long b, s;</span><br><span class="line">        if ((as &#x3D; counterCells) !&#x3D; null ||</span><br><span class="line">            !U.compareAndSwapLong(this, BASECOUNT, b &#x3D; baseCount, s &#x3D; b + x)) &#123; &#x2F;&#x2F; counterCells不为空或者比较交换失败</span><br><span class="line">            CounterCell a; long v; int m;</span><br><span class="line">            &#x2F;&#x2F; 无竞争标识</span><br><span class="line">            boolean uncontended &#x3D; true;</span><br><span class="line">            if (as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0 ||</span><br><span class="line">                (a &#x3D; as[ThreadLocalRandom.getProbe() &amp; m]) &#x3D;&#x3D; null ||</span><br><span class="line">                !(uncontended &#x3D;</span><br><span class="line">                  U.compareAndSwapLong(a, CELLVALUE, v &#x3D; a.value, v + x))) &#123; &#x2F;&#x2F; </span><br><span class="line">                fullAddCount(x, uncontended);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (check &lt;&#x3D; 1)</span><br><span class="line">                return;</span><br><span class="line">            s &#x3D; sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">        if (check &gt;&#x3D; 0) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; int n, sc;</span><br><span class="line">            while (s &gt;&#x3D; (long)(sc &#x3D; sizeCtl) &amp;&amp; (tab &#x3D; table) !&#x3D; null &amp;&amp;</span><br><span class="line">                   (n &#x3D; tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                int rs &#x3D; resizeStamp(n);</span><br><span class="line">                if (sc &lt; 0) &#123;</span><br><span class="line">                    if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                        sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||</span><br><span class="line">                        transferIndex &lt;&#x3D; 0)</span><br><span class="line">                        break;</span><br><span class="line">                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                    transfer(tab, null);</span><br><span class="line">                s &#x3D; sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数主要完成binCount的值加1的操作。</p><h3 id="get函数"><a href="#get函数" class="headerlink" title="get函数"></a>get函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">        &#x2F;&#x2F; 计算key的hash值</span><br><span class="line">        int h &#x3D; spread(key.hashCode()); </span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123; &#x2F;&#x2F; 表不为空并且表的长度大于0并且key所在的桶不为空</span><br><span class="line">            if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123; &#x2F;&#x2F; 表中的元素的hash值与key的hash值相等</span><br><span class="line">                if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))) &#x2F;&#x2F; 键相等</span><br><span class="line">                    &#x2F;&#x2F; 返回值</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (eh &lt; 0) &#x2F;&#x2F; 结点hash值小于0</span><br><span class="line">                &#x2F;&#x2F; 在桶（链表&#x2F;红黑树）中查找</span><br><span class="line">                return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;</span><br><span class="line">            while ((e &#x3D; e.next) !&#x3D; null) &#123; &#x2F;&#x2F; 对于结点hash值大于0的情况</span><br><span class="line">                if (e.hash &#x3D;&#x3D; h &amp;&amp;</span><br><span class="line">                    ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>get函数根据key的hash值来计算在哪个桶中，再遍历桶，查找元素，若找到则返回该结点，否则，返回null。</p><h3 id="replaceNode函数"><a href="#replaceNode函数" class="headerlink" title="replaceNode函数"></a>replaceNode函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">final V replaceNode(Object key, V value, Object cv) &#123;</span><br><span class="line">        &#x2F;&#x2F; 计算key的hash值</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0 ||</span><br><span class="line">                (f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#x2F;&#x2F; table表为空或者表长度为0或者key所对应的桶为空</span><br><span class="line">                &#x2F;&#x2F; 跳出循环</span><br><span class="line">                break;</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED) &#x2F;&#x2F; 桶中第一个结点的hash值为MOVED</span><br><span class="line">                &#x2F;&#x2F; 转移</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                boolean validated &#x3D; false;</span><br><span class="line">                synchronized (f) &#123; &#x2F;&#x2F; 加锁同步</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123; &#x2F;&#x2F; 桶中的第一个结点没有发生变化</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 结点hash值大于0</span><br><span class="line">                            validated &#x3D; true;</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f, pred &#x3D; null;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123; &#x2F;&#x2F; 结点的hash值与指定的hash值相等，并且key也相等</span><br><span class="line">                                    V ev &#x3D; e.val;</span><br><span class="line">                                    if (cv &#x3D;&#x3D; null || cv &#x3D;&#x3D; ev ||</span><br><span class="line">                                        (ev !&#x3D; null &amp;&amp; cv.equals(ev))) &#123; &#x2F;&#x2F; cv为空或者与结点value相等或者不为空并且相等</span><br><span class="line">                                        &#x2F;&#x2F; 保存该结点的val值</span><br><span class="line">                                        oldVal &#x3D; ev;</span><br><span class="line">                                        if (value !&#x3D; null) &#x2F;&#x2F; value为null</span><br><span class="line">                                            &#x2F;&#x2F; 设置结点value值</span><br><span class="line">                                            e.val &#x3D; value;</span><br><span class="line">                                        else if (pred !&#x3D; null) &#x2F;&#x2F; 前驱不为空</span><br><span class="line">                                            &#x2F;&#x2F; 前驱的后继为e的后继，即删除了e结点</span><br><span class="line">                                            pred.next &#x3D; e.next;</span><br><span class="line">                                        else</span><br><span class="line">                                            &#x2F;&#x2F; 设置table表中下标为index的值为e.next</span><br><span class="line">                                            setTabAt(tab, i, e.next);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                pred &#x3D; e;</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null)</span><br><span class="line">                                    break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 为红黑树结点类型</span><br><span class="line">                            validated &#x3D; true;</span><br><span class="line">                            &#x2F;&#x2F; 类型转化</span><br><span class="line">                            TreeBin&lt;K,V&gt; t &#x3D; (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                            if ((r &#x3D; t.root) !&#x3D; null &amp;&amp;</span><br><span class="line">                                (p &#x3D; r.findTreeNode(hash, key, null)) !&#x3D; null) &#123; &#x2F;&#x2F; 根节点不为空并且存在与指定hash和key相等的结点</span><br><span class="line">                                &#x2F;&#x2F; 保存p结点的value</span><br><span class="line">                                V pv &#x3D; p.val;</span><br><span class="line">                                if (cv &#x3D;&#x3D; null || cv &#x3D;&#x3D; pv ||</span><br><span class="line">                                    (pv !&#x3D; null &amp;&amp; cv.equals(pv))) &#123; &#x2F;&#x2F; cv为空或者与结点value相等或者不为空并且相等</span><br><span class="line">                                    oldVal &#x3D; pv;</span><br><span class="line">                                    if (value !&#x3D; null) </span><br><span class="line">                                        p.val &#x3D; value;</span><br><span class="line">                                    else if (t.removeTreeNode(p)) &#x2F;&#x2F; 移除p结点</span><br><span class="line">                                        setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (validated) &#123;</span><br><span class="line">                    if (oldVal !&#x3D; null) &#123;</span><br><span class="line">                        if (value &#x3D;&#x3D; null)</span><br><span class="line">                            &#x2F;&#x2F; baseCount值减一</span><br><span class="line">                            addCount(-1L, -1);</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数对remove函数提供支持，remove函数底层是调用的replaceNode函数实现结点的删除。　</p><p>ConcurrentHashMap的性能相比HashMap的线程安全同步集合和Hashtable而言，性能都要高出不少。原因是经过Collections封装的线程安全的HashMap和Hashtable都是对整个结构加锁，而ConcurrentHashMap是对每一个桶单独进行锁操作，不同的桶之间的操作不会相互影响，可以并发执行。因此，其速度会快很多。</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocurrentHashMap1.8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CocurrentHashMap1.7</title>
      <link href="2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/5%E3%80%81CocurrentHashMap1.7/"/>
      <url>2020/09/19/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/5%E3%80%81CocurrentHashMap1.7/</url>
      
        <content type="html"><![CDATA[<ul><li><p>　HashMap ：HashMap是线程不安全的，在并发环境下，可能会形成环状链表（扩容时可能造成），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的。</p></li><li><p>HashTable ： HashTable和HashMap的实现原理几乎一样，差别无非是</p></li></ul><ol><li>HashTable不允许key和value为null；</li><li>HashTable是线程安全的。但是HashTable线程安全的策略是在get/put所有相关操作都是synchronized的</li></ol><p>HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的”分段锁”思想。</p><h4 id="1-8中放弃了1-7的Segment臃肿的设计，取而代之的是采用Node-CAS-Synchronized来保证并发安全进行实现"><a href="#1-8中放弃了1-7的Segment臃肿的设计，取而代之的是采用Node-CAS-Synchronized来保证并发安全进行实现" class="headerlink" title="==1.8中放弃了1.7的Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现=="></a>==1.8中放弃了1.7的Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现==</h4><h3 id="ConcurrentHashMap源码分析："><a href="#ConcurrentHashMap源码分析：" class="headerlink" title="ConcurrentHashMap源码分析："></a>ConcurrentHashMap源码分析：</h3><ol><li>Node类</li></ol><p>　　Node类主要用于存储具体键值对，其子类有ForwardingNode、ReservationNode、TreeNode和TreeBin四个子类</p><ol start="2"><li>Traverser类</li></ol><p>　　Traverser类主要用于遍历操作，其子类有BaseIterator、KeySpliterator、ValueSpliterator、EntrySpliterator四个类，BaseIterator用于遍历操作。KeySplitertor、ValueSpliterator、EntrySpliterator则用于键、值、键值对的划分。</p><ol start="3"><li>CollectionView类</li></ol><p>　　CollectionView抽象类主要定义了视图操作，其子类KeySetView、ValueSetView、EntrySetView分别表示键视图、值视图、键值对视图。对视图均可以进行操作。</p><ol start="4"><li>Segment类</li></ol><p>　　Segment类在JDK1.8中与之前的版本的JDK作用存在很大的差别，JDK1.8下，其在普通的ConcurrentHashMap操作中已经没有失效，其在序列化与反序列化的时候会发挥作用。</p><ol start="5"><li>CounterCell</li></ol><p>CounterCell类主要用于对baseCount的计数。</p><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements ConcurrentMap&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 7249069246763182397L;</span><br><span class="line">    &#x2F;&#x2F; 表的最大容量</span><br><span class="line">    private static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line">    &#x2F;&#x2F; 默认表的大小</span><br><span class="line">    private static final int DEFAULT_CAPACITY &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 最大数组大小</span><br><span class="line">    static final int MAX_ARRAY_SIZE &#x3D; Integer.MAX_VALUE - 8;</span><br><span class="line">    &#x2F;&#x2F; 默认并发数</span><br><span class="line">    private static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 装载因子</span><br><span class="line">    private static final float LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">    &#x2F;&#x2F; 转化为红黑树的阈值</span><br><span class="line">    static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line">    &#x2F;&#x2F; 由红黑树转化为链表的阈值</span><br><span class="line">    static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line">    &#x2F;&#x2F; 转化为红黑树的表的最小容量</span><br><span class="line">    static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br><span class="line">    &#x2F;&#x2F; 每次进行转移的最小值</span><br><span class="line">    private static final int MIN_TRANSFER_STRIDE &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 生成sizeCtl所使用的bit位数</span><br><span class="line">    private static int RESIZE_STAMP_BITS &#x3D; 16;</span><br><span class="line">    &#x2F;&#x2F; 进行扩容所允许的最大线程数</span><br><span class="line">    private static final int MAX_RESIZERS &#x3D; (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;</span><br><span class="line">    &#x2F;&#x2F; 记录sizeCtl中的大小所需要进行的偏移位数</span><br><span class="line">    private static final int RESIZE_STAMP_SHIFT &#x3D; 32 - RESIZE_STAMP_BITS;    </span><br><span class="line">    &#x2F;&#x2F; 一系列的标识</span><br><span class="line">    static final int MOVED     &#x3D; -1; &#x2F;&#x2F; hash for forwarding nodes</span><br><span class="line">    static final int TREEBIN   &#x3D; -2; &#x2F;&#x2F; hash for roots of trees</span><br><span class="line">    static final int RESERVED  &#x3D; -3; &#x2F;&#x2F; hash for transient reservations</span><br><span class="line">    static final int HASH_BITS &#x3D; 0x7fffffff; &#x2F;&#x2F; usable bits of normal node hash</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    &#x2F;** Number of CPUS, to place bounds on some sizings *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 获取可用的CPU个数</span><br><span class="line">    static final int NCPU &#x3D; Runtime.getRuntime().availableProcessors();</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    &#x2F;** For serialization compatibility. *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 进行序列化的属性</span><br><span class="line">    private static final ObjectStreamField[] serialPersistentFields &#x3D; &#123;</span><br><span class="line">        new ObjectStreamField(&quot;segments&quot;, Segment[].class),</span><br><span class="line">        new ObjectStreamField(&quot;segmentMask&quot;, Integer.TYPE),</span><br><span class="line">        new ObjectStreamField(&quot;segmentShift&quot;, Integer.TYPE)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 表</span><br><span class="line">    transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line">    &#x2F;&#x2F; 下一个表</span><br><span class="line">    private transient volatile Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Base counter value, used mainly when there is no contention,</span><br><span class="line">     * but also as a fallback during table initialization</span><br><span class="line">     * races. Updated via CAS.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 基本计数</span><br><span class="line">    private transient volatile long baseCount;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Table initialization and resizing control.  When negative, the</span><br><span class="line">     * table is being initialized or resized: -1 for initialization,</span><br><span class="line">     * else -(1 + the number of active resizing threads).  Otherwise,</span><br><span class="line">     * when table is null, holds the initial table size to use upon</span><br><span class="line">     * creation, or 0 for default. After initialization, holds the</span><br><span class="line">     * next element count value upon which to resize the table.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 对表初始化和扩容控制</span><br><span class="line">    private transient volatile int sizeCtl;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The next table index (plus one) to split while resizing.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 扩容下另一个表的索引</span><br><span class="line">    private transient volatile int transferIndex;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Spinlock (locked via CAS) used when resizing and&#x2F;or creating CounterCells.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 旋转锁</span><br><span class="line">    private transient volatile int cellsBusy;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Table of counter cells. When non-null, size is a power of 2.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; counterCell表</span><br><span class="line">    private transient volatile CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; views</span><br><span class="line">    &#x2F;&#x2F; 视图</span><br><span class="line">    private transient KeySetView&lt;K,V&gt; keySet;</span><br><span class="line">    private transient ValuesView&lt;K,V&gt; values;</span><br><span class="line">    private transient EntrySetView&lt;K,V&gt; entrySet;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Unsafe mechanics</span><br><span class="line">    private static final sun.misc.Unsafe U;</span><br><span class="line">    private static final long SIZECTL;</span><br><span class="line">    private static final long TRANSFERINDEX;</span><br><span class="line">    private static final long BASECOUNT;</span><br><span class="line">    private static final long CELLSBUSY;</span><br><span class="line">    private static final long CELLVALUE;</span><br><span class="line">    private static final long ABASE;</span><br><span class="line">    private static final int ASHIFT;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            U &#x3D; sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k &#x3D; ConcurrentHashMap.class;</span><br><span class="line">            SIZECTL &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;sizeCtl&quot;));</span><br><span class="line">            TRANSFERINDEX &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;transferIndex&quot;));</span><br><span class="line">            BASECOUNT &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;baseCount&quot;));</span><br><span class="line">            CELLSBUSY &#x3D; U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(&quot;cellsBusy&quot;));</span><br><span class="line">            Class&lt;?&gt; ck &#x3D; CounterCell.class;</span><br><span class="line">            CELLVALUE &#x3D; U.objectFieldOffset</span><br><span class="line">                (ck.getDeclaredField(&quot;value&quot;));</span><br><span class="line">            Class&lt;?&gt; ak &#x3D; Node[].class;</span><br><span class="line">            ABASE &#x3D; U.arrayBaseOffset(ak);</span><br><span class="line">            int scale &#x3D; U.arrayIndexScale(ak);</span><br><span class="line">            if ((scale &amp; (scale - 1)) !&#x3D; 0)</span><br><span class="line">                throw new Error(&quot;data type scale not a power of two&quot;);</span><br><span class="line">            ASHIFT &#x3D; 31 - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用于创建一个带有默认初始容量 (16)、加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。</span><br><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;创建一个带有指定初始容量、默认加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。</span><br><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity &lt; 0) &#x2F;&#x2F; 初始容量小于0，抛出异常</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        int cap &#x3D; ((initialCapacity &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); &#x2F;&#x2F; 找到最接近该容量的2的幂次方数</span><br><span class="line">        &#x2F;&#x2F; 初始化</span><br><span class="line">        this.sizeCtl &#x3D; cap;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;构造一个与给定映射具有相同映射关系的新映射。</span><br><span class="line">    public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this.sizeCtl &#x3D; DEFAULT_CAPACITY;</span><br><span class="line">        &#x2F;&#x2F; 将集合m的元素全部放入</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个带有指定初始容量、加载因子和默认 concurrencyLevel (1) 的新的空映射。</span><br><span class="line">     public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        this(initialCapacity, loadFactor, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个带有指定初始容量、加载因子和并发级别的新的空映射。</span><br><span class="line">    public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                             float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">        if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0) &#x2F;&#x2F; 合法性判断</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (initialCapacity &lt; concurrencyLevel)   &#x2F;&#x2F; Use at least as many bins</span><br><span class="line">            initialCapacity &#x3D; concurrencyLevel;   &#x2F;&#x2F; as estimated threads</span><br><span class="line">        long size &#x3D; (long)(1.0 + (long)initialCapacity &#x2F; loadFactor);</span><br><span class="line">        int cap &#x3D; (size &gt;&#x3D; (long)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((int)size);</span><br><span class="line">        this.sizeCtl &#x3D; cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="putVal函数"><a href="#putVal函数" class="headerlink" title="putVal函数"></a>putVal函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">        if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException(); &#x2F;&#x2F; 键或值为空，抛出异常</span><br><span class="line">        &#x2F;&#x2F; 键的hash值经过计算获得hash值</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        int binCount &#x3D; 0;</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) &#x2F;&#x2F; 表为空或者表的长度为0</span><br><span class="line">                &#x2F;&#x2F; 初始化表</span><br><span class="line">                tab &#x3D; initTable();</span><br><span class="line">            else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 表不为空并且表的长度大于0，并且该桶不为空</span><br><span class="line">                if (casTabAt(tab, i, null,</span><br><span class="line">                             new Node&lt;K,V&gt;(hash, key, value, null))) &#x2F;&#x2F; 比较并且交换值，如tab的第i项为空则用新生成的node替换</span><br><span class="line">                    break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED) &#x2F;&#x2F; 该结点的hash值为MOVED</span><br><span class="line">                &#x2F;&#x2F; 进行结点的转移（在扩容的过程中）</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                synchronized (f) &#123; &#x2F;&#x2F; 加锁同步</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123; &#x2F;&#x2F; 找到table表下标为i的节点</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 该table表中该结点的hash值大于0</span><br><span class="line">                            &#x2F;&#x2F; binCount赋值为1</span><br><span class="line">                            binCount &#x3D; 1;</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123; &#x2F;&#x2F; 结点的hash值相等并且key也相等</span><br><span class="line">                                    &#x2F;&#x2F; 保存该结点的val值</span><br><span class="line">                                    oldVal &#x3D; e.val;</span><br><span class="line">                                    if (!onlyIfAbsent) &#x2F;&#x2F; 进行判断</span><br><span class="line">                                        &#x2F;&#x2F; 将指定的value保存至结点，即进行了结点值的更新</span><br><span class="line">                                        e.val &#x3D; value;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                &#x2F;&#x2F; 保存当前结点</span><br><span class="line">                                Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 当前结点的下一个结点为空，即为最后一个结点</span><br><span class="line">                                    &#x2F;&#x2F; 新生一个结点并且赋值给next域</span><br><span class="line">                                    pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, null);</span><br><span class="line">                                    &#x2F;&#x2F; 退出循环</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 结点为红黑树结点类型</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            &#x2F;&#x2F; binCount赋值为2</span><br><span class="line">                            binCount &#x3D; 2;</span><br><span class="line">                            if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) !&#x3D; null) &#123; &#x2F;&#x2F; 将hash、key、value放入红黑树</span><br><span class="line">                                &#x2F;&#x2F; 保存结点的val</span><br><span class="line">                                oldVal &#x3D; p.val;</span><br><span class="line">                                if (!onlyIfAbsent) &#x2F;&#x2F; 判断</span><br><span class="line">                                    &#x2F;&#x2F; 赋值结点value值</span><br><span class="line">                                    p.val &#x3D; value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (binCount !&#x3D; 0) &#123; &#x2F;&#x2F; binCount不为0</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD) &#x2F;&#x2F; 如果binCount大于等于转化为红黑树的阈值</span><br><span class="line">                        &#x2F;&#x2F; 进行转化</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    if (oldVal !&#x3D; null) &#x2F;&#x2F; 旧值不为空</span><br><span class="line">                        &#x2F;&#x2F; 返回旧值</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 增加binCount的数量</span><br><span class="line">        addCount(1L, binCount);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：put函数底层调用了putVal进行数据的插入，对于putVal函数的流程大体如下。</p><p>　　① 判断存储的key、value是否为空，若为空，则抛出异常，否则，进入步骤②</p><p>　　② 计算key的hash值，随后进入无限循环，该无限循环可以确保成功插入数据，若table表为空或者长度为0，则初始化table表，否则，进入步骤③</p><p>　　③ 根据key的hash值取出table表中的结点元素，若取出的结点为空（该桶为空），则使用CAS将key、value、hash值生成的结点放入桶中。否则，进入步骤④</p><p>　　④ 若该结点的的hash值为MOVED，则对该桶中的结点进行转移，否则，进入步骤⑤</p><p>　　⑤ 对桶中的第一个结点（即table表中的结点）进行加锁，对该桶进行遍历，桶中的结点的hash值与key值与给定的hash值和key值相等，则根据标识选择是否进行更新操作（用给定的value值替换该结点的value值），若遍历完桶仍没有找到hash值与key值和指定的hash值与key值相等的结点，则直接新生一个结点并赋值为之前最后一个结点的下一个结点。进入步骤⑥</p><p>　　⑥ 若binCount值达到红黑树转化的阈值，则将桶中的结构转化为红黑树存储，最后，增加binCount的值。</p><p>　　在putVal函数中会涉及到如下几个函数：initTable、tabAt、casTabAt、helpTransfer、putTreeVal、treeifyBin、addCount函数。下面对其中涉及到的函数进行分析。</p><h3 id="initTable"><a href="#initTable" class="headerlink" title="　　initTable"></a>　　initTable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">        while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            if ((sc &#x3D; sizeCtl) &lt; 0) &#x2F;&#x2F; sizeCtl小于0，则进行线程让步等待</span><br><span class="line">                Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin</span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; &#x2F;&#x2F; 比较sizeCtl的值与sc是否相等，相等则用-1替换</span><br><span class="line">                try &#123;</span><br><span class="line">                    if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; table表为空或者大小为0</span><br><span class="line">                        &#x2F;&#x2F; sc的值是否大于0，若是，则n为sc，否则，n为默认初始容量</span><br><span class="line">                        int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                        &#x2F;&#x2F; 新生结点数组</span><br><span class="line">                        Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                        &#x2F;&#x2F; 赋值给table</span><br><span class="line">                        table &#x3D; tab &#x3D; nt;</span><br><span class="line">                        &#x2F;&#x2F; sc为n * 3&#x2F;4</span><br><span class="line">                        sc &#x3D; n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    &#x2F;&#x2F; 设置sizeCtl的值</span><br><span class="line">                    sizeCtl &#x3D; sc;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 返回table表</span><br><span class="line">        return tab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于table的大小，会根据sizeCtl的值进行设置，如果没有设置szieCtl的值，那么默认生成的table大小为16，否则，会根据sizeCtl的大小设置table大小。</p><h3 id="tabAt函数"><a href="#tabAt函数" class="headerlink" title="tabAt函数"></a>tabAt函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</span><br><span class="line">        return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数返回table数组中下标为i的结点，可以看到是通过Unsafe对象通过反射获取的，getObjectVolatile的第二项参数为下标为i的偏移地址。</p><h3 id="casTabAt函数"><a href="#casTabAt函数" class="headerlink" title="casTabAt函数"></a>casTabAt函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,</span><br><span class="line">                                      Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</span><br><span class="line">      return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此函数用于比较table数组下标为i的结点是否为c，若为c，则用v交换操作。否则，不进行交换操作。</p><h3 id="helpTransfer函数"><a href="#helpTransfer函数" class="headerlink" title="helpTransfer函数"></a>helpTransfer函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">        if (tab !&#x3D; null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">            (nextTab &#x3D; ((ForwardingNode&lt;K,V&gt;)f).nextTable) !&#x3D; null) &#123; &#x2F;&#x2F; table表不为空并且结点类型使ForwardingNode类型，并且结点的nextTable不为空</span><br><span class="line">            int rs &#x3D; resizeStamp(tab.length);</span><br><span class="line">            while (nextTab &#x3D;&#x3D; nextTable &amp;&amp; table &#x3D;&#x3D; tab &amp;&amp;</span><br><span class="line">                   (sc &#x3D; sizeCtl) &lt; 0) &#123; &#x2F;&#x2F; 条件判断</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                    sc &#x3D;&#x3D; rs + MAX_RESIZERS || transferIndex &lt;&#x3D; 0) &#x2F;&#x2F; </span><br><span class="line">                    break;</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; &#x2F;&#x2F; 比较并交换</span><br><span class="line">                    &#x2F;&#x2F; 将table的结点转移到nextTab中</span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        return table;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此函数用于在扩容时将table表中的结点转移到nextTable中。</p><h3 id="putTreeVal函数"><a href="#putTreeVal函数" class="headerlink" title="putTreeVal函数"></a>putTreeVal函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">final TreeNode&lt;K,V&gt; putTreeVal(int h, K k, V v) &#123;</span><br><span class="line">            Class&lt;?&gt; kc &#x3D; null;</span><br><span class="line">            boolean searched &#x3D; false;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; p &#x3D; root;;) &#123;</span><br><span class="line">                int dir, ph; K pk;</span><br><span class="line">                if (p &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    first &#x3D; root &#x3D; new TreeNode&lt;K,V&gt;(h, k, v, null, null);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else if ((ph &#x3D; p.hash) &gt; h)</span><br><span class="line">                    dir &#x3D; -1;</span><br><span class="line">                else if (ph &lt; h)</span><br><span class="line">                    dir &#x3D; 1;</span><br><span class="line">                else if ((pk &#x3D; p.key) &#x3D;&#x3D; k || (pk !&#x3D; null &amp;&amp; k.equals(pk)))</span><br><span class="line">                    return p;</span><br><span class="line">                else if ((kc &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">                          (kc &#x3D; comparableClassFor(k)) &#x3D;&#x3D; null) ||</span><br><span class="line">                         (dir &#x3D; compareComparables(kc, k, pk)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    if (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched &#x3D; true;</span><br><span class="line">                        if (((ch &#x3D; p.left) !&#x3D; null &amp;&amp;</span><br><span class="line">                             (q &#x3D; ch.findTreeNode(h, k, kc)) !&#x3D; null) ||</span><br><span class="line">                            ((ch &#x3D; p.right) !&#x3D; null &amp;&amp;</span><br><span class="line">                             (q &#x3D; ch.findTreeNode(h, k, kc)) !&#x3D; null))</span><br><span class="line">                            return q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir &#x3D; tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp &#x3D; p;</span><br><span class="line">                if ((p &#x3D; (dir &lt;&#x3D; 0) ? p.left : p.right) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x, f &#x3D; first;</span><br><span class="line">                    first &#x3D; x &#x3D; new TreeNode&lt;K,V&gt;(h, k, v, f, xp);</span><br><span class="line">                    if (f !&#x3D; null)</span><br><span class="line">                        f.prev &#x3D; x;</span><br><span class="line">                    if (dir &lt;&#x3D; 0)</span><br><span class="line">                        xp.left &#x3D; x;</span><br><span class="line">                    else</span><br><span class="line">                        xp.right &#x3D; x;</span><br><span class="line">                    if (!xp.red)</span><br><span class="line">                        x.red &#x3D; true;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        lockRoot();</span><br><span class="line">                        try &#123;</span><br><span class="line">                            root &#x3D; balanceInsertion(root, x);</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            unlockRoot();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            assert checkInvariants(root);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>　说明：此函数用于将指定的hash、key、value值添加到红黑树中，若已经添加了，则返回null，否则返回该结点。</p><h3 id="treeifyBin函数"><a href="#treeifyBin函数" class="headerlink" title="　treeifyBin函数"></a>　treeifyBin函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</span><br><span class="line">        Node&lt;K,V&gt; b; int n, sc;</span><br><span class="line">        if (tab !&#x3D; null) &#123; &#x2F;&#x2F; 表不为空</span><br><span class="line">            if ((n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY) &#x2F;&#x2F; table表的长度小于最小的长度</span><br><span class="line">                &#x2F;&#x2F; 进行扩容，调整某个桶中结点数量过多的问题（由于某个桶中结点数量超出了阈值，则触发treeifyBin）</span><br><span class="line">                tryPresize(n &lt;&lt; 1);</span><br><span class="line">            else if ((b &#x3D; tabAt(tab, index)) !&#x3D; null &amp;&amp; b.hash &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 桶中存在结点并且结点的hash值大于等于0</span><br><span class="line">                synchronized (b) &#123; &#x2F;&#x2F; 对桶中第一个结点进行加锁</span><br><span class="line">                    if (tabAt(tab, index) &#x3D;&#x3D; b) &#123; &#x2F;&#x2F; 第一个结点没有变化</span><br><span class="line">                        TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;</span><br><span class="line">                        for (Node&lt;K,V&gt; e &#x3D; b; e !&#x3D; null; e &#x3D; e.next) &#123; &#x2F;&#x2F; 遍历桶中所有结点</span><br><span class="line">                            &#x2F;&#x2F; 新生一个TreeNode结点</span><br><span class="line">                            TreeNode&lt;K,V&gt; p &#x3D;</span><br><span class="line">                                new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                  null, null);</span><br><span class="line">                            if ((p.prev &#x3D; tl) &#x3D;&#x3D; null) &#x2F;&#x2F; 该结点前驱为空</span><br><span class="line">                                &#x2F;&#x2F; 设置p为头结点</span><br><span class="line">                                hd &#x3D; p;</span><br><span class="line">                            else</span><br><span class="line">                                &#x2F;&#x2F; 尾节点的next域赋值为p</span><br><span class="line">                                tl.next &#x3D; p;</span><br><span class="line">                            &#x2F;&#x2F; 尾节点赋值为p</span><br><span class="line">                            tl &#x3D; p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; 设置table表中下标为index的值为hd</span><br><span class="line">                        setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此函数用于将桶中的数据结构转化为红黑树，其中，值得注意的是，当table的长度未达到阈值时，会进行一次扩容操作，该操作会使得触发treeifyBin操作的某个桶中的所有元素进行一次重新分配，这样可以避免某个桶中的结点数量太大。</p><h3 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private final void addCount(long x, int check) &#123;</span><br><span class="line">        CounterCell[] as; long b, s;</span><br><span class="line">        if ((as &#x3D; counterCells) !&#x3D; null ||</span><br><span class="line">            !U.compareAndSwapLong(this, BASECOUNT, b &#x3D; baseCount, s &#x3D; b + x)) &#123; &#x2F;&#x2F; counterCells不为空或者比较交换失败</span><br><span class="line">            CounterCell a; long v; int m;</span><br><span class="line">            &#x2F;&#x2F; 无竞争标识</span><br><span class="line">            boolean uncontended &#x3D; true;</span><br><span class="line">            if (as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0 ||</span><br><span class="line">                (a &#x3D; as[ThreadLocalRandom.getProbe() &amp; m]) &#x3D;&#x3D; null ||</span><br><span class="line">                !(uncontended &#x3D;</span><br><span class="line">                  U.compareAndSwapLong(a, CELLVALUE, v &#x3D; a.value, v + x))) &#123; &#x2F;&#x2F; </span><br><span class="line">                fullAddCount(x, uncontended);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (check &lt;&#x3D; 1)</span><br><span class="line">                return;</span><br><span class="line">            s &#x3D; sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">        if (check &gt;&#x3D; 0) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; int n, sc;</span><br><span class="line">            while (s &gt;&#x3D; (long)(sc &#x3D; sizeCtl) &amp;&amp; (tab &#x3D; table) !&#x3D; null &amp;&amp;</span><br><span class="line">                   (n &#x3D; tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                int rs &#x3D; resizeStamp(n);</span><br><span class="line">                if (sc &lt; 0) &#123;</span><br><span class="line">                    if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                        sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||</span><br><span class="line">                        transferIndex &lt;&#x3D; 0)</span><br><span class="line">                        break;</span><br><span class="line">                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                    transfer(tab, null);</span><br><span class="line">                s &#x3D; sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数主要完成binCount的值加1的操作。</p><h3 id="get函数"><a href="#get函数" class="headerlink" title="get函数"></a>get函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">        &#x2F;&#x2F; 计算key的hash值</span><br><span class="line">        int h &#x3D; spread(key.hashCode()); </span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123; &#x2F;&#x2F; 表不为空并且表的长度大于0并且key所在的桶不为空</span><br><span class="line">            if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123; &#x2F;&#x2F; 表中的元素的hash值与key的hash值相等</span><br><span class="line">                if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))) &#x2F;&#x2F; 键相等</span><br><span class="line">                    &#x2F;&#x2F; 返回值</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (eh &lt; 0) &#x2F;&#x2F; 结点hash值小于0</span><br><span class="line">                &#x2F;&#x2F; 在桶（链表&#x2F;红黑树）中查找</span><br><span class="line">                return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;</span><br><span class="line">            while ((e &#x3D; e.next) !&#x3D; null) &#123; &#x2F;&#x2F; 对于结点hash值大于0的情况</span><br><span class="line">                if (e.hash &#x3D;&#x3D; h &amp;&amp;</span><br><span class="line">                    ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>get函数根据key的hash值来计算在哪个桶中，再遍历桶，查找元素，若找到则返回该结点，否则，返回null。</p><h3 id="replaceNode函数"><a href="#replaceNode函数" class="headerlink" title="replaceNode函数"></a>replaceNode函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">final V replaceNode(Object key, V value, Object cv) &#123;</span><br><span class="line">        &#x2F;&#x2F; 计算key的hash值</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0 ||</span><br><span class="line">                (f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#x2F;&#x2F; table表为空或者表长度为0或者key所对应的桶为空</span><br><span class="line">                &#x2F;&#x2F; 跳出循环</span><br><span class="line">                break;</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED) &#x2F;&#x2F; 桶中第一个结点的hash值为MOVED</span><br><span class="line">                &#x2F;&#x2F; 转移</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                boolean validated &#x3D; false;</span><br><span class="line">                synchronized (f) &#123; &#x2F;&#x2F; 加锁同步</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123; &#x2F;&#x2F; 桶中的第一个结点没有发生变化</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 结点hash值大于0</span><br><span class="line">                            validated &#x3D; true;</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f, pred &#x3D; null;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123; &#x2F;&#x2F; 结点的hash值与指定的hash值相等，并且key也相等</span><br><span class="line">                                    V ev &#x3D; e.val;</span><br><span class="line">                                    if (cv &#x3D;&#x3D; null || cv &#x3D;&#x3D; ev ||</span><br><span class="line">                                        (ev !&#x3D; null &amp;&amp; cv.equals(ev))) &#123; &#x2F;&#x2F; cv为空或者与结点value相等或者不为空并且相等</span><br><span class="line">                                        &#x2F;&#x2F; 保存该结点的val值</span><br><span class="line">                                        oldVal &#x3D; ev;</span><br><span class="line">                                        if (value !&#x3D; null) &#x2F;&#x2F; value为null</span><br><span class="line">                                            &#x2F;&#x2F; 设置结点value值</span><br><span class="line">                                            e.val &#x3D; value;</span><br><span class="line">                                        else if (pred !&#x3D; null) &#x2F;&#x2F; 前驱不为空</span><br><span class="line">                                            &#x2F;&#x2F; 前驱的后继为e的后继，即删除了e结点</span><br><span class="line">                                            pred.next &#x3D; e.next;</span><br><span class="line">                                        else</span><br><span class="line">                                            &#x2F;&#x2F; 设置table表中下标为index的值为e.next</span><br><span class="line">                                            setTabAt(tab, i, e.next);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                pred &#x3D; e;</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null)</span><br><span class="line">                                    break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 为红黑树结点类型</span><br><span class="line">                            validated &#x3D; true;</span><br><span class="line">                            &#x2F;&#x2F; 类型转化</span><br><span class="line">                            TreeBin&lt;K,V&gt; t &#x3D; (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                            if ((r &#x3D; t.root) !&#x3D; null &amp;&amp;</span><br><span class="line">                                (p &#x3D; r.findTreeNode(hash, key, null)) !&#x3D; null) &#123; &#x2F;&#x2F; 根节点不为空并且存在与指定hash和key相等的结点</span><br><span class="line">                                &#x2F;&#x2F; 保存p结点的value</span><br><span class="line">                                V pv &#x3D; p.val;</span><br><span class="line">                                if (cv &#x3D;&#x3D; null || cv &#x3D;&#x3D; pv ||</span><br><span class="line">                                    (pv !&#x3D; null &amp;&amp; cv.equals(pv))) &#123; &#x2F;&#x2F; cv为空或者与结点value相等或者不为空并且相等</span><br><span class="line">                                    oldVal &#x3D; pv;</span><br><span class="line">                                    if (value !&#x3D; null) </span><br><span class="line">                                        p.val &#x3D; value;</span><br><span class="line">                                    else if (t.removeTreeNode(p)) &#x2F;&#x2F; 移除p结点</span><br><span class="line">                                        setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (validated) &#123;</span><br><span class="line">                    if (oldVal !&#x3D; null) &#123;</span><br><span class="line">                        if (value &#x3D;&#x3D; null)</span><br><span class="line">                            &#x2F;&#x2F; baseCount值减一</span><br><span class="line">                            addCount(-1L, -1);</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：此函数对remove函数提供支持，remove函数底层是调用的replaceNode函数实现结点的删除。　</p><p>ConcurrentHashMap的性能相比HashMap的线程安全同步集合和Hashtable而言，性能都要高出不少。原因是经过Collections封装的线程安全的HashMap和Hashtable都是对整个结构加锁，而ConcurrentHashMap是对每一个桶单独进行锁操作，不同的桶之间的操作不会相互影响，可以并发执行。因此，其速度会快很多。</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocurrentHashMap1.7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前中后缀表达式</title>
      <link href="2020/09/19/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E3%80%81%E6%A0%88/3%E3%80%81%E5%89%8D%E4%B8%AD%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2020/09/19/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E3%80%81%E6%A0%88/3%E3%80%81%E5%89%8D%E4%B8%AD%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>前缀记法、中缀记法和后缀记法。它们之间的区别在于运算符相对与操作数的位置不同</p><ul><li>(3 + 4) × 5 - 6 就是中缀表达式</li><li>一 * + 3 4 5 6 前缀表达式（波兰式）</li><li>3 4 + 5 × 6 - 后缀表达式（逆波兰式）</li></ul><p>虽然人的大脑很容易理解与分析中缀表达式，但对计算机来说中缀表达式却是很复杂的，因此计算表达式的值时，通常需要先将中缀表达式转换为前缀或后缀表达式，然后再进行求值。对计算机来说，计算前缀或后缀表达式的值非常简单。</p><h3 id="前缀表达式求值："><a href="#前缀表达式求值：" class="headerlink" title="前缀表达式求值："></a>前缀表达式求值：</h3><p>从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果。</p><p>例如前缀表达式“- × + 3 4 5 6”：</p><ul><li>(1) 从右至左扫描，将6、5、4、3压入堆栈；</li><li>(2) 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素，注意与后缀表达式做比较），计算出3+4的值，得7，再将7入栈；</li><li>(3) 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈；</li><li>(4) 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。</li></ul><h3 id="后缀表达式求值："><a href="#后缀表达式求值：" class="headerlink" title="后缀表达式求值："></a>后缀表达式求值：</h3><p>与前缀表达式类似，只是顺序是从左至右</p><p>例如后缀表达式“3 4 + 5 × 6 -”：</p><ul><li>(1) 从左至右扫描，将3和4压入堆栈；</li><li>(2) 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素，注意与前缀表达式做比较），计算出3+4的值，得7，再将7入栈；</li><li>(3) 将5入栈；</li><li>(4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</li><li>(5) 将6入栈；</li><li>(6) 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。</li></ul><h3 id="中缀表达式转后缀表达式："><a href="#中缀表达式转后缀表达式：" class="headerlink" title="中缀表达式转后缀表达式："></a>中缀表达式转后缀表达式：</h3><p>中缀表达式1 + (( 2 + 3)* 4 ) –5，请将它转化为后缀表达式。</p><p>首先将中缀表达式转换为表达式树，然后后序遍历表达式树，所得结果就是后缀表达式。</p><p>将中缀表达式转化为表达式树方法：表达式树的树叶是操作数，而其他的节点为操作符，根节点为优先级最低且靠右的操作符（如上述表达式优先级最低的是- 和+，但 + 更靠右，所以根为+），圆括号不包括。如上述中缀表达式转换后的表达式树如下：</p><p><img src="https://img-blog.csdn.net/20140402144303578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2Fsa2Vya2Fscg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><p>经过后序遍历表达式树后得到的后缀表达式为：12 3 + 4 * + 5 –</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line">public class PolandNotation &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;完成将一个中缀表达式转成后缀表达式的功能</span><br><span class="line">&#x2F;&#x2F;说明</span><br><span class="line">&#x2F;&#x2F;1. 1+((2+3)×4)-5 &#x3D;&gt; 转成  1 2 3 + 4 × + 5 –</span><br><span class="line">&#x2F;&#x2F;2. 因为直接对str 进行操作，不方便，因此 先将  &quot;1+((2+3)×4)-5&quot; &#x3D;》 中缀的表达式对应的List</span><br><span class="line">&#x2F;&#x2F;   即 &quot;1+((2+3)×4)-5&quot; &#x3D;&gt; ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span><br><span class="line">&#x2F;&#x2F;3. 将得到的中缀表达式对应的List &#x3D;&gt; 后缀表达式对应的List</span><br><span class="line">&#x2F;&#x2F;   即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  &#x3D;》 ArrayList [1,2,3,+,4,*,+,5,–]</span><br><span class="line"></span><br><span class="line">String expression &#x3D; &quot;1+((2+3)*4)-5&quot;;&#x2F;&#x2F;注意表达式 </span><br><span class="line">List&lt;String&gt; infixExpressionList &#x3D; toInfixExpressionList(expression);</span><br><span class="line">System.out.println(&quot;中缀表达式对应的List&#x3D;&quot; + infixExpressionList); &#x2F;&#x2F; ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span><br><span class="line">List&lt;String&gt; suffixExpreesionList &#x3D; parseSuffixExpreesionList(infixExpressionList);</span><br><span class="line">System.out.println(&quot;后缀表达式对应的List&quot; + suffixExpreesionList); &#x2F;&#x2F;ArrayList [1,2,3,+,4,*,+,5,–] </span><br><span class="line"></span><br><span class="line">System.out.printf(&quot;expression&#x3D;%d&quot;, calculate(suffixExpreesionList)); &#x2F;&#x2F; ?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;先定义给逆波兰表达式</span><br><span class="line">&#x2F;&#x2F;(30+4)×5-6  &#x3D;&gt; 30 4 + 5 × 6 - &#x3D;&gt; 164</span><br><span class="line">&#x2F;&#x2F; 4 * 5 - 8 + 60 + 8 &#x2F; 2 &#x3D;&gt; 4 5 * 8 - 60 + 8 2 &#x2F; + </span><br><span class="line">&#x2F;&#x2F;测试 </span><br><span class="line">&#x2F;&#x2F;说明为了方便，逆波兰表达式 的数字和符号使用空格隔开</span><br><span class="line">&#x2F;&#x2F;String suffixExpression &#x3D; &quot;30 4 + 5 * 6 -&quot;;</span><br><span class="line">String suffixExpression &#x3D; &quot;4 5 * 8 - 60 + 8 2 &#x2F; +&quot;; &#x2F;&#x2F; 76</span><br><span class="line">&#x2F;&#x2F;思路</span><br><span class="line">&#x2F;&#x2F;1. 先将 &quot;3 4 + 5 × 6 - &quot; &#x3D;&gt; 放到ArrayList中</span><br><span class="line">&#x2F;&#x2F;2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list &#x3D; getListString(suffixExpression);</span><br><span class="line">System.out.println(&quot;rpnList&#x3D;&quot; + list);</span><br><span class="line">int res &#x3D; calculate(list);</span><br><span class="line">System.out.println(&quot;计算的结果是&#x3D;&quot; + res);</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  &#x3D;》 ArrayList [1,2,3,+,4,*,+,5,–]</span><br><span class="line">&#x2F;&#x2F;方法：将得到的中缀表达式对应的List &#x3D;&gt; 后缀表达式对应的List</span><br><span class="line">public static List&lt;String&gt; parseSuffixExpreesionList(List&lt;String&gt; ls) &#123;</span><br><span class="line">&#x2F;&#x2F;定义两个栈</span><br><span class="line">Stack&lt;String&gt; s1 &#x3D; new Stack&lt;String&gt;(); &#x2F;&#x2F; 符号栈</span><br><span class="line">&#x2F;&#x2F;说明：因为s2 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出</span><br><span class="line">&#x2F;&#x2F;因此比较麻烦，这里我们就不用 Stack&lt;String&gt; 直接使用 List&lt;String&gt; s2</span><br><span class="line">&#x2F;&#x2F;Stack&lt;String&gt; s2 &#x3D; new Stack&lt;String&gt;(); &#x2F;&#x2F; 储存中间结果的栈s2</span><br><span class="line">List&lt;String&gt; s2 &#x3D; new ArrayList&lt;String&gt;(); &#x2F;&#x2F; 储存中间结果的Lists2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;遍历ls</span><br><span class="line">for(String item: ls) &#123;</span><br><span class="line">&#x2F;&#x2F;如果是一个数，加入s2</span><br><span class="line">if(item.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">s2.add(item);</span><br><span class="line">&#125; else if (item.equals(&quot;(&quot;)) &#123;</span><br><span class="line">s1.push(item);</span><br><span class="line">&#125; else if (item.equals(&quot;)&quot;)) &#123;</span><br><span class="line">&#x2F;&#x2F;如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span><br><span class="line">while(!s1.peek().equals(&quot;(&quot;)) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line">s1.pop();&#x2F;&#x2F;!!! 将 ( 弹出 s1栈， 消除小括号</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;当item的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较</span><br><span class="line">&#x2F;&#x2F;问题：我们缺少一个比较优先级高低的方法</span><br><span class="line">while(s1.size() !&#x3D; 0 &amp;&amp; Operation.getValue(s1.peek()) &gt;&#x3D; Operation.getValue(item) ) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;还需要将item压入栈</span><br><span class="line">s1.push(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将s1中剩余的运算符依次弹出并加入s2</span><br><span class="line">while(s1.size() !&#x3D; 0) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return s2; &#x2F;&#x2F;注意因为是存放到List, 因此按顺序输出就是对应的后缀表达式对应的List</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法：将 中缀表达式转成对应的List</span><br><span class="line">&#x2F;&#x2F;  s&#x3D;&quot;1+((2+3)×4)-5&quot;;</span><br><span class="line">public static List&lt;String&gt; toInfixExpressionList(String s) &#123;</span><br><span class="line">&#x2F;&#x2F;定义一个List,存放中缀表达式 对应的内容</span><br><span class="line">List&lt;String&gt; ls &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">int i &#x3D; 0; &#x2F;&#x2F;这时是一个指针，用于遍历 中缀表达式字符串</span><br><span class="line">String str; &#x2F;&#x2F; 对多位数的拼接</span><br><span class="line">char c; &#x2F;&#x2F; 每遍历到一个字符，就放入到c</span><br><span class="line">do &#123;</span><br><span class="line">&#x2F;&#x2F;如果c是一个非数字，我需要加入到ls</span><br><span class="line">if((c&#x3D;s.charAt(i)) &lt; 48 ||  (c&#x3D;s.charAt(i)) &gt; 57) &#123;</span><br><span class="line">ls.add(&quot;&quot; + c);</span><br><span class="line">i++; &#x2F;&#x2F;i需要后移</span><br><span class="line">&#125; else &#123; &#x2F;&#x2F;如果是一个数，需要考虑多位数</span><br><span class="line">str &#x3D; &quot;&quot;; &#x2F;&#x2F;先将str 置成&quot;&quot; &#39;0&#39;[48]-&gt;&#39;9&#39;[57]</span><br><span class="line">while(i &lt; s.length() &amp;&amp; (c&#x3D;s.charAt(i)) &gt;&#x3D; 48 &amp;&amp; (c&#x3D;s.charAt(i)) &lt;&#x3D; 57) &#123;</span><br><span class="line">str +&#x3D; c;&#x2F;&#x2F;拼接</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">ls.add(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;while(i &lt; s.length());</span><br><span class="line">return ls;&#x2F;&#x2F;返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList中</span><br><span class="line">public static List&lt;String&gt; getListString(String suffixExpression) &#123;</span><br><span class="line">&#x2F;&#x2F;将 suffixExpression 分割</span><br><span class="line">String[] split &#x3D; suffixExpression.split(&quot; &quot;);</span><br><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">for(String ele: split) &#123;</span><br><span class="line">list.add(ele);</span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;完成对逆波兰表达式的运算</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 1)从左至右扫描，将3和4压入堆栈；</span><br><span class="line">2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；</span><br><span class="line">3)将5入栈；</span><br><span class="line">4)接下来是×运算符，因此弹出5和7，计算出7×5&#x3D;35，将35入栈；</span><br><span class="line">5)将6入栈；</span><br><span class="line">6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public static int calculate(List&lt;String&gt; ls) &#123;</span><br><span class="line">&#x2F;&#x2F; 创建给栈, 只需要一个栈即可</span><br><span class="line">Stack&lt;String&gt; stack &#x3D; new Stack&lt;String&gt;();</span><br><span class="line">&#x2F;&#x2F; 遍历 ls</span><br><span class="line">for (String item : ls) &#123;</span><br><span class="line">&#x2F;&#x2F; 这里使用正则表达式来取出数</span><br><span class="line">if (item.matches(&quot;\\d+&quot;)) &#123; &#x2F;&#x2F; 匹配的是多位数</span><br><span class="line">&#x2F;&#x2F; 入栈</span><br><span class="line">stack.push(item);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; pop出两个数，并运算， 再入栈</span><br><span class="line">int num2 &#x3D; Integer.parseInt(stack.pop());</span><br><span class="line">int num1 &#x3D; Integer.parseInt(stack.pop());</span><br><span class="line">int res &#x3D; 0;</span><br><span class="line">if (item.equals(&quot;+&quot;)) &#123;</span><br><span class="line">res &#x3D; num1 + num2;</span><br><span class="line">&#125; else if (item.equals(&quot;-&quot;)) &#123;</span><br><span class="line">res &#x3D; num1 - num2;</span><br><span class="line">&#125; else if (item.equals(&quot;*&quot;)) &#123;</span><br><span class="line">res &#x3D; num1 * num2;</span><br><span class="line">&#125; else if (item.equals(&quot;&#x2F;&quot;)) &#123;</span><br><span class="line">res &#x3D; num1 &#x2F; num2;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">throw new RuntimeException(&quot;运算符有误&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;把res 入栈</span><br><span class="line">stack.push(&quot;&quot; + res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;最后留在stack中的数据是运算结果</span><br><span class="line">return Integer.parseInt(stack.pop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编写一个类 Operation 可以返回一个运算符 对应的优先级</span><br><span class="line">class Operation &#123;</span><br><span class="line">private static int ADD &#x3D; 1;</span><br><span class="line">private static int SUB &#x3D; 1;</span><br><span class="line">private static int MUL &#x3D; 2;</span><br><span class="line">private static int DIV &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;写一个方法，返回对应的优先级数字</span><br><span class="line">public static int getValue(String operation) &#123;</span><br><span class="line">int result &#x3D; 0;</span><br><span class="line">switch (operation) &#123;</span><br><span class="line">case &quot;+&quot;:</span><br><span class="line">result &#x3D; ADD;</span><br><span class="line">break;</span><br><span class="line">case &quot;-&quot;:</span><br><span class="line">result &#x3D; SUB;</span><br><span class="line">break;</span><br><span class="line">case &quot;*&quot;:</span><br><span class="line">result &#x3D; MUL;</span><br><span class="line">break;</span><br><span class="line">case &quot;&#x2F;&quot;:</span><br><span class="line">result &#x3D; DIV;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">System.out.println(&quot;不存在该运算符&quot; + operation);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前中后缀表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈：应用</title>
      <link href="2020/09/19/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E3%80%81%E6%A0%88/%E6%A0%88%EF%BC%9A%E5%BA%94%E7%94%A8/"/>
      <url>2020/09/19/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E3%80%81%E6%A0%88/%E6%A0%88%EF%BC%9A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1、如何实现浏览器的前进和后退功能"><a href="#1、如何实现浏览器的前进和后退功能" class="headerlink" title="1、如何实现浏览器的前进和后退功能"></a>1、如何实现浏览器的前进和后退功能</h3><h3 id="2、两个栈实现一个队列"><a href="#2、两个栈实现一个队列" class="headerlink" title="2、两个栈实现一个队列"></a>2、两个栈实现一个队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class StackToQueue&lt;T&gt; &#123;</span><br><span class="line">    Stack&lt;T&gt; stackOne &#x3D; new Stack&lt;T&gt;();</span><br><span class="line">    Stack&lt;T&gt; stackTwo &#x3D; new Stack&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    private void push(T data) &#123;</span><br><span class="line">        stackOne.push(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private T pop() &#123;</span><br><span class="line">        while (!stackOne.isEmpty()) &#123;</span><br><span class="line">            stackTwo.push(stackOne.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        T first &#x3D; stackTwo.pop();</span><br><span class="line">        while (!stackTwo.isEmpty()) &#123;</span><br><span class="line">            stackOne.push(stackTwo.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return first;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、两个队列实现一个栈"><a href="#3、两个队列实现一个栈" class="headerlink" title="3、两个队列实现一个栈"></a>3、两个队列实现一个栈</h3><p>入栈操作，我们固定把元素压入queue1<br>出栈操作，如果队列1不为空，就把队列1中q1.size()-1个元素poll出来，添加到队列2中，再把队列中那个最后的元素poll出来<br>这两个队列中始终有一个是空的。另一个非空。push添加元素到非空队列中，pop把非空队列中前面的元素都转移到另一个队列中，只剩最后一个元素，再把最后一个元素pop出来。这样这一个队列是空的，另一个队列又非空了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class QueueToStack&lt;T&gt; &#123;</span><br><span class="line">    private ArrayDeque&lt;T&gt; queueOne &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line">    private ArrayDeque&lt;T&gt; queueTwo &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private void push(T t) &#123;</span><br><span class="line">        queueOne.offer(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private T pop() &#123;</span><br><span class="line">        if (!queueOne.isEmpty() || !queueTwo.isEmpty()) &#123;</span><br><span class="line">            if (!queueOne.isEmpty()) &#123;</span><br><span class="line">                while (queueOne.size() &gt; 1) &#123;</span><br><span class="line">                    queueTwo.offer(queueOne.poll());</span><br><span class="line">                &#125;</span><br><span class="line">                return queueOne.poll();</span><br><span class="line">            &#125; else if (!queueTwo.isEmpty()) &#123;</span><br><span class="line">                while (queueTwo.size() &gt; 1) &#123;</span><br><span class="line">                    queueOne.offer(queueTwo.poll());</span><br><span class="line">                &#125;</span><br><span class="line">                return queueTwo.poll();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private T top() &#123;</span><br><span class="line">        T top &#x3D; null;</span><br><span class="line">        if (!isEmpty()) &#123;</span><br><span class="line">            if (!queueOne.isEmpty()) &#123;</span><br><span class="line">                while (queueOne.size() &gt; 1) &#123;</span><br><span class="line">                    queueTwo.offer(queueOne.poll());</span><br><span class="line">                &#125;</span><br><span class="line">                top &#x3D; queueOne.peek();</span><br><span class="line">                queueTwo.offer(queueOne.poll());</span><br><span class="line">            &#125; else if (!queueTwo.isEmpty()) &#123;</span><br><span class="line">                while (queueTwo.size() &gt; 1) &#123;</span><br><span class="line">                    queueOne.offer(queueTwo.poll());</span><br><span class="line">                &#125;</span><br><span class="line">                top &#x3D; queueTwo.peek();</span><br><span class="line">                queueOne.offer(queueTwo.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            return top;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isEmpty() &#123;</span><br><span class="line">        return queueOne.isEmpty() &amp;&amp; queueTwo.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈：应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP、BASE理论</title>
      <link href="2020/09/16/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2%E3%80%81CAP%E3%80%81BASE%E7%90%86%E8%AE%BA/"/>
      <url>2020/09/16/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2%E3%80%81CAP%E3%80%81BASE%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<ul><li>1、商品服务请求主数据库写入商品信息（添加商品、修改商品、删除商品）</li><li>2、主数据库向商品服务响应写入成功。</li><li>3、商品服务请求从数据库读取商品信息。</li></ul><h4 id="C-Consistency："><a href="#C-Consistency：" class="headerlink" title="C  Consistency："></a>C  Consistency：</h4><p>一致性是指写操作后的读操作可以读取到最新的数据状态，当数据分布在多个节点上，从任意结点读取到的数据都 是最新的状态。<br>上图中，商品信息的读写要满足一致性就是要实现如下目标：</p><ul><li>1、商品服务写入主数据库成功，则向从数据库查询新数据也成功。</li><li>2、商品服务写入主数据库失败，则向从数据库查询新数据也失败。 如何实现一致性？</li><li>3、写入主数据库后要将数据同步到从数据库。</li><li>4、写入主数据库后，在向从数据库同步期间要将从数据库锁定，待同步完成后再释放锁，以免在新数据写入成功 后，向从数据库查询到旧的数据。</li></ul><p>分布式系统一致性的特点：</p><ul><li>1、由于存在数据同步的过程，写操作的响应会有一定的延迟。 </li><li>2、为了保证数据一致性会对资源暂时锁定，待数据同步完成释放锁定资源。 </li><li>3、如果请求数据同步失败的结点则会返回错误信息，一定不会返回旧数据。 </li></ul><h4 id="A-Availability-："><a href="#A-Availability-：" class="headerlink" title="A - Availability ："></a>A - Availability ：</h4><p>可用性是指任何事务操作都可以得到响应结果，且不会出现响应超时或响应错误。 上图中，商品信息读取满足可用性就是要实现如下目标： </p><ul><li>1、从数据库接收到数据查询的请求则立即能够响应数据查询结果。 </li><li>2、从数据库不允许出现响应超时或响应错误。 如何实现可用性？ </li><li>1、写入主数据库后要将数据同步到从数据库。 </li><li>2、由于要保证从数据库的可用性，不可将从数据库中的资源进行锁定。 </li><li>3、即时数据还没有同步过来，从数据库也要返回要查询的数据，哪怕是旧数据，如果连旧数据也没有则可以按照 约定返回一个默认信息，但不能返回错误或响应超时。 分布式系统可用性的特点： 1、 所有请求都有响应，且不会出现响应超时或响应错误。</li></ul><h5 id="P-Partition-tolerance-："><a href="#P-Partition-tolerance-：" class="headerlink" title="P - Partition tolerance ："></a>P - Partition tolerance ：</h5><p>通常分布式系统的各各结点部署在不同的子网，这就是网络分区，不可避免的会出现由于网络问题而导致结点之间 通信失败，此时仍可对外提供服务，这叫分区容忍性。 上图中，商品信息读写满足分区容忍性就是要实现如下目标： </p><ul><li>1、主数据库向从数据库同步数据失败不影响读写操作。 </li><li>2、其一个结点挂掉不影响另一个结点对外提供服务。 如何实现分区容忍性？ </li><li>1、尽量使用异步取代同步操作，例如使用异步方式将数据从主数据库同步到从数据，这样结点之间能有效的实现 松耦合。 </li><li>2、添加从数据库结点，其中一个从结点挂掉其它从结点提供服务。 分布式分区容忍性的特点： 1、分区容忍性分是布式系统具备的基本能力。</li></ul><p>一般都会做出如下选择：保证P和A，舍弃C强一致，保证最终一致性。</p><p>BASE理论</p><p>1、理解强一致性和最终一致性 CAP理论告诉我们一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍 性（Partition tolerance）这三项中的两项，其中AP在实际应用中较多，AP即舍弃一致性，保证可用性和分区容忍 性，但是在实际生产中很多场景都要实现一致性，比如前边我们举的例子主数据库向从数据库同步数据，即使不要 一致性，但是最终也要将数据同步成功来保证数据一致，这种一致性和CAP中的一致性不同，CAP中的一致性要求 在任何时间查询每个结点数据都必须一致，它强调的是强一致性，但是最终一致性是允许可以在一段时间内每个结 点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。 </p><p>2、Base理论介绍 BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩 写。</p><p>==BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性==，当出现故障允许部分不可用但要保证 核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为“柔 性事务”。</p><ul><li>基本可用:分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如，电商网站交易付款出 现问题了，商品依然可以正常浏览。 </li><li>软状态:由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫软状态），这个状态不影响系统可用 性，如订单的”支付中”、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。 </li><li>最终一致:最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的”支付中”状态，最终会变 为“支付成功”或者”支付失败”，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式事务解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP、BASE理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何存储IP地址</title>
      <link href="2020/09/14/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8IP%E5%9C%B0%E5%9D%80/"/>
      <url>2020/09/14/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8IP%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<p> IP地址 本来就是一个字符串，存放在数据库作为字符穿类型</p><p> 网络地址：<br>192.168.33.123每一个值最大不会越过255，也就是十六进制的FF，两个Byte刚好表示的最大值是255，<br>这样子，就可以用一个32位的整形来保存这个IP<br>1100 0000 1010 1000 0010 0001 0111 1011<br>把这些二进制合在一起就是32位的数了<br>11000000101010000010000101111011<br>十进制为<br>3232244091</p><p>《高性能MySQL 第3版》第4.1.7节时，作者建议当存储IPv4地址时，应该使用32位的无符号整数（UNSIGNED INT）来存储IP<br>地址<br>优点：</p><ul><li>节省空间，不管是数据存储空间，还是索引存储空间</li><li>便于使用范围查询（BETWEEN…AND），且效率更高</li></ul><p>如果是 IPv4地址 的话 可通过数据库自带的函数 INET_ATON 和 INET_NTOA 进行转化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT INET_ATON(&#39;209.207.224.40&#39;);</span><br><span class="line">-&gt; 3520061480</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT INET_NTOA(3520061480);</span><br><span class="line">-&gt; &#39;209.207.224.40&#39;</span><br></pre></td></tr></table></figure><p>如果是 IPv6地址 的话，MySQL 5.6 版本之后。则使用函数 INET6_ATON 和 INET6_NTOA 进行转化。然后数据库定义为 varbinary 类型，分配 128bits 空间（因为 ipv6采用的是128bits，16个字节）；或者定义为 char 类型，分配<br>32bits 空间</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 如何存储IP地址 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传漏洞</title>
      <link href="2020/09/10/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/3%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
      <url>2020/09/10/Study%20notes/%E5%AF%86%E7%A0%81%E5%AD%A6/web%E6%94%BB%E5%87%BB/3%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>文件上传攻击指的是恶意攻击者利用一些站点没有对文件的类型做很好的校验，上传了可执行的文件或者脚本，并且通过脚本获得服务器上相应的权力，或者是通过诱导外部用户访问、下载上传的病毒或木马文件，达到攻击的目的</p><ul><li>1、文件上传的目录设置为不可执行</li><li>2、上传的文件需要使用随机数等进行重命名，使攻击者无法猜测到上传文件的访问路径</li><li>3、对于图片类型的文件，可以在上传后，利用imagemagick等工具对图片进行相应的缩放，破坏恶意用户上传的二进制可执行文件的结构，来避免恶意代码执行</li><li>4、对HTTP包头的content-type也和上传文件的大小也需要进行检查。</li><li>5、不能简单地通过后缀名来判断文件类型，很多类型的文件起始的几个字节内容是固定的，根据这几个字节(魔数)的内容就可以确定文件类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public enum FileType&#123;</span><br><span class="line">    JPEG(&quot;FFD8FF&quot;),</span><br><span class="line">    PNG(&quot;89504E47&quot;),</span><br><span class="line">    GIF(&quot;47494638&quot;),</span><br><span class="line">    TIFF(&quot;49492A00&quot;),</span><br><span class="line">    BMP(&quot;424D&quot;),</span><br><span class="line">    DWG(&quot;41433130&quot;),</span><br><span class="line">    PSD(&quot;38425053&quot;),</span><br><span class="line">    XML(&quot;3C3F786D6C&quot;),</span><br><span class="line">    HTML(&quot;68746D6C3E&quot;),</span><br><span class="line">    PDF(&quot;255044462D312E&quot;),</span><br><span class="line">    ZIP(&quot;504B0304&quot;),</span><br><span class="line">    RAR(&quot;52617221&quot;),</span><br><span class="line">    WAV(&quot;57415645&quot;),</span><br><span class="line">    AVI(&quot;41564920&quot;),</span><br><span class="line"></span><br><span class="line">    private String value &#x3D; &quot;&quot;;</span><br><span class="line">    private FileType(String value)&#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getValue()&#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setValue(String value)&#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *读取文件头</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"> private static String getFileHeader(String filePath) throws IOException &#123;</span><br><span class="line">     &#x2F;&#x2F;这里需要注意的是，每个文件的魔数的长度都不相同，因此需要使用startwith</span><br><span class="line">     byte[] b &#x3D; new byte[28];</span><br><span class="line">     InputStream is &#x3D; null;</span><br><span class="line">     is &#x3D; new FileInputStream(filePath);</span><br><span class="line">     is.read(b, 0, 28);</span><br><span class="line">     is.close();</span><br><span class="line"></span><br><span class="line">     return bytes2hex(b);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">  *判断文件类型</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static FileType getType(String filePath) throws IOException &#123;</span><br><span class="line">      String fileHead &#x3D; getFileHeader(filePath);</span><br><span class="line">      if(fileHead &#x3D;&#x3D; null || fileHead.length() &#x3D;&#x3D; 0)&#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">      fileHead &#x3D; fileHead.toUpperCase();</span><br><span class="line">      FileType[] fileTypes &#x3D; FileType.values();</span><br><span class="line">      for(FileType type : fileTypes)&#123;</span><br><span class="line">          if(fileHead.startsWith(type.getValue()))&#123;</span><br><span class="line">              return type;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web攻击 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis延时队列</title>
      <link href="2020/08/24/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/12%E3%80%81redis%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/"/>
      <url>2020/08/24/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/12%E3%80%81redis%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<ul><li>超时订单自动取消</li><li>用户未点击确认收货，超时订单自动完成</li></ul><p>定时任务扫表处理的缺点：</p><ul><li>数据量大的情况下延时较高，若在规定时间处理不完，影响业务</li><li>维护多个定时任务，重复扫描业务表</li></ul><h5 id="JDK的DelayQueue延时队列"><a href="#JDK的DelayQueue延时队列" class="headerlink" title="JDK的DelayQueue延时队列"></a>JDK的DelayQueue延时队列</h5><h5 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h5><p>实现原理</p><p>利用 Redis 的 sorted set 结构，使用 timeStamp 作为 score，比如你的任务是要延迟5分钟，那么就在当前时间上加5分钟作为 score ，客户端做轮询处理，且轮询任务每秒只轮询 score 大于当前时间的 key即可</p><p>优点：简单易用</p><p>缺点</p><ul><li>单个 zset 支持不了太大的数据量，百万级的延迟任务需求，则处理不过来</li><li>定时器轮询方案可能会有异常终止的情况需要自己处理，同时消息处理失败的回滚方案，您也要自己处理。</li></ul><h5 id="RabbitMQ-延时队列（常用的落地方式）"><a href="#RabbitMQ-延时队列（常用的落地方式）" class="headerlink" title="RabbitMQ 延时队列（常用的落地方式）"></a>RabbitMQ 延时队列（常用的落地方式）</h5><p>利用RabbitMQ 有两个特性，一个是 Time-To-Live Extensions，另一个是 Dead Letter Exchanges。</p><p>TTL：消息的存活时间，单位为微秒。</p><p>DLX：死信交换机。绑定在死信交换机上的即死信队列。RabbitMQ的Queue（队列）可以配置两个参数x-dead-letter-exchange和x-dead-letter-routing-key（可选），一旦队列内出现了Dead Letter（死信），则按照这两个参数可以将消息重新路由到另一个Exchange（交换机），让消息重新被消费</p><p>我们将订单消息A0001发送到延迟队列order.delay.queue，并设置x-message-tt消息存活时间为30分钟，当到达30分钟后订单消息A0001成为了Dead Letter（死信），延迟队列检测到有死信，通过配置x-dead-letter-exchange，将死信重新转发到能正常消费的关单队列，直接监听关单队列处理关单逻辑即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void send(String delayTimes) &#123;</span><br><span class="line">    amqpTemplate.convertAndSend(&quot;order.pay.exchange&quot;, &quot;order.pay.queue&quot;,&quot;大家好我是延迟数据&quot;, message -&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 设置延迟毫秒值</span><br><span class="line">        message.getMessageProperties().setExpiration(String.valueOf(delayTimes));</span><br><span class="line">        return message;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Bean(name &#x3D; &quot;order.delay.queue&quot;)</span><br><span class="line">public Queue getMessageQueue() &#123;</span><br><span class="line">    return QueueBuilder</span><br><span class="line">            .durable(RabbitConstant.DEAD_LETTER_QUEUE)</span><br><span class="line">            &#x2F;&#x2F; 配置到期后转发的交换</span><br><span class="line">            .withArgument(&quot;x-dead-letter-exchange&quot;, &quot;order.close.exchange&quot;)</span><br><span class="line">            &#x2F;&#x2F; 配置到期后转发的路由键</span><br><span class="line">            .withArgument(&quot;x-dead-letter-routing-key&quot;, &quot;order.close.queue&quot;)</span><br><span class="line">            .build();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>优点：</p><p>如果面临大数据量需求可以很容易的横向扩展，同时消息支持持久化，有问题可回滚。</p><p>缺点：</p><p>配置麻烦，额外增加一个死信交换机和一个死信队列的配置；</p><p>RabbitMQ的定位是消息中间件，TTL 和 DLX 特性去实现一个功能。若需要替换其他MQ，则不满足</p><p>需要考虑不同延迟的消息要放到不同的队列：消息队列具有先进先出的特点，如果第一个进入队列的消息 A 的延迟是10分钟，第二个进入队列的消息B 的延迟是5分钟，期望的是谁先到 TTL谁先出，但是事实是B已经到期了，而还要等到 A 的延迟10分钟结束A先出之后，B 才能出</p><p>当用户发送一个消息请求给服务器后台的时候，服务器会检测这条消息是否需要进行延时处理，如果需要就放入到延时队列中，由延时任务检测器进行检测和处理，对于不需要进行延时处理的任务，服务器会立马对消息进行处理，并把处理后的结果返会给用户。</p><h5 id="Netty-HashedWheelTimer"><a href="#Netty-HashedWheelTimer" class="headerlink" title="Netty#HashedWheelTimer"></a>Netty#HashedWheelTimer</h5><p>HashedWheelTimer 是 Netty 中 的一个基础工具类，主要用来高效处理大量定时任务，且任务对时间精度要求相对不高， 在Netty 中的应用场景就是连接超时或者任务处理超时，一般都是操作比较快速的任务，缺点是内存占用相对较高</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis延时队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="2020/08/15/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/1%E3%80%81HTTP/"/>
      <url>2020/08/15/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/1%E3%80%81HTTP/</url>
      
        <content type="html"><![CDATA[<p>连接超时参数 ConnectTimeout，让用户配置建连阶段的最长等待时间。</p><h4 id="ConnectTimeout"><a href="#ConnectTimeout" class="headerlink" title="ConnectTimeout"></a>ConnectTimeout</h4><p>让用户配置建连阶段的最长等待时间</p><p>一般来说，TCP 三次握手建立连接需要的时间非常短，通常在毫秒级最多到秒级，如果几秒连接不上，那么可能永远也连接不上。因此，设置特别长的连接超时意义不大，将其配置得短一些（比如 1~5 秒）即可。如果是纯内网调用的话，这个参数可以设置得更短，在下游服务离线无法连接的时候，可以快速失败。</p><h4 id="ReadTimeout"><a href="#ReadTimeout" class="headerlink" title="ReadTimeout"></a>ReadTimeout</h4><p>是建立连接后从服务器读取到可用资源所用的时间。</p><p>HTTP 请求通过 URL 传递参数时，不能超过 2048 字节。</p><p>HTTP 请求通过 body 传递内容时，nginx 默认限制是 1MB，tomcat 默认限制为 2MB，当确实有业务需要传较大内容时，可以通过调<br>大服务器端的限制</p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="2020/08/13/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7%E3%80%81%E5%A0%86/%E5%A0%86/"/>
      <url>2020/08/13/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7%E3%80%81%E5%A0%86/%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<ul><li>堆是一个完全二叉树；==完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。==</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</li></ul><p>完全二叉树：如果二叉树的深度为k，则除第k层外其余所有层节点的度都为2，且叶子节点从左到右依次存在。也即是，将满二叉树的最后一层从左到右依次删除若干节点就得到完全二叉树。满二叉树是一棵特殊的完全二叉树，但完全二叉树不一定是满二叉树。<br><img src="https://static001.geekbang.org/resource/image/18/60/18413c6597c2850b75367393b401ad60.jpg" alt="image"></p><p>堆是具有以下性质的完全二叉树：==每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。==<br><img src="https://static001.geekbang.org/resource/image/4c/99/4c452a1ad3b2d152daa2727d06097099.jpg" alt="image"></p><p>第 1 个和第 2 个是大顶堆，第 3 个是小顶堆，第 4 个不是堆</p><h3 id="堆的实现："><a href="#堆的实现：" class="headerlink" title="堆的实现："></a>堆的实现：</h3><p>完全二叉树比较适合用数组来存储，节省空间<br><img src="https://static001.geekbang.org/resource/image/4d/1e/4d349f57947df6590a2dd1364c3b0b1e.jpg" alt="image"></p><p>数组中下标为 i 的节点的左子节点，就是下标为 i∗2 的节点，右子节点就是下标为 i∗2+1 的节点，父节点就是下标为 i/2 的节点。</p>]]></content>
      
      
      <categories>
          
          <category> 堆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis单进程单线程为什么还这么快</title>
      <link href="2020/08/10/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/14%E3%80%81Redis%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%BF%99%E4%B9%88%E5%BF%AB/"/>
      <url>2020/08/10/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/14%E3%80%81Redis%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%BF%99%E4%B9%88%E5%BF%AB/</url>
      
        <content type="html"><![CDATA[<p>Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</p><h2 id="1、redis单线程为什么这么快？"><a href="#1、redis单线程为什么这么快？" class="headerlink" title="1、redis单线程为什么这么快？"></a>1、redis单线程为什么这么快？</h2><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。（如何测试redis的速度？10w+/s）数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p><p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p><p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；因为Redis是基于内存的操作，CPU不是Redis的瓶颈，==Redis的瓶颈最有可能是机器内存的大小或者网络带宽==</p><p>4、使用多路I/O复用模型，非阻塞IO；</p><p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p><h2 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h2><p>1、单进程多线程模型：MySQL、Memcached、Oracle（Windows版本）；</p><p>2、多进程模型：Oracle（Linux版本）；</p><p>3、Nginx有两类进程，一类称为Master进程(相当于管理进程)，另一类称为Worker进程（实际工作进程）。启动方式有两种：</p><p>（1）单进程启动：此时系统中仅有一个进程，该进程既充当Master进程的角色，也充当Worker进程的角色。</p><p>（2）多进程启动：此时系统有且仅有一个Master进程，至少有一个Worker进程工作。</p><p>（3）Master进程主要进行一些全局性的初始化工作和管理Worker的工作；事件处理是在Worker中进行的。</p><h2 id="2、redis阻塞和性能监控"><a href="#2、redis阻塞和性能监控" class="headerlink" title="2、redis阻塞和性能监控"></a>2、redis阻塞和性能监控</h2><p>Redis的事件循环在一个线程中处理，作为一个单线程程序，重要的是要保证事件处理的时延短，这样，事件循环中的后续任务才不会阻塞；<br>当redis的数据量达到一定级别后（比如20G），阻塞操作对性能的影响尤为严重； </p><ul><li><p>keys、sort等命令<br>keys命令用于查找所有符合给定模式 pattern 的 key，时间复杂度为O(N)， N 为数据库中 key 的数量。当数据库中的个数达到千万时，这个命令会造成读写线程阻塞数秒；<br>类似的命令有sunion sort等操作； </p></li><li><p>smembers命令</p></li></ul><p>smembers命令用于获取集合全集，时间复杂度为O(N),N为集合中的数量；<br>如果一个集合中保存了千万量级的数据，一次取回也会造成事件处理线程的长时间阻塞；</p><ul><li>save命令</li></ul><p>save命令使用事件处理线程进行数据的持久化；当数据量大的时候，会造成线程长时间阻塞（我们的生产上，reids内存中1个G保存需要12s左右），整个redis被block；<br>save阻塞了事件处理的线程，我们甚至无法使用redis-cli查看当前的系统状态，造成“何时保存结束，目前保存了多少”这样的信息都无从得知；</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis单进程单线程为什么还这么快 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayBlockingQueue</title>
      <link href="2020/08/08/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/8%E3%80%81ArrayBlockingQueue/"/>
      <url>2020/08/08/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/8%E3%80%81ArrayBlockingQueue/</url>
      
        <content type="html"><![CDATA[<p>ArrayBlockingQueue的底层数据结构是数组,对数组的访问添加了锁的机制，使其能够支持多线程并发。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性　　"></a>属性　　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span><br><span class="line">        implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">    &#x2F;&#x2F; 版本序列号</span><br><span class="line">    private static final long serialVersionUID &#x3D; -817911632652898426L;</span><br><span class="line">    &#x2F;&#x2F; 存放实际元素的数组</span><br><span class="line">    final Object[] items;</span><br><span class="line">    &#x2F;&#x2F; 取元素索引</span><br><span class="line">    int takeIndex;</span><br><span class="line">    &#x2F;&#x2F; 获取元素索引</span><br><span class="line">    int putIndex;</span><br><span class="line">    &#x2F;&#x2F; 队列中的项</span><br><span class="line">    int count;</span><br><span class="line">    &#x2F;&#x2F; 可重入锁</span><br><span class="line">    final ReentrantLock lock;</span><br><span class="line">    &#x2F;&#x2F; 等待获取条件</span><br><span class="line">    private final Condition notEmpty;</span><br><span class="line">    &#x2F;&#x2F; 等待存放条件</span><br><span class="line">    private final Condition notFull;</span><br><span class="line">    &#x2F;&#x2F; 迭代器</span><br><span class="line">    transient Itrs itrs &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　说明：从类的属性中可以清楚的看到其底层的结构是Object类型的数组，取元素和存元素有不同的索引，有一个可重入锁ReentrantLock，两个条件Condition　</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="　构造函数"></a>　构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建一个带有给定的（固定）容量和默认访问策略的 ArrayBlockingQueue。    </span><br><span class="line"> public ArrayBlockingQueue(int capacity) &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用两个参数的构造函数</span><br><span class="line">        this(capacity, false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue。</span><br><span class="line">    public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始容量必须大于0</span><br><span class="line">        if (capacity &lt;&#x3D; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        &#x2F;&#x2F; 初始化数组</span><br><span class="line">        this.items &#x3D; new Object[capacity];</span><br><span class="line">        &#x2F;&#x2F; 初始化可重入锁</span><br><span class="line">        lock &#x3D; new ReentrantLock(fair);</span><br><span class="line">        &#x2F;&#x2F; 初始化等待条件</span><br><span class="line">        notEmpty &#x3D; lock.newCondition();</span><br><span class="line">        notFull &#x3D;  lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue，它最初包含给定 collection 的元素，并以 collection 迭代器的遍历顺序添加元素。</span><br><span class="line">    public ArrayBlockingQueue(int capacity, boolean fair,</span><br><span class="line">                              Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用两个参数的构造函数</span><br><span class="line">        this(capacity, fair);</span><br><span class="line">        &#x2F;&#x2F; 可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 上锁</span><br><span class="line">        lock.lock(); &#x2F;&#x2F; Lock only for visibility, not mutual exclusion</span><br><span class="line">        try &#123;</span><br><span class="line">            int i &#x3D; 0;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (E e : c) &#123; &#x2F;&#x2F; 遍历集合</span><br><span class="line">                    &#x2F;&#x2F; 检查元素是否为空</span><br><span class="line">                    checkNotNull(e);</span><br><span class="line">                    &#x2F;&#x2F; 存入ArrayBlockingQueue中</span><br><span class="line">                    items[i++] &#x3D; e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ArrayIndexOutOfBoundsException ex) &#123; &#x2F;&#x2F; 当初始化容量小于传入集合的大小时，会抛出异常</span><br><span class="line">                throw new IllegalArgumentException();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 元素数量</span><br><span class="line">            count &#x3D; i;</span><br><span class="line">            &#x2F;&#x2F; 初始化存元素的索引</span><br><span class="line">            putIndex &#x3D; (i &#x3D;&#x3D; capacity) ? 0 : i;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="put函数"><a href="#put函数" class="headerlink" title="put函数　　"></a>put函数　　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        &#x2F;&#x2F; 获取可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 如果当前线程未被中断，则获取锁</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count &#x3D;&#x3D; items.length) &#x2F;&#x2F; 判断元素是否已满</span><br><span class="line">                &#x2F;&#x2F; 若满，则等待</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#x2F;&#x2F; 入队列</span><br><span class="line">            enqueue(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　说明：put函数用于存放元素，在当前线程被中断时会抛出异常，并且当队列已经满时，会阻塞一直等待。其中，put会调用enqueue函数，enqueue函数源码如下　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">        &#x2F;&#x2F; assert lock.getHoldCount() &#x3D;&#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F; assert items[putIndex] &#x3D;&#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 获取数组</span><br><span class="line">        final Object[] items &#x3D; this.items;</span><br><span class="line">        &#x2F;&#x2F; 将元素放入</span><br><span class="line">        items[putIndex] &#x3D; x;</span><br><span class="line">        if (++putIndex &#x3D;&#x3D; items.length) &#x2F;&#x2F; 放入后存元素的索引等于数组长度（表示已满）</span><br><span class="line">            &#x2F;&#x2F; 重置存索引为0</span><br><span class="line">            putIndex &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 元素数量加1</span><br><span class="line">        count++;</span><br><span class="line">        &#x2F;&#x2F; 唤醒在notEmpty条件上等待的线程</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：enqueue函数用于将元素存入底层Object数组中，并且会唤醒等待notEmpty条件的线程。</p><h3 id="offer函数"><a href="#offer函数" class="headerlink" title="offer函数　　"></a>offer函数　　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">        &#x2F;&#x2F; 检查元素不能为空</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        &#x2F;&#x2F; 可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (count &#x3D;&#x3D; items.length) &#x2F;&#x2F; 元素个数等于数组长度，则返回</span><br><span class="line">                return false; </span><br><span class="line">            else &#123; &#x2F;&#x2F; 添加进数组</span><br><span class="line">                enqueue(e);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放数组</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：offer函数也用于存放元素，在调用ArrayBlockingQueue的add方法时，会间接的调用到offer函数，offer函数添加元素不会抛出异常，当底层Object数组已满时，则返回false，否则，会调用enqueue函数，将元素存入底层Object数组。并唤醒等待notEmpty条件的线程。</p><h3 id="take函数"><a href="#take函数" class="headerlink" title="take函数　"></a>take函数　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F; 可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 如果当前线程未被中断，则获取锁，中断会抛出异常</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count &#x3D;&#x3D; 0) &#x2F;&#x2F; 元素数量为0，即Object数组为空</span><br><span class="line">                &#x2F;&#x2F; 则等待notEmpty条件</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#x2F;&#x2F; 出队列</span><br><span class="line">            return dequeue();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：take函数用于从ArrayBlockingQueue中获取一个元素，其与put函数相对应，在当前线程被中断时会抛出异常，并且==当队列为空时，会阻塞一直等待==。其中，take会调用dequeue函数，dequeue函数源码如下　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private E dequeue() &#123;</span><br><span class="line">        &#x2F;&#x2F; assert lock.getHoldCount() &#x3D;&#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F; assert items[takeIndex] !&#x3D; null;</span><br><span class="line">        final Object[] items &#x3D; this.items;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        &#x2F;&#x2F; 取元素</span><br><span class="line">        E x &#x3D; (E) items[takeIndex];</span><br><span class="line">        &#x2F;&#x2F; 该索引的值赋值为null</span><br><span class="line">        items[takeIndex] &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 取值索引等于数组长度</span><br><span class="line">        if (++takeIndex &#x3D;&#x3D; items.length)</span><br><span class="line">            &#x2F;&#x2F; 重新赋值取值索引</span><br><span class="line">            takeIndex &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 元素个数减1</span><br><span class="line">        count--;</span><br><span class="line">        if (itrs !&#x3D; null) </span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">        &#x2F;&#x2F; 唤醒在notFull条件上等待的线程</span><br><span class="line">        notFull.signal();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：dequeue函数用于将取元素，并且会唤醒等待notFull条件的线程。</p><h3 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数　　"></a>poll函数　　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">        &#x2F;&#x2F; 重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 若元素个数为0则返回null，否则，调用dequeue，出队列</span><br><span class="line">            return (count &#x3D;&#x3D; 0) ? null : dequeue();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　说明：poll函数用于获取元素，其与offer函数相对应，不会抛出异常，当元素个数为0是，返回null，否则，调用dequeue函数，并唤醒等待notFull条件的线程。并返回。</p><h3 id="clear函数"><a href="#clear函数" class="headerlink" title="　 clear函数　　"></a>　 clear函数　　</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">        &#x2F;&#x2F; 数组</span><br><span class="line">        final Object[] items &#x3D; this.items;</span><br><span class="line">        &#x2F;&#x2F; 可重入锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        &#x2F;&#x2F; 获取锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 保存元素个数</span><br><span class="line">            int k &#x3D; count;</span><br><span class="line">            if (k &gt; 0) &#123; &#x2F;&#x2F; 元素个数大于0</span><br><span class="line">                &#x2F;&#x2F; 存数元素索引</span><br><span class="line">                final int putIndex &#x3D; this.putIndex;</span><br><span class="line">                &#x2F;&#x2F; 取元素索引</span><br><span class="line">                int i &#x3D; takeIndex;</span><br><span class="line">                do &#123;</span><br><span class="line">                    &#x2F;&#x2F; 赋值为null</span><br><span class="line">                    items[i] &#x3D; null;</span><br><span class="line">                    if (++i &#x3D;&#x3D; items.length) &#x2F;&#x2F; 重新赋值i</span><br><span class="line">                        i &#x3D; 0;</span><br><span class="line">                &#125; while (i !&#x3D; putIndex);</span><br><span class="line">                &#x2F;&#x2F; 重新赋值取元素索引</span><br><span class="line">                takeIndex &#x3D; putIndex;</span><br><span class="line">                &#x2F;&#x2F; 元素个数为0</span><br><span class="line">                count &#x3D; 0;</span><br><span class="line">                if (itrs !&#x3D; null)</span><br><span class="line">                    itrs.queueIsEmpty();</span><br><span class="line">                for (; k &gt; 0 &amp;&amp; lock.hasWaiters(notFull); k--) &#x2F;&#x2F; 若有等待notFull条件的线程，则逐一唤醒</span><br><span class="line">                    notFull.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure><p>clear函数用于清空ArrayBlockingQueue，并且会释放所有等待notFull条件的线程（存放元素的线程）。</p><p>ArrayBlockingQueue是通过ReentrantLock和Condition条件来保证多线程的正确访问的</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayBlockingQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BlockingQueue</title>
      <link href="2020/08/08/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/7%E3%80%81BlockingQueue/"/>
      <url>2020/08/08/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/7%E3%80%81BlockingQueue/</url>
      
        <content type="html"><![CDATA[<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><ul><li>在队列为空时，获取元素的线程会等待队列变为非空</li><li>当队列满时，存储元素的线程会等待队列可用</li></ul><p>应用：阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>阻塞队列提供了四种处理方法:<br>方法\处理方式 | 抛出异常| 返回特殊值| 一直阻塞| 超时退出<br>—|—|—|—|—<br>插入方法 | add(e)| offer(e)| put(e)| offer(e,time,unit)<br>移除方法 | remove()|poll()|take()|     poll(time,unit)<br>检查方法| element()| peek()| | </p><p>插入方法    add(e)    offer(e)    put(e)    offer(e,time,unit)<br>移除方法    remove()    poll()    take()    poll(time,unit)<br>检查方法    element()    peek()    不可用    不可用</p><ul><li>抛出异常：是指当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</li><li>返回特殊值：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元素，如果没有则返回null</li><li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻塞消费者线程，直到队列可用。</li><li>超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。</li></ul><p>JDK7提供了7个阻塞队列。分别是</p><ul><li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</li><li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。默认情况下元素采取自然顺序排列，也可以通过比较器comparator来指定元素的排序规则。元素按照升序排列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul><p>阻塞队列简单实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class BlockingQueue &#123;</span><br><span class="line"></span><br><span class="line">    private List queue &#x3D; new LinkedList();</span><br><span class="line">    </span><br><span class="line">    private int  limit &#x3D; 10;</span><br><span class="line">    </span><br><span class="line">    public BlockingQueue(int limit)&#123;</span><br><span class="line">    </span><br><span class="line">    this.limit &#x3D; limit;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public synchronized void enqueue(Object item)</span><br><span class="line">    </span><br><span class="line">    throws InterruptedException  &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;当队列满时，存储元素的线程会等待队列可用</span><br><span class="line">    </span><br><span class="line">    while(this.queue.size() &#x3D;&#x3D; this.limit) &#123;</span><br><span class="line">    </span><br><span class="line">    wait();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(this.queue.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    </span><br><span class="line">    notifyAll();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    this.queue.add(item);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public synchronized Object dequeue()</span><br><span class="line">    </span><br><span class="line">    throws InterruptedException&#123;</span><br><span class="line">    &#x2F;&#x2F;在队列为空时，获取元素的线程会等待队列变为非空</span><br><span class="line">    </span><br><span class="line">    while(this.queue.size() &#x3D;&#x3D; 0)&#123;</span><br><span class="line">    </span><br><span class="line">    wait();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(this.queue.size() &#x3D;&#x3D; this.limit)&#123;</span><br><span class="line">    </span><br><span class="line">    notifyAll();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return this.queue.remove(0);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BlockingQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized优化</title>
      <link href="2020/08/02/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/6%E3%80%81synchronized%E4%BC%98%E5%8C%96/"/>
      <url>2020/08/02/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/6%E3%80%81synchronized%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h4 id="Synchronized的实现："><a href="#Synchronized的实现：" class="headerlink" title="Synchronized的实现："></a>Synchronized的实现：</h4><ul><li>Synchronized同步代码块基于monitorenter进入和monitorexit退出（JVM保证其成对出现） Monitor监视器对象实现</li><li>Synchronized同步方法基于ACC_SYNCHRONIZED 标志来隐式实现的</li><li></li></ul><p>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。==任何对象都有 一个monitor与之关联==，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter 指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象在内存中的布局分为三块区域：对象头、实例变量和填充数据</p><p><img src="https://images2017.cnblogs.com/blog/918656/201708/918656-20170824180707777-1312147323.png" alt="image"></p><ul><li><p>实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</p></li><li><p>填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点了解即可。</p></li><li><p>对象头：Hotspot虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、KlassPointer（类型指针）虚拟机通过这个指针来确定这个对象是哪个类的实例</p></li></ul><p>（1）Mark Word它是实现轻量级锁和偏向锁的关键。用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>jdk1.6以后对synchronized的锁进行了优化：==无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁==(单向)</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让其获得锁的代价更低而引入了偏向锁。</p><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。</p><p>如果测试成功，表示线程已经获得了锁。</p><p>如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成01（表示当前是偏向锁）。</p><p>如果没有设置，则使用轻量级锁使用CAS竞争。</p><p>如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p><p><img src="http://s4.sinaimg.cn/mw690/003wfAbNzy6MSO08bIvf3&690" alt="image"></p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>通过CAS竞争锁，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p><p><img src="http://s1.sinaimg.cn/mw690/003wfAbNzy6MSOsRjkAa0&690" alt="image"></p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。<br><img src="https://img2018.cnblogs.com/blog/1323383/201903/1323383-20190306134123353-740044884.png" alt="image"></p><h2 id="jvm其他对锁的其他优化方式："><a href="#jvm其他对锁的其他优化方式：" class="headerlink" title="jvm其他对锁的其他优化方式："></a>jvm其他对锁的其他优化方式：</h2><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void synchronized()&#123;</span><br><span class="line">    &#x2F;&#x2F;业务处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程获取锁，并执行过程中，切换到线程B，线程不能获取锁，便放弃CPU执行时间。挂起线程和恢复线程的操作比较耗费性能。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行。让线程执行一个忙循环（自旋），不放弃CPU执行时间，等待一下线程A释放锁。这项技术就是所谓的自旋锁。</p><p>JDK6之前使用-XX：+UseSpinning参数来开启。jdk6之后默认开启。自旋次数的默认值是10次，用户可以使用参数-XX：PreBlockSpin来更改。超过自旋次数，线程便挂起。</p><p>如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源。</p><p>在JDK 1.6中引入了自适应的自旋锁。==由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定自旋次数==。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。 另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。 </p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>==虚拟机对检测到不可能存在共享数据竞争的锁进行消除==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String concatString（String s1，String s2，String s3）&#123;</span><br><span class="line">    return s1+s2+s3；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK5之后编辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String concatString（String s1，String s2，String s3）&#123;</span><br><span class="line">    StringBuffer sb&#x3D;new StringBuffer（）；</span><br><span class="line">    sb.append（s1）；</span><br><span class="line">    sb.append（s2）；</span><br><span class="line">    sb.append（s3）；</span><br><span class="line">    return sb.toString（）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个StringBuffer.append（）方法中都有一个同步块，锁就是sb对象。 虚拟机观察变量sb，很快就会发现它的动态作用域被限制在concatString（）方法内部。 也就是说，sb的所有引用永远不会“逃逸”到concatString（）方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>==将连续的加锁操作， 精简到只加一次锁==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String concatString（String s1，String s2，String s3）&#123;</span><br><span class="line">    StringBuffer sb&#x3D;new StringBuffer（）；</span><br><span class="line">    sb.append（s1）；</span><br><span class="line">    sb.append（s2）；</span><br><span class="line">    sb.append（s3）；</span><br><span class="line">    return sb.toString（）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，示例代码就是扩展到第一个append（）操作之前直至最后一个append（）操作之后，这样只需要加锁一次就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> synchronized优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程的优点与缺点</title>
      <link href="2020/08/02/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9/"/>
      <url>2020/08/02/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>减少上下文切换的方案：</p><ul><li>无锁并发编程：多线程竞争时，会引起上下文切换（因为只有一个线程能进入临界区，获取锁失败的线程会被阻塞在临界区之外，线程此时挂起），所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的 ID 按照 Hash 取模分段，不同的线程处理不同段的数据。</li><li>CAS 算法：Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁。（这种方式思想同无锁并发编程一样，只不过这是一种具体的且常见的实现手段）</li><li>使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。（使用少量线程不止可以减少上下文切换，同时也减少了系统的开销）</li><li>使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li></ul><ul><li>缓存导致的可见性问题</li><li>线程切换带来的原子性问题，</li><li>指令重排带来的有序性问题。</li></ul><h2 id="多线程优点："><a href="#多线程优点：" class="headerlink" title="多线程优点："></a>多线程优点：</h2><h4 id="1-资源利用率更好，发挥多处理器的能力"><a href="#1-资源利用率更好，发挥多处理器的能力" class="headerlink" title="1.  资源利用率更好，发挥多处理器的能力"></a>1.  资源利用率更好，发挥多处理器的能力</h4><p>从磁盘读取一个文件需要5秒，处理一个文件需要2秒。处理两个文件则需要：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5秒读取文件A</span><br><span class="line">2秒处理文件A</span><br><span class="line">5秒读取文件B</span><br><span class="line">2秒处理文件B</span><br><span class="line">---------------------</span><br><span class="line">6总共需要14秒</span><br></pre></td></tr></table></figure><p>大部分的CPU时间用于等待磁盘去读取数据。在这段时间里，CPU非常的空闲。它可以做一些别的事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5秒读取文件A</span><br><span class="line">5秒读取文件B + 2秒处理文件A</span><br><span class="line">2秒处理文件B</span><br><span class="line">---------------------</span><br><span class="line">总共需要12秒</span><br></pre></td></tr></table></figure><p>总结：CPU能够在等待磁盘/网络IO的时候做一些其他的事情。</p><h4 id="2、公平性"><a href="#2、公平性" class="headerlink" title="2、公平性"></a>2、公平性</h4><p>通过粗粒度的时间分片，使用户和程序都能共享计算机资源，而不是等一个进程执行完了，在执行下一个进程。</p><h4 id="3-程序设计在某些情况下更简单"><a href="#3-程序设计在某些情况下更简单" class="headerlink" title="3.  程序设计在某些情况下更简单"></a>3.  程序设计在某些情况下更简单</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多线程处理一个程序比多进程处理同一个程序设计更容易实现</span><br></pre></td></tr></table></figure><h4 id="3-程序响应更快"><a href="#3-程序响应更快" class="headerlink" title="3. 程序响应更快"></a>3. 程序响应更快</h4><h2 id="多线程缺点："><a href="#多线程缺点：" class="headerlink" title="多线程缺点："></a>多线程缺点：</h2><h4 id="1-并发线程安全问题"><a href="#1-并发线程安全问题" class="headerlink" title="1. 并发线程安全问题"></a>1. 并发线程安全问题</h4><h4 id="2、活跃性问题"><a href="#2、活跃性问题" class="headerlink" title="2、活跃性问题"></a>2、活跃性问题</h4><p>在单线程中活跃性问题表现之一就是无限循环，使得循环后面的代码无法得到执行。多线程活跃性时常见形式是死锁，线程A在等待线程B释放锁，而线程B永远不释放</p><h4 id="3-性能问题"><a href="#3-性能问题" class="headerlink" title="3.性能问题"></a>3.性能问题</h4><ul><li>如上下文切换的开销等性能问题，当CPU从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。上下文切换并不廉价。</li></ul><p>lmbench3可检测上下文切换的时间</p><ul><li>增加资源消耗：线程在运行的时候需要从计算机里面得到一些资源。除了CPU，线程还需要一些内存来维持它本地的堆栈。它也需要占用操作系统中一些资源来管理线程。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程的优点与缺点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty的介绍</title>
      <link href="2020/07/23/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/9%E3%80%81Netty%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/07/23/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/9%E3%80%81Netty%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h5 id="传统NIO编程的缺点："><a href="#传统NIO编程的缺点：" class="headerlink" title="传统NIO编程的缺点："></a>传统NIO编程的缺点：</h5><ul><li>NIO 的类库和 API 繁杂，使用麻烦：需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。</li><li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。</li><li>JDK NIO 的 Bug：例如臭名昭著的 Epoll Bug<br>空轮询：<br>在NIO中通过Selector的轮询当前是否有IO事件，根据JDK NIO api描述，Selector的select方法会一直阻塞，直到IO事件达到或超时，但是在Linux平台上这里有时会出现问题，在某些场景下select方法会直接返回，即使没有超时并且也没有IO事件到达，它会导致线程陷入死循环，会让CPU飙到100%，极大地影响系统的可靠性，到目前为止，JDK都没有完全解决这个问题。</li></ul><h5 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h5><p>Netty 是由 JBOSS 提供的一个Java开源框架，是一个==异步的、基于事件驱动的网络应用框架==，用以快速开发高性能、高可靠性的网络 IO 程序。（netty在github上的star数2w+，排名前25的）</p><ul><li>支持常用应用层协议</li><li>解决传输问题：粘包、半包问题</li><li>支持流量整形。流量控制，黑白名单等功能</li><li>完善的断连、ldle等异常</li><li>API功能更强大</li><li>屏蔽JDK的实现细节。如使用NIO切换到AIO需要修改很多代码，使用netty可以做到轻易切换</li><li>解决NIO的已知bug 如：</li></ul><p>空轮询BUG：</p><p>Netty的处理空轮询的方式：检测问题的存在，然后处理</p><p>记录select空转的次数，定义一个阀值，这个阀值默认是512，可以在应用层通过设置系统属性io.netty.selectorAutoRebuildThreshold传入，当空转的次数超过了这个阀值，重新构建新Selector，将老Selector上注册的Channel转移到新建的Selector上，关闭老Selector，用新的Selector代替老Selector，详细实现可以查看NioEventLoop中的selector和rebuildSelector方法：</p><p>Option not found异常：</p><p>IP_TOS参数使用时抛出Option not found异常：<br>。解决方式：规避这个问题。从根本上就不支持设置该参数</p><h5 id="同类型框架："><a href="#同类型框架：" class="headerlink" title="同类型框架："></a>同类型框架：</h5><ul><li>Apache Mina 同一作者开发。本人回答：nima是作者与另一人协同开发。netty是nima的增强版，使用比mima更简单。netty的自由性更高因为nima是属于apache下管理。</li><li>Sun Grizzly 用的很少、文档较少</li><li>Apple Swift NIO 、ACE .非java语言</li><li>Cindy 淘汰产品</li><li>tomcat jetty 底层通信框架并未独立出来，都只是为了更好的服务于Servlet容器。不具有通用型。</li></ul><h5 id="netty应用场景"><a href="#netty应用场景" class="headerlink" title="netty应用场景"></a>netty应用场景</h5><ul><li>数据库：阿里云的NoSql:cassandra</li><li>大数据：Hadoop、Spark</li><li>MQ: RocketMQ</li><li>检索：elasticsearch</li><li>RPC框架：gRPC、Dubbo、Spring5（springboot2为webflux选择的默认部署就是netty，而不再是tomcat和jetty）、zookeeper、分布式计算框架 Storm</li><li>Netty 基本是 Java 语言处理网络 IO 的首选框架，性能和稳定性都有保障，社区比较活跃，基于 Netty 进行二次定制服务成本小。</li></ul><h5 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class NettyServer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1. 创建一个线程组：接收客户端连接</span><br><span class="line">        EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">        &#x2F;&#x2F;2. 创建一个线程组：处理网络操作</span><br><span class="line">        EventLoopGroup workerGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">        &#x2F;&#x2F;3. 创建服务器端启动助手来配置参数【辅助启动类，降低服务端的开发复杂度】</span><br><span class="line">        ServerBootstrap b &#x3D; new ServerBootstrap();</span><br><span class="line">        b.group(bossGroup, workerGroup) &#x2F;&#x2F;4.设置两个线程组</span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * FileChannel:用于文件的数据读写</span><br><span class="line">                 * DatagramChannel:用于 UDP 的数据读写</span><br><span class="line">                 * ServerSocketChannel 和 SocketChannel:用于 TCP 的数据读写</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                .channel(NioServerSocketChannel.class) &#x2F;&#x2F;5.使用NioServerSocketChannel作为服务器端通道的实现</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, 128) &#x2F;&#x2F;6.设置线程队列中等待连接的个数</span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, true) &#x2F;&#x2F;7.保持活动连接状态</span><br><span class="line">                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;  &#x2F;&#x2F;8. 创建一个通道初始化对象</span><br><span class="line">                    public void initChannel(SocketChannel sc) &#123;   &#x2F;&#x2F;9. 往Pipeline链中添加自定义的handler类</span><br><span class="line">                        sc.pipeline().addLast(new NettyServerHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(&quot;......Server is ready......&quot;);</span><br><span class="line">        ChannelFuture cf &#x3D; b.bind(6668).sync();  &#x2F;&#x2F;10. 绑定端口 bind方法是异步的  sync方法是同步阻塞的</span><br><span class="line">        System.out.println(&quot;......Server is starting......&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;11. 关闭通道，关闭线程组</span><br><span class="line">        cf.channel().closeFuture().sync(); &#x2F;&#x2F;异步</span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;服务器端的业务处理类</span><br><span class="line">public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;读取数据事件</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">        System.out.println(&quot;Server:&quot; + ctx);</span><br><span class="line">        ByteBuf buf &#x3D; (ByteBuf) msg;</span><br><span class="line">        System.out.println(&quot;客户端发来的消息：&quot; + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;数据读取完毕事件</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello client(&gt;^ω^&lt;)喵&quot;, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;异常发生事件</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable t) &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class NettyClient &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1. 创建一个线程组</span><br><span class="line">        EventLoopGroup group &#x3D; new NioEventLoopGroup();</span><br><span class="line">        &#x2F;&#x2F;2. 创建客户端的启动助手，完成相关配置</span><br><span class="line">        Bootstrap b &#x3D; new Bootstrap();</span><br><span class="line">        b.group(group)  &#x2F;&#x2F;3. 设置线程组</span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * FileChannel:用于文件的数据读写</span><br><span class="line">                 * DatagramChannel:用于 UDP 的数据读写</span><br><span class="line">                 * ServerSocketChannel 和 SocketChannel:用于 TCP 的数据读写</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                .channel(NioSocketChannel.class)  &#x2F;&#x2F;4. 设置客户端通道的实现类</span><br><span class="line">                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;  &#x2F;&#x2F;5. 创建一个通道初始化对象</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                        socketChannel.pipeline().addLast(new NettyClientHandler()); &#x2F;&#x2F;6.往Pipeline链中添加自定义的handler</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(&quot;......Client is  ready......&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;7.启动客户端去连接服务器端  connect方法是异步的   sync方法是同步阻塞的</span><br><span class="line">        ChannelFuture cf &#x3D; b.connect(&quot;127.0.0.1&quot;, 6668).sync();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;8.关闭连接(异步非阻塞)</span><br><span class="line">        cf.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;客户端业务处理类</span><br><span class="line">public class NettyClientHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通道就绪事件</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        System.out.println(&quot;Client:&quot; + ctx);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, server ^(*￣(oo)￣)^&quot;, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;读取数据事件</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">        ByteBuf buf &#x3D; (ByteBuf) msg;</span><br><span class="line">        System.out.println(&quot;服务器端发来的消息：&quot; + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生命周期管理，所引入的 Bootstrapping 机制。我们通常要做的创建 Channel、绑定端口、注册 Handler 等，都可以通过这个统一的入口，以 Fluent API 等形式完成，相对简化了 API 使用。与之相对应， Bootstrap则是 Client 端的通常入口。</li><li>Channel，作为一个基于 NIO 的扩展框架，Channel 和 Selector 等概念仍然是 Netty 的基础组件，但是针对应用开发具体需求，提供了相对易用的抽象。</li><li>EventLoop，这是 Netty 处理事件的核心机制。例子中使用了 EventLoopGroup。我们在 NIO 中通常要做的几件事情，如注册感兴趣的事件、调度相应的 Handler 等，都是 EventLoop 负责。</li><li>ChannelFuture，这是 Netty 实现异步 IO 的基础之一，保证了同一个 Channel 操作的调用顺序。Netty 扩展了 Java 标准的 Future，提供了针对自己场景的特有Future定义。</li><li>ChannelHandler，这是应用开发者放置业务逻辑的主要地方，也是我上面提到的“Separation Of Concerns”原则的体现。</li><li>ChannelPipeline，它是 ChannelHandler 链条的容器，每个 Channel 在创建后，自动被分配一个 ChannelPipeline。在上面的示例中，我们通过 ServerBootstrap 注册了 ChannelInitializer，并且实现了 initChannel 方法，而在该方法中则承担了向 ChannelPipleline 安装其他 Handler 的任务。</li></ul>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty的介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reactor模式</title>
      <link href="2020/07/22/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/8%E3%80%81Reactor%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/22/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/8%E3%80%81Reactor%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Reactor模式也叫反应器模式，大多数IO相关组件如Netty、Redis在使用的IO模式。</p><h5 id="传统同步阻塞IO模式"><a href="#传统同步阻塞IO模式" class="headerlink" title="传统同步阻塞IO模式"></a>传统同步阻塞IO模式</h5><p>传统同步阻塞IO，读写阻塞，线程等待时间过长<br>且每个连接开一个线程处理优化版本：使用线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主线程维护连接</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Socket socket &#x3D; serverSocket.accept();</span><br><span class="line">                &#x2F;&#x2F;方式一：每个连接开一个线程处理</span><br><span class="line">                &#x2F;&#x2F;方式二：提交线程池处理</span><br><span class="line">                executorService.submit(new Handler(socket));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 处理读写服务</span><br><span class="line">    class Handler implements Runnable &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;获取Socket的输入流，接收数据</span><br><span class="line">                BufferedReader buf &#x3D; new BufferedReader(newInputStreamReader(socket.getInputStream()));</span><br><span class="line">                String readData &#x3D; buf.readLine();</span><br><span class="line">                while (readData !&#x3D; null) &#123;</span><br><span class="line">                    readData &#x3D; buf.readLine();</span><br><span class="line">                    System.out.println(readData);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="Reactor的影子"><a href="#Reactor的影子" class="headerlink" title="Reactor的影子"></a>Reactor的影子</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public NIOServer(int port) throws Exception &#123;</span><br><span class="line">        selector &#x3D; Selector.open();</span><br><span class="line">        serverSocket &#x3D; ServerSocketChannel.open();</span><br><span class="line">        serverSocket.socket().bind(new InetSocketAddress(port));</span><br><span class="line">        serverSocket.configureBlocking(false);</span><br><span class="line">        serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (!Thread.interrupted()) &#123;</span><br><span class="line">            &#x2F;&#x2F;阻塞等待事件</span><br><span class="line">            selector.select();</span><br><span class="line">            &#x2F;&#x2F; 事件列表</span><br><span class="line">            Set selected &#x3D; selector.selectedKeys();</span><br><span class="line">            Iterator it &#x3D; selected.iterator();</span><br><span class="line">            while (it.hasNext()) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                &#x2F;&#x2F;分发事件,统一处理</span><br><span class="line">                dispatch((SelectionKey) (it.next()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dispatch(SelectionKey key) throws Exception &#123;</span><br><span class="line">        if (key.isAcceptable()) &#123;</span><br><span class="line">            register(key);&#x2F;&#x2F;新链接建立，注册</span><br><span class="line">        &#125; else if (key.isReadable()) &#123;</span><br><span class="line">            read(key);&#x2F;&#x2F;读事件处理</span><br><span class="line">        &#125; else if (key.isWritable()) &#123;</span><br><span class="line">            wirete(key);&#x2F;&#x2F;写事件处理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述的NIO例子已经拥有reactor的影子<br>1、基于事件驱动-&gt; selector（支持对多个socketChannel的监听）</p><p>2、统一的事件分派中心-&gt; dispatch</p><p>首先Reactor 是一种设计模式。I/O 复用结合线程池，就是 Reactor 模式基本设计思想</p><p>Reactor模式，是基于Java NIO的，在他的基础上，抽象出来三个组件：</p><ul><li>Reactor：负责响应事件，将事件分发给绑定了该事件的Handler处理；</li><li>Handler：事件处理器，绑定了某类事件，负责执行对应事件的Task对事件进行处理；</li><li>Acceptor：Handler的一种，绑定了ACCEPT事件，当客户端发起connect请求时，Reactor会将accept事件分发给Acceptor处理。</li></ul><h5 id="单Reactor单线程；"><a href="#单Reactor单线程；" class="headerlink" title="单Reactor单线程；"></a>单Reactor单线程；</h5><ul><li>Reactor 对象通过select 监控客户端请求事件, 收到事件后，通过dispatch进行分发</li><li>如果建立连接事件, 则由Acceptor 通过accept 处理连接请求, 然后创建一个Handler对象处理完成连接后的各种事件</li><li>如果是IO读写就绪事件，则由reactor分发调用连接对应的handler 来处理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 负责处理IO事件到来，分发事件处理</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Reactor implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private Reactor() throws Exception &#123;</span><br><span class="line">        SelectionKey sk &#x3D; serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#x2F;&#x2F; attach Acceptor 处理新连接</span><br><span class="line">        sk.attach(new Acceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (!Thread.interrupted()) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set selected &#x3D; selector.selectedKeys();</span><br><span class="line">            Iterator it &#x3D; selected.iterator();</span><br><span class="line">            while (it.hasNext()) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                &#x2F;&#x2F;分发事件处理</span><br><span class="line">                dispatch((SelectionKey) (it.next()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dispatch(SelectionKey k) &#123;</span><br><span class="line">        &#x2F;&#x2F; 若是连接事件获取是acceptor</span><br><span class="line">        &#x2F;&#x2F; 若是IO读写事件获取是handler</span><br><span class="line">        Runnable runnable &#x3D; (Runnable) (k.attachment());</span><br><span class="line">        if (runnable !&#x3D; null) &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 连接事件就绪,处理连接事件</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Acceptor implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            SocketChannel c &#x3D; serverSocket.accept();</span><br><span class="line">            if (c !&#x3D; null) &#123;&#x2F;&#x2F; Handler构造器中注册读写</span><br><span class="line">                new Handler(c, selector);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 处理读写业务逻辑</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Handler implements Runnable &#123;</span><br><span class="line">    final SelectionKey sk;</span><br><span class="line"></span><br><span class="line">    public Handler(SocketChannel socket, Selector selector) throws Exception &#123;</span><br><span class="line">        sk &#x3D; socket.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        sk.attach(this);</span><br><span class="line">        socket.configureBlocking(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (sk.isReadable()) &#123;</span><br><span class="line">            read(sk);&#x2F;&#x2F;读事件处理</span><br><span class="line">        &#125; else if (sk.isWritable()) &#123;</span><br><span class="line">            wirete(sk);&#x2F;&#x2F;写事件处理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于单线程模型，acceptor处理和handler处理都在一个线程中处理；这个的缺点显而易见，当某个handler阻塞时，会导致其他所有的client的handler都得不到执行，并且更严重的是，handler的阻塞会导致整个服务不能接收新的client请求，因为acceptor也被阻塞了。</p><h5 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程"></a>单 Reactor 多线程</h5><p>与单Reactor单线程模型的区别在于：</p><ul><li>handler 只负责响应事件，不做具体的业务处理, 通过read 读取数据后，会分发给后面的worker线程池的某个线程处理业务</li><li>worker 线程池会分配独立线程完成真正的业务，并将结果返回给handler</li><li>handler收到响应后，通过send 将结果返回给client</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;多线程处理业务逻辑</span><br><span class="line">ExecutorService executorService &#x3D; Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    if (sk.isReadable()) &#123;</span><br><span class="line">        &#x2F;&#x2F;任务异步处理读事件处理，通过send 将读写结果返回给client</span><br><span class="line">        executorService.submit(() -&gt; read(sk));</span><br><span class="line">    &#125; else if (sk.isWritable()) &#123;</span><br><span class="line">        &#x2F;&#x2F;任务异步处理读事件处理，通过send 将读写结果返回给client</span><br><span class="line">        executorService.submit(() -&gt; write(sk));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="主从-Reactor-多线程-："><a href="#主从-Reactor-多线程-：" class="headerlink" title="主从 Reactor 多线程 ："></a>主从 Reactor 多线程 ：</h5><p>单Reactor 多线程的缺点是：<br>如果服务器需要同时处理大量的客户端连接请求或在进行客户单连接时，进行一些权限的检查，那么单线程的Acceptor很有可能处理不过来，造成大量的客户端不能连接到服务器。<br>所以主从Reactor多线程模型中，服务器端接收客户端的连接请求不在是一个线程，而是由一个独立的线程池组成的。主从Reactor的方式，将连接和数据处理完全分开维护，将大大提高并发量</p><hr><ul><li>Reactor主线程 MainReactor 对象通过select 监听连接事件, 收到事件后，通过Acceptor 处理连接事件</li><li>当 Acceptor  处理连接事件后，MainReactor 将连接分配给SubReactor </li><li>subreactor 将连接加入到连接队列进行监听,并创建handler进行各种事件处理</li><li>当有新事件发生时， subreactor 就会调用对应的handler处理</li><li>handler 通过read 读取数据，分发给后面的worker 线程处理</li><li>worker 线程池分配独立的worker 线程进行业务处理，并返回结果</li><li>handler 收到响应的结果后，再通过send 将结果返回给client</li><li>Reactor 主线程可以对应多个Reactor 子线程, 即MainRecator 可以关联多个SubReactor</li></ul><p>Netty 主要基于主从 Reactors 多线程模型（如图）做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor</p><p>Netty的线程模型是Reactor模型的变种，那就是去掉线程池的第三种形式的变种，这也是Netty NIO的默认模式。</p><p>Netty 中使用 Reactor 模式</p><p>Reactor 单线程模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup eventGroup &#x3D; new NioEventLoopGroup(1);</span><br><span class="line">ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();</span><br><span class="line">serverBootstrap.group(eventGroup);</span><br></pre></td></tr></table></figure><p>非主从 Reactor 多线程模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup eventGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();</span><br><span class="line">serverBootstrap.group(eventGroup);</span><br></pre></td></tr></table></figure><p>主从 Reactor 多线程模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup &#x3D; new NioEventLoopGroup(); </span><br><span class="line">ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();</span><br><span class="line">serverBootstrap.group(bossGroup, workerGroup);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reactor模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO模型-NIO</title>
      <link href="2020/07/22/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/2%E3%80%81IO%E6%A8%A1%E5%9E%8B-NIO/"/>
      <url>2020/07/22/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/2%E3%80%81IO%E6%A8%A1%E5%9E%8B-NIO/</url>
      
        <content type="html"><![CDATA[<p>Java 1.4 中引入了 NIO。NIO 以块的方式处理数据,块 I/O 的效率比流 I/O 高很多</p><p> NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据先总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道 。</p><p>BIO同步阻塞：<br>阻塞节点1：等待客户端的连接<br>阻塞节点2：客户端连接请求进来后，需要创建独立的线程处理，且当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上</p><p>相比于BIO</p><p>第个阶段大量的连接统统都可以过来直接注册到Selector复用器上面，同时只要单个或者少量的线程来循环处理这些连接事件就可以了，一旦达到“就绪”的条件，就可以立即执行真正的I/O操作。</p><p> Selector 、 Channel 和 Buffer 的关系图：</p><ul><li>一个Selector实例对应一个线程，</li><li>一个Selector可以注册多个channel 实例，每个channel都有唯一一个与之对应的Buffer实例</li><li>Selector 会根据不同的事件，在各个channel上切换【事件决定】</li><li>Buffer 就是一个内存块 ， 底层是有一个数组。数据读和写都必须通过Buffer【连接点其实是Channle，而读写的容器是Buffer。】</li><li>channel中数据的读取写入是双向的【flip 方法切换】, 可以返回底层操作系统的情况, 比如Linux ， 底层的操作系统通道就是双向的</li></ul><p>总结：<br>NIO的三个主要特点：面向缓冲、同步非阻塞和多路复用。</p><p>再谈Unix的I/O多路复用模型：</p><p>I/O多路复用，I/O就是指的我们网络I/O,多路指多个TCP连接(或多个Channel)，复用指复用一个或少量线程。串起来理解就是很多个网络I/O复用一个或少量的线程来处理这些连接。（select，poll，epoll都是IO多路复用的机制）</p><p>epoll是Linux目前大规模网络并发程序开发的首选模型。在绝大多数情况下性能远超select和poll。目前流行的高性能web服务器Nginx正式依赖于epoll提供的高效网络套接字轮询服务。但是，在并发连接不高的情况下，多线程+阻塞I/O方式可能性能更好。</p><p>redis<br>1.单线程 避免了锁 线程之间的互相竞争<br>2、内存的读取I/O多路复用</p><p>nginx 采用的是多进程（单线程） + io多路复用(epoll)模型 实现高并发</p><h5 id="NIO-一定优于-BIO-么"><a href="#NIO-一定优于-BIO-么" class="headerlink" title="NIO 一定优于 BIO 么"></a>NIO 一定优于 BIO 么</h5><ul><li>相比NIO,BIO的代码简单</li><li>特定场景：连接数少，并发度低，BIO 性能不输 NIO。只是为了考虑后期拓展，才习惯选用NIO</li></ul><h5 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;网络服务器端程序</span><br><span class="line">public class NIOServer &#123;</span><br><span class="line">    public static void main(String[] args) throws  Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;1. 得到一个ServerSocketChannel对象</span><br><span class="line">        ServerSocketChannel serverSocketChannel&#x3D;ServerSocketChannel.open();</span><br><span class="line">        &#x2F;&#x2F;2. 得到一个Selector对象</span><br><span class="line">        Selector selector&#x3D;Selector.open();</span><br><span class="line">        &#x2F;&#x2F;3. 绑定一个端口号, 在服务器的6666监听</span><br><span class="line">        &#x2F;&#x2F;serverSocketChannel.bind(new InetSocketAddress(6666));</span><br><span class="line">        serverSocketChannel.socket().bind(new InetSocketAddress(6666));</span><br><span class="line">        &#x2F;&#x2F;4. 设置非阻塞方式</span><br><span class="line">        serverSocketChannel.configureBlocking(false);</span><br><span class="line">        &#x2F;&#x2F;5. 把ServerSocketChannel对象注册给Selector对象</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#x2F;&#x2F;6. 干活</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            &#x2F;&#x2F;6.1 监控客户端</span><br><span class="line">            &#x2F;&#x2F;如果使用 selector.select() 就会阻塞在这里的</span><br><span class="line">            if(selector.select(1000)&#x3D;&#x3D;0)&#123;  &#x2F;&#x2F;nio非阻塞式的优势</span><br><span class="line">                System.out.println(&quot;Server:等待了1秒，无客户端连接&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;6.2 得到SelectionKey,判断通道里的事件</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator&#x3D;selector.selectedKeys().iterator();</span><br><span class="line">            while(keyIterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key&#x3D;keyIterator.next();</span><br><span class="line">                if(key.isAcceptable())&#123;  &#x2F;&#x2F;客户端连接请求事件</span><br><span class="line"></span><br><span class="line">                    SocketChannel socketChannel&#x3D;serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(false);</span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(1024));</span><br><span class="line">                &#125;</span><br><span class="line">                if(key.isReadable())&#123;  &#x2F;&#x2F;读取客户端数据事件</span><br><span class="line">                    SocketChannel channel&#x3D;(SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer buffer&#x3D;(ByteBuffer) key.attachment();</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(&quot;接收到客户端数据：&quot;+new String(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 6.3 手动从集合中移除当前key,防止重复处理</span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;网络客户端程序</span><br><span class="line">public class NIOClient &#123;</span><br><span class="line">    public static void main(String[] args) throws  Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;1. 得到一个网络通道</span><br><span class="line">        SocketChannel channel&#x3D;SocketChannel.open();</span><br><span class="line">        &#x2F;&#x2F;2. 设置非阻塞方式</span><br><span class="line">        channel.configureBlocking(false);</span><br><span class="line">        &#x2F;&#x2F;3. 提供服务器端的IP地址和端口号</span><br><span class="line">        InetSocketAddress address&#x3D;new InetSocketAddress(&quot;127.0.0.1&quot;,6666);</span><br><span class="line">        &#x2F;&#x2F;4. 连接服务器端</span><br><span class="line">        if(!channel.connect(address))&#123;</span><br><span class="line">            while(!channel.finishConnect())&#123;  &#x2F;&#x2F;nio非阻塞式</span><br><span class="line">                System.out.println(&quot;客户端: 因为连接需要时间，客户端不会阻塞，可以做个计算工作...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;连接成功了..</span><br><span class="line">        &#x2F;&#x2F;5. 得到一个缓冲区并存入数据</span><br><span class="line">        String msg&#x3D;&quot;hello,尚硅谷&quot;;</span><br><span class="line">        ByteBuffer writeBuf &#x3D; ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">        &#x2F;&#x2F;6. 发送数据</span><br><span class="line">        channel.write(writeBuf);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO模型-NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git全局配置</title>
      <link href="2020/07/19/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/2%E3%80%81%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/git/git%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/"/>
      <url>2020/07/19/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/2%E3%80%81%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/git/git%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p> 在使用git之前我们可以配置一下git的用户名称和用户邮箱,这听起来好像挺鸡肋的,不过有时候也是有必要的,配置了git的用户名称和邮箱后,我们提交版本都会带上我们自己的信息哦.</p><h4 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config [--local | --global | --system] user.name &#39;Your name&#39;</span><br><span class="line">git config [--local | --global | --system] user.email &#39;Your email&#39;</span><br></pre></td></tr></table></figure><ul><li>local：区域为本仓库</li><li>global: 当前用户的所有仓库</li><li>system: 本系统的所有用户</li></ul><h4 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h4><p>这个指令添加local参数时候需要进入某个仓库里面才能使用，不然会提示错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list [--local | --global | --system]</span><br></pre></td></tr></table></figure><h4 id="清除配置"><a href="#清除配置" class="headerlink" title="清除配置"></a>清除配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --unset [--local | --global | --system] user.name &#39;Your name&#39;</span><br></pre></td></tr></table></figure><p>HTTPS协议 和 ssh 协议 进行代码的推送/拉取。两种协议的差别仅在于同一个仓库使用不同协议时的地址不同，以及对应的授权实现不同。</p><p>https 协议 克隆 对初学者来说会比较方便 ，复制 https url 然后到 git Bash 里面直接用 clone 命令克隆到本地就好了，但是 每次fetch和push代码都需要输入账号和密码 ，这也是 https 协议 的麻烦之处。</p><p>而使用 SSH 协议 克隆需要在克隆之前先配置和添加好 SSH key，因此， 如果用户想要使用 SSH url 克隆的话，必须是这个仓库的拥有者 。</p><p>1、客户端生成ssh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot;</span><br><span class="line">#SHA256:4fVSSBu8wbB39xRT9&#x2F;PdBjaK+K7mXNC3XBXmAaz1ecQ x@qq.com</span><br></pre></td></tr></table></figure><p>2、客户端查看生成的key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>3、在服务端仓库管理中配置客户端的公钥</p><p>4、客户端验证key的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gitee.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git全局配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty工作原理</title>
      <link href="2020/07/16/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/10%E3%80%81netty%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>2020/07/16/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/10%E3%80%81netty%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ul><li>Netty抽象出两组线程池 BossGroup 专门负责接收客户端的连接, WorkerGroup 专门负责网络的读写</li><li>BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup</li><li>NioEventLoopGroup 相当于一个事件循环组, 这个组中含有多个事件循环 ，每一个事件循环是 NioEventLoop</li><li>NioEventLoop 表示一个不断循环的执行处理任务的线程， 每个NioEventLoop 都有一个selector , 用于监听绑定在其上的socket的网络通讯</li><li>NioEventLoopGroup 可以有多个线程, 即可以含有多个NioEventLoop</li><li>每个Boss NioEventLoop 循环执行的步骤有3步</li><li>轮询accept 事件</li><li>处理accept 事件 , 与client建立连接 , 生成NioScocketChannel , 并将其注册到某个worker NIOEventLoop 上的 selector </li><li>处理任务队列的任务 ， 即 runAllTasks</li><li><ol start="7"><li>每个 Worker NIOEventLoop 循环执行的步骤</li></ol></li><li>轮询read, write 事件</li><li>处理i/o事件， 即read , write 事件，在对应NioScocketChannel 处理</li><li>处理任务队列的任务 ， 即 runAllTasks</li><li><ol start="8"><li>每个Worker NIOEventLoop  处理业务时，会使用pipeline(管道), pipeline 中包含了 channel , 即通过pipeline 可以获取到对应通道, 管道中维护了很多的 处理器</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty工作原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>积分系统设计</title>
      <link href="2020/07/12/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%A7%AF%E5%88%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
      <url>2020/07/12/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%A7%AF%E5%88%86%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<ul><li>1、设计模式要干的事情就是解耦</li><li>2、设计模式是思想，不用强记定义</li><li>3、抛开业务谈设计模式是空谈，设计模式学习最注重应用场景</li></ul><p>设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦</p><p>笼统地来讲，积分系统无外乎就两个大的功能点，一个是赚取积分，另一个是消费积分。</p><p>赚取积分功能包括积分赚取渠道，比如下订单、每日签到、评论等；还包括积分兑换规则，比如订单金额与积分的兑换比例，每日签到赠送多少积分等。</p><p>消费积分功能包括积分消费渠道，比如抵扣订单金额、兑换优惠券、积分换购、参与活动扣积分等；还包括积分兑换规则，比如多少积分可以换算成抵扣订单的多少金额，一张优惠券需要多少积分来兑换等等。</p><p>第一种划分方式是：积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护（增删改查），不划分到积分系统中，而是放到更上层的营销系统中。这样积分系统就会变得非常简单，只需要负责增加积分、减少积分、查询积分、查询积分明细等这几个工作。</p><p>第二种划分方式是：积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护，分散在各个相关业务系统中，比如订单系统、评论系统、签到系统、换购商城、优惠券系统等。还是刚刚那个下订单赚取积分的例子，在这种情况下，用户下订单成功之后，订单系统根据商品对应的积分兑换比例，计算所能兑换的积分数量，然后直接调用积分系统给用户增加积分。</p><p>第三种划分方式是：所有的功能都划分到积分系统中，包括积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护。还是同样的例子，用户下订单成功之后，订单系统直接告知积分系统订单交易成功，积分系统根据订单信息查询积分兑换规则，给用户增加积分。</p><p>我们可以反过来通过看它是否符合高内聚、低耦合特性来判断。如果一个功能的修改或添加，经常要跨团队、跨项目、跨系统才能完成，那说明模块划分的不够合理，职责不够清晰，耦合过于严重。除此之外，为了避免业务知识的耦合，让下层系统更加通用，一般来讲，我们不希望下层系统（也就是被调用的系统）包含太多上层系统（也就是调用系统）的业务信息，但是，可以接受上层系统包含下层系统的业务信息。比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息。但是，反过来，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。所以，综合考虑，我们更倾向于第一种和第二种模块划分方式。但是，不管选择这两种中的哪一种，积分系统所负责的工作是一样的，只包含积分的增、减、查询，以及积分明细的记录和查询。</p><p>为什么要分 MVC 三层开发？</p><p>分层能起到代码复用的作用分层能起到隔离变化的作用分层能起到隔离关注点的作用分层能提高代码的可测试性分层能应对系统的复杂性</p><p>BO、VO、Entity 存在的意义是什么？</p><p>从设计的角度来说，VO、BO、Entity 的设计思路并不违反 DRY 原则，为了分层清晰、减少耦合，多维护几个类的成本也并不是不能接受的。但是，如果你真的有代码洁癖，对于代码重复的问题，我们可以通过继承或者组合来解决</p><p>数据对象之间的转化？也可以使用 Java 中提供了数据对象转化工具，比如 BeanUtils、Dozer 等，可以大大简化繁琐的对象转化工作。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 积分系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3%E3%80%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。比如，你有没有考虑过这样几个问题：</p><ul><li>直接使用构造函数或者配合 set 方法就能创建对象，为什么还需要建造者模式来创建呢？</li><li>建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？</li></ul><p>工厂模式根据不同的参数来决定创建哪种类型的对象<br>建造者模式是用来创建一种类型的复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</p><p>示例：</p><p>我们需要定义一个资源池配置类 ResourcePoolConfig。他有name（必须）,maxTotal、maxIdle、minIdle等属性。</p><p>工厂模式的解决的问题是根据不同的参数，创建不同的池配置如：线程池、连接池、对象池</p><p>创建一个连接池对象，将它相关属性以构造函数的入参，传入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ResourcePoolConfig &#123;</span><br><span class="line">  private static final int DEFAULT_MAX_TOTAL &#x3D; 8;</span><br><span class="line">  private static final int DEFAULT_MAX_IDLE &#x3D; 8;</span><br><span class="line">  private static final int DEFAULT_MIN_IDLE &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  private String name;</span><br><span class="line">  private int maxTotal &#x3D; DEFAULT_MAX_TOTAL;</span><br><span class="line">  private int maxIdle &#x3D; DEFAULT_MAX_IDLE;</span><br><span class="line">  private int minIdle &#x3D; DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">  public ResourcePoolConfig(String name, Integer maxTotal, Integer maxIdle, Integer minIdle) &#123;</span><br><span class="line">    if (StringUtils.isBlank(name)) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;name should not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line"></span><br><span class="line">    if (maxTotal !&#x3D; null) &#123;</span><br><span class="line">      if (maxTotal &lt;&#x3D; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;maxTotal should be positive.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.maxTotal &#x3D; maxTotal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (maxIdle !&#x3D; null) &#123;</span><br><span class="line">      if (maxIdle &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;maxIdle should not be negative.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.maxIdle &#x3D; maxIdle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (minIdle !&#x3D; null) &#123;</span><br><span class="line">      if (minIdle &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;minIdle should not be negative.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.minIdle &#x3D; minIdle;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...省略getter方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：可配置项逐渐增多，变成了 8 个、10 个，甚至更多的时候，构造函数的入参将变得特别臃肿。用set()代替呢。<br>将必填参数以构造函数，非必填的则是暴露set方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ResourcePoolConfig &#123;</span><br><span class="line">  private static final int DEFAULT_MAX_TOTAL &#x3D; 8;</span><br><span class="line">  private static final int DEFAULT_MAX_IDLE &#x3D; 8;</span><br><span class="line">  private static final int DEFAULT_MIN_IDLE &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  private String name;</span><br><span class="line">  private int maxTotal &#x3D; DEFAULT_MAX_TOTAL;</span><br><span class="line">  private int maxIdle &#x3D; DEFAULT_MAX_IDLE;</span><br><span class="line">  private int minIdle &#x3D; DEFAULT_MIN_IDLE;</span><br><span class="line">  </span><br><span class="line">  public ResourcePoolConfig(String name) &#123;</span><br><span class="line">    if (StringUtils.isBlank(name)) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;name should not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setMaxTotal(int maxTotal) &#123;</span><br><span class="line">    if (maxTotal &lt;&#x3D; 0) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;maxTotal should be positive.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.maxTotal &#x3D; maxTotal;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setMaxIdle(int maxIdle) &#123;</span><br><span class="line">    if (maxIdle &lt; 0) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;maxIdle should not be negative.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.maxIdle &#x3D; maxIdle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setMinIdle(int minIdle) &#123;</span><br><span class="line">    if (minIdle &lt; 0) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;minIdle should not be negative.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.minIdle &#x3D; minIdle;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...省略getter方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li><p>1、若必填参数还是很多的时候，构造函数就又会出现参数列表很长的问题，如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。</p></li><li><p>2、假设配置项之间有一定的依赖关系，依赖关系或者约束条件的校验逻辑就无处安放。比如，如果用户设置了 maxTotal、maxIdle、minIdle 其中一个，就必须显式地设置另外两个</p></li><li><p>3、如果我们希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。</p></li></ul><p>传统的构造函数和set()组合很难解决以上问题。</p><p>建造者模式，是如何解决这些问题的呢。</p><p>我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，<br>然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。<br>我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ResourcePoolConfig &#123;</span><br><span class="line">  private String name;</span><br><span class="line">  private int maxTotal;</span><br><span class="line">  private int maxIdle;</span><br><span class="line">  private int minIdle;</span><br><span class="line"></span><br><span class="line">  private ResourcePoolConfig(Builder builder) &#123;</span><br><span class="line">    this.name &#x3D; builder.name;</span><br><span class="line">    this.maxTotal &#x3D; builder.maxTotal;</span><br><span class="line">    this.maxIdle &#x3D; builder.maxIdle;</span><br><span class="line">    this.minIdle &#x3D; builder.minIdle;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;...省略getter方法...</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;我们将Builder类设计成了ResourcePoolConfig的内部类。</span><br><span class="line">  &#x2F;&#x2F;我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span><br><span class="line">  public static class Builder &#123;</span><br><span class="line">    private static final int DEFAULT_MAX_TOTAL &#x3D; 8;</span><br><span class="line">    private static final int DEFAULT_MAX_IDLE &#x3D; 8;</span><br><span class="line">    private static final int DEFAULT_MIN_IDLE &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int maxTotal &#x3D; DEFAULT_MAX_TOTAL;</span><br><span class="line">    private int maxIdle &#x3D; DEFAULT_MAX_IDLE;</span><br><span class="line">    private int minIdle &#x3D; DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">    public ResourcePoolConfig build() &#123;</span><br><span class="line">      &#x2F;&#x2F; 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span><br><span class="line">      if (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (maxIdle &gt; maxTotal) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return new ResourcePoolConfig(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setName(String name) &#123;</span><br><span class="line">      if (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.name &#x3D; name;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setMaxTotal(int maxTotal) &#123;</span><br><span class="line">      if (maxTotal &lt;&#x3D; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.maxTotal &#x3D; maxTotal;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setMaxIdle(int maxIdle) &#123;</span><br><span class="line">      if (maxIdle &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.maxIdle &#x3D; maxIdle;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setMinIdle(int minIdle) &#123;</span><br><span class="line">      if (minIdle &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.minIdle &#x3D; minIdle;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span><br><span class="line">ResourcePoolConfig config &#x3D; new ResourcePoolConfig.Builder()</span><br><span class="line">        .setName(&quot;dbconnectionpool&quot;)</span><br><span class="line">        .setMaxTotal(16)</span><br><span class="line">        .setMaxIdle(10)</span><br><span class="line">        .setMinIdle(12)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建造者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器模式</title>
      <link href="2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>已经没落的模式</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迭代器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板方法模式</title>
      <link href="2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13%E3%80%81%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/09/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13%E3%80%81%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>模板方法模式确实非常简单，仅仅使用了Java的继承机制，定义一个抽象类，定义抽象的基本方法和具体的模板方法（==模板方法中调用基本方法，实现固定逻辑==）</p><p> 基本方法：基本方法也叫做基本操作，是由子类实现的方法，并且在模板方法被调用</p><p> 模板方法：可以有一个或几个，一般是一个具体方法，也就是一个框架，实现对基本方法的调度， 完成固定的逻辑。==为了防止恶意的操作，一般模板方法都加上final关键字，不允许被覆写。==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public abstract class AbstractClass &#123;</span><br><span class="line">  public final void templateMethod() &#123;</span><br><span class="line">    method1();</span><br><span class="line">    method2();</span><br><span class="line">  &#125;</span><br><span class="line">  protected abstract void method1();</span><br><span class="line">  protected abstract void method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteClass1 extends AbstractClass &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void method1() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void method2() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteClass2 extends AbstractClass &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void method1() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void method2() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractClass demo &#x3D; ConcreteClass1();</span><br><span class="line">demo.templateMethod();</span><br></pre></td></tr></table></figure><p> Java Servlet中模板方法的使用。</p><p> HttpServlet 的 service() 方法就是一个模板方法，它实现了整个 HTTP 请求的执行流程，doGet()、doPost() 是模板中可以由子类来定制的部分。实际上，这就相当于 Servlet 框架提供了一个扩展点（doGet()、doPost() 方法），让框架用户在不用修改 Servlet 框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    this.doPost(req, resp);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    resp.getWriter().write(&quot;Hello World.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.xzg.cd.HelloServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;hello&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>当我们在浏览器中输入网址（比如，<a href="http://127.0.0.1:8080/hello">http://127.0.0.1:8080/hello</a> ）的时候，Servlet 容器会接收到相应的请求，并且根据 URL 和 Servlet 之间的映射关系，找到相应的 Servlet（HelloServlet），然后执行它的 service() 方法。service() 方法定义在父类 HttpServlet 中，它会调用 doGet() 或 doPost() 方法，然后输出数据（“Hello world”）到网页。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void service(ServletRequest req, ServletResponse res)</span><br><span class="line">    throws ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    HttpServletRequest  request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line">    if (!(req instanceof HttpServletRequest &amp;&amp;</span><br><span class="line">            res instanceof HttpServletResponse)) &#123;</span><br><span class="line">        throw new ServletException(&quot;non-HTTP request or response&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    request &#x3D; (HttpServletRequest) req;</span><br><span class="line">    response &#x3D; (HttpServletResponse) res;</span><br><span class="line">    service(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void service(HttpServletRequest req, HttpServletResponse resp)</span><br><span class="line">    throws ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    String method &#x3D; req.getMethod();</span><br><span class="line">    if (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        long lastModified &#x3D; getLastModified(req);</span><br><span class="line">        if (lastModified &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            &#x2F;&#x2F; servlet doesn&#39;t support if-modified-since, no reason</span><br><span class="line">            &#x2F;&#x2F; to go through further expensive logic</span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            long ifModifiedSince &#x3D; req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">            if (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                &#x2F;&#x2F; If the servlet mod time is later, call doGet()</span><br><span class="line">                &#x2F;&#x2F; Round down to the nearest second for a proper compare</span><br><span class="line">                &#x2F;&#x2F; A ifModifiedSince of -1 will always be less</span><br><span class="line">                maybeSetLastModified(resp, lastModified);</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        long lastModified &#x3D; getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">    &#125; else if (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String errMsg &#x3D; lStrings.getString(&quot;http.method_not_implemented&quot;);</span><br><span class="line">        Object[] errArgs &#x3D; new Object[1];</span><br><span class="line">        errArgs[0] &#x3D; method;</span><br><span class="line">        errMsg &#x3D; MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调的原理解析：</p><p>回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”</p><p>同步回调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface ICallback &#123;</span><br><span class="line">  void methodToCallback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BClass &#123;</span><br><span class="line">  public void process(ICallback callback) &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    callback.methodToCallback();</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AClass &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    BClass b &#x3D; new BClass();</span><br><span class="line">    b.process(new ICallback() &#123; &#x2F;&#x2F;回调对象</span><br><span class="line">      @Override</span><br><span class="line">      public void methodToCallback() &#123;</span><br><span class="line">        System.out.println(&quot;Call back me.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调可以细分为同步回调和异步回调。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上。回调基于组合关系来实现，模板模式基于继承关系来实现，回调比模板模式更加灵活。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板方法模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰模式</title>
      <link href="2020/07/08/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7%E3%80%81%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/07/08/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7%E3%80%81%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装饰模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法模式（常用）</title>
      <link href="2020/07/07/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.1%E3%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89/"/>
      <url>2020/07/07/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.1%E3%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>工厂模式分为三种更加细分的类型：</p><ul><li>简单工厂【常用】</li><li>工厂方法（属于工厂方法的一种特例）【常用】</li><li>抽象工厂【不常用】</li></ul><p>备注：</p><p>工厂类都是以“Factory”这个单词结尾<br>工厂类中创建对象的方法一般都是 create </p><p>实例：</p><p>我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……）</p><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>将多个对象的创建逻辑放到一个工厂类中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RuleConfigSource &#123;</span><br><span class="line">  public RuleConfig load(String ruleConfigFilePath) &#123;</span><br><span class="line">    String ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);</span><br><span class="line">    IRuleConfigParser parser &#x3D; null;</span><br><span class="line">    if (&quot;json&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser &#x3D; new JsonRuleConfigParser();</span><br><span class="line">    &#125; else if (&quot;xml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser &#x3D; new XmlRuleConfigParser();</span><br><span class="line">    &#125; else if (&quot;yaml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser &#x3D; new YamlRuleConfigParser();</span><br><span class="line">    &#125; else if (&quot;properties&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser &#x3D; new PropertiesRuleConfigParser();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new InvalidRuleConfigException(</span><br><span class="line">             &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String configText &#x3D; &quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中</span><br><span class="line">    RuleConfig ruleConfig &#x3D; parser.parse(configText);</span><br><span class="line">    return ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getFileExtension(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json</span><br><span class="line">    return &quot;json&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RuleConfigParserFactory &#123;</span><br><span class="line">  private static final Map&lt;String, RuleConfigParser&gt; cachedParsers &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    cachedParsers.put(&quot;json&quot;, new JsonRuleConfigParser());</span><br><span class="line">    cachedParsers.put(&quot;xml&quot;, new XmlRuleConfigParser());</span><br><span class="line">    cachedParsers.put(&quot;yaml&quot;, new YamlRuleConfigParser());</span><br><span class="line">    cachedParsers.put(&quot;properties&quot;, new PropertiesRuleConfigParser());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static IRuleConfigParser createParser(String configFormat) &#123;</span><br><span class="line">    if (configFormat &#x3D;&#x3D; null || configFormat.isEmpty()) &#123;</span><br><span class="line">      return null;&#x2F;&#x2F;返回null还是IllegalArgumentException全凭你自己说了算</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParser parser &#x3D; cachedParsers.get(configFormat.toLowerCase());</span><br><span class="line">    return parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>当每个对象的创建逻辑都比较复杂，要组合其他类对象，做各种初始化操作的时候，为了避免设计一个过于庞大的简单工厂类，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中【简单工厂的工厂】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface IRuleConfigParserFactory &#123;</span><br><span class="line">  IRuleConfigParser createParser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new JsonRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new XmlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new YamlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public IRuleConfigParser createParser() &#123;</span><br><span class="line">    return new PropertiesRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RuleConfigSource &#123;</span><br><span class="line">  public RuleConfig load(String ruleConfigFilePath) &#123;</span><br><span class="line">    String ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);</span><br><span class="line"></span><br><span class="line">    IRuleConfigParserFactory parserFactory &#x3D; RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class="line">    if (parserFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw new InvalidRuleConfigException(&quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParser parser &#x3D; parserFactory.createParser();</span><br><span class="line"></span><br><span class="line">    String configText &#x3D; &quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中</span><br><span class="line">    RuleConfig ruleConfig &#x3D; parser.parse(configText);</span><br><span class="line">    return ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getFileExtension(String filePath) &#123;</span><br><span class="line">    &#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json</span><br><span class="line">    return &quot;json&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;因为工厂类只包含方法，不包含成员变量，完全可以复用，</span><br><span class="line">&#x2F;&#x2F;不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span><br><span class="line">public class RuleConfigParserFactoryMap &#123; &#x2F;&#x2F;工厂的工厂</span><br><span class="line">  private static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    cachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static IRuleConfigParserFactory getParserFactory(String type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParserFactory parserFactory &#x3D; cachedFactories.get(type.toLowerCase());</span><br><span class="line">    return parserFactory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当我们新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工厂方法模式（常用） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器</title>
      <link href="2020/07/05/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>2020/07/05/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>利用布隆过滤器解决缓存穿透</p><p>布隆过滤器的巨大用处就是，能够迅速判断一个元素是否在一个集合中。因此他有如下三个使用场景:</p><ul><li><p>网页爬虫对URL的去重，避免爬取相同的URL地址</p></li><li><p>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）</p></li><li><p>缓存穿透，将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt;     </span><br><span class="line">        &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt;      </span><br><span class="line">        &lt;version&gt;22.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建字符串布隆过滤器，使用编码UTF-8</span><br><span class="line">     &#x2F;&#x2F;创建时需要传入四个参数，但我们只要关心前三个就行</span><br><span class="line">     &#x2F;&#x2F;Funnel，这是Guava中定义的一个接口，它和PrimitiveSink配套使用，主要是把任意类型的数据转化成Java基本数据类型（primitive value，如char，byte，int……），默认用java.nio.ByteBuffer实现，最终均转化为byte数组</span><br><span class="line">     &#x2F;&#x2F;expectedInsertions 期望插入数据数，int或long</span><br><span class="line">     &#x2F;&#x2F;fpp期望误判率，比如1E-7（千万分之一）</span><br><span class="line">     &#x2F;&#x2F;Strategy 策略，默认选取64位哈希映射函数，BloomFilterStrategies.MURMUR128_MITZ_64</span><br><span class="line">     BloomFilter&lt;CharSequence&gt; bloomFilter &#x3D; BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), 200000, 1E-7);</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;置入元素，其实也有boolean类型返回，但是尊重注解，就不返回值了</span><br><span class="line">     bloomFilter.put(&quot;测试测试&quot;);</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;判断元素是否存在，true存在，false不存在。</span><br><span class="line">     boolean isContain&#x3D;bloomFilter.mightContain(&quot;测试测试&quot;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 布隆过滤器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap(JDK7)</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/11%E3%80%81HashMap(JDK7)/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/11%E3%80%81HashMap(JDK7)/</url>
      
        <content type="html"><![CDATA[<p>它允许 null 值和null键，它不是线程同步的，同时也不保证有序</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>　哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，哈希表的主干就是数组</p><ul><li>存储：通过把当前元素的关键字 通过hash函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</li><li>查询：查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</li></ul><h4 id="哈希冲突："><a href="#哈希冲突：" class="headerlink" title="　哈希冲突："></a>　哈希冲突：</h4><p>　</p><ul><li>　1、开放定址法（发生冲突，继续寻找下一块未被占用的存储地址）　</li><li>　2、散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式（==jdk7==）</li></ul><p>==不同hash值的key的Entry&lt;K,V&gt;存在数组table中—-数组存储；<br>每个相同hash值的key的Entry&lt;K,V&gt;用链表存储==</p><p>HashMap的整体结构如下：<br><img src="http://images2015.cnblogs.com/blog/1024555/201611/1024555-20161113235348670-746615111.png" alt="image"></p><p>==影响 HashMap 性能的两个重要参数：==<br>“initial capacity”（初始化容量）：容量就是哈希表桶的个数（主干数组的长度）</p><p>”loadfactor“（负载因子）：负载因子就是键值对个数与哈希表长度的一个比值，当比值超过负载因子之后，HashMap 就会进行 rehash操作来进行扩容。</p><p>负载因子为什么是0.75 ， 不是0.5或者1？</p><p>如果是1，那意味着每次空间使用完毕才扩容，在一定程度上会增加put时候的时间。</p><p>如果是1，那意味着每次空间使用完毕才扩容，在一定程度上会增加put时候的时间。</p><h4 id="源码分析："><a href="#源码分析：" class="headerlink" title="　源码分析："></a>　源码分析：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br></pre></td><td class="code"><pre><span class="line">package java.util;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class HashMap&lt;K,V&gt;</span><br><span class="line">    extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 默认初始容量，默认为2的4次方 &#x3D; 16，2的n次方是为了加快hash计算速度，；；减少hash冲突，，，h &amp; (length-1)，，1111111</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 最大容量，默认为2的30次方，</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 默认负载因子，默认为0.75</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *当数组表还没扩容的时候，一个共享的空表对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final Entry&lt;?,?&gt;[] EMPTY_TABLE &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 数组表，大小可以改变，且大小必须为2的幂</span><br><span class="line">     *&#x2F;</span><br><span class="line">    transient Entry&lt;K,V&gt;[] table &#x3D; (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当前Map中key-value映射的个数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    transient int size;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 下次扩容阈值，当size &gt; capacity * load factor时，开始扩容</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int threshold;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 负载因子</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final float loadFactor;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Hash表结构性修改次数，用于实现迭代器快速失败行为</span><br><span class="line">     *&#x2F;</span><br><span class="line">    transient int modCount;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 容量阈值，默认大小为Integer.MAX_VALUE</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT &#x3D; Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 静态内部类Holder，存放一些只能在虚拟机启动后才能初始化的值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static class Holder &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 容量阈值，初始化hashSeed的时候会用到该值</span><br><span class="line">         *&#x2F;</span><br><span class="line">        static final int ALTERNATIVE_HASHING_THRESHOLD;</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            &#x2F;&#x2F;获取系统变量jdk.map.althashing.threshold</span><br><span class="line">            String altThreshold &#x3D; java.security.AccessController.doPrivileged(</span><br><span class="line">                new sun.security.action.GetPropertyAction(</span><br><span class="line">                    &quot;jdk.map.althashing.threshold&quot;));</span><br><span class="line"></span><br><span class="line">            int threshold;</span><br><span class="line">            try &#123;</span><br><span class="line">                threshold &#x3D; (null !&#x3D; altThreshold)</span><br><span class="line">                        ? Integer.parseInt(altThreshold)</span><br><span class="line">                        : ALTERNATIVE_HASHING_THRESHOLD_DEFAULT;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; jdk.map.althashing.threshold系统变量默认为-1，如果为-1，则将阈值设为Integer.MAX_VALUE</span><br><span class="line">                if (threshold &#x3D;&#x3D; -1) &#123;</span><br><span class="line">                    threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;阈值需要为正数</span><br><span class="line">                if (threshold &lt; 0) &#123;</span><br><span class="line">                    throw new IllegalArgumentException(&quot;value must be positive integer.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch(IllegalArgumentException failed) &#123;</span><br><span class="line">                throw new Error(&quot;Illegal value for &#39;jdk.map.althashing.threshold&#39;&quot;, failed);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ALTERNATIVE_HASHING_THRESHOLD &#x3D; threshold;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 计算hash值的时候需要用到</span><br><span class="line">     *&#x2F;</span><br><span class="line">    transient int hashSeed &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 生成一个空的HashMap,并指定其容量大小和负载因子</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        &#x2F;&#x2F;保证初始容量大于等于0</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#x2F;&#x2F;保证初始容量不大于最大容量MAXIMUM_CAPACITY</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;loadFactor小于0或为无效数字</span><br><span class="line">        if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        &#x2F;&#x2F;负载因子</span><br><span class="line">        this.loadFactor &#x3D; loadFactor;</span><br><span class="line">        &#x2F;&#x2F;下次扩容大小</span><br><span class="line">        threshold &#x3D; initialCapacity;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 生成一个空的HashMap,并指定其容量大小，负载因子使用默认的0.75</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HashMap(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 生成一个空的HashMap,容量大小使用默认值16，负载因子使用默认值0.75</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HashMap() &#123;</span><br><span class="line">        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据指定的map生成一个新的HashMap,负载因子使用默认值，初始容量大小为Math.max((int) (m.size() &#x2F; DEFAULT_LOAD_FACTOR) + 1,DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this(Math.max((int) (m.size() &#x2F; DEFAULT_LOAD_FACTOR) + 1,</span><br><span class="line">                      DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">        putAllForCreate(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回&gt;&#x3D;number的最小2的n次方值，如number&#x3D;5，则返回8</span><br><span class="line">    private static int roundUpToPowerOf2(int number) &#123;</span><br><span class="line">        &#x2F;&#x2F; assert number &gt;&#x3D; 0 : &quot;number must be non-negative&quot;;</span><br><span class="line">        return number &gt;&#x3D; MAXIMUM_CAPACITY</span><br><span class="line">                ? MAXIMUM_CAPACITY</span><br><span class="line">                : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 对table扩容</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void inflateTable(int toSize) &#123;</span><br><span class="line">        &#x2F;&#x2F; Find a power of 2 &gt;&#x3D; toSize</span><br><span class="line">        &#x2F;&#x2F;找一个值（2的n次方，且&gt;&#x3D;toSize）</span><br><span class="line">        int capacity &#x3D; roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;下次扩容阈值</span><br><span class="line">        threshold &#x3D; (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">        </span><br><span class="line">        table &#x3D; new Entry[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; internal utilities</span><br><span class="line"></span><br><span class="line">    void init() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 初始化hashSeed</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final boolean initHashSeedAsNeeded(int capacity) &#123;</span><br><span class="line">        boolean currentAltHashing &#x3D; hashSeed !&#x3D; 0;</span><br><span class="line">        boolean useAltHashing &#x3D; sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (capacity &gt;&#x3D; Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        boolean switching &#x3D; currentAltHashing ^ useAltHashing;</span><br><span class="line">        if (switching) &#123;</span><br><span class="line">            hashSeed &#x3D; useAltHashing</span><br><span class="line">                ? sun.misc.Hashing.randomHashSeed(this)</span><br><span class="line">                : 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return switching;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 生成hash值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int hash(Object k) &#123;</span><br><span class="line">        int h &#x3D; hashSeed;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;如果key是字符串，调用un.misc.Hashing.stringHash32生成hash值</span><br><span class="line">        &#x2F;&#x2F;Oracle表示能生成更好的hash分布，不过这在jdk8中已删除</span><br><span class="line">        if (0 !&#x3D; h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">            return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;一次散列，调用k的hashCode方法，与hashSeed做异或操作</span><br><span class="line">        h ^&#x3D; k.hashCode();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This function ensures that hashCodes that differ only by</span><br><span class="line">        &#x2F;&#x2F; constant multiples at each bit position have a bounded</span><br><span class="line">        &#x2F;&#x2F; number of collisions (approximately 8 at default load factor).</span><br><span class="line">        &#x2F;&#x2F;二次散列，</span><br><span class="line">        h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回hash值的索引，采用除模取余法，h &amp; (length-1)操作 等价于 hash % length操作， 但&amp;操作性能更优</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static int indexFor(int h, int length) &#123;</span><br><span class="line">        &#x2F;&#x2F; assert Integer.bitCount(length) &#x3D;&#x3D; 1 : &quot;length must be a non-zero power of 2&quot;;</span><br><span class="line">        return h &amp; (length-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回key-value映射个数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断map是否为空</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return size &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回指定key对应的value</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        &#x2F;&#x2F;key为null情况</span><br><span class="line">        if (key &#x3D;&#x3D; null)</span><br><span class="line">            return getForNullKey();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;根据key查找节点</span><br><span class="line">        Entry&lt;K,V&gt; entry &#x3D; getEntry(key);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;返回key对应的值</span><br><span class="line">        return null &#x3D;&#x3D; entry ? null : entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找key为null的value，注意如果key为null，则其hash值为0，默认是放在table[0]里的</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private V getForNullKey() &#123;</span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;在table[0]的链表上查找key为null的键值对，因为null默认是存在table[0]的桶里</span><br><span class="line">        for (Entry&lt;K,V&gt; e &#x3D; table[0]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">            if (e.key &#x3D;&#x3D; null)</span><br><span class="line">                return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *判断是否包含指定的key</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean containsKey(Object key) &#123;</span><br><span class="line">        return getEntry(key) !&#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据key查找键值对，找不到返回null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果key为null，hash值为0，否则调用hash方法，对key生成hash值</span><br><span class="line">        int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : hash(key);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;调用indexFor方法生成hash值的索引，遍历该索引下的链表，查找key“相等”的键值对</span><br><span class="line">        for (Entry&lt;K,V&gt; e &#x3D; table[indexFor(hash, table.length)];</span><br><span class="line">             e !&#x3D; null;</span><br><span class="line">             e &#x3D; e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                return e;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 向map存入一个键值对，如果key已存在，则覆盖</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public V put(K key, V value) &#123;</span><br><span class="line">        &#x2F;&#x2F;数组为空，对数组扩容</span><br><span class="line">        if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;对key为null的键值对调用putForNullKey处理</span><br><span class="line">        if (key &#x3D;&#x3D; null)</span><br><span class="line">            return putForNullKey(value);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;生成hash值</span><br><span class="line">        int hash &#x3D; hash(key);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;生成hash值索引</span><br><span class="line">        int i &#x3D; indexFor(hash, table.length);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;查找是否有key“相等”的键值对，有的话覆盖</span><br><span class="line">        for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue &#x3D; e.value;</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;操作次数加一，用于迭代器快速失败行为</span><br><span class="line">        modCount++;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;在指定hash值索引处的链表上增加该键值对</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 存放key为null的键值对，存放在索引为0的链表上，已存在的话，替换</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private V putForNullKey(V value) &#123;</span><br><span class="line">        for (Entry&lt;K,V&gt; e &#x3D; table[0]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">            &#x2F;&#x2F;已存在key为null，则替换</span><br><span class="line">            if (e.key &#x3D;&#x3D; null) &#123;</span><br><span class="line">                V oldValue &#x3D; e.value;</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;操作次数加一，用于迭代器快速失败行为</span><br><span class="line">        modCount++;</span><br><span class="line">        &#x2F;&#x2F;在指定hash值索引处的链表上增加该键值对</span><br><span class="line">        addEntry(0, null, value, 0);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 添加键值对</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void putForCreate(K key, V value) &#123;</span><br><span class="line">        &#x2F;&#x2F;生成hash值</span><br><span class="line">        int hash &#x3D; null &#x3D;&#x3D; key ? 0 : hash(key);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;生成hash值索引，</span><br><span class="line">        int i &#x3D; indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * key“相等”，则替换</span><br><span class="line">         *&#x2F;</span><br><span class="line">        for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;在指定索引处的链表上创建该键值对</span><br><span class="line">        createEntry(hash, key, value, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;将制定map的键值对添加到map中</span><br><span class="line">    private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">            putForCreate(e.getKey(), e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 对数组扩容</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void resize(int newCapacity) &#123;</span><br><span class="line">        Entry[] oldTable &#x3D; table;</span><br><span class="line">        int oldCapacity &#x3D; oldTable.length;</span><br><span class="line">        </span><br><span class="line">        if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;创建一个指定大小的数组</span><br><span class="line">        Entry[] newTable &#x3D; new Entry[newCapacity];</span><br><span class="line">        </span><br><span class="line">        transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;table索引替换成新数组</span><br><span class="line">        table &#x3D; newTable;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;重新计算阈值</span><br><span class="line">        threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 拷贝旧的键值对到新的哈希表中</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">        int newCapacity &#x3D; newTable.length;</span><br><span class="line">        &#x2F;&#x2F;遍历旧的数组</span><br><span class="line">        for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            while(null !&#x3D; e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">                if (rehash) &#123;</span><br><span class="line">                    e.hash &#x3D; null &#x3D;&#x3D; e.key ? 0 : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;根据新的数组长度，重新计算索引，</span><br><span class="line">                int i &#x3D; indexFor(e.hash, newCapacity);</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F;插入到链表表头</span><br><span class="line">                e.next &#x3D; newTable[i];</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F;将e放到索引为i处</span><br><span class="line">                newTable[i] &#x3D; e;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F;将e设置成下个节点</span><br><span class="line">                e &#x3D; next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将制定map的键值对put到本map，key“相等”的直接覆盖</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        int numKeysToBeAdded &#x3D; m.size();</span><br><span class="line">        if (numKeysToBeAdded &#x3D;&#x3D; 0)</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;空map，扩容</span><br><span class="line">        if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable((int) Math.max(numKeysToBeAdded * loadFactor, threshold));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 判断是否需要扩容</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (numKeysToBeAdded &gt; threshold) &#123;</span><br><span class="line">            int targetCapacity &#x3D; (int)(numKeysToBeAdded &#x2F; loadFactor + 1);</span><br><span class="line">            if (targetCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">                targetCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">            int newCapacity &#x3D; table.length;</span><br><span class="line">            while (newCapacity &lt; targetCapacity)</span><br><span class="line">                newCapacity &lt;&lt;&#x3D; 1;</span><br><span class="line">            if (newCapacity &gt; table.length)</span><br><span class="line">                resize(newCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;依次遍历键值对，并put</span><br><span class="line">        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">            put(e.getKey(), e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 移除指定key的键值对</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public V remove(Object key) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e &#x3D; removeEntryForKey(key);</span><br><span class="line">        return (e &#x3D;&#x3D; null ? null : e.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 移除指定key的键值对</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123;</span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;计算hash值及索引</span><br><span class="line">        int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : hash(key);</span><br><span class="line">        int i &#x3D; indexFor(hash, table.length);</span><br><span class="line">        </span><br><span class="line">        Entry&lt;K,V&gt; prev &#x3D; table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e &#x3D; prev;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;头节点为table[i]的单链表上执行删除节点操作</span><br><span class="line">        while (e !&#x3D; null) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">            Object k;</span><br><span class="line">            &#x2F;&#x2F;找到要删除的节点</span><br><span class="line">            if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                if (prev &#x3D;&#x3D; e)</span><br><span class="line">                    table[i] &#x3D; next;</span><br><span class="line">                else</span><br><span class="line">                    prev.next &#x3D; next;</span><br><span class="line">                e.recordRemoval(this);</span><br><span class="line">                return e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev &#x3D; e;</span><br><span class="line">            e &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 删除指定键值对对象(Entry对象)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final Entry&lt;K,V&gt; removeMapping(Object o) &#123;</span><br><span class="line">        if (size &#x3D;&#x3D; 0 || !(o instanceof Map.Entry))</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        Map.Entry&lt;K,V&gt; entry &#x3D; (Map.Entry&lt;K,V&gt;) o;</span><br><span class="line">        Object key &#x3D; entry.getKey();</span><br><span class="line">        int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : hash(key);</span><br><span class="line">        &#x2F;&#x2F;得到数组索引</span><br><span class="line">        int i &#x3D; indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev &#x3D; table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e &#x3D; prev;</span><br><span class="line">        &#x2F;&#x2F;开始遍历该单链表</span><br><span class="line">        while (e !&#x3D; null) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">            &#x2F;&#x2F;找到节点</span><br><span class="line">            if (e.hash &#x3D;&#x3D; hash &amp;&amp; e.equals(entry)) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                if (prev &#x3D;&#x3D; e)</span><br><span class="line">                    table[i] &#x3D; next;</span><br><span class="line">                else</span><br><span class="line">                    prev.next &#x3D; next;</span><br><span class="line">                e.recordRemoval(this);</span><br><span class="line">                return e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev &#x3D; e;</span><br><span class="line">            e &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 清空map，将table数组所有元素设为null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        Arrays.fill(table, null);</span><br><span class="line">        size &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断是否含有指定value的键值对</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean containsValue(Object value) &#123;</span><br><span class="line">        if (value &#x3D;&#x3D; null)</span><br><span class="line">            return containsNullValue();</span><br><span class="line"></span><br><span class="line">        Entry[] tab &#x3D; table;</span><br><span class="line">        &#x2F;&#x2F;遍历table数组</span><br><span class="line">        for (int i &#x3D; 0; i &lt; tab.length ; i++)</span><br><span class="line">            &#x2F;&#x2F;遍历每条单链表</span><br><span class="line">            for (Entry e &#x3D; tab[i] ; e !&#x3D; null ; e &#x3D; e.next)</span><br><span class="line">                if (value.equals(e.value))</span><br><span class="line">                    return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断是否含有value为null的键值对</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private boolean containsNullValue() &#123;</span><br><span class="line">        Entry[] tab &#x3D; table;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; tab.length ; i++)</span><br><span class="line">            for (Entry e &#x3D; tab[i] ; e !&#x3D; null ; e &#x3D; e.next)</span><br><span class="line">                if (e.value &#x3D;&#x3D; null)</span><br><span class="line">                    return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 浅拷贝，键值对不复制</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        HashMap&lt;K,V&gt; result &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            result &#x3D; (HashMap&lt;K,V&gt;)super.clone();</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; assert false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (result.table !&#x3D; EMPTY_TABLE) &#123;</span><br><span class="line">            result.inflateTable(Math.min(</span><br><span class="line">                (int) Math.min(</span><br><span class="line">                    size * Math.min(1 &#x2F; loadFactor, 4.0f),</span><br><span class="line">                    &#x2F;&#x2F; we have limits...</span><br><span class="line">                    HashMap.MAXIMUM_CAPACITY),</span><br><span class="line">               table.length));</span><br><span class="line">        &#125;</span><br><span class="line">        result.entrySet &#x3D; null;</span><br><span class="line">        result.modCount &#x3D; 0;</span><br><span class="line">        result.size &#x3D; 0;</span><br><span class="line">        result.init();</span><br><span class="line">        result.putAllForCreate(this);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;内部类，节点对象，每个节点包含下个节点的引用</span><br><span class="line">    static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        int hash;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 创建节点</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value &#x3D; v;</span><br><span class="line">            next &#x3D; n;</span><br><span class="line">            key &#x3D; k;</span><br><span class="line">            hash &#x3D; h;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;获取节点的key</span><br><span class="line">        public final K getKey() &#123;</span><br><span class="line">            return key;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;获取节点的value</span><br><span class="line">        public final V getValue() &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;设置新value，并返回旧的value</span><br><span class="line">        public final V setValue(V newValue) &#123;</span><br><span class="line">            V oldValue &#x3D; value;</span><br><span class="line">            value &#x3D; newValue;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断key和value是否相同,两个都“相等”，返回true</span><br><span class="line">        public final boolean equals(Object o) &#123;</span><br><span class="line">            if (!(o instanceof Map.Entry))</span><br><span class="line">                return false;</span><br><span class="line">            Map.Entry e &#x3D; (Map.Entry)o;</span><br><span class="line">            Object k1 &#x3D; getKey();</span><br><span class="line">            Object k2 &#x3D; e.getKey();</span><br><span class="line">            if (k1 &#x3D;&#x3D; k2 || (k1 !&#x3D; null &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">                Object v1 &#x3D; getValue();</span><br><span class="line">                Object v2 &#x3D; e.getValue();</span><br><span class="line">                if (v1 &#x3D;&#x3D; v2 || (v1 !&#x3D; null &amp;&amp; v1.equals(v2)))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final int hashCode() &#123;</span><br><span class="line">            return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final String toString() &#123;</span><br><span class="line">            return getKey() + &quot;&#x3D;&quot; + getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * This method is invoked whenever the value in an entry is</span><br><span class="line">         * overwritten by an invocation of put(k,v) for a key k that&#39;s already</span><br><span class="line">         * in the HashMap.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        void recordAccess(HashMap&lt;K,V&gt; m) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * This method is invoked whenever the entry is</span><br><span class="line">         * removed from the table.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        void recordRemoval(HashMap&lt;K,V&gt; m) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 添加新节点，如有必要，执行扩容操作</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;</span><br><span class="line">            resize(2 * table.length);</span><br><span class="line">            hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;</span><br><span class="line">            bucketIndex &#x3D; indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 插入单链表表头</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e &#x3D; table[bucketIndex];</span><br><span class="line">        table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;hashmap迭代器</span><br><span class="line">    private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next;        &#x2F;&#x2F; 下个键值对索引</span><br><span class="line">        int expectedModCount;   &#x2F;&#x2F; 用于判断快速失败行为</span><br><span class="line">        int index;              &#x2F;&#x2F; current slot</span><br><span class="line">        Entry&lt;K,V&gt; current;     &#x2F;&#x2F; current entry</span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            expectedModCount &#x3D; modCount;</span><br><span class="line">            if (size &gt; 0) &#123; &#x2F;&#x2F; advance to first entry</span><br><span class="line">                Entry[] t &#x3D; table;</span><br><span class="line">                while (index &lt; t.length &amp;&amp; (next &#x3D; t[index++]) &#x3D;&#x3D; null)</span><br><span class="line">                    ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final boolean hasNext() &#123;</span><br><span class="line">            return next !&#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final Entry&lt;K,V&gt; nextEntry() &#123;</span><br><span class="line">            if (modCount !&#x3D; expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            Entry&lt;K,V&gt; e &#x3D; next;</span><br><span class="line">            if (e &#x3D;&#x3D; null)</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line"></span><br><span class="line">            if ((next &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Entry[] t &#x3D; table;</span><br><span class="line">                while (index &lt; t.length &amp;&amp; (next &#x3D; t[index++]) &#x3D;&#x3D; null)</span><br><span class="line">                    ;</span><br><span class="line">            &#125;</span><br><span class="line">            current &#x3D; e;</span><br><span class="line">            return e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            if (current &#x3D;&#x3D; null)</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            if (modCount !&#x3D; expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            Object k &#x3D; current.key;</span><br><span class="line">            current &#x3D; null;</span><br><span class="line">            HashMap.this.removeEntryForKey(k);</span><br><span class="line">            expectedModCount &#x3D; modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;ValueIterator迭代器</span><br><span class="line">    private final class ValueIterator extends HashIterator&lt;V&gt; &#123;</span><br><span class="line">        public V next() &#123;</span><br><span class="line">            return nextEntry().value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;KeyIterator迭代器</span><br><span class="line">    private final class KeyIterator extends HashIterator&lt;K&gt; &#123;</span><br><span class="line">        public K next() &#123;</span><br><span class="line">            return nextEntry().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;&#x2F;KeyIterator迭代器</span><br><span class="line">    private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">        public Map.Entry&lt;K,V&gt; next() &#123;</span><br><span class="line">            return nextEntry();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 返回迭代器方法</span><br><span class="line">    Iterator&lt;K&gt; newKeyIterator()   &#123;</span><br><span class="line">        return new KeyIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;V&gt; newValueIterator()   &#123;</span><br><span class="line">        return new ValueIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()   &#123;</span><br><span class="line">        return new EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Views</span><br><span class="line"></span><br><span class="line">    private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回一个set集合，包含key</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Set&lt;K&gt; keySet() &#123;</span><br><span class="line">        Set&lt;K&gt; ks &#x3D; keySet;</span><br><span class="line">        return (ks !&#x3D; null ? ks : (keySet &#x3D; new KeySet()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final class KeySet extends AbstractSet&lt;K&gt; &#123;</span><br><span class="line">        public Iterator&lt;K&gt; iterator() &#123;</span><br><span class="line">            return newKeyIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        public int size() &#123;</span><br><span class="line">            return size;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean contains(Object o) &#123;</span><br><span class="line">            return containsKey(o);</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean remove(Object o) &#123;</span><br><span class="line">            return HashMap.this.removeEntryForKey(o) !&#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        public void clear() &#123;</span><br><span class="line">            HashMap.this.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回一个value集合，包含value</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Collection&lt;V&gt; values() &#123;</span><br><span class="line">        Collection&lt;V&gt; vs &#x3D; values;</span><br><span class="line">        return (vs !&#x3D; null ? vs : (values &#x3D; new Values()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final class Values extends AbstractCollection&lt;V&gt; &#123;</span><br><span class="line">        public Iterator&lt;V&gt; iterator() &#123;</span><br><span class="line">            return newValueIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        public int size() &#123;</span><br><span class="line">            return size;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean contains(Object o) &#123;</span><br><span class="line">            return containsValue(o);</span><br><span class="line">        &#125;</span><br><span class="line">        public void clear() &#123;</span><br><span class="line">            HashMap.this.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回一个键值对集合</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        return entrySet0();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es &#x3D; entrySet;</span><br><span class="line">        return es !&#x3D; null ? es : (entrySet &#x3D; new EntrySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">        public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            return newEntryIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean contains(Object o) &#123;</span><br><span class="line">            if (!(o instanceof Map.Entry))</span><br><span class="line">                return false;</span><br><span class="line">            Map.Entry&lt;K,V&gt; e &#x3D; (Map.Entry&lt;K,V&gt;) o;</span><br><span class="line">            Entry&lt;K,V&gt; candidate &#x3D; getEntry(e.getKey());</span><br><span class="line">            return candidate !&#x3D; null &amp;&amp; candidate.equals(e);</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean remove(Object o) &#123;</span><br><span class="line">            return removeMapping(o) !&#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        public int size() &#123;</span><br><span class="line">            return size;</span><br><span class="line">        &#125;</span><br><span class="line">        public void clear() &#123;</span><br><span class="line">            HashMap.this.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * map序列化,可实现深拷贝</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">        throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Write out the threshold, loadfactor, and any hidden stuff</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Write out number of buckets</span><br><span class="line">        if (table&#x3D;&#x3D;EMPTY_TABLE) &#123;</span><br><span class="line">            s.writeInt(roundUpToPowerOf2(threshold));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           s.writeInt(table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Write out size (number of Mappings)</span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Write out keys and values (alternating)</span><br><span class="line">        if (size &gt; 0) &#123;</span><br><span class="line">            for(Map.Entry&lt;K,V&gt; e : entrySet0()) &#123;</span><br><span class="line">                s.writeObject(e.getKey());</span><br><span class="line">                s.writeObject(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; 362498820763181265L;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 反序列化，读取字节码转为对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">         throws IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Read in the threshold (ignored), loadfactor, and any hidden stuff</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor)) &#123;</span><br><span class="line">            throw new InvalidObjectException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; set other fields that need values</span><br><span class="line">        table &#x3D; (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Read in number of buckets</span><br><span class="line">        s.readInt(); &#x2F;&#x2F; ignored.</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Read number of mappings</span><br><span class="line">        int mappings &#x3D; s.readInt();</span><br><span class="line">        if (mappings &lt; 0)</span><br><span class="line">            throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +</span><br><span class="line">                                               mappings);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; capacity chosen by number of mappings and desired load (if &gt;&#x3D; 0.25)</span><br><span class="line">        int capacity &#x3D; (int) Math.min(</span><br><span class="line">                    mappings * Math.min(1 &#x2F; loadFactor, 4.0f),</span><br><span class="line">                    &#x2F;&#x2F; we have limits...</span><br><span class="line">                    HashMap.MAXIMUM_CAPACITY);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; allocate the bucket array;</span><br><span class="line">        if (mappings &gt; 0) &#123;</span><br><span class="line">            inflateTable(capacity);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            threshold &#x3D; capacity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        init();  &#x2F;&#x2F; Give subclass a chance to do its thing.</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Read the keys and values, and put the mappings in the HashMap</span><br><span class="line">        for (int i &#x3D; 0; i &lt; mappings; i++) &#123;</span><br><span class="line">            K key &#x3D; (K) s.readObject();</span><br><span class="line">            V value &#x3D; (V) s.readObject();</span><br><span class="line">            putForCreate(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; These methods are used when serializing HashSets</span><br><span class="line">    int   capacity()     &#123; return table.length; &#125;</span><br><span class="line">    float loadFactor()   &#123; return loadFactor;   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容操作："><a href="#扩容操作：" class="headerlink" title="扩容操作："></a>扩容操作：</h2><p>==当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。==</p><h4 id="为何HashMap的数组长度一定是2的次幂？"><a href="#为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="为何HashMap的数组长度一定是2的次幂？"></a>为何HashMap的数组长度一定是2的次幂？</h4><ul><li>如果length为2的次幂  则length-1 转化为二进制必定是11111……的形式，在于h的二进制与操作效率会非常的快，<br>而且空间不浪费；</li><li>如果length不是2的次幂，比如length为15，则length-1为14，对应的二进制为1110，在于h与操作，</li><li>最后一位都为0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费</li></ul><h3 id="HashMap在多线程下，put死循环"><a href="#HashMap在多线程下，put死循环" class="headerlink" title="HashMap在多线程下，put死循环"></a>HashMap在多线程下，put死循环</h3><p>resize()扩容的时候，调用<br>transfer()方法，而这种方法实现的机制就是将每一个链表转化到新链表，而且链表中的位置发生反转，而这在多线程情况下是非常easy造成链表回路。从而发生get()死循环。我们看一下他的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable) &#123;</span><br><span class="line">    Entry[] src &#x3D; table;</span><br><span class="line">    int newCapacity &#x3D; newTable.length;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e &#x3D; src[j];</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            src[j] &#x3D; null;</span><br><span class="line">            do &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">                int i &#x3D; indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next &#x3D; newTable[i];</span><br><span class="line">                newTable[i] &#x3D; e;</span><br><span class="line">                e &#x3D; next;</span><br><span class="line">            &#125; while (e !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假如有两个线程P1、P2，以及链表 a–&gt;b–&gt;null</p><ul><li>1、P1先运行，运行完”Entry&lt;K,V&gt; next = e.next;”代码后发生堵塞，或者其它情况不再运行下去，此时e=a。next=b</li><li>2、而P2已经运行完整段代码，于是当前的新链表newTable[i]为b–&gt;a–&gt;null</li><li>3、P1又继续运行”Entry&lt;K,V&gt; next = e.next;”之后的代码，则运行完”e=next;”后，newTable[i]为a&lt;–&gt;b。则造成回路，while(e!=null)一直死循环</li></ul>]]></content>
      
      
      <categories>
          
          <category> java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap(JDK7) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis安装</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/2%E3%80%81redis%E5%AE%89%E8%A3%85/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSql/1%E3%80%81redis/2%E3%80%81redis%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<ul><li><p>(先安装gcc环境：yum install gcc-c++)</p></li><li><p>1、下载redis.tar并上传至服务器</p></li><li><p>2、解压<br>tar -zxvf redis-5.0.5.tar.gz -C /usr/local/redis/</p></li><li><p>3、编译并安装<br>cd /usr/local/redis/redis-5.0.5  </p><p>make PREFIX=/usr/local/redis install  </p></li></ul><p>会在同级目录下生成：redis-benchmark  redis-check-aof  redis-check-rdb  redis-cli  redis-sentinel  redis-server文件夹</p><ul><li>4、指定配置文件启动redis</li></ul><p>　./bin/redis-server ./redis.conf　</p><ul><li>　5、登录<br>　./redis-cli -h 127.0.0.1 -p 6379 -a myPassword</li></ul><p>修改配置文件<br>允许有所ip访问 指定密码 后台运行等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line">#redis.conf</span><br><span class="line"># Redis configuration file example.</span><br><span class="line"># .&#x2F;redis-server &#x2F;path&#x2F;to&#x2F;redis.conf</span><br><span class="line"></span><br><span class="line">################################## INCLUDES ###################################</span><br><span class="line">#这在你有标准配置模板但是每个redis服务器又需要个性设置的时候很有用。</span><br><span class="line"># include &#x2F;path&#x2F;to&#x2F;local.conf</span><br><span class="line"># include &#x2F;path&#x2F;to&#x2F;other.conf</span><br><span class="line"></span><br><span class="line">################################ GENERAL #####################################</span><br><span class="line"></span><br><span class="line">#是否在后台执行，yes：后台运行；no：不是后台运行（老版本默认）</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line">  #3.2里的参数，是否开启保护模式，默认开启。要是配置里没有指定bind和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。要是开启了密码   和bind，可以开启。否   则最好关闭，设置为no。</span><br><span class="line">  protected-mode yes</span><br><span class="line">#redis的进程文件</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis&#x2F;redis-server.pid</span><br><span class="line"></span><br><span class="line">#redis监听的端口号。</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line">#此参数确定了TCP连接中已完成队列(完成三次握手之后)的长度， 当然此值必须不大于Linux系统定义的&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn值，默认是511，而Linux的默认参数值是128。当系统并发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定。该内核参数默认值一般是128，对于负载很大的服务程序来说大大的不够。一般会将它修改为2048或者更大。在&#x2F;etc&#x2F;sysctl.conf中添加:net.core.somaxconn &#x3D; 2048，然后在终端中执行sysctl -p。</span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line">#指定 redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line">#配置unix socket来让redis支持监听本地连接。</span><br><span class="line"># unixsocket &#x2F;var&#x2F;run&#x2F;redis&#x2F;redis.sock</span><br><span class="line">#配置unix socket使用文件的权限</span><br><span class="line"># unixsocketperm 700</span><br><span class="line"></span><br><span class="line"># 此参数为设置客户端空闲超过timeout，服务端会断开连接，为0则服务端不会主动断开连接，不能小于0。</span><br><span class="line">timeout 0</span><br><span class="line"></span><br><span class="line">#tcp keepalive参数。如果设置不为0，就使用配置tcp的SO_KEEPALIVE值，使用keepalive有两个好处:检测挂掉的对端。降低中间设备出问题而导致网络看似连接却已经与对端端口的问题。在Linux内核中，设置了keepalive，redis会定时给对端发送ack。检测到对端关闭需要两倍的设置值。</span><br><span class="line">tcp-keepalive 0</span><br><span class="line"></span><br><span class="line">#指定了服务端日志的级别。级别包括：debug（很多信息，方便开发、测试），verbose（许多有用的信息，但是没有debug级别信息多），notice（适当的日志级别，适合生产环境），warn（只有非常重要的信息）</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line">#指定了记录日志的文件。空字符串的话，日志会打印到标准输出设备。后台运行的redis标准输出是&#x2F;dev&#x2F;null。</span><br><span class="line">logfile &#x2F;var&#x2F;log&#x2F;redis&#x2F;redis-server.log</span><br><span class="line"></span><br><span class="line">#是否打开记录syslog功能</span><br><span class="line"># syslog-enabled no</span><br><span class="line"></span><br><span class="line">#syslog的标识符。</span><br><span class="line"># syslog-ident redis</span><br><span class="line"></span><br><span class="line">#日志的来源、设备</span><br><span class="line"># syslog-facility local0</span><br><span class="line"></span><br><span class="line">#数据库的数量，默认使用的数据库是DB 0。可以通过”SELECT “命令选择一个db</span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line">################################ SNAPSHOTTING ################################</span><br><span class="line"># 快照配置</span><br><span class="line"># 注释掉“save”这一行配置项就可以让保存数据库功能失效</span><br><span class="line"># 设置sedis进行数据库镜像的频率。</span><br><span class="line"># 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化） </span><br><span class="line"># 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化） </span><br><span class="line"># 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">#当RDB持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no：可以继续进行工作，可以通过info中的rdb_last_bgsave_status了解RDB持久化是否有错误</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line">#使用压缩rdb文件，rdb文件压缩使用LZF压缩算法，yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line">#是否校验rdb文件。从rdb格式的第五个版本开始，在rdb文件的末尾会带上CRC64的校验和。这跟有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗，所以如果你追求高性能，可以关闭该配置。</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line">#rdb文件的名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">#数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录</span><br><span class="line">dir &#x2F;var&#x2F;lib&#x2F;redis</span><br><span class="line"></span><br><span class="line">################################# REPLICATION #################################</span><br><span class="line">#复制选项，slave复制对应的master。</span><br><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line">#如果master设置了requirepass，那么slave要连上master，需要有master的密码才行。masterauth就是用来配置master的密码，这样可以在连上master后进行认证。</span><br><span class="line"># masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line">#当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：1) 如果slave-serve-stale-data设置为yes(默认设置)，从库会继续响应客户端的请求。2) 如果slave-serve-stale-data设置为no，除去INFO和SLAVOF命令之外的任何请求都会返回一个错误”SYNC with master in progress”。</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"></span><br><span class="line">#作为从服务器，默认情况下是只读的（yes），可以修改成NO，用于写（不建议）。</span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line">#是否使用socket方式复制数据。目前redis复制提供两种方式，disk和socket。如果新的slave连上来或者重连的slave无法部分同步，就会执行全量同步，master会生成rdb文件。有2种方式：disk方式是master创建一个新的进程把rdb文件保存到磁盘，再把磁盘上的rdb文件传递给slave。socket是master创建一个新的进程，直接把rdb文件以socket的方式发给slave。disk方式的时候，当一个rdb保存的过程中，多个slave都能共享这个rdb文件。socket的方式就的一个个slave顺序复制。在磁盘速度缓慢，网速快的情况下推荐用socket方式。</span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line">#diskless复制的延迟时间，防止设置为0。一旦复制开始，节点不会再接收新slave的复制请求直到下一个rdb传输。所以最好等待一段时间，等更多的slave连上来。</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line">#slave根据指定的时间间隔向服务器发送ping请求。时间间隔可以通过 repl_ping_slave_period 来设置，默认10秒。</span><br><span class="line"># repl-ping-slave-period 10</span><br><span class="line"></span><br><span class="line">#复制连接超时时间。master和slave都有超时时间的设置。master检测到slave上次发送的时间超过repl-timeout，即认为slave离线，清除该slave信息。slave检测到上次和master交互的时间超过repl-timeout，则认为master离线。需要注意的是repl-timeout需要设置一个比repl-ping-slave-period更大的值，不然会经常检测到超时。</span><br><span class="line"># repl-timeout 60</span><br><span class="line"></span><br><span class="line">#是否禁止复制tcp链接的tcp nodelay参数，可传递yes或者no。默认是no，即使用tcp nodelay。如果master设置了yes来禁止tcp nodelay设置，在把数据复制给slave的时候，会减少包的数量和更小的网络带宽。但是这也可能带来数据的延迟。默认我们推荐更小的延迟，但是在数据量传输很大的场景下，建议选择yes。</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line">#复制缓冲区大小，这是一个环形复制缓冲区，用来保存最新复制的命令。这样在slave离线的时候，不需要完全复制master的数据，如果可以执行部分同步，只需要把缓冲区的部分数据复制给slave，就能恢复正常复制状态。缓冲区的大小越大，slave离线的时间可以更长，复制缓冲区只有在有slave连接的时候才分配内存。没有slave的一段时间，内存会被释放出来，默认1m。</span><br><span class="line"># repl-backlog-size 5mb</span><br><span class="line"></span><br><span class="line">#master没有slave一段时间会释放复制缓冲区的内存，repl-backlog-ttl用来设置该时间长度。单位为秒。</span><br><span class="line"># repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line">#当master不可用，Sentinel会根据slave的优先级选举一个master。最低的优先级的slave，当选master。而配置成0，永远不会被选举。</span><br><span class="line">slave-priority 100</span><br><span class="line"></span><br><span class="line">#redis提供了可以让master停止写入的方式，如果配置了min-slaves-to-write，健康的slave的个数小于N，mater就禁止写入。master最少得有多少个健康的slave存活才能执行写命令。这个配置虽然不能保证N个slave都一定能接收到master的写操作，但是能避免没有足够健康的slave的时候，master不能写入来避免数据丢失。设置为0是关闭该功能。</span><br><span class="line"># min-slaves-to-write 3</span><br><span class="line"></span><br><span class="line">#延迟小于min-slaves-max-lag秒的slave才认为是健康的slave。</span><br><span class="line"># min-slaves-max-lag 10</span><br><span class="line"></span><br><span class="line"># 设置1或另一个设置为0禁用这个特性。</span><br><span class="line"># Setting one or the other to 0 disables the feature.</span><br><span class="line"># By default min-slaves-to-write is set to 0 (feature disabled) and</span><br><span class="line"># min-slaves-max-lag is set to 10.</span><br><span class="line"></span><br><span class="line">################################## SECURITY ###################################</span><br><span class="line">#requirepass配置可以让用户使用AUTH命令来认证密码，才能使用其他命令。这让redis可以使用在不受信任的网络中。为了保持向后的兼容性，可以注释该命令，因为大部分用户也不需要认证。使用requirepass的时候需要注意，因为redis太快了，每秒可以认证15w次密码，简单的密码很容易被攻破，所以最好使用一个更复杂的密码。</span><br><span class="line"># requirepass foobared</span><br><span class="line"></span><br><span class="line">#把危险的命令给修改成其他名称。比如CONFIG命令可以重命名为一个很难被猜到的命令，这样用户不能使用，而内部工具还能接着使用。</span><br><span class="line"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line"></span><br><span class="line">#设置成一个空的值，可以禁止一个命令</span><br><span class="line"># rename-command CONFIG &quot;&quot;</span><br><span class="line">################################### LIMITS ####################################</span><br><span class="line"></span><br><span class="line"># 设置能连上redis的最大客户端连接数量。默认是10000个客户端连接。由于redis不区分连接是客户端连接还是内部打开文件或者和slave连接等，所以maxclients最小建议设置到32。如果超过了maxclients，redis会给新的连接发送’max number of clients reached’，并关闭连接。</span><br><span class="line"># maxclients 10000</span><br><span class="line"></span><br><span class="line">#redis配置的最大内存容量。当内存满了，需要配合maxmemory-policy策略进行处理。注意slave的输出缓冲区是不计算在maxmemory内的。所以为了防止主机内存使用完，建议设置的maxmemory需要更小一些。</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br><span class="line">#内存容量超过maxmemory后的处理策略。</span><br><span class="line">#volatile-lru：利用LRU算法移除设置过过期时间的key。</span><br><span class="line">#volatile-random：随机移除设置过过期时间的key。</span><br><span class="line">#volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）</span><br><span class="line">#allkeys-lru：利用LRU算法移除任何key。</span><br><span class="line">#allkeys-random：随机移除任何key。</span><br><span class="line">#noeviction：不移除任何key，只是返回一个写错误。</span><br><span class="line">#上面的这些驱逐策略，如果redis没有合适的key驱逐，对于写命令，还是会返回错误。redis将不再接收写请求，只接收get请求。写命令包括：set setnx setex append incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby getset mset msetnx exec sort。</span><br><span class="line"># maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line">#lru检测的样本数。使用lru或者ttl淘汰算法，从需要淘汰的列表中随机选择sample个key，选出闲置时间最长的key移除。</span><br><span class="line"># maxmemory-samples 5</span><br><span class="line"></span><br><span class="line">############################## APPEND ONLY MODE ###############################</span><br><span class="line">#默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line">#aof文件名</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line">#aof持久化策略的配置</span><br><span class="line">#no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。</span><br><span class="line">#always表示每次写入都执行fsync，以保证数据同步到磁盘。</span><br><span class="line">#everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"># 在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line">#aof自动重写配置。当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">#设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line">#aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data&#x3D;ordered选项（redis宕机或者异常终止不会造成尾部不完整现象。）出现这种现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line">################################ LUA SCRIPTING ###############################</span><br><span class="line"># 如果达到最大时间限制（毫秒），redis会记个log，然后返回error。当一个脚本超过了最大时限。只有SCRIPT KILL和SHUTDOWN NOSAVE可以用。第一个可以杀没有调write命令的东西。要是已经调用了write，只能用第二个命令杀。</span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line">################################ REDIS CLUSTER ###############################</span><br><span class="line">#集群开关，默认是不开启集群模式。</span><br><span class="line"># cluster-enabled yes</span><br><span class="line"></span><br><span class="line">#集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要一个单独的配置文件，请确保与实例运行的系统中配置文件名称不冲突</span><br><span class="line"># cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line">#节点互连超时的阀值。集群节点超时毫秒数</span><br><span class="line"># cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line">#在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：</span><br><span class="line">#比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period</span><br><span class="line">#如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移 </span><br><span class="line"># cluster-slave-validity-factor 10</span><br><span class="line"></span><br><span class="line">#master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2 个可工作的从节点时，它的一个从节点会尝试迁移。</span><br><span class="line"># cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line">#默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致。</span><br><span class="line"># cluster-require-full-coverage yes</span><br><span class="line"></span><br><span class="line">################################## SLOW LOG ###################################</span><br><span class="line">###slog log是用来记录redis运行中执行比较慢的命令耗时。当命令的执行超过了指定时间，就记录在slow log中，slog log保存在内存中，所以没有IO操作。</span><br><span class="line">#执行时间比slowlog-log-slower-than大的请求记录到slowlog里面，单位是微秒，所以1000000就是1秒。注意，负数时间会禁用慢查询日志，而0则会强制记录所有命令。</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line">#慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。这个长度没有限制。只要有足够的内存就行。你可以通过 SLOWLOG RESET 来释放内存。</span><br><span class="line">slowlog-max-len 128</span><br><span class="line"></span><br><span class="line">################################ LATENCY MONITOR ##############################</span><br><span class="line">#延迟监控功能是用来监控redis中执行比较缓慢的一些操作，用LATENCY打印redis实例在跑命令时的耗时图表。只记录大于等于下边设置的值的操作。0的话，就是关闭监视。默认延迟监控功能是关闭的，如果你需要打开，也可以通过CONFIG SET命令动态设置。</span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line"></span><br><span class="line">############################# EVENT NOTIFICATION ##############################</span><br><span class="line">#键空间通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件。因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。</span><br><span class="line">#notify-keyspace-events 的参数可以是以下字符的任意组合，它指定了服务器该发送哪些类型的通知：</span><br><span class="line">##K 键空间通知，所有通知以 __keyspace@__ 为前缀</span><br><span class="line">##E 键事件通知，所有通知以 __keyevent@__ 为前缀</span><br><span class="line">##g DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知</span><br><span class="line">##$ 字符串命令的通知</span><br><span class="line">##l 列表命令的通知</span><br><span class="line">##s 集合命令的通知</span><br><span class="line">##h 哈希命令的通知</span><br><span class="line">##z 有序集合命令的通知</span><br><span class="line">##x 过期事件：每当有过期键被删除时发送</span><br><span class="line">##e 驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送</span><br><span class="line">##A 参数 g$lshzxe 的别名</span><br><span class="line">#输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何 通知被分发。详细使用可以参考http:&#x2F;&#x2F;redis.io&#x2F;topics&#x2F;notifications</span><br><span class="line"></span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line"></span><br><span class="line">############################### ADVANCED CONFIG ###############################</span><br><span class="line">#数据量小于等于hash-max-ziplist-entries的用ziplist，大于hash-max-ziplist-entries用hash</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">#value大小小于等于hash-max-ziplist-value的用ziplist，大于hash-max-ziplist-value用hash。</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line">#数据量小于等于list-max-ziplist-entries用ziplist，大于list-max-ziplist-entries用list。</span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line">#value大小小于等于list-max-ziplist-value的用ziplist，大于list-max-ziplist-value用list。</span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line">#数据量小于等于set-max-intset-entries用iniset，大于set-max-intset-entries用set。</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line">#数据量小于等于zset-max-ziplist-entries用ziplist，大于zset-max-ziplist-entries用zset。</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">#value大小小于等于zset-max-ziplist-value用ziplist，大于zset-max-ziplist-value用zset。</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line">#value大小小于等于hll-sparse-max-bytes使用稀疏数据结构（sparse），大于hll-sparse-max-bytes使用稠密的数据结构（dense）。一个比16000大的value是几乎没用的，建议的value大概为3000。如果对CPU要求不高，对空间要求较高的，建议设置到10000左右。</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"></span><br><span class="line">#Redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用。当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存。</span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line">##对客户端输出缓冲进行限制可以强迫那些不从服务器读取数据的客户端断开连接，用来强制关闭传输缓慢的客户端。</span><br><span class="line">#对于normal client，第一个0表示取消hard limit，第二个0和第三个0表示取消soft limit，normal client默认取消限制，因为如果没有寻问，他们是不会接收数据的。</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">#对于slave client和MONITER client，如果client-output-buffer一旦超过256mb，又或者超过64mb持续60秒，那么服务器就会立即断开客户端连接。</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">#对于pubsub client，如果client-output-buffer一旦超过32mb，又或者超过8mb持续60秒，那么服务器就会立即断开客户端连接。</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"></span><br><span class="line">#redis执行任务的频率为1s除以hz。</span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line">#在aof重写的时候，如果打开了aof-rewrite-incremental-fsync开关，系统会每32MB执行一次fsync。这对于把文件写入磁盘是有帮助的，可以避免过大的延迟峰值。</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS原理</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/AQS%E5%8E%9F%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/AQS%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ul><li>Sync queue：同步队列，是一个双向链表。包括head节点和tail节点。head节点主要用作后续的调度。</li><li>Condition queue：非必须，单向链表。当程序中存在cindition的时候才会存在此列表。</li></ul><h2 id="AQS核心思想"><a href="#AQS核心思想" class="headerlink" title="AQS核心思想"></a>AQS核心思想</h2><p>==同步组件的实现者通过使用AQS提供的模板方法实现同步组件语义，AQS则实现了对同步状态的管理，以及对阻塞线程进行排队，等待通知等等一些底层的实现处理==</p><p>可重写的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tryAcquire(int arg)独占获取同步状态，实现该方法需要查询当前状态，并判断同步状态是否符合预期状态，然后再进行CAS设置同步状态。</span><br><span class="line">treRelease(int arg)独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tryAcquireShared(int arg)共享式获取同步状态，返回大于等于0的值，表示获取成功，反之失败</span><br><span class="line">tryReleaseShared(int arg)共享式释放同步状态</span><br><span class="line">isHeldExclusively()当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占</span><br></pre></td></tr></table></figure><p>同步器提供的模板方法： </p><p>（1）独占式锁方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;独占式获取同步状态，如果获取失败则插入同步队列进行等待；</span><br><span class="line">void acquire(int arg);</span><br><span class="line">&#x2F;&#x2F;与acquire方法相同，但在同步队列中进行等待的时候可以检测中断；</span><br><span class="line">void acquireInterruptibly(int arg);</span><br><span class="line">&#x2F;&#x2F;在acquireInterruptibly基础上增加了超时等待功能，在超时时间内没有获得同步状态返回false;</span><br><span class="line">boolean tryAcquireNanos(int arg, long nanosTimeout);</span><br><span class="line">&#x2F;&#x2F;释放同步状态，该方法会唤醒在同步队列中的下一个节点</span><br><span class="line">boolean release(int arg);</span><br></pre></td></tr></table></figure><p>（2）共享式锁方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;：共享式获取同步状态，与独占式的区别在于同一时刻有多个线程获取同步状态；</span><br><span class="line">void acquireShared(int arg);</span><br><span class="line">&#x2F;&#x2F;：在acquireShared方法基础上增加了能响应中断的功能；</span><br><span class="line">void acquireSharedInterruptibly(int arg);</span><br><span class="line">&#x2F;&#x2F;：在acquireSharedInterruptibly基础上增加了超时等待的功能；</span><br><span class="line">boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</span><br><span class="line">&#x2F;&#x2F;：共享式释放同步状态</span><br><span class="line">boolean releaseShared(int arg)</span><br></pre></td></tr></table></figure><p>要想掌握AQS的底层实现，其实也就是对这些模板方法的逻辑进行学习。</p><p>AQS通过持有头尾指针管理同步队列(同步队列是一个双向队列)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile Node head;</span><br><span class="line"></span><br><span class="line">private transient volatile Node tail;</span><br><span class="line"></span><br><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure><p>AQS的静态内部类Node</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">volatile int waitStatus &#x2F;&#x2F;节点状态</span><br><span class="line">volatile Node prev &#x2F;&#x2F;当前节点&#x2F;线程的前驱节点</span><br><span class="line">volatile Node next; &#x2F;&#x2F;当前节点&#x2F;线程的后继节点</span><br><span class="line">volatile Thread thread;&#x2F;&#x2F;加入同步队列的线程引用</span><br><span class="line">Node nextWaiter;&#x2F;&#x2F;等待队列中的下一个节点</span><br></pre></td></tr></table></figure><p>节点的状态有以下这些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int CANCELLED &#x3D;  1&#x2F;&#x2F;节点从同步队列中取消</span><br><span class="line">int SIGNAL    &#x3D; -1&#x2F;&#x2F;后继节点的线程处于等待状态，如果当前节点释放同步状态会通知后继节点，使得后继节点的线程能够运行；</span><br><span class="line">int CONDITION &#x3D; -2&#x2F;&#x2F;当前节点进入等待队列中</span><br><span class="line">int PROPAGATE &#x3D; -3&#x2F;&#x2F;表示下一次共享式同步状态获取将会无条件传播下去</span><br><span class="line">int INITIAL &#x3D; 0;&#x2F;&#x2F;初始状态</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="一：获取独占式锁"><a href="#一：获取独占式锁" class="headerlink" title="一：获取独占式锁"></a>一：获取独占式锁</h1><h3 id="1、开始获取独占式锁："><a href="#1、开始获取独占式锁：" class="headerlink" title="1、开始获取独占式锁："></a>1、开始获取独占式锁：</h3><p>调用lock()方法是获取独占式锁，获取失败就将当前线程加入同步队列，成功则线程执行。而lock()方法实际上会调用AQS的acquire()方法.</p><p>acquire根据当前获得同步状态成功与否做了两件事情：</p><ol><li>成功，则方法结束返回，</li><li>失败，则先调用addWaiter()将线程加入等待队列,然后在调用acquireQueued()方法:排队获取锁。</li></ol><p>==acquire 该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移出。==</p><p>==首先调用自定义同步器实现的tryAcquire(int arg)方法，该方法<br>保证线程安全的获取同步状态，如果同步状态获取失败，则构造同步节点（独占式<br>Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过addWaiter(Node node)<br>方法将该节点加入到同步队列的尾部，最后调用acquireQueued(Node node,int arg)方法，使得该<br>节点以“死循环”的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的<br>唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">&#x2F;&#x2F;先看同步状态是否获取成功，如果成功则方法结束返回</span><br><span class="line">&#x2F;&#x2F;若失败则先调用addWaiter()方法再调用acquireQueued()方法</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、获取独占式锁态失败-做入队操作"><a href="#2、获取独占式锁态失败-做入队操作" class="headerlink" title="2、获取独占式锁态失败:做入队操作"></a>2、获取独占式锁态失败:做入队操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. 将当前线程构建成Node类型</span><br><span class="line">        Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">        &#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure</span><br><span class="line">        &#x2F;&#x2F; 2. 当前尾节点是否为null？</span><br><span class="line">        Node pred &#x3D; tail;</span><br><span class="line">        if (pred !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 2.2 将当前节点尾插入的方式插入同步队列中</span><br><span class="line">            node.prev &#x3D; pred;</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next &#x3D; node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 2.1. 当前同步队列尾节点为null，说明当前线程是第一个加入同步队列进行等待的线程</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自旋的过程（for (;;)）</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t &#x3D; tail;</span><br><span class="line">        if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">            &#x2F;&#x2F;1. 构造头结点</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail &#x3D; head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 2. 尾插入，CAS操作失败自旋尝试</span><br><span class="line">            node.prev &#x3D; t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next &#x3D; node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enq()方法：</p><ol><li>处理当前同步队列（带头双向链表）尾节点为null时进行入队操作；</li><li>compareAndSetTail(t, node)方法会利用CAS操作设置尾节点，CAS操作失败后负责自旋进行尝试会在for (;;)for死循环中不断尝试，直至成功return返回为止。</li></ol><p><img src="https://img-blog.csdn.net/20170819204120318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDYzNDMzOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><p>在同步队列中的节点（线程）会做什么事情了来保证自己能够有机会获得独占式锁了？自旋：acquireQueued</p><h3 id="入队列后，线程排队获取独占式锁的过程：acquireQueued"><a href="#入队列后，线程排队获取独占式锁的过程：acquireQueued" class="headerlink" title="入队列后，线程排队获取独占式锁的过程：acquireQueued"></a>入队列后，线程排队获取独占式锁的过程：acquireQueued</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">        boolean failed &#x3D; true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted &#x3D; false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                &#x2F;&#x2F; 1. 获得当前节点的先驱节点</span><br><span class="line">                final Node p &#x3D; node.predecessor();</span><br><span class="line">                &#x2F;&#x2F; 2. 当前节点能否获取独占式锁                  </span><br><span class="line">                &#x2F;&#x2F; 2.1 如果当前节点的先驱节点是头结点并且成功获取同步状态，即可以获得独占式锁</span><br><span class="line">                if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    &#x2F;&#x2F;获取锁成功，出队操作</span><br><span class="line">                    &#x2F;&#x2F;队列头指针用指向当前节点</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    &#x2F;&#x2F;释放前驱节点</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 2.2 获取锁失败，线程进入等待状态等待获取独占式锁</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;做出队操作：</span><br><span class="line">private void setHead(Node node) &#123;</span><br><span class="line">        head &#x3D; node;</span><br><span class="line">        node.thread &#x3D; null;</span><br><span class="line">        node.prev &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自旋获取锁整体示意图</p><p>只有前驱节点是头节点才能够尝试获取同步状态，因为</p><ul><li>第一，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会<br>唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。</li><li>第二，维护同步队列的FIFO原则。该方法中，节点自旋获取同步状态的行为</li></ul><p><img src="https://img-blog.csdn.net/20180509095351100?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmdoYW4xMjIy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p><h3 id="排队获取独占式获取成功，做出队操作："><a href="#排队获取独占式获取成功，做出队操作：" class="headerlink" title="排队获取独占式获取成功，做出队操作："></a>排队获取独占式获取成功，做出队操作：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;做出队操作：</span><br><span class="line">private void setHead(Node node) &#123;</span><br><span class="line">        head &#x3D; node;</span><br><span class="line">        node.thread &#x3D; null;</span><br><span class="line">        node.prev &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排队获取独占式获取失败"><a href="#排队获取独占式获取失败" class="headerlink" title="排队获取独占式获取失败"></a>排队获取独占式获取失败</h3><p>获取锁失败的时候会调用shouldParkAfterFailedAcquire()方法和parkAndCheckInterrupt()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    int ws &#x3D; pred.waitStatus;</span><br><span class="line">    if (ws &#x3D;&#x3D; Node.SIGNAL)</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * This node has already set status asking a release</span><br><span class="line">         * to signal it, so it can safely park.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        return true;</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">         * indicate retry.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next &#x3D; node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">         * need a signal, but don&#39;t park yet.  Caller will need to</span><br><span class="line">         * retry to make sure it cannot acquire before parking.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二：释放独占式锁：release"><a href="#二：释放独占式锁：release" class="headerlink" title="二：释放独占式锁：release()"></a>二：释放独占式锁：release()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">        if (tryRelease(arg)) &#123;</span><br><span class="line">            Node h &#x3D; head;</span><br><span class="line">            if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line"></span><br><span class="line">    int ws &#x3D; node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;头节点的后继节点</span><br><span class="line">    Node s &#x3D; node.next;</span><br><span class="line">    if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s &#x3D; null;</span><br><span class="line">        for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">            if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                s &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s !&#x3D; null)</span><br><span class="line">        &#x2F;&#x2F;后继节点不为null时唤醒该线程</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同步状态释放成功（tryRelease返回true）则会执行if块中的代码，当head指向的头结点不为null，并且该节点的状态值不为0的话才会执行unparkSuccessor()方法。==每一次锁释放后就会唤醒队列中该节点的后继节点所引用的线程，从而进一步可以佐证获得锁的过程是一个FIFO（先进先出）的过程。==</p><h1 id="三：独占式锁的获取和释放总结-很重要-："><a href="#三：独占式锁的获取和释放总结-很重要-：" class="headerlink" title="三：独占式锁的获取和释放总结(很重要)："></a>三：独占式锁的获取和释放总结(很重要)：</h1><p>==在获取同步状态时，AQS维护一个同步队列，获取同步状态失败的线程会加入到队列中进行自旋；移除队列（或停止自旋）的条件是前驱节点是头结点并且成功获得了同步状态。在释放同步状态时，同步器会调用unparkSuccessor()方法唤醒后继节点。==</p><p><img src="https://img-blog.csdn.net/2018083010402464?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjY3ODE3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p><h1 id="四：共享锁的获取"><a href="#四：共享锁的获取" class="headerlink" title="四：共享锁的获取"></a>四：共享锁的获取</h1><p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状<br>态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                int r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 当该节点的前驱节点是头结点且成功获取同步状态</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是<br>tryAcquireShared(int arg)方法返回值大于等于0。可以看到，在doAcquireShared(int arg)方法的自<br>旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示<br>该次获取同步状态成功并从自旋过程中退出。</p><h3 id="共享锁的释放（releaseShared-方法）"><a href="#共享锁的释放（releaseShared-方法）" class="headerlink" title="共享锁的释放（releaseShared()方法）"></a>共享锁的释放（releaseShared()方法）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>释放同步状态之后，将会唤醒后续处于等待状态的节点。对于能够支持多个线<br>程同时访问的并发组件（比如Semaphore），它和独占式主要区别在于tryReleaseShared(int arg)<br>方法必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证的，因为<br>释放同步状态的操作会同时来自多个线程。</p><h1 id="五：获取超时等待式锁：tryAcquireNanos"><a href="#五：获取超时等待式锁：tryAcquireNanos" class="headerlink" title="五：获取超时等待式锁：tryAcquireNanos()"></a>五：获取超时等待式锁：tryAcquireNanos()</h1><p>lock.tryLock(timeout,TimeUnit)，该方法会调用AQS的方法tryAcquireNanos(),方式达到超时等待获取锁的效果，该方法会在三种情况下才会返回：</p><ul><li>在超时时间内，当前线程成功获取了锁；</li><li>当前线程在超时时间内被中断；</li><li>超时时间结束，仍未获得锁返回false。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public final boolean tryAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    return tryAcquire(arg) ||</span><br><span class="line">        &#x2F;&#x2F;实现超时等待的效果</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean doAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (nanosTimeout &lt;&#x3D; 0L)</span><br><span class="line">        return false;</span><br><span class="line">    &#x2F;&#x2F;1. 根据超时时间和当前时间计算出截止时间</span><br><span class="line">    final long deadline &#x3D; System.nanoTime() + nanosTimeout;</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            &#x2F;&#x2F;2. 当前线程获得锁出队列</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 3.1 重新计算超时时间</span><br><span class="line">            nanosTimeout &#x3D; deadline - System.nanoTime();</span><br><span class="line">            &#x2F;&#x2F; 3.2 已经超时返回false</span><br><span class="line">            if (nanosTimeout &lt;&#x3D; 0L)</span><br><span class="line">                return false;</span><br><span class="line">            &#x2F;&#x2F; 3.3 线程阻塞等待 </span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(this, nanosTimeout);</span><br><span class="line">            &#x2F;&#x2F; 3.4 线程被中断抛出被中断异常</span><br><span class="line">            if (Thread.interrupted())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://upload-images.jianshu.io/upload_images/2615789-a80779d4736afb87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/704/format/webp" alt="image"></li></ul><p>程序逻辑同独占锁可响应中断式获取基本一致，唯一的不同在于获取锁失败后，对超时时间的处理上，在第1步会先计算出按照现在时间和超时时间计算出理论上的截止时间，比如当前时间是8h10min,超时时间是10min，那么根据deadline = System.nanoTime() + nanosTimeout计算出刚好达到超时时间时的系统时间就是8h 10min+10min = 8h 20min。然后根据deadline - System.nanoTime()就可以判断是否已经超时了，比如，当前系统时间是8h 30min很明显已经超过了理论上的系统时间8h 20min，deadline - System.nanoTime()计算出来就是一个负数，自然而然会在3.2步中的If判断之间返回false。如果还没有超时即3.2步中的if判断为true时就会继续执行3.3步通过LockSupport.parkNanos使得当前线程阻塞，同时在3.4步增加了对中断的检测，若检测出被中断直接抛出被中断异常</p>]]></content>
      
      
      <categories>
          
          <category> JUC锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的事务传播行为</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/</url>
      
        <content type="html"><![CDATA[<p>事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。这是Spring为我们提供的强大的工具箱，使用事务传播行可以为我们的开发工作提供许多便利。</p><h2 id="1、PROPAGATION-REQUIRED-默认"><a href="#1、PROPAGATION-REQUIRED-默认" class="headerlink" title="1、PROPAGATION_REQUIRED(默认)"></a>1、PROPAGATION_REQUIRED(默认)</h2><p>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</p><p>场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User1ServiceImpl implements User1Service &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">    public void addRequired(User1 user)&#123;</span><br><span class="line">        user1Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User2ServiceImpl implements User2Service &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">    public void addRequired(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">    public void addRequiredException(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（1-1）REQUIRED外围方法没有开启事务。"><a href="#（1-1）REQUIRED外围方法没有开启事务。" class="headerlink" title="（1.1）REQUIRED外围方法没有开启事务。"></a>（1.1）REQUIRED外围方法没有开启事务。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_exception_required_required()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequired(user2);</span><br><span class="line">    </span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“张三”、“李四”均插入。外围方法notransaction_exception_required_required未开启事务，插入“张三”、“李四”方法在自己的事务中独立运行(且自己的事务未发生异常)，外围方法异常不影响内部插入“张三”、“李四”方法独立的事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_required_required_exception()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiredException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“张三”插入，“李四”未插入。外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,所以插入“李四”方法抛出异常只会回滚插入“李四”方法，“张三”方法不受影响。</p><p>==结论：通过这两个方法我们证明了在外围方法未开启事务的情况下Propagation.REQUIRED修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。==</p><h4 id="（1-2）REQUIRED外围方法开启事务。"><a href="#（1-2）REQUIRED外围方法开启事务。" class="headerlink" title="（1.2）REQUIRED外围方法开启事务。"></a>（1.2）REQUIRED外围方法开启事务。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void transaction_exception_required_required()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequired(user2);</span><br><span class="line">    </span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“张三”、“李四”均未插入。外围方法开启事务，内部方法加入外围方法事务，外围方法回滚，内部方法也要回滚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void transaction_required_required_exception()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiredException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“张三”、“李四”均未插入.外围方法开启事务，内部方法加入外围方法事务，内部方法抛出异常回滚，外围方法感知异常致使整体事务回滚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public void transaction_required_required_exception_try()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        user2Service.addRequiredException(user2);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        System.out.println(&quot;方法回滚&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“张三”、“李四”均未插入。外围方法开启事务，内部方法加入外围方法事务，内部方法抛出异常回滚，即使方法被catch不被外围方法感知，整个事务依然回滚。</p><p>==结论：果我们证明在外围方法开启事务的情况下Propagation.REQUIRED修饰的内部方法会加入到外围方法的事务中，所有Propagation.REQUIRED修饰的内部方法和外围方法均属于同一事务，只要一个方法回滚，整个事务均回滚。==</p><h2 id="2-PROPAGATION-REQUIRES-NEW"><a href="#2-PROPAGATION-REQUIRES-NEW" class="headerlink" title="2.PROPAGATION_REQUIRES_NEW"></a>2.PROPAGATION_REQUIRES_NEW</h2><p>新建事务，如果当前存在事务，把当前事务挂起。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User1ServiceImpl implements User1Service &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</span><br><span class="line">    public void addRequiresNew(User1 user)&#123;</span><br><span class="line">        user1Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">    public void addRequired(User1 user)&#123;</span><br><span class="line">        user1Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User2ServiceImpl implements User2Service &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</span><br><span class="line">    public void addRequiresNew(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</span><br><span class="line">    public void addRequiresNewException(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2-1）、REQUIRES-NEW：外围方法没有开启事务。"><a href="#（2-1）、REQUIRES-NEW：外围方法没有开启事务。" class="headerlink" title="（2.1）、REQUIRES_NEW：外围方法没有开启事务。"></a>（2.1）、REQUIRES_NEW：外围方法没有开启事务。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_exception_requiresNew_requiresNew()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequiresNew(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user2);</span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>张三”插入，“李四”插入。外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,外围方法抛出异常回滚不会影响内部方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_requiresNew_requiresNew_exception()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequiresNew(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNewException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“张三”插入，“李四”未插入。外围方法没有开启事务，插入“张三”方法和插入“李四”方法分别开启自己的事务，插入“李四”方法抛出异常回滚，其他事务不受影响。</p><p>==结论：在外围方法未开启事务的情况下Propagation.REQUIRES_NEW修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。==</p><h4 id="（2-2）、REQUIRES-NEW：外围方法开启事务。"><a href="#（2-2）、REQUIRES-NEW：外围方法开启事务。" class="headerlink" title="（2.2）、REQUIRES_NEW：外围方法开启事务。"></a>（2.2）、REQUIRES_NEW：外围方法开启事务。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void transaction_exception_required_requiresNew_requiresNew()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user2);</span><br><span class="line">    </span><br><span class="line">    User2 user3&#x3D;new User2();</span><br><span class="line">    user3.setName(&quot;王五&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user3);</span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“张三”未插入，“李四”插入，“王五”插入。外围方法开启事务，插入“张三”方法和外围方法一个事务，插入“李四”方法、插入“王五”方法分别在独立的新建事务中，外围方法抛出异常只回滚和外围方法同一事务的方法，故插入“张三”的方法回滚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void transaction_required_requiresNew_requiresNew_exception()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user2);</span><br><span class="line">    </span><br><span class="line">    User2 user3&#x3D;new User2();</span><br><span class="line">    user3.setName(&quot;王五&quot;);</span><br><span class="line">    user2Service.addRequiresNewException(user3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“张三”未插入，“李四”插入，“王五”未插入。外围方法开启事务，插入“张三”方法和外围方法一个事务，插入“李四”方法、插入“王五”方法分别在独立的新建事务中。插入“王五”方法抛出异常，首先插入 “王五”方法的事务被回滚，异常继续抛出被外围方法感知，外围方法事务亦被回滚，故插入“张三”方法也被回滚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void transaction_required_requiresNew_requiresNew_exception_try()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user2);</span><br><span class="line">    User2 user3&#x3D;new User2();</span><br><span class="line">    user3.setName(&quot;王五&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        user2Service.addRequiresNewException(user3);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        System.out.println(&quot;回滚&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“张三”插入，“李四”插入，“王五”未插入。外围方法开启事务，插入“张三”方法和外围方法一个事务，插入“李四”方法、插入“王五”方法分别在独立的新建事务中。插入“王五”方法抛出异常，首先插入“王五”方法的事务被回滚，异常被catch不会被外围方法感知，外围方法事务不回滚，故插入“张三”方法插入成功。</p><p>==结论：在外围方法开启事务的情况下Propagation.REQUIRES_NEW修饰的内部方法依然会单独开启独立事务，且与外部方法事务也独立，内部方法之间、内部方法和外部方法事务均相互独立，互不干扰==。</p><h2 id="3-PROPAGATION-NESTED"><a href="#3-PROPAGATION-NESTED" class="headerlink" title="3.PROPAGATION_NESTED"></a>3.PROPAGATION_NESTED</h2><p>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User1ServiceImpl implements User1Service &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.NESTED)</span><br><span class="line">    public void addNested(User1 user)&#123;</span><br><span class="line">        user1Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User2ServiceImpl implements User2Service &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.NESTED)</span><br><span class="line">    public void addNested(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation &#x3D; Propagation.NESTED)</span><br><span class="line">    public void addNestedException(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（3-1）外围方法没有开启事务。"><a href="#（3-1）外围方法没有开启事务。" class="headerlink" title="（3.1）外围方法没有开启事务。"></a>（3.1）外围方法没有开启事务。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_exception_nested_nested()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addNested(user2);</span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“张三”、“李四”均插入。外围方法未开启事务，插入“张三”、“李四”方法在自己的事务中独立运行，外围方法异常不影响内部插入“张三”、“李四”方法独立的事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_nested_nested_exception()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addNestedException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“张三”插入，“李四”未插入。外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,所以插入“李四”方法抛出异常只会回滚插入“李四”方法，插入“张三”方法不受影响。</p><p>==结论：通过这两个方法我们证明了在外围方法未开启事务的情况下Propagation.NESTED和Propagation.REQUIRED作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。==</p><h4 id="（3-2）外围方法开启事务。"><a href="#（3-2）外围方法开启事务。" class="headerlink" title="（3.2）外围方法开启事务。"></a>（3.2）外围方法开启事务。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public void transaction_exception_nested_nested()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addNested(user2);</span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“张三”、“李四”均未插入。外围方法开启事务，内部事务为外围事务的子事务，外围方法回滚，内部方法也要回滚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public void transaction_nested_nested_exception()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addNestedException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“张三”、“李四”均未插入。外围方法开启事务，内部事务为外围事务的子事务，内部方法抛出异常回滚，且外围方法感知异常致使整体事务回滚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public void transaction_nested_nested_exception_try()&#123;</span><br><span class="line">    User1 user1&#x3D;new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2&#x3D;new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        user2Service.addNestedException(user2);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        System.out.println(&quot;方法回滚&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“张三”插入、“李四”未插入。外围方法开启事务，内部事务为外围事务的子事务，插入“张三”内部方法抛出异常，可以单独对子事务回滚。</p><p>==结论：以上试验结果我们证明在外围方法开启事务的情况下Propagation.NESTED修饰的内部方法属于外部事务的子事务，外围主事务回滚，子事务一定回滚，而内部子事务可以单独回滚而不影响外围主事务和其他子事务==</p><h2 id="REQUIRED-REQUIRES-NEW-NESTED异同"><a href="#REQUIRED-REQUIRES-NEW-NESTED异同" class="headerlink" title=". REQUIRED,REQUIRES_NEW,NESTED异同"></a>. REQUIRED,REQUIRES_NEW,NESTED异同</h2><h2 id="4、PROPAGATION-NOT-SUPPORTED"><a href="#4、PROPAGATION-NOT-SUPPORTED" class="headerlink" title="4、PROPAGATION_NOT_SUPPORTED"></a>4、PROPAGATION_NOT_SUPPORTED</h2><p>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><h2 id="5、PROPAGATION-NEVER"><a href="#5、PROPAGATION-NEVER" class="headerlink" title="5、PROPAGATION_NEVER"></a>5、PROPAGATION_NEVER</h2><p>以非事务方式执行，如果当前存在事务，则抛出异常。</p><h2 id="6、PROPAGATION-SUPPORTS"><a href="#6、PROPAGATION-SUPPORTS" class="headerlink" title="6、PROPAGATION_SUPPORTS"></a>6、PROPAGATION_SUPPORTS</h2><p>支持当前事务，如果当前没有事务，就以非事务方式执行。</p><h2 id="7、PROPAGATION-MANDATORY"><a href="#7、PROPAGATION-MANDATORY" class="headerlink" title="7、PROPAGATION_MANDATORY"></a>7、PROPAGATION_MANDATORY</h2><p>使用当前的事务，如果当前没有事务，就抛出异常。</p>]]></content>
      
      
      <categories>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring的事务传播行为 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>00_AQS</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/00_AQS/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/JUC%E9%94%81/00_AQS/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC中的AQS"><a href="#JUC中的AQS" class="headerlink" title="JUC中的AQS"></a>JUC中的AQS</h1><h2 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h2><ul><li>java.util.concurrent中有许多可阻塞的类，如ReentrantLock、Semaphore、ReentrantReadWriteLock、CountDownLatch、SynchronousQueue和FutureTask等，这些阻塞类有一个共同点就是都是基于AQS构建的。</li><li>AQS(AbstractQueuedSynchronizer)即队列同步器。是用来构建锁或者其他同步组件的基础框架，是JUC并发包中的核心基础组件。</li><li>AQS解决了实现同步器是涉及到的大量细节问题，如：获取同步状态、FIFO同步队列等。在基于AQS构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提供了吞吐量。</li><li>AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态。</li><li>AQS使用一个int类型的成员变量state来表示同步状态，当state&gt;0时表示已经获取锁，当state=0时表示释放了锁。AQS提供了三个方法来对同步状态state进行操作。</li><li>AQS通过内置的FIFO同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态失败时，AQS会将当前线程以及等待状态等信息构造成一个Node并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。</li></ul><h2 id="AQS结构"><a href="#AQS结构" class="headerlink" title="AQS结构"></a>AQS结构</h2><pre><code>见代码</code></pre><h2 id="AQS提供的主要方法"><a href="#AQS提供的主要方法" class="headerlink" title="AQS提供的主要方法"></a>AQS提供的主要方法</h2><ul><li><strong>getState()</strong>:返回同步状态的当前值</li><li><strong>setState(int newState)</strong>:设置当前同步状态</li><li><strong>compareAndSetState(int expect, int update)</strong>:使用CAS设置当前状态，该方法能够保证状态设置的原子性</li><li><strong>isHeldExclusively()</strong>:当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程独占</li><li><strong>acquire(int arg)</strong>:独占式获取同步状态，如果当前线程获取同步状态成功，则由改方法返回，否则，将会进入同步队列等待，该方法将会调用可重写的tryAcquire(int arg)方法</li><li><strong>acquireInterruptibly(int arg)</strong>:与acquire(int arg)相同，但是该方法响应中断，当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法抛出InterruptedException异常并返回</li><li>**acquireShared(int arg)**：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态</li><li>**acquireSharedInterruptibly(int arg)**：共享式获取同步状态，响应中断</li><li>**release(int arg)**：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒</li><li>**releaseShared(int arg)**：共享式释放同步状态</li></ul><hr><ul><li><strong>tryAcquire(int arg)</strong>:独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态</li><li><strong>tryRelease(int arg)</strong>:独占式释放同步状态</li><li><strong>tryAcquireNanos(int arg, long nanos)</strong>:超时获取同步状态，如果当前线程在nanos时间内没有获取到同步状态，那么将会返回false，已经获取则返回true</li><li><strong>tryAcquireShared(int arg)</strong>:共享式获取同步状态，返回值大于等于0表示获取成功，否则获取失败</li><li><strong>tryReleaseShared(int arg)</strong>:共享式释放同步状态</li><li>**tryAcquireSharedNanos(int arg, long nanosTimeout)**：共享式获取同步状态，增加超时限制</li></ul><h2 id="CLH同步队列"><a href="#CLH同步队列" class="headerlink" title="CLH同步队列"></a>CLH同步队列</h2><ul><li>CLH同步队列是一个FIFO双向队列，AQS依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</li><li>在CLH同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next）<br> CLH同步队列结构<br><img src="./image/CLH%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97.jpg" alt="image"></li></ul><h2 id="同步状态的获取与释放"><a href="#同步状态的获取与释放" class="headerlink" title="同步状态的获取与释放"></a>同步状态的获取与释放</h2><ul><li>AQS的设计模式采用了模板方法，子类通过继承的方式，实现AQS的抽象方法来管理同步状态，AQS提供了大量的模板方法来事项同步，主要分三类：独占式获取和释放同步状态、共享式获取和释放同步状态、查询同步队列中的等待线程情况。</li></ul><h2 id="ReentrantLock结构"><a href="#ReentrantLock结构" class="headerlink" title="ReentrantLock结构"></a>ReentrantLock结构</h2><p><img src="./image/ReentrantLock.jpg" alt="image"></p><h3 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h3><ul><li>独占式指同一时刻仅有一个线程持有同步状态</li><li>独占式同步状态获取：acquire(int arg)方法为AQS提供的模板方法，改方法为独占式获取同步状态，但是该方法对中断不敏感，也就是说由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。</li><li>各个方法的定义：</li><li><strong>tryAcquire</strong>：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。该方法自定义同步组件自己实现，该方法必须要保证线程安全的获取同步状态。</li><li><strong>addWaiter</strong>：如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。</li><li><strong>acquireQueued</strong>：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。</li><li><strong>selfInterrupt</strong>：产生一个中断。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ReentrantLock的lock代码</span><br><span class="line">public void lock() &#123;</span><br><span class="line">       sync.lock();</span><br><span class="line">   &#125;</span><br><span class="line">&#x2F;&#x2F;NonfairSync的lock代码</span><br><span class="line">final void lock() &#123;</span><br><span class="line">if (compareAndSetState(0, 1))</span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">else</span><br><span class="line">acquire(1);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;AQS中的acquire</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">       if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br><span class="line">改写为</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">       if (tryAcquire(arg)) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       Node newNode &#x3D; addWaiter(Node.EXCLUSIVE);</span><br><span class="line">       boolean interrupted &#x3D; acquireQueued(newNode, arg);</span><br><span class="line">       if (interrupted) &#123;</span><br><span class="line">           selfInterrupt();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>acquire(int arg)方法流程图 </code></pre><p><img src="./image/acquire()%E6%96%B9%E6%B3%95.jpg" alt="image"></p><ul><li><p>独占式获取响应中断：AQS提供了acquire(int arg)方法以供独占式获取同步状态，但是该方法对中断不响应，对线程进行中断操作后，该线程会依然位于CLH同步队列中等待获取同步状态，为了响应中断，AQS提供了acquireInterruptibly(int arg)方法，该方法在等待获取同步状态时，如果当前线程被中断了，会立即响应中断并抛出InterruptedException。</p><blockquote><p>首先校验该线程是否已经中断了，如果是则抛出InterruptedException，否则执行tryAcquire(int arg)方法获取同步状态，如果获取成功，则直接返回，否则执行doAcquireInterruptibly(int arg)。</p></blockquote><blockquote><p>doAcquireInterruptibly(int arg)方法与acquire(int arg)方法仅有两个差别。</p></blockquote><blockquote><blockquote><p>1.方法声明抛出InterruptedException异常。</p></blockquote></blockquote><blockquote><blockquote><p>2.在中断方法处不再是使用interrupted标志，而是直接抛出InterruptedException异常。</p></blockquote></blockquote></li></ul><ul><li><p>独占式超时获取    </p><blockquote><blockquote><p>AQS除了提供上面两个方法外，还提供了一个增强版的方法：tryAcquireNanos(int arg,long nanos)。该方法为acquireInterruptibly方法的进一步增强，它除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回false，否则返回true。<br><img src="./image/acquireNano%E6%96%B9%E6%B3%95.jpg" alt="image"></p></blockquote></blockquote></li><li><p>独占式同步状态释放</p><blockquote><blockquote><p>当线程获取同步状态后，执行完相应逻辑后就需要释放同步状态。AQS提供了release(int arg)方法释放同步状态。该方法同样是先调用自定义同步器自定义的tryRelease(int arg)方法来释放同步状态，释放成功后，会调用unparkSuccessor(Node node)方法唤醒后继节点。<br>** 在AQS中维护着一个FIFO的同步队列，当线程获取同步状态失败后，则会加入到这个CLH同步队列的对尾并一直保持着自旋。在CLH同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态，获取成功则退出CLH同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。**</p></blockquote></blockquote></li></ul><h3 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h3><ul><li>共享式与独占式的最主要区别在于同一时刻独占式只能有一个线程获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。例如读操作可以有多个线程同时进行，而写操作同一时刻只能有一个线程进行写操作，其他操作都会被阻塞。</li><li>共享式同步状态获取    AQS提供acquireShared(int arg)方法共享式获取同步状态：</li><li>方法首先是调用tryAcquireShared(int arg)方法尝试获取同步状态，如果获取失败则调用doAcquireShared(int arg)自旋方式获取同步状态，共享式获取同步状态的标志是返回 &gt;= 0 的值表示获取成功。</li><li>tryAcquireShared(int arg)方法尝试获取同步状态，返回值为int，当其 &gt;= 0 时，表示能够获取到同步状态，这个时候就可以从自旋过程中退出。</li><li>acquireShared(int arg)方法不响应中断，与独占式相似，AQS也提供了响应中断、超时的方法，分别是：acquireSharedInterruptibly(int arg)、tryAcquireSharedNanos(int arg,long nanos)。</li><li>共享式同步状态释放    获取同步状态后，需要调用release(int arg)方法释放同步状态</li><li>因为可能会存在多个线程同时行释放同步状态资源，所以需要确保同步状态安全地成功释放，一般都是通过CAS和循环来完成的。</li></ul><h2 id="阻塞和唤醒线程"><a href="#阻塞和唤醒线程" class="headerlink" title="阻塞和唤醒线程"></a>阻塞和唤醒线程</h2><ul><li>在线程获取同步状态时如果获取失败，则加入CLH同步队列，通过通过自旋的方式不断获取同步状态，但是在自旋的过程中则需要判断当前线程是否需要阻塞，其主要方法在acquireQueued()</li><li>在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态，检查状态的方法为 shouldParkAfterFailedAcquire(Node pred, Node node) 方法，该方法主要靠前驱节点判断当前线程是否应该被阻塞</li></ul>]]></content>
      
      
      <categories>
          
          <category> JUC锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 00_AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList实现原理</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/3%E3%80%81LinkedList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/3%E3%80%81LinkedList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="1、LinkedList特点："><a href="#1、LinkedList特点：" class="headerlink" title="1、LinkedList特点："></a>1、LinkedList特点：</h3><ul><li><p>数据存储是基于双向链表实现的。（fast-fail机制与arrayList一致，因为都是AbstractList子类）</p></li><li><p>插入数据很快。先是在双向链表中找到要插入节点的位置index，找到之后，再插入一个新节点。</p></li><li><p>双向链表查找index位置的节点时，有一个加速动作：若index &lt; 双向链表长度的1/2，则从前向后查找; 否则，从后向前查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        return node(index).item;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">        &#x2F;&#x2F; assert isElementIndex(index);</span><br><span class="line"></span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">            x &#x3D; x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">        for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">            x &#x3D; x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除数据很快。先是在双向链表中找到要插入节点的位置index，找到之后，进行如下操作：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.previous.next &#x3D; node.next;node.next.previous &#x3D; node.previous;node &#x3D; null</span><br></pre></td></tr></table></figure></li></ul><p>具体源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">        &#x2F;&#x2F; assert x !&#x3D; null;</span><br><span class="line">    final E element &#x3D; x.item;</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; x.prev;</span><br><span class="line">    </span><br><span class="line">    if (prev &#x3D;&#x3D; null) &#123;</span><br><span class="line">        first &#x3D; next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev.next &#x3D; next;</span><br><span class="line">        x.prev &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">        last &#x3D; prev;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next.prev &#x3D; prev;</span><br><span class="line">        x.next &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    x.item &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 。查找节点过程和插入一样。</p><ul><li><p>获取数据很慢，需要从Head节点进行查找。</p></li><li><p>遍历数据很慢，每次获取数据都需要从头开始。</p></li></ul><p>2、实现原理（JDK.8）源码分析</p><h4 id="成员变量和构造方法"><a href="#成员变量和构造方法" class="headerlink" title="成员变量和构造方法"></a>成员变量和构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;当前存储的元素个数</span><br><span class="line">transient int size &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;首节点</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;末节点</span><br><span class="line">transient Node&lt;E&gt; last;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;空构造器</span><br><span class="line">public LinkedList() &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;传入集合参数的构造器</span><br><span class="line">&#x2F;&#x2F;该集合里面的所有元素插入到LinkedList中，</span><br><span class="line">注意这里是“插入”而不是说“初始化添加”，</span><br><span class="line">因为LinkedList并非线程安全，可能在this（）调用之后，已经有其他的线程向里面插入数据了。</span><br><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    this();&#x2F;&#x2F;调用当前类的构造函数</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="addAll添加元素"><a href="#addAll添加元素" class="headerlink" title="addAll添加元素"></a>addAll添加元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *在链表的尾端追加指定集合的所有元素，按指定的迭代器的集合顺序返回，在这个操作执行总是如果指定的集合被修改了</span><br><span class="line"> *，那么该行为操作将提示未定义</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    return addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">&#x2F;&#x2F; 检查index是否越界，index&#x3D;size+1</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    &#x2F;&#x2F;将集合参数转化为数组</span><br><span class="line">    Object[] a &#x3D; c.toArray();</span><br><span class="line">    int numNew &#x3D; a.length;&#x2F;&#x2F;要插入的集合长度</span><br><span class="line">    if (numNew &#x3D;&#x3D; 0)</span><br><span class="line">        return false;</span><br><span class="line">    &#x2F;&#x2F;定义pred和succ两个Node对象，用于标识要插入元素的前置节点和后置节点</span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 这里为什么要写if..else？</span><br><span class="line">     * 因为该方法不一定是从上层方法addAll(size, c)过来的，还有可能是直接调用了addAll(int index, Collection&lt;? extends E&gt; c)</span><br><span class="line">     * 方法，从上层addAll(size, c)跳转过来的，size&#x3D;index也就从尾部插入，但是直接调用的该方法，则从传进来的参数index这个位置（肯能是任何位置）插入</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (index &#x3D;&#x3D; size) &#123;&#x2F;&#x2F;表明是从尾部插入</span><br><span class="line">        succ &#x3D; null;&#x2F;&#x2F;从尾部插入，后置节点为null</span><br><span class="line">        pred &#x3D; last;&#x2F;&#x2F;从尾部插入，前置节点为当前LinkedList中的最后一个节点</span><br><span class="line">    &#125; else &#123;&#x2F;&#x2F;表明不是从尾部插入</span><br><span class="line">        succ &#x3D; node(index);&#x2F;&#x2F;查到当前LinkedList中位置为index的节点并把它赋给要插入元素的后置节点</span><br><span class="line">        pred &#x3D; succ.prev;&#x2F;&#x2F;把上一步得到的节点的前置节点赋值给要插入元素的后置节点</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    for (Object o : a) &#123;&#x2F;&#x2F;变量集合参数</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;) E e &#x3D; (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, null);</span><br><span class="line">        if (pred &#x3D;&#x3D; null)&#x2F;&#x2F;说明插入之前当前链表是空链表</span><br><span class="line">            first &#x3D; newNode;&#x2F;&#x2F;新节点是第一个节点</span><br><span class="line">        else</span><br><span class="line">            pred.next &#x3D; newNode;&#x2F;&#x2F;设置插入元素的的前置节点的后置节点为新节点</span><br><span class="line">        pred &#x3D; newNode;&#x2F;&#x2F;更改指向后将新节点对象赋给pred作为下次循环中新插入节点的前一个对象节点，依次循环</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;&#x2F;此时pred代表集合元素的插入完后的最后一个节点对象</span><br><span class="line">    if (succ &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;结尾添加的话在添加完集合元素后将最后一个集合的节点对象pred作为last</span><br><span class="line">        last &#x3D; pred;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        pred.next &#x3D; succ;&#x2F;&#x2F;将集合元素的最后一个节点对象的next指针指向原index位置上的Node对象</span><br><span class="line">        succ.prev &#x3D; pred;&#x2F;&#x2F;将原index位置上的pred指针对象指向集合的最后一个对象</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    size +&#x3D; numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Returns the (non-null) Node at the specified element index.</span><br><span class="line"> * 返回index位置的非空节点</span><br><span class="line"> * 折半查询 </span><br><span class="line"> *&#x2F;</span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 如果index小于当前元素个数的一半，则从前向后遍历查询 ，否则从后向前遍历查询</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">            x &#x3D; x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">        for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">            x &#x3D; x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="add方法："><a href="#add方法：" class="headerlink" title="add方法："></a>add方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 获取当前链表的最后一个节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建一个以当前最后一个节点为之前节点的节点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last &#x3D; newNode;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 空表，首次插入</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next &#x3D; newNode;&#x2F;&#x2F;不是首次插入，则最后一个节点的后置节点地址赋值给新节点</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法:"></a>remove方法:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *从第一个节点循环指针查找</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    &#x2F;&#x2F;如果移除的数据为Null</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;遍历找到第一个为null的节点，然后移除掉</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F;遍历找到第一条不为null与参数相等的数据，然后移除掉</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert x !&#x3D; null;</span><br><span class="line">&#x2F;&#x2F;移除的数据</span><br><span class="line">    final E element &#x3D; x.item;</span><br><span class="line">    &#x2F;&#x2F;移除节点的后置节点</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">  &#x2F;&#x2F;移除节点的前置节点</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; x.prev;</span><br><span class="line">    </span><br><span class="line">    if (prev &#x3D;&#x3D; null) &#123;</span><br><span class="line">        first &#x3D; next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev.next &#x3D; next;</span><br><span class="line">        x.prev &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">        last &#x3D; prev;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next.prev &#x3D; prev;</span><br><span class="line">        x.next &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    x.item &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="清除clear"><a href="#清除clear" class="headerlink" title="清除clear"></a>清除clear</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">    &#x2F;&#x2F;遍历所以的数据，置为null,方便垃圾回收</span><br><span class="line">    for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; ) &#123;</span><br><span class="line">        Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">        x.item &#x3D; null;</span><br><span class="line">        x.next &#x3D; null;</span><br><span class="line">        x.prev &#x3D; null;</span><br><span class="line">        x &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line">    first &#x3D; last &#x3D; null;</span><br><span class="line">    size &#x3D; 0;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="细节：add和offer的区别："><a href="#细节：add和offer的区别：" class="headerlink" title="细节：add和offer的区别："></a>细节：add和offer的区别：</h4><p>linkendList的offer都是调用的add方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">        return add(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>add是list的</p><p>offer是queue的</p><p>add：<br>将指定的元素插入到list中指定的的位置。</p><p>offer：<br>如果在不违反容量限制的情况下，尽可能快的将指定的元素插入到queue中去</p>]]></content>
      
      
      <categories>
          
          <category> java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList实现原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈对表达式求值的应用</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E3%80%81%E6%A0%88/2%E3%80%81%E6%A0%88%E5%AF%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E3%80%81%E6%A0%88/2%E3%80%81%E6%A0%88%E5%AF%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="中缀表达式求值："><a href="#中缀表达式求值：" class="headerlink" title="中缀表达式求值："></a>中缀表达式求值：</h3><ul><li>开始遍历表达式</li><li>—-是否为数字</li><li>———是：压入数字栈</li><li>———否：判断符号栈是否为空</li><li>—————-是：压入符号栈</li><li>—————-否：判断当前操作符与栈中的操作符优先级</li><li>————————大于：压入符号栈</li><li>————————小于等于：从数字栈pop出两个数字，从符号栈中pop出一个符号，做运算。并将结果压入数字栈</li><li>遍历表达式结束:顺序从数字栈和符号栈中pop出数字和符号进行运算，最后栈中只剩一个数字（最终结果）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">public class Calculator &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String expression &#x3D; &quot;7*2*2-5+1-5+3-4&quot;; &#x2F;&#x2F; 15&#x2F;&#x2F;如何处理多位数的问题？</span><br><span class="line">        &#x2F;&#x2F;创建两个栈，数栈，一个符号栈</span><br><span class="line">        ArrayStack2 numStack &#x3D; new ArrayStack2(10);</span><br><span class="line">        ArrayStack2 operStack &#x3D; new ArrayStack2(10);</span><br><span class="line">        &#x2F;&#x2F;定义需要的相关变量</span><br><span class="line">        int index &#x3D; 0;&#x2F;&#x2F;用于扫描</span><br><span class="line">        int num1 &#x3D; 0;</span><br><span class="line">        int num2 &#x3D; 0;</span><br><span class="line">        int oper &#x3D; 0;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        char ch &#x3D; &#39; &#39;; &#x2F;&#x2F;将每次扫描得到char保存到ch</span><br><span class="line">        String keepNum &#x3D; &quot;&quot;; &#x2F;&#x2F;用于拼接 多位数</span><br><span class="line">        &#x2F;&#x2F;开始while循环的扫描expression</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            &#x2F;&#x2F;依次得到expression 的每一个字符</span><br><span class="line">            ch &#x3D; expression.substring(index, index + 1).charAt(0);</span><br><span class="line">            &#x2F;&#x2F;判断ch是什么，然后做相应的处理</span><br><span class="line">            if (operStack.isOper(ch)) &#123;&#x2F;&#x2F;如果是运算符</span><br><span class="line">                &#x2F;&#x2F;判断当前的符号栈是否为空</span><br><span class="line">                if (!operStack.isEmpty()) &#123;</span><br><span class="line">                    &#x2F;&#x2F;如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符,就需要从数栈中pop出两个数,</span><br><span class="line">                    &#x2F;&#x2F;在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈</span><br><span class="line">                    if (operStack.priority(ch) &lt;&#x3D; operStack.priority(operStack.peek())) &#123;</span><br><span class="line">                        num1 &#x3D; numStack.pop();</span><br><span class="line">                        num2 &#x3D; numStack.pop();</span><br><span class="line">                        oper &#x3D; operStack.pop();</span><br><span class="line">                        res &#x3D; numStack.cal(num1, num2, oper);</span><br><span class="line">                        &#x2F;&#x2F;把运算的结果如数栈</span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        &#x2F;&#x2F;然后将当前的操作符入符号栈</span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        &#x2F;&#x2F;如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.</span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F;如果为空直接入符号栈..</span><br><span class="line">                    operStack.push(ch); &#x2F;&#x2F; 1 + 3</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F;如果是数，则直接入数栈</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;numStack.push(ch - 48); &#x2F;&#x2F;? &quot;1+3&quot; &#39;1&#39; &#x3D;&gt; 1</span><br><span class="line">                &#x2F;&#x2F;分析思路</span><br><span class="line">                &#x2F;&#x2F;1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数</span><br><span class="line">                &#x2F;&#x2F;2. 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈</span><br><span class="line">                &#x2F;&#x2F;3. 因此我们需要定义一个变量 字符串，用于拼接</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;处理多位数</span><br><span class="line">                keepNum +&#x3D; ch;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;如果ch已经是expression的最后一位，就直接入栈</span><br><span class="line">                if (index &#x3D;&#x3D; expression.length() - 1) &#123;</span><br><span class="line">                    numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈</span><br><span class="line">                    &#x2F;&#x2F;注意是看后一位，不是index++</span><br><span class="line">                    if (operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) &#123;</span><br><span class="line">                        &#x2F;&#x2F;如果后一位是运算符，则入栈 keepNum &#x3D; &quot;1&quot; 或者 &quot;123&quot;</span><br><span class="line">                        numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                        &#x2F;&#x2F;重要的!!!!!!, keepNum清空</span><br><span class="line">                        keepNum &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;让index + 1, 并判断是否扫描到expression最后.</span><br><span class="line">            index++;</span><br><span class="line">            if (index &gt;&#x3D; expression.length()) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果符号栈为空，则计算到最后的结果, 数栈中只有一个数字【结果】</span><br><span class="line">            if (operStack.isEmpty()) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            num1 &#x3D; numStack.pop();</span><br><span class="line">            num2 &#x3D; numStack.pop();</span><br><span class="line">            oper &#x3D; operStack.pop();</span><br><span class="line">            res &#x3D; numStack.cal(num1, num2, oper);</span><br><span class="line">            numStack.push(res);&#x2F;&#x2F;入栈</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将数栈的最后数，pop出，就是结果</span><br><span class="line">        int res2 &#x3D; numStack.pop();</span><br><span class="line">        System.out.printf(&quot;表达式 %s &#x3D; %d&quot;, expression, res2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;先创建一个栈,直接使用前面创建好</span><br><span class="line">&#x2F;&#x2F;定义一个 ArrayStack2 表示栈, 需要扩展功能</span><br><span class="line">class ArrayStack2 &#123;</span><br><span class="line">    private int maxSize; &#x2F;&#x2F; 栈的大小</span><br><span class="line">    private int[] stack; &#x2F;&#x2F; 数组，数组模拟栈，数据就放在该数组</span><br><span class="line">    private int top &#x3D; -1;&#x2F;&#x2F; top表示栈顶，初始化为-1</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造器</span><br><span class="line">    public ArrayStack2(int maxSize) &#123;</span><br><span class="line">        this.maxSize &#x3D; maxSize;</span><br><span class="line">        stack &#x3D; new int[this.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;增加一个方法，可以返回当前栈顶的值, 但是不是真正的pop</span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        return stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;栈满</span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        return top &#x3D;&#x3D; maxSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;栈空</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return top &#x3D;&#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;入栈-push</span><br><span class="line">    public void push(int value) &#123;</span><br><span class="line">        &#x2F;&#x2F;先判断栈是否满</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;栈满&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;出栈-pop, 将栈顶的数据返回</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        &#x2F;&#x2F;先判断栈是否空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            &#x2F;&#x2F;抛出异常</span><br><span class="line">            throw new RuntimeException(&quot;栈空，没有数据~&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int value &#x3D; stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;栈空，没有数据~~&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;需要从栈顶开始显示数据</span><br><span class="line">        for (int i &#x3D; top; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            System.out.printf(&quot;stack[%d]&#x3D;%d\n&quot;, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回运算符的优先级，优先级是程序员来确定, 优先级使用数字表示</span><br><span class="line">    &#x2F;&#x2F;数字越大，则优先级就越高.</span><br><span class="line">    public int priority(int oper) &#123;</span><br><span class="line">        if (oper &#x3D;&#x3D; &#39;*&#39; || oper &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else if (oper &#x3D;&#x3D; &#39;+&#39; || oper &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return -1; &#x2F;&#x2F; 假定目前的表达式只有 +, - , * , &#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断是不是一个运算符</span><br><span class="line">    public boolean isOper(char val) &#123;</span><br><span class="line">        return val &#x3D;&#x3D; &#39;+&#39; || val &#x3D;&#x3D; &#39;-&#39; || val &#x3D;&#x3D; &#39;*&#39; || val &#x3D;&#x3D; &#39;&#x2F;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;计算方法</span><br><span class="line">    public int cal(int num1, int num2, int oper) &#123;</span><br><span class="line">        int res &#x3D; 0; &#x2F;&#x2F; res 用于存放计算的结果</span><br><span class="line">        switch (oper) &#123;</span><br><span class="line">            case &#39;+&#39;:</span><br><span class="line">                res &#x3D; num1 + num2;</span><br><span class="line">                break;</span><br><span class="line">            case &#39;-&#39;:</span><br><span class="line">                res &#x3D; num2 - num1;&#x2F;&#x2F; 注意顺序</span><br><span class="line">                break;</span><br><span class="line">            case &#39;*&#39;:</span><br><span class="line">                res &#x3D; num1 * num2;</span><br><span class="line">                break;</span><br><span class="line">            case &#39;&#x2F;&#39;:</span><br><span class="line">                res &#x3D; num2 &#x2F; num1;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈对表达式求值的应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashSet</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/9%E3%80%81HashSet/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/9%E3%80%81HashSet/</url>
      
        <content type="html"><![CDATA[<ol><li>HashSet概述：<br>HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。</li><li>HashSet的实现：<br>对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，因此HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成，</li></ol><p>往HashSet添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值 ，<br>　　然后通过元素 的哈希值经过移位等运算，就可以算出该元素在哈希表中 的存储位置。</p><p>情况1： 如果算出元素存储的位置目前没有任何元素存储，那么该元素可以直接存储到该位置上。</p><p>情况2： 如果算出该元素的存储位置目前已经存在有其他的元素了，那么会调用该元素的equals方法与该位置的元素再比较一次，如果equals返回的是true，那么该元素与这个位置上的元素就视为重复元素，不允许添加，如果equals方法返回的是false，那么该元素运行添加。</p><p>HashSet的源代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt;</span><br><span class="line">   extends AbstractSet&lt;E&gt;</span><br><span class="line">   implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">   static final long serialVersionUID &#x3D; -5024744406713321676L;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 底层使用HashMap来保存HashSet中所有元素。</span><br><span class="line">   private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。</span><br><span class="line">   private static final Object PRESENT &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 默认的无参构造器，构造一个空的HashSet。</span><br><span class="line">    * </span><br><span class="line">    * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public HashSet() &#123;</span><br><span class="line"> map &#x3D; new HashMap&lt;E,Object&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 构造一个包含指定collection中的元素的新set。</span><br><span class="line">    *</span><br><span class="line">    * 实际底层使用默认的加载因子0.75和足以包含指定</span><br><span class="line">    * collection中所有元素的初始容量来创建一个HashMap。</span><br><span class="line">    * @param c 其中的元素将存放在此set中的collection。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line"> map &#x3D; new HashMap&lt;E,Object&gt;(Math.max((int) (c.size()&#x2F;.75f) + 1, 16));</span><br><span class="line"> addAll(c);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 以指定的initialCapacity和loadFactor构造一个空的HashSet。</span><br><span class="line">    *</span><br><span class="line">    * 实际底层以相应的参数构造一个空的HashMap。</span><br><span class="line">    * @param initialCapacity 初始容量。</span><br><span class="line">    * @param loadFactor 加载因子。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public HashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line"> map &#x3D; new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 以指定的initialCapacity构造一个空的HashSet。</span><br><span class="line">    *</span><br><span class="line">    * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。</span><br><span class="line">    * @param initialCapacity 初始容量。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public HashSet(int initialCapacity) &#123;</span><br><span class="line"> map &#x3D; new HashMap&lt;E,Object&gt;(initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。</span><br><span class="line">    * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。</span><br><span class="line">    *</span><br><span class="line">    * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。</span><br><span class="line">    * @param initialCapacity 初始容量。</span><br><span class="line">    * @param loadFactor 加载因子。</span><br><span class="line">    * @param dummy 标记。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line"> map &#x3D; new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。</span><br><span class="line">    * </span><br><span class="line">    * 底层实际调用底层HashMap的keySet来返回所有的key。</span><br><span class="line">    * 可见HashSet中的元素，只是存放在了底层HashMap的key上，</span><br><span class="line">    * value使用一个static final的Object对象标识。</span><br><span class="line">    * @return 对此set中元素进行迭代的Iterator。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line"> return map.keySet().iterator();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 返回此set中的元素的数量（set的容量）。</span><br><span class="line">    *</span><br><span class="line">    * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。</span><br><span class="line">    * @return 此set中的元素的数量（set的容量）。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public int size() &#123;</span><br><span class="line"> return map.size();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 如果此set不包含任何元素，则返回true。</span><br><span class="line">    *</span><br><span class="line">    * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。</span><br><span class="line">    * @return 如果此set不包含任何元素，则返回true。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public boolean isEmpty() &#123;</span><br><span class="line"> return map.isEmpty();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 如果此set包含指定元素，则返回true。</span><br><span class="line">    * 更确切地讲，当且仅当此set包含一个满足(o&#x3D;&#x3D;null ? e&#x3D;&#x3D;null : o.equals(e))</span><br><span class="line">    * 的e元素时，返回true。</span><br><span class="line">    *</span><br><span class="line">    * 底层实际调用HashMap的containsKey判断是否包含指定key。</span><br><span class="line">    * @param o 在此set中的存在已得到测试的元素。</span><br><span class="line">    * @return 如果此set包含指定元素，则返回true。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public boolean contains(Object o) &#123;</span><br><span class="line"> return map.containsKey(o);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 如果此set中尚未包含指定元素，则添加指定元素。</span><br><span class="line">    * 更确切地讲，如果此 set 没有包含满足(e&#x3D;&#x3D;null ? e2&#x3D;&#x3D;null : e.equals(e2))</span><br><span class="line">    * 的元素e2，则向此set 添加指定的元素e。</span><br><span class="line">    * 如果此set已包含该元素，则该调用不更改set并返回false。</span><br><span class="line">    *</span><br><span class="line">    * 底层实际将将该元素作为key放入HashMap。</span><br><span class="line">    * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key</span><br><span class="line">    * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true），</span><br><span class="line">    * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变，</span><br><span class="line">    * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中，</span><br><span class="line">    * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。</span><br><span class="line">    * @param e 将添加到此set中的元素。</span><br><span class="line">    * @return 如果此set尚未包含指定元素，则返回true。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public boolean add(E e) &#123;</span><br><span class="line"> return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 如果指定元素存在于此set中，则将其移除。</span><br><span class="line">    * 更确切地讲，如果此set包含一个满足(o&#x3D;&#x3D;null ? e&#x3D;&#x3D;null : o.equals(e))的元素e，</span><br><span class="line">    * 则将其移除。如果此set已包含该元素，则返回true</span><br><span class="line">    * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。</span><br><span class="line">    *</span><br><span class="line">    * 底层实际调用HashMap的remove方法删除指定Entry。</span><br><span class="line">    * @param o 如果存在于此set中则需要将其移除的对象。</span><br><span class="line">    * @return 如果set包含指定元素，则返回true。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public boolean remove(Object o) &#123;</span><br><span class="line"> return map.remove(o)&#x3D;&#x3D;PRESENT;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 从此set中移除所有元素。此调用返回后，该set将为空。</span><br><span class="line">    *</span><br><span class="line">    * 底层实际调用HashMap的clear方法清空Entry中所有元素。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public void clear() &#123;</span><br><span class="line"> map.clear();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。</span><br><span class="line">    *</span><br><span class="line">    * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public Object clone() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           HashSet&lt;E&gt; newSet &#x3D; (HashSet&lt;E&gt;) super.clone();</span><br><span class="line">           newSet.map &#x3D; (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">           return newSet;</span><br><span class="line">       &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">           throw new InternalError();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashSet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀疏数组 SparseArray</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1%E3%80%81%E6%95%B0%E7%BB%84/2%E3%80%81%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%20SparseArray/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1%E3%80%81%E6%95%B0%E7%BB%84/2%E3%80%81%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%20SparseArray/</url>
      
        <content type="html"><![CDATA[<p>稀疏数组：Android提供的一个工具类。</p><p> Android 开发中，我们可以使用 SparseArray 来实现更高效的实现 Map</p><p>SparseArray指的是稀疏数组，是Android中对HashMap的性能优化。所谓稀疏数组就是数组中的大部分的内容值都未被使用或者都为0，在数组中仅有少部分的空间使用。因此造成了内存空间的浪费，为了节省内存空间，并且不影响数组中原有的内容值，我们可以采用一种压缩的方式来表示稀疏数组的内容。</p><p>稀疏数组如何记录数据：</p><ul><li>记录数组一共有几行几列，有多少个不同的值</li><li>把具有不同值的元素的行列及值记录在一个小规模的数组(稀疏数组)中，从而缩小程序的规模</li></ul><p>如图将二维数组 转为稀疏数组（见笔记4）</p><p>源码实现：</p><h4 id="一、成员变量"><a href="#一、成员变量" class="headerlink" title="一、成员变量"></a>一、成员变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 删除操作时替换对应位置 value 的默认值</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static final Object DELETED &#x3D; new Object();</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 是否需要回收</span><br><span class="line"> *&#x2F;</span><br><span class="line">private boolean mGarbage &#x3D; false;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 存储 key 的数组</span><br><span class="line"> *&#x2F;</span><br><span class="line">private int[] mKeys;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 存储 value 的数组</span><br><span class="line"> *&#x2F;</span><br><span class="line">private Object[] mValues;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 当前存储的键值对数量</span><br><span class="line"> *&#x2F;</span><br><span class="line">private int mSize;</span><br></pre></td></tr></table></figure><h4 id="二、构造函数"><a href="#二、构造函数" class="headerlink" title="二、构造函数"></a>二、构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 创建一个空 map 初始容量为 10</span><br><span class="line"> *&#x2F;</span><br><span class="line">public SparseArray() &#123; this(10); &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 根据指定初始容量创建键值对为空的稀疏数组，并且不会申请额外内存；指定初始容量为 0 时会创建一个轻量级的不需要任何内存分配的稀疏数组</span><br><span class="line"> * capacity 容量</span><br><span class="line"> *&#x2F;</span><br><span class="line">public SparseArray(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        mKeys &#x3D; EmptyArray.INT; &#x2F;&#x2F; 长度为 0 的 int 类型数组</span><br><span class="line">        mValues &#x3D; EmptyArray.OBJECT; &#x2F;&#x2F; 长度为 0 的 Object 类型数组</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mValues &#x3D; ArrayUtils.newUnpaddedObjectArray(initialCapacity);</span><br><span class="line">        mKeys &#x3D; new int[mValues.length];</span><br><span class="line">    &#125;</span><br><span class="line">    mSize &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、添加-修改-操作"><a href="#三、添加-修改-操作" class="headerlink" title="三、添加/修改 操作"></a>三、添加/修改 操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">public void put(int key, E value) &#123;</span><br><span class="line">    int i &#x3D; ContainerHelpers.binarySearch(mKeys, mSize, key); &#x2F;&#x2F; 使用二分法查找对应的 key 在数组中的下标</span><br><span class="line"></span><br><span class="line">    if (i &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 索引大于等于 0 说明原数组中有对应 key</span><br><span class="line">        mValues[i] &#x3D; value; &#x2F;&#x2F; 则直接 Value 数组中的 value 值为最新的 value</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; 索引小于 0 说明原数组中不存在对应的 key</span><br><span class="line">        i &#x3D; ~i; &#x2F;&#x2F; 取反后得到当前 key 应该在的位置</span><br><span class="line"></span><br><span class="line">        if (i &lt; mSize &amp;&amp; mValues[i] &#x3D;&#x3D; DELETED) &#123; &#x2F;&#x2F; 如果数组长度够，并且当前位置已被回收则直接对该位置赋值</span><br><span class="line">            mKeys[i] &#x3D; key;</span><br><span class="line">            mValues[i] &#x3D; value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mGarbage &amp;&amp; mSize &gt;&#x3D; mKeys.length) &#123; &#x2F;&#x2F; 回收状态为 true 并且内容长度大于等于 key 数组长度</span><br><span class="line">            gc(); &#x2F;&#x2F; 回收，整理数组</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Search again because indices may have changed.</span><br><span class="line">            i &#x3D; ~ContainerHelpers.binarySearch(mKeys, mSize, key); &#x2F;&#x2F; 再次使用二分法查找位置</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mKeys &#x3D; GrowingArrayUtils.insert(mKeys, mSize, i, key); &#x2F;&#x2F; 执行 key 插入到 key 数组对应位置</span><br><span class="line">        mValues &#x3D; GrowingArrayUtils.insert(mValues, mSize, i, value); &#x2F;&#x2F; 执行 value 插入到 value 数组对应位置</span><br><span class="line">        mSize++; &#x2F;&#x2F; 键值对数量加 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ContainerHelpers </span><br><span class="line">static int binarySearch(int[] array, int size, int value) &#123;</span><br><span class="line">        int lo &#x3D; 0;</span><br><span class="line">        int hi &#x3D; size - 1;</span><br><span class="line"></span><br><span class="line">        while (lo &lt;&#x3D; hi) &#123;</span><br><span class="line">            final int mid &#x3D; (lo + hi) &gt;&gt;&gt; 1; &#x2F;&#x2F; 带符号右移，也就是做除以 2，这里是找到中间位置索引的操作</span><br><span class="line">            final int midVal &#x3D; array[mid]; </span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 下面是正常的二分法操作</span><br><span class="line">            if (midVal &lt; value) &#123;</span><br><span class="line">                lo &#x3D; mid + 1;</span><br><span class="line">            &#125; else if (midVal &gt; value) &#123;</span><br><span class="line">                hi &#x3D; mid - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return mid;  &#x2F;&#x2F; value found</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ~lo;  &#x2F;&#x2F; 当数组中不存在对应 value 的时候，这里是将如果数组中存在 value 时应该在的位置取反后返回</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">private void gc() &#123;</span><br><span class="line">    int n &#x3D; mSize; &#x2F;&#x2F; 键值对数量</span><br><span class="line">    int o &#x3D; 0;</span><br><span class="line">    int[] keys &#x3D; mKeys;</span><br><span class="line">    Object[] values &#x3D; mValues;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123; &#x2F;&#x2F; 通过循环将 value 数组中的 DELETED 值移除，并且 DELETED 以后的键跟值都往前补</span><br><span class="line">        Object val &#x3D; values[i];</span><br><span class="line"></span><br><span class="line">        if (val !&#x3D; DELETED) &#123;</span><br><span class="line">            if (i !&#x3D; o) &#123; &#x2F;&#x2F; 循环第一次执行时 i 和 o 都是 0 ，这种情况不需要处理</span><br><span class="line">                keys[o] &#x3D; keys[i];</span><br><span class="line">                values[o] &#x3D; val;</span><br><span class="line">                values[i] &#x3D; null; &#x2F;&#x2F; 原位置置空</span><br><span class="line">            &#125;</span><br><span class="line">            o++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mGarbage &#x3D; false; &#x2F;&#x2F; 回收状态置为 false</span><br><span class="line">    mSize &#x3D; o; &#x2F;&#x2F; 将键值对的值更新为实际的键值对数量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * GrowingArrayUtils 中定义了 泛型&#x2F;int&#x2F;long&#x2F;boolean 等类型数组在指定位置插入数据的方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static int[] insert(int[] array, int currentSize, int index, int element) &#123;</span><br><span class="line">    assert currentSize &lt;&#x3D; array.length;</span><br><span class="line"></span><br><span class="line">    if (currentSize + 1 &lt;&#x3D; array.length) &#123; &#x2F;&#x2F; 不需要扩容</span><br><span class="line">        System.arraycopy(array, index, array, index + 1, currentSize - index); &#x2F;&#x2F; 将对应位置后的内容右移</span><br><span class="line">        array[index] &#x3D; element;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 需要扩容，</span><br><span class="line">    int[] newArray &#x3D; new int[growSize(currentSize)];</span><br><span class="line">    System.arraycopy(array, 0, newArray, 0, index); &#x2F;&#x2F; 将对应位置前的内容插入</span><br><span class="line">    newArray[index] &#x3D; element; &#x2F;&#x2F; 将对应位置内容插入</span><br><span class="line">    System.arraycopy(array, index, newArray, index + 1, array.length - index); &#x2F;&#x2F; 将对应位置后的内容插入</span><br><span class="line">    return newArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * GrowingArrayUtils 中定义了 泛型&#x2F;int&#x2F;long&#x2F;boolean 等类型数组在指定位置插入数据的方法，这个方法的作用为，在位置超出数组大小时，计算扩容后数组的新长度</span><br><span class="line"> * 旧数组长度小于 4 则设置为 8，否则都是在当前长度基础上扩容一被</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static int growSize(int currentSize) &#123;</span><br><span class="line">    return currentSize &lt;&#x3D; 4 ? 8 : currentSize * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="查找方法-get-int-key"><a href="#查找方法-get-int-key" class="headerlink" title="查找方法 get(int key)"></a>查找方法 get(int key)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public E get(int key) &#123;</span><br><span class="line">    return get(key, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 根据 key 查找 value ，如果 key 不存在则返回指定的默认值</span><br><span class="line"> *&#x2F;</span><br><span class="line">public E get(int key, E valueIfKeyNotFound) &#123;</span><br><span class="line">    int i &#x3D; ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    if (i &lt; 0 || mValues[i] &#x3D;&#x3D; DELETED) &#123;</span><br><span class="line">        return valueIfKeyNotFound;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (E) mValues[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="五、删除方法-delete-int-key"><a href="#五、删除方法-delete-int-key" class="headerlink" title="五、删除方法 delete(int key)"></a>五、删除方法 delete(int key)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 删除操作</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void delete(int key) &#123;</span><br><span class="line">    int i &#x3D; ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    if (i &gt;&#x3D; 0) &#123;</span><br><span class="line">        if (mValues[i] !&#x3D; DELETED) &#123;</span><br><span class="line">            mValues[i] &#x3D; DELETED;</span><br><span class="line">            mGarbage &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E removeReturnOld(int key) &#123;</span><br><span class="line">    int i &#x3D; ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    if (i &gt;&#x3D; 0) &#123;</span><br><span class="line">        if (mValues[i] !&#x3D; DELETED) &#123;</span><br><span class="line">            final E old &#x3D; (E) mValues[i];</span><br><span class="line">            mValues[i] &#x3D; DELETED;</span><br><span class="line">            mGarbage &#x3D; true;</span><br><span class="line">            return old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 删除指定位置的值</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void removeAt(int index) &#123;</span><br><span class="line">    if (mValues[index] !&#x3D; DELETED) &#123;</span><br><span class="line">        mValues[index] &#x3D; DELETED;</span><br><span class="line">        mGarbage &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 以 index 开始，删除之后 size 个值，包含 index 位置，不包含 index + size</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void removeAtRange(int index, int size) &#123;</span><br><span class="line">    final int end &#x3D; Math.min(mSize, index + size);</span><br><span class="line">    for (int i &#x3D; index; i &lt; end; i++) &#123;</span><br><span class="line">        removeAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他方法略</p><p>总结：</p><p>SparseArray 的代码非常少，只有 450 行左右，并且特别易于理解。但 SparseArray 要比 HashMap 更加高效，在 Android 手机中，如果 key 为 int 类型的 Map 数据，最好使用 SparseArray 来实现。</p>]]></content>
      
      
      <categories>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 稀疏数组 SparseArray </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81String/String/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81String/String/</url>
      
        <content type="html"><![CDATA[<p>==在String中，其实最底层的实现就是通过一个final char value[] 来保存String字符串的，所有的方法操作都是对char[]的操作==</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line"></span><br><span class="line">    private final char value[];</span><br><span class="line"></span><br><span class="line">    private int hash; </span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; -6849794470754667710L;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><ul><li><p>java.io.Serializable这个序列化接口没有任何方法和域，仅用于标识序列化的语意。</p></li><li><p>Comparable<String>这个接口只有一个compareTo(T 0)接口，用于对两个实例化对象比较大小。</p></li><li><p>CharSequence这个接口是一个只读的字符序列。包括length(), charAt(int index), subSequence(int start, int end)这几个API接口，值得一提的是，StringBuffer和StringBuild也是实现了改接口。</p></li></ul><ul><li><p>value[]是存储String的内容的，即当使用String str = “abc”;的时候，本质上，”abc”是存储在一个char类型的数组中的。</p></li><li><p>hash是String实例化的hashcode的一个缓存。因为String经常被用于比较，比如在HashMap中。如果每次进行比较都重新计算hashcode的值的话，那无疑是比较麻烦的，而保存一个hashcode的缓存无疑能优化这样的操作。</p></li></ul><h2 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public String() &#123;</span><br><span class="line">    this.value &#x3D; &quot;&quot;.value;</span><br><span class="line">&#125;</span><br><span class="line">public String(String original) &#123;</span><br><span class="line">    this.value &#x3D; original.value;</span><br><span class="line">    this.hash &#x3D; original.hash;</span><br><span class="line">&#125;</span><br><span class="line">public String(char value[]) &#123;</span><br><span class="line">    this.value &#x3D; Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br><span class="line">public String(char value[], int offset, int count) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public String(int[] codePoints, int offset, int count) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">@Deprecated</span><br><span class="line">public String(byte ascii[], int hibyte, int offset, int count) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">public String(byte ascii[], int hibyte) &#123;</span><br><span class="line">    this(ascii, hibyte, 0, ascii.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因此String s=new String();创建的一个空 “”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String() &#123;</span><br><span class="line">    this.value &#x3D; &quot;&quot;.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String支持多种初始化方法，包括接收String，char[],byte[],StringBuffer等多种参数类型的初始化方法。但本质上，其实就是将接收到的参数传递给全局变量value[]。</p><h2 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int length() &#123;</span><br><span class="line">        return value.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return value.length &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public char charAt(int index) &#123;</span><br><span class="line">        if ((index &lt; 0) || (index &gt;&#x3D; value.length)) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(index);</span><br><span class="line">        &#125;</span><br><span class="line">        return value[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>知道了String其实内部是通过char[]实现的，那么就不难发现length()，isEmpty()，charAt()这些方法其实就是在内部调用数组的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取当前字符串的二进制</span><br><span class="line">    public void getBytes(int srcBegin, int srcEnd, byte dst[], int dstBegin) &#123;</span><br><span class="line">        if (srcBegin &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">        &#125;</span><br><span class="line">        if (srcEnd &gt; value.length) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        if (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">        &#125;</span><br><span class="line">        Objects.requireNonNull(dst);</span><br><span class="line"></span><br><span class="line">        int j &#x3D; dstBegin;</span><br><span class="line">        int n &#x3D; srcEnd;</span><br><span class="line">        int i &#x3D; srcBegin;</span><br><span class="line">        char[] val &#x3D; value;   &#x2F;* avoid getfield opcode *&#x2F;</span><br><span class="line"></span><br><span class="line">        while (i &lt; n) &#123;</span><br><span class="line">            dst[j++] &#x3D; (byte)val[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public byte[] getBytes(String charsetName)</span><br><span class="line">            throws UnsupportedEncodingException &#123;</span><br><span class="line">        if (charsetName &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        return StringCoding.encode(charsetName, value, 0, value.length);</span><br><span class="line">    &#125;</span><br><span class="line">　　</span><br><span class="line">　　public byte[] getBytes() &#123;</span><br><span class="line">    　　return StringCoding.encode(value, 0, value.length);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>将String字符串转成二进制的几种方式，可以指定byte数组，也能让其返回一个byte数组。本质上，其实都是调用了StringCoding.encode()这个静态方法</p><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p> hashCode()和equals()两个方法比较重要且有所关系就放一起了，equals()是string能成为广泛用于Map[key,value]中key的关键所在。</p><p>==equals逻辑==：</p><ul><li>1、先判断是否是当前对象，</li><li>2、判断字符串（char数组）长度是否相等</li><li>3、遍历char[],判断每个char字符是否相等</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">        if (this &#x3D;&#x3D; anObject) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (anObject instanceof String) &#123;</span><br><span class="line">            String anotherString &#x3D; (String)anObject;</span><br><span class="line">            int n &#x3D; value.length;</span><br><span class="line">            if (n &#x3D;&#x3D; anotherString.value.length) &#123;</span><br><span class="line">                char v1[] &#x3D; value;</span><br><span class="line">                char v2[] &#x3D; anotherString.value;</span><br><span class="line">                int i &#x3D; 0;</span><br><span class="line">                while (n-- !&#x3D; 0) &#123;</span><br><span class="line">                    if (v1[i] !&#x3D; v2[i])</span><br><span class="line">                        return false;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">        int h &#x3D; hash;</span><br><span class="line">        if (h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">            char val[] &#x3D; value;</span><br><span class="line"></span><br><span class="line">            for (int i &#x3D; 0; i &lt; value.length; i++) &#123;</span><br><span class="line">                h &#x3D; 31 * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash &#x3D; h;</span><br><span class="line">        &#125;</span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在String中，其实最底层的实现就是通过一个final char value[] 来保存String字符串的，所有的方法操作都是对char[]的操作，抓住这一点，其实很多设计方法，方法的实现方式就显而易见了。</p><p>==细节==：<br>string.intern</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">判断这个常量是否存在于常量池。</span><br><span class="line">  如果存在</span><br><span class="line">   判断存在内容是引用还是常量，</span><br><span class="line">    如果是引用，</span><br><span class="line">     返回引用地址指向堆空间对象，</span><br><span class="line">    如果是常量，</span><br><span class="line">     直接返回常量池常量</span><br><span class="line">  如果不存在，</span><br><span class="line">   将当前对象引用复制到常量池,并且返回的是当前对象的引用</span><br></pre></td></tr></table></figure><p>jdk1.7之前，字符串常量存储在方法区的PermGen Space</p><p>在jdk1.7之后，字符串常量重新被移到了堆中。</p><h3 id="字符串拼接-和concat的区别"><a href="#字符串拼接-和concat的区别" class="headerlink" title="字符串拼接+和concat的区别"></a>字符串拼接+和concat的区别</h3><ul><li>+可以是字符串或者数字及其他基本类型数据，而concat只能接收字符串。<br>如果拼接空字符串，concat会稍快，在速度上两者可以忽略不计，如果拼接更多字符串建议用StringBuilder</li><li>从字节码来看+号编译后就是使用了StringBuiler来拼接，所以一行+++的语句就会创建一个StringBuilder，多条+++语句就会创建多个，所以为什么建议用StringBuilder的原因。</li><li>+左右可以为null，concat为会空指针。</li><li>申明赋值的String与new String();的区别：<br>String a=”aa”;是再常量池中创建一个aa的字符串<br>String a=new String(“aa”);是创建一个String的应用类型等式右半边存放与堆区。在栈区中的a指向堆区的引用地址。</li></ul>]]></content>
      
      
      <categories>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发三大利器：限流</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84%E7%AD%96%E7%95%A5/2%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%89%E5%A4%A7%E5%88%A9%E5%99%A8%EF%BC%9A%E9%99%90%E6%B5%81/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84%E7%AD%96%E7%95%A5/2%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%89%E5%A4%A7%E5%88%A9%E5%99%A8%EF%BC%9A%E9%99%90%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>有些时候，缓存和降级是解决不了问题的，比如，电商的双十一，用户的购买，下单等行为，是涉及到大量写操作，而且是核心链路，无法降级的。</p><ul><li>缓存:将数据缓存起来，减少数据库压力，保护DB和磁盘IO</li><li>降级:保护核心系统/服务，降低非核心系统业务请求响应，防止请求积压过多引发系统崩溃</li><li>限流:在某一时间段内或者某常规时间对请求进行限制访问，保护系统</li></ul><h4 id="一、在哪些节点做访问限流"><a href="#一、在哪些节点做访问限流" class="headerlink" title="一、在哪些节点做访问限流"></a>一、在哪些节点做访问限流</h4><p>网关、接口</p><h4 id="二、限流的方式【两窗两桶】"><a href="#二、限流的方式【两窗两桶】" class="headerlink" title="二、限流的方式【两窗两桶】"></a>二、限流的方式【两窗两桶】</h4><h5 id="1、固定时间窗口-计数器算法"><a href="#1、固定时间窗口-计数器算法" class="headerlink" title="1、固定时间窗口-计数器算法"></a>1、固定时间窗口-计数器算法</h5><p>计数器算法是限流算法里最简单也是最容易实现的一种算法。计数器算法是使用计数器在周期内累加访问次数，当达到设定的限流值时，触发限流策略。下一个周期开始时，进行清零，重新计数。【redis的incr原子自增性和线程安全即可轻松实现。】</p><p>计数器算法是限流算法里最简单也是最容易实现的一种算法。比如我们规定，对于A接口来说，我们1分钟的访问次数不能超过100个。那么我们可以这么做：在一开 始的时候，我们可以设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个 请求的间隔时间还在1分钟之内，那么说明请求数过多；如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置 counter</p><p>致命的临界问题</p><p>假设有一个恶意用户，他在0:59时，瞬间发送了100个请求，并且1:00又瞬间发送了100个请求，那么其实这个用户在 1秒里面，瞬间发送了200个请求。我们刚才规定的是1分钟最多100个请求，也就是每秒钟最多1.7个请求，用户通过在时间窗口的重置节点处突发请求， 可以瞬间超过我们的速率限制。用户有可能通过算法的这个漏洞，瞬间压垮我们的应用</p><h5 id="2、滑动时间窗口-计数器算法"><a href="#2、滑动时间窗口-计数器算法" class="headerlink" title="2、滑动时间窗口-计数器算法"></a>2、滑动时间窗口-计数器算法</h5><p>固定窗口就像是滑动窗口的一个特例。滑动窗口将固定窗口再等分为多个小的窗口，每一次对一个小的窗口进行流量控制。这种方法可以很好的解决之前的临界问题。</p><p>假设我们将1s划分为4个窗口，则每个窗口对应250ms。假设恶意用户还是在上一秒的最后一刻和下一秒的第一刻冲击服务，按照滑动窗口的原理，此时统计上一秒的最后750毫秒和下一秒的前250毫秒，这种方式能够判断出用户的访问依旧超过了1s的访问数量，因此依然会阻拦用户的访问。</p><h5 id="2、漏桶算法"><a href="#2、漏桶算法" class="headerlink" title="2、漏桶算法"></a>2、漏桶算法</h5><p>当请求到达时，就是往漏桶里“加水”，而当请求被处理掉，就是水从漏桶的底部漏出。水漏出的速度是固定的，当“加水”太快，桶就会溢出，也就是“拒绝请求”。从而使得桶里的水的体积不可能超出桶的容量。</p><p>该算法存在三个变量：桶的容量capacity，水漏出的速度rate，以及当前的水量water。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">long timeStamp&#x3D;getNowTime();</span><br><span class="line">int capacity; &#x2F;&#x2F; 桶的容量</span><br><span class="line">int rate ; &#x2F;&#x2F;水漏出的速度</span><br><span class="line">int water; &#x2F;&#x2F;当前水量</span><br><span class="line"></span><br><span class="line">bool limitFlow() &#123;</span><br><span class="line">  &#x2F;&#x2F;先执行漏水，因为rate是固定的，所以可以认为“时间间隔*rate”即为漏出的水量</span><br><span class="line">  long now &#x3D; getNowTime();</span><br><span class="line">  water &#x3D; max(0, water- (now - timeStamp)*rate);</span><br><span class="line">  timeStamp &#x3D; now;</span><br><span class="line"></span><br><span class="line">  if (water &lt; capacity) &#123; &#x2F;&#x2F; 水还未满，加水</span><br><span class="line">    water ++;</span><br><span class="line">    return true;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return false;&#x2F;&#x2F;水满，拒绝加水</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、令牌桶算法"><a href="#3、令牌桶算法" class="headerlink" title="3、令牌桶算法"></a>3、令牌桶算法</h5><p>令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。从原理上看，令牌桶算法和漏桶算法是相反的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">long timeStamp&#x3D;getNowTime();</span><br><span class="line">int capacity; &#x2F;&#x2F; 桶的容量</span><br><span class="line">int rate ; &#x2F;&#x2F;令牌放入速度</span><br><span class="line">int tokens; &#x2F;&#x2F;当前水量</span><br><span class="line"></span><br><span class="line">bool limitFlow() &#123;</span><br><span class="line">  &#x2F;&#x2F;先执行添加令牌的操作</span><br><span class="line">  long now &#x3D; getNowTime();</span><br><span class="line">  tokens &#x3D; max(capacity, tokens+ (now - timeStamp)*rate);</span><br><span class="line">  timeStamp &#x3D; now;</span><br><span class="line">  &#x2F;&#x2F;令牌已用完，拒绝访问</span><br><span class="line">  if(tokens&lt;1)&#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;else&#123;&#x2F;&#x2F;还有令牌，领取令牌</span><br><span class="line">    tokens--;</span><br><span class="line">    retun true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Google开源工具包Guava提供了限流工具类RateLimiter，该类基于令牌桶算法来完成限流，非常易于使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;26.0-jre&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;预估数据库能承受并发10，超过了可能会造成故障，我们就可以对该请求接口进行限流。</span><br><span class="line">RateLimiter rateLimiter &#x3D; RateLimiter.create(10);  </span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;&#x2F;test&quot;)  </span><br><span class="line">public Object test() &#123;  </span><br><span class="line">    &#x2F;&#x2F;rateLimiter.acquire()该方法会阻塞线程，直到令牌桶中能取到令牌为止才继续向下执行，并返回等待的时间。</span><br><span class="line">     System.out.println(&quot;等待时间&quot; + rateLimiter.acquire());  </span><br><span class="line">&#x2F;&#x2F;处理购买逻辑 ...</span><br><span class="line"></span><br><span class="line">return &quot;购买成功&quot;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">acquire()</span><br><span class="line">从RateLimiter获取一个许可，该方法会被阻塞直到获取到请求</span><br><span class="line"></span><br><span class="line">acquire(int permits)</span><br><span class="line">从RateLimiter获取指定许可数，该方法会被阻塞直到获取到请求</span><br><span class="line"></span><br><span class="line">create(double permitsPerSecond)</span><br><span class="line">根据指定的稳定吞吐率创建RateLimiter，这里的吞吐率是指每秒多少许可数（通常是指QPS，每秒多少查询）</span><br><span class="line"></span><br><span class="line">create(double permitsPerSecond, long warmupPeriod, TimeUnit unit)</span><br><span class="line">根据指定的稳定吞吐率和预热期来创建RateLimiter，这里的吞吐率是指每秒多少许可数（通常是指QPS，每秒多少个请求量），在这段预热时间内，RateLimiter每秒分配的许可数会平稳地增长直到预热期结束时达到其最大速率。（只要存在足够请求数来使其饱和）</span><br><span class="line"></span><br><span class="line">getRate()</span><br><span class="line">返回RateLimiter 配置中的稳定速率，该速率单位是每秒多少许可数</span><br><span class="line"></span><br><span class="line">setRate(double permitsPerSecond)</span><br><span class="line">更新RateLimite的稳定速率，参数permitsPerSecond 由构造RateLimiter的工厂方法提供。</span><br><span class="line"></span><br><span class="line">tryAcquire()</span><br><span class="line">从RateLimiter 获取许可，如果该许可可以在无延迟下的情况下立即获取得到的话</span><br><span class="line"></span><br><span class="line">tryAcquire(int permits)</span><br><span class="line">从RateLimiter 获取许可数，如果该许可数可以在无延迟下的情况下立即获取得到的话</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tryAcquire(int permits, long timeout, TimeUnit unit)</span><br><span class="line">从RateLimiter 获取指定许可数如果该许可数可以在不超过timeout的时间内获取得到的话，或者如果无法在timeout 过期之前获取得到许可数的话，那么立即返回false （无需等待）</span><br><span class="line"></span><br><span class="line">tryAcquire(long timeout, TimeUnit unit)</span><br><span class="line">从RateLimiter 获取许可如果该许可可以在不超过timeout的时间内获取得到的话，或者如果无法在timeout 过期之前获取得到许可的话，那么立即返回false（无需等待）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 高并发架构策略 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发三大利器：限流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/10%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/10%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>我们在字符串 A 中查找字符串 B，那字符串 A 就是主串，字符串 B 就是模式串。我们把主串的长度记作 n，模式串的长度记作 m。因为我们是在主串中查找模式串，所以 n&gt;m。</p><h2 id="BF（暴力匹配算法、朴素算法）O-n-m"><a href="#BF（暴力匹配算法、朴素算法）O-n-m" class="headerlink" title="BF（暴力匹配算法、朴素算法）O(n*m)"></a>BF（暴力匹配算法、朴素算法）O(n*m)</h2><p>在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class ViolenceMatch &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">&#x2F;&#x2F;测试暴力匹配算法</span><br><span class="line">String str1 &#x3D; &quot;aaabbaaaccssdd&quot;;</span><br><span class="line">String str2 &#x3D; &quot;acc&quot;;</span><br><span class="line">int index &#x3D; violenceMatch(str1, str2);</span><br><span class="line">System.out.println(&quot;index&#x3D;&quot; + index);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 暴力匹配算法实现</span><br><span class="line">public static int violenceMatch(String str1, String str2) &#123;</span><br><span class="line">char[] s1 &#x3D; str1.toCharArray();</span><br><span class="line">char[] s2 &#x3D; str2.toCharArray();</span><br><span class="line"></span><br><span class="line">int s1Len &#x3D; s1.length;</span><br><span class="line">int s2Len &#x3D; s2.length;</span><br><span class="line"></span><br><span class="line">int i &#x3D; 0; &#x2F;&#x2F; i索引指向s1</span><br><span class="line">int j &#x3D; 0; &#x2F;&#x2F; j索引指向s2</span><br><span class="line">while (i &lt; s1Len &amp;&amp; j &lt; s2Len) &#123;&#x2F;&#x2F; 保证匹配时，不越界</span><br><span class="line"></span><br><span class="line">if(s1[i] &#x3D;&#x3D; s2[j]) &#123;&#x2F;&#x2F;匹配ok</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125; else &#123; &#x2F;&#x2F;没有匹配成功</span><br><span class="line">&#x2F;&#x2F;如果失配（即str1[i]! &#x3D; str2[j]），令i &#x3D; i - (j - 1)，j &#x3D; 0。</span><br><span class="line">i &#x3D; i - (j - 1);</span><br><span class="line">j &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断是否匹配成功</span><br><span class="line">if(j &#x3D;&#x3D; s2Len) &#123;</span><br><span class="line">return i - j;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="RK算法-O-n-：-是BF算法的升级版引入hash算法用于字符串的比较"><a href="#RK算法-O-n-：-是BF算法的升级版引入hash算法用于字符串的比较" class="headerlink" title="RK算法 O(n)： 是BF算法的升级版引入hash算法用于字符串的比较"></a>RK算法 O(n)： 是BF算法的升级版引入hash算法用于字符串的比较</h2><p>在BF算法中，如果模式串长度为 m，主串长度为 n，那在主串中，就会有 n-m+1 个长度为 m 的子串，我们只需要暴力地对比这 n-m+1 个子串与模式串，就可以找出主串与模式串匹配的子串。但是，每次检查主串与子串是否匹配，需要依次比对每个字符，时间复杂较高O(n*m )</p><p>我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值是否相等（数字比较效率优于字符串的比较）只是比较的效率提高 整体的效率还是一样。</p><p>hash算法的设计就很重要:==假设要匹配的字符串的字符集中只包含 K 个字符，我们可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。==</p><h2 id="BM算法："><a href="#BM算法：" class="headerlink" title="BM算法："></a>BM算法：</h2><p>我们把模式串和主串的匹配过程，看作模式串在主串中不停地往后滑动。当遇到不匹配的字符时，BF 算法和 RK 算法的做法是，模式串往后滑动一位，然后从模式串的第一个字符开始重新匹配。<br><img src="https://static001.geekbang.org/resource/image/43/f9/4316dd98eac500a01a0fd632bb5e77f9.jpg" alt="image"></p><p>主串中的 c，在模式串中是不存在的，所以，模式串向后滑动的时候，只要 c 与模式串有重合，肯定无法匹配。所以，我们可以一次性把模式串往后多滑动几位，把模式串移动到 c 的后面。到底将模式串往后多滑动几位呢， BM算法的本质就是寻找这个规律。</p><p>模式串的末尾往前倒着匹配，当我们发现某个字符没法匹配的时候。我们把这个没有匹配的字符叫作坏字符（主串中的字符）。</p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p><a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html">https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class KMPAlgorithm &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">String str1 &#x3D; &quot;BBC ABCDAB ABCDABCDABDE&quot;;</span><br><span class="line">String str2 &#x3D; &quot;ABCDABD&quot;;</span><br><span class="line">&#x2F;&#x2F;String str2 &#x3D; &quot;BBC&quot;;</span><br><span class="line"></span><br><span class="line">int[] next &#x3D; kmpNext(&quot;ABCDABD&quot;); &#x2F;&#x2F;[0, 1, 2, 0]</span><br><span class="line">System.out.println(&quot;next&#x3D;&quot; + Arrays.toString(next));</span><br><span class="line"></span><br><span class="line">int index &#x3D; kmpSearch(str1, str2, next);</span><br><span class="line">System.out.println(&quot;index&#x3D;&quot; + index); &#x2F;&#x2F; 15了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;写出我们的kmp搜索算法</span><br><span class="line">&#x2F;**</span><br><span class="line"> * </span><br><span class="line"> * @param str1 源字符串</span><br><span class="line"> * @param str2 子串</span><br><span class="line"> * @param next 部分匹配表, 是子串对应的部分匹配表</span><br><span class="line"> * @return 如果是-1就是没有匹配到，否则返回第一个匹配的位置</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static int kmpSearch(String str1, String str2, int[] next) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;遍历 </span><br><span class="line">for(int i &#x3D; 0, j &#x3D; 0; i &lt; str1.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;需要处理 str1.charAt(i) ！&#x3D; str2.charAt(j), 去调整j的大小</span><br><span class="line">&#x2F;&#x2F;KMP算法核心点, 可以验证...</span><br><span class="line">while( j &gt; 0 &amp;&amp; str1.charAt(i) !&#x3D; str2.charAt(j)) &#123;</span><br><span class="line">j &#x3D; next[j-1]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(str1.charAt(i) &#x3D;&#x3D; str2.charAt(j)) &#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">if(j &#x3D;&#x3D; str2.length()) &#123;&#x2F;&#x2F;找到了 &#x2F;&#x2F; j &#x3D; 3 i </span><br><span class="line">return i - j + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return  -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取到一个字符串(子串) 的部分匹配值表</span><br><span class="line">public static  int[] kmpNext(String dest) &#123;</span><br><span class="line">&#x2F;&#x2F;创建一个next 数组保存部分匹配值</span><br><span class="line">int[] next &#x3D; new int[dest.length()];</span><br><span class="line">next[0] &#x3D; 0; &#x2F;&#x2F;如果字符串是长度为1 部分匹配值就是0</span><br><span class="line">for(int i &#x3D; 1, j &#x3D; 0; i &lt; dest.length(); i++) &#123;</span><br><span class="line">&#x2F;&#x2F;当dest.charAt(i) !&#x3D; dest.charAt(j) ，我们需要从next[j-1]获取新的j</span><br><span class="line">&#x2F;&#x2F;直到我们发现 有  dest.charAt(i) &#x3D;&#x3D; dest.charAt(j)成立才退出</span><br><span class="line">&#x2F;&#x2F;这时kmp算法的核心点</span><br><span class="line">while(j &gt; 0 &amp;&amp; dest.charAt(i) !&#x3D; dest.charAt(j)) &#123;</span><br><span class="line">j &#x3D; next[j-1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当dest.charAt(i) &#x3D;&#x3D; dest.charAt(j) 满足时，部分匹配值就是+1</span><br><span class="line">if(dest.charAt(i) &#x3D;&#x3D; dest.charAt(j)) &#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">next[i] &#x3D; j;</span><br><span class="line">&#125;</span><br><span class="line">return next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多模式串匹配：AC自动机"><a href="#多模式串匹配：AC自动机" class="headerlink" title="多模式串匹配：AC自动机"></a>多模式串匹配：AC自动机</h2><p>BF 算法、RK 算法、BM 算法、KMP 算法，还有 Trie 树。前面四种算法都是单模式串匹配算法，只有 Trie 树是多模式串匹配算法。</p><p>多个模式串和一个主串之间做匹配。</p><p>将模式串作为主串，从第一个字符（假设是字符 C）开始，在 Trie 树中匹配。当匹配到 Trie 树的叶子节点，或者中途遇到不匹配字符的时候，我们将主串的开始匹配位置后移一位，也就是从字符 C 的下一个字符开始，重新在 Trie 树中匹配。</p><p>基于 Trie 树的这种处理方法，有点类似单模式串匹配的 BF 算法。我们知道，单模式串匹配算法中，KMP 算法对 BF 算法进行改进，引入了 next 数组，让匹配失败时，尽可能将模式串往后多滑动几位。借鉴单模式串的优化改进方法，能否对多模式串 Trie 树进行改进，进一步提高 Trie 树的效率呢？这就要用到 AC 自动机算法了。</p><p>==AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class AcNode &#123;</span><br><span class="line">  public char data; </span><br><span class="line">  public AcNode[] children &#x3D; new AcNode[26]; &#x2F;&#x2F; 字符集只包含 a~z 这 26 个字符</span><br><span class="line">  public boolean isEndingChar &#x3D; false; &#x2F;&#x2F; 结尾字符为 true</span><br><span class="line">  public int length &#x3D; -1; &#x2F;&#x2F; 当 isEndingChar&#x3D;true 时，记录模式串长度</span><br><span class="line">  public AcNode fail; &#x2F;&#x2F; 失败指针</span><br><span class="line">  public AcNode(char data) &#123;</span><br><span class="line">    this.data &#x3D; data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>AC 自动机的构建，包含两个操作：</p><ul><li>将多个模式串构建成 Trie 树；</li><li>在 Trie 树上构建失败指针（相当于 KMP 中的失效函数 next 数组）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/10%E3%80%81%E5%8F%8D%E5%B0%84/1%E3%80%81%E5%8F%8D%E5%B0%84/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/10%E3%80%81%E5%8F%8D%E5%B0%84/1%E3%80%81%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>Java反射机制可以在运行期(Runtime)检查类，接口，变量以及方法的信息。反射还可以在运行期实例化对象，调用方法，通过调用get/set方法获取变量的值。</p><h3 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h3><p>检查一个类的信息之前，你首先需要获取类的Class对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class myObjectClass &#x3D; MyObject.class;</span><br><span class="line">&#x2F;&#x2F;在运行期获取的类名字符串</span><br><span class="line">String className &#x3D; ... ;</span><br><span class="line">Class class &#x3D; Class.forName(className);</span><br></pre></td></tr></table></figure><h3 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h3><p>获取全类名（含包名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass &#x3D; ... </span><br><span class="line">String className &#x3D; aClass.getName();</span><br></pre></td></tr></table></figure><p>获取类名（不含包名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass &#x3D; ...</span><br><span class="line">String simpleClassName &#x3D; aClass.getSimpleName();</span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class  aClass &#x3D; ... </span><br><span class="line">int modifiers &#x3D; aClass.getModifiers();</span><br></pre></td></tr></table></figure><p>一个类的修饰符，即public,private,static等等的关键字，每个修饰符都是一个位标识(flag bit)，可以使用java.lang.reflect.Modifier类中的方法来检查修饰符的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Modifier.isAbstract(int modifiers);</span><br><span class="line">Modifier.isFinal(int modifiers);</span><br><span class="line">Modifier.isInterface(int modifiers);</span><br><span class="line">Modifier.isNative(int modifiers);</span><br><span class="line">Modifier.isPrivate(int modifiers);</span><br><span class="line">Modifier.isProtected(int modifiers);</span><br><span class="line">Modifier.isPublic(int modifiers);</span><br><span class="line">Modifier.isStatic(int modifiers);</span><br><span class="line">Modifier.isStrict(int modifiers);</span><br><span class="line">Modifier.isSynchronized(int modifiers);</span><br><span class="line">Modifier.isTransient(int modifiers);</span><br><span class="line">Modifier.isVolatile(int modifiers);</span><br></pre></td></tr></table></figure><h3 id="包信息"><a href="#包信息" class="headerlink" title="包信息"></a>包信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Package package &#x3D; aClass.getPackage();</span><br></pre></td></tr></table></figure><h3 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h3><p>可以继续在父类对象上进行反射操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class superclass &#x3D; aClass.getSuperclass();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现的接口"><a href="#实现的接口" class="headerlink" title="实现的接口"></a>实现的接口</h3><p>由于一个类可以实现多个接口，因此getInterfaces();方法返回一个Class数组，在Java中接口同样有对应的Class对象。（当前类的父类如果实现了接口，这些接口是不会在返回的Class集合中的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class[] interfaces &#x3D; aClass.getInterfaces();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>Constructor数组包含每一个声明为公有的（Public）构造方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] constructors &#x3D; aClass.getConstructors();</span><br></pre></td></tr></table></figure><p>返回参数为String类型的构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class aClass &#x3D; ...&#x2F;&#x2F;获取Class对象</span><br><span class="line">Constructor constructor &#x3D;</span><br><span class="line">      aClass.getConstructor(new Class[]&#123;String.class&#125;);</span><br></pre></td></tr></table></figure><p>Constructor对象实例化一个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor &#x3D; MyObject.class.getConstructor(String.class);</span><br><span class="line">MyObject myObject &#x3D; (MyObject)</span><br><span class="line">       constructor.newInstance(&quot;constructor-arg1&quot;);</span><br></pre></td></tr></table></figure><p>constructor.newInstance()方法的方法参数是一个==可变参数==列表，但是当你调用构造方法的时候你必须提供精确的参数，即形参与实参必须一一对应。在这个例子中构造方法需要一个String类型的参数，那我们在调用newInstance方法的时候就必须传入一个String类型的参数。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Field对象数组包含了指定类中声明为公有的(public)的所有变量集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field[] method &#x3D; aClass.getFields();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">获取指定的变量：</span><br><span class="line">Class  aClass &#x3D; MyObject.class</span><br><span class="line">Field field &#x3D; aClass.getField(&quot;someField&quot;); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变量名称</span><br><span class="line">String fieldName &#x3D; field.getName();</span><br><span class="line">&#x2F;&#x2F;变量类型</span><br><span class="line">Field field &#x3D; aClass.getField(&quot;someField&quot;);</span><br><span class="line">Object fieldType &#x3D; field.getType();</span><br><span class="line">&#x2F;&#x2F;获取或设置（get&#x2F;set）变量值</span><br><span class="line">Class  aClass &#x3D; MyObject.class</span><br><span class="line">Field field &#x3D; aClass.getField(&quot;someField&quot;);</span><br><span class="line"></span><br><span class="line">MyObject objectInstance &#x3D; new MyObject();</span><br><span class="line"></span><br><span class="line">Object value &#x3D; field.get(objectInstance);</span><br><span class="line"></span><br><span class="line">field.set(objetInstance, value);</span><br></pre></td></tr></table></figure><ul><li>==访问私有变量==<br>Class.getDeclaredField(String name)<br>Class.getDeclaredFields()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class PrivateObject &#123;</span><br><span class="line">  private String privateString &#x3D; null;</span><br><span class="line">  public PrivateObject(String privateString) &#123;</span><br><span class="line">    this.privateString &#x3D; privateString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PrivateObject privateObject &#x3D; new PrivateObject(&quot;The Private Value&quot;);</span><br><span class="line"></span><br><span class="line">Field privateStringField &#x3D; PrivateObject.class.</span><br><span class="line">            getDeclaredField(&quot;privateString&quot;);</span><br><span class="line">&#x2F;&#x2F;关闭指定类Field实例的反射访问检查(暴力反射)</span><br><span class="line">&#x2F;&#x2F;不论是私有的、受保护的以及包访问的作用域和不在他的访问权限作用域之内，可以在任何地方访问</span><br><span class="line">privateStringField.setAccessible(true);</span><br><span class="line"></span><br><span class="line">String fieldValue &#x3D; (String) privateStringField.get(privateObject);</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Method对象数组包含了指定类中声明为公有的(public)的所有变量集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class aClass &#x3D; ...&#x2F;&#x2F;获取Class对象</span><br><span class="line">Method[] method &#x3D; aClass.getMethods();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过参数类型来获取指定的方法  </span><br><span class="line">Method method &#x3D; aClass.getMethod(&quot;doSomething&quot;, new Class[]&#123;String.class&#125;);</span><br><span class="line">&#x2F;&#x2F;无参方法第二个参数传入null即可</span><br><span class="line">Method method &#x3D; aClass.getMethod(&quot;doSomething&quot;, null);</span><br><span class="line">&#x2F;&#x2F;获取指定方法的方法参数是哪些：</span><br><span class="line">Class[] parameterTypes &#x3D; method.getParameterTypes();</span><br><span class="line">&#x2F;&#x2F;获取指定方法的返回类型</span><br><span class="line">Class returnType &#x3D; method.getReturnType();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Getters and Setters不能直接寻找getters和setters，需要通过get set方法特性获取</p><ul><li>Getter方法的名字以get开头，没有方法参数，返回一个值。   </li><li>Setter方法的名字以set开头，有一个方法参数。<br>setters方法有可能会有返回值也有可能没有，一些Setter方法返回void，一些用来设置值，有一些对象的setter方法在方法链中被调用（译者注：这类的setter方法必须要有返回值），因此你不应该妄自假设setter方法的返回值，一切应该视情况而定。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void printGettersSetters(Class aClass)&#123;</span><br><span class="line">  Method[] methods &#x3D; aClass.getMethods();</span><br><span class="line"></span><br><span class="line">  for(Method method : methods)&#123;</span><br><span class="line">    if(isGetter(method)) System.out.println(&quot;getter: &quot; + method);</span><br><span class="line">    if(isSetter(method)) System.out.println(&quot;setter: &quot; + method);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean isGetter(Method method)&#123;</span><br><span class="line">  if(!method.getName().startsWith(&quot;get&quot;))      return false;</span><br><span class="line">  if(method.getParameterTypes().length !&#x3D; 0)   return false;</span><br><span class="line">  if(void.class.equals(method.getReturnType()) return false;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean isSetter(Method method)&#123;</span><br><span class="line">  if(!method.getName().startsWith(&quot;set&quot;)) return false;</span><br><span class="line">  if(method.getParameterTypes().length !&#x3D; 1) return false;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Method对象调用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取一个方法名为doSomesthing，参数类型为String的方法</span><br><span class="line">Method method &#x3D; MyObject.class.getMethod(&quot;doSomething&quot;, String.class);</span><br><span class="line">Object returnValue &#x3D; method.invoke(null, &quot;parameter-value1&quot;);</span><br></pre></td></tr></table></figure><ul><li>invoke第一个参数是调用方法的对象</li></ul><p>如果是一个静态方法调用的话则可以用null代替</p><ul><li>invoke第二个参数是一个可变参数列表</li></ul><p>==访问私有方法。==</p><p>Class.getDeclaredMethod(String name, Class[] parameterTypes)或者Class.getDeclaredMethods() </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PrivateObject privateObject &#x3D; new PrivateObject(&quot;The Private Value&quot;);</span><br><span class="line"></span><br><span class="line">Method privateStringMethod &#x3D; PrivateObject.class.</span><br><span class="line">        getDeclaredMethod(&quot;getPrivateString&quot;, null);</span><br><span class="line"></span><br><span class="line">privateStringMethod.setAccessible(true);</span><br><span class="line"></span><br><span class="line">String returnValue &#x3D; (String)</span><br><span class="line">        privateStringMethod.invoke(privateObject, null);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 反射 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>声明式事务底层原理</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Spring 的声明式事务管理在底层是建立在 AOP 的基础之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p><ul><li>基于<tx>和<aop>命名空间的xml配置文件；</li><li>基于@Transactional注解。</li></ul><p>声明式事务结合IoC容器和Spirng已有的FactoryBean来对事务管理进行属性配置</p><ul><li><p>TransactionAttributeSourceAdvisor，这是一个通知器，用它来对属性值进行存储、处理。</p></li><li><p>创建事物的过程，这个过程是委托给具体的事物管理器来创建的，Spring通过TransactionStatus来传递相关的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> public class TransactionProxyFactoryBean extends AbstractSingletonProxyFactoryBean  </span><br><span class="line">        implements FactoryBean, BeanFactoryAware &#123;  </span><br><span class="line">&#x2F;&#x2F;这里是Spring事务处理而使用的AOP拦截器，中间封装了Spring对事务处理的代码来支持声明式事务处理的实现  </span><br><span class="line">    private final TransactionInterceptor transactionInterceptor &#x3D; new TransactionInterceptor();  </span><br><span class="line">  </span><br><span class="line">    private Pointcut pointcut;  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;这里Spring把TransactionManager注入到TransactionInterceptor中去  </span><br><span class="line">    public void setTransactionManager(PlatformTransactionManager transactionManager) &#123;  </span><br><span class="line">        this.transactionInterceptor.setTransactionManager(transactionManager);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;这里把在bean配置文件中读到的事务管理的属性信息注入到TransactionInterceptor中去  </span><br><span class="line">    public void setTransactionAttributes(Properties transactionAttributes) &#123;  </span><br><span class="line">        this.transactionInterceptor.setTransactionAttributes(transactionAttributes);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    .........中间省略了其他一些方法.......  </span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;这里创建Spring AOP对事务处理的Advisor  </span><br><span class="line">    protected Object createMainInterceptor() &#123;  </span><br><span class="line">        this.transactionInterceptor.afterPropertiesSet();  </span><br><span class="line">        if (this.pointcut !&#x3D; null) &#123;  </span><br><span class="line">            &#x2F;&#x2F;这里使用默认的通知器  </span><br><span class="line">            return new DefaultPointcutAdvisor(this.pointcut, this.transactionInterceptor);  </span><br><span class="line">        &#125;  </span><br><span class="line">        else &#123;  </span><br><span class="line">            &#x2F;&#x2F; 使用上面定义好的TransactionInterceptor作为拦截器，同时使用TransactionAttributeSourceAdvisor  </span><br><span class="line">            return new TransactionAttributeSourceAdvisor(this.transactionInterceptor);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>IOC初始化bean的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void afterPropertiesSet() &#123;  </span><br><span class="line">    .......  </span><br><span class="line">    &#x2F;&#x2F;TransactionProxyFactoryBean实际上使用ProxyFactory完成AOP的基本功能。  </span><br><span class="line">    ProxyFactory proxyFactory &#x3D; new ProxyFactory();  </span><br><span class="line">  </span><br><span class="line">    if (this.preInterceptors !&#x3D; null) &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; this.preInterceptors.length; i++) &#123;  </span><br><span class="line">            proxyFactory.addAdvisor(this.advisorAdapterRegistry.wrap(this.preInterceptors[i]));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;这里是Spring加入通知器的地方  </span><br><span class="line">    &#x2F;&#x2F;有两种通知器可以被加入DefaultPointcutAdvisor或者TransactionAttributeSourceAdvisor  </span><br><span class="line">    &#x2F;&#x2F;这里把Spring处理声明式事务处理的AOP代码都放到ProxyFactory中去，怎样加入advisor我们可以参考ProxyFactory的父类AdvisedSupport()  </span><br><span class="line">    &#x2F;&#x2F;由它来维护一个advice的链表，通过这个链表的增删改来抽象我们对整个通知器配置的增删改操作。  </span><br><span class="line">    proxyFactory.addAdvisor(this.advisorAdapterRegistry.wrap(createMainInterceptor()));  </span><br><span class="line">  </span><br><span class="line">    if (this.postInterceptors !&#x3D; null) &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; this.postInterceptors.length; i++) &#123;  </span><br><span class="line">            proxyFactory.addAdvisor(this.advisorAdapterRegistry.wrap(this.postInterceptors[i]));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    proxyFactory.copyFrom(this);  </span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;这里创建AOP的目标源  </span><br><span class="line">    TargetSource targetSource &#x3D; createTargetSource(this.target);  </span><br><span class="line">    proxyFactory.setTargetSource(targetSource);  </span><br><span class="line">  </span><br><span class="line">    if (this.proxyInterfaces !&#x3D; null) &#123;  </span><br><span class="line">        proxyFactory.setInterfaces(this.proxyInterfaces);  </span><br><span class="line">    &#125;  </span><br><span class="line">    else if (!isProxyTargetClass()) &#123;  </span><br><span class="line">        proxyFactory.setInterfaces(ClassUtils.getAllInterfacesForClass(targetSource.getTargetClass()));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    this.proxy &#x3D; getProxy(proxyFactory);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Spring 已经定义了一个transctionInterceptor作为拦截器或者AOP advice的实现，在IOC容器中定义的其他属性比如transactionManager和事务管理的属性都会传到已经定义好的 TransactionInterceptor那里去进行处理。以上反映了基本的Spring AOP的定义过程，其中pointcut和advice都已经定义好，同时也通过通知器配置到ProxyFactory中去了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionAttributeSourceAdvisor extends AbstractPointcutAdvisor &#123;  </span><br><span class="line">    &#x2F;&#x2F;和其他Advisor一样，同样需要定义AOP中的用到的Interceptor和Pointcut  </span><br><span class="line">    &#x2F;&#x2F;Interceptor使用传进来的TransactionInterceptor  </span><br><span class="line">    &#x2F;&#x2F;而对于pointcut,这里定义了一个内部类，参见下面的代码    </span><br><span class="line">    private TransactionInterceptor transactionInterceptor;  </span><br><span class="line">  </span><br><span class="line">    private final TransactionAttributeSourcePointcut pointcut &#x3D; new TransactionAttributeSourcePointcut();  </span><br><span class="line">     </span><br><span class="line">    .........  </span><br><span class="line">    &#x2F;&#x2F;定义的PointCut内部类  </span><br><span class="line">        private class TransactionAttributeSourcePointcut extends StaticMethodMatcherPointcut implements Serializable &#123;  </span><br><span class="line">       .......  </span><br><span class="line">      &#x2F;&#x2F;方法匹配的实现，使用了TransactionAttributeSource类  </span><br><span class="line">        public boolean matches(Method method, Class targetClass) &#123;  </span><br><span class="line">            TransactionAttributeSource tas &#x3D; getTransactionAttributeSource();  </span><br><span class="line">            &#x2F;&#x2F;这里使用TransactionAttributeSource来对配置属性进行处理  </span><br><span class="line">            return (tas !&#x3D; null &amp;&amp; tas.getTransactionAttribute(method, targetClass) !&#x3D; null);  </span><br><span class="line">        &#125;  </span><br><span class="line">    ........省略了equal,hashcode,tostring的代码  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 声明式事务底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC回收三：垃圾回收器</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/10%E3%80%81GC%E5%9B%9E%E6%94%B6%E4%B8%89%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/10%E3%80%81GC%E5%9B%9E%E6%94%B6%E4%B8%89%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>1、通过引用计数和可达性算法可以分析出谁需要被收回</li><li>2、同过了解回收算法知道如何去回收</li><li>3、接下来就是使用不同垃圾回收器去回收</li></ul><p>JDK7之后的HotSpot虚拟机包含垃圾回收器有：</p><p><img src="https://img-blog.csdn.net/20170906171932635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2lsZW5jZU9P/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><p>其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。</p><h3 id="Serial收集器（复制算法"><a href="#Serial收集器（复制算法" class="headerlink" title="Serial收集器（复制算法)"></a>Serial收集器（复制算法)</h3><p>Serial收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。Serial收集器依然是client模式下的虚拟机新生代的默认收集器<br><img src="https://img-blog.csdn.net/20170906172624319?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2lsZW5jZU9P/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><h3 id="ParNew收集器-复制算法"><a href="#ParNew收集器-复制算法" class="headerlink" title="ParNew收集器 (复制算法)"></a>ParNew收集器 (复制算法)</h3><p>新生代并行收集器，ParNew收集器其实就是Serial收集器的多线程版本<img src="https://img-blog.csdn.net/20170906172857773?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2lsZW5jZU9P/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><h3 id="Parallel-Scavenge收集器-复制算法"><a href="#Parallel-Scavenge收集器-复制算法" class="headerlink" title="Parallel Scavenge收集器(复制算法)"></a>Parallel Scavenge收集器(复制算法)</h3><p>新生代并行收集器，追求高吞吐量，高效利用 CPU。</p><p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。由于与吞吐量关系密切，Parallel Scavenge收集器也经常称为“吞吐量优先”收集器。</p><p><img src="https://img-blog.csdn.net/20170906173049744?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2lsZW5jZU9P/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><h3 id="Serial-Old收集器-标记-整理算法"><a href="#Serial-Old收集器-标记-整理算法" class="headerlink" title="Serial Old收集器(标记-整理算法)"></a>Serial Old收集器(标记-整理算法)</h3><p>老年代单线程收集器，Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用[1]，另一种用途就是作为CMS收集器的后备预案，在并发收集发生ConcurrentMode Failure时使用。</p><h3 id="Parallel-Old收集器-标记-整理算法"><a href="#Parallel-Old收集器-标记-整理算法" class="headerlink" title="Parallel Old收集器 (标记-整理算法)"></a>Parallel Old收集器 (标记-整理算法)</h3><p>老年代并行收集器，吞吐量优先</p><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在JDK 1.6中才开始提供的。</p><h3 id="CMS收集器（标记-清除算法）"><a href="#CMS收集器（标记-清除算法）" class="headerlink" title="CMS收集器（标记-清除算法）"></a>CMS收集器（标记-清除算法）</h3><p>老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</p><p>CMS（Concurrent Mark Sweep）<br>垃圾回收和程序的线程同时运行，可以降低stw200ms左右的时间。</p><p>收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。<br>运作过程分为4个步骤，包括：<br>a)初始标记（CMS initial mark）<br>b)并发标记（CMS concurrent mark）<br>c)重新标记（CMS remark）<br>d)并发清除（CMS concurrent sweep）</p><p>CMS收集器存在3个缺点：<br>1 对CPU资源敏感。一般并发执行的程序对CPU数量都是比较敏感的<br>2 无法处理浮动垃圾。在并发清理阶段用户线程还在执行，这时产生的垃圾无法清理。<br>3 由于标记-清除算法产生大量的空间碎片</p><h3 id="G1收集器-标记-整理算法"><a href="#G1收集器-标记-整理算法" class="headerlink" title="G1收集器 (标记-整理算法)"></a>G1收集器 (标记-整理算法)</h3><p>Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</p><ul><li><p>G1是一款面向服务端应用的垃圾收集器。 </p></li><li><p>G1收集器的运作大致可划分为以下几个步骤：</p></li><li><p>a)初始标记（Initial Marking） </p></li><li><p>b)并发标记（Concurrent Marking） </p></li><li><p>c)最终标记（Final Marking） </p></li><li><p>d)筛选回收（Live Data Counting and Evacuation）</p></li></ul><h3 id="常见生成环境的垃圾回收器组合"><a href="#常见生成环境的垃圾回收器组合" class="headerlink" title="常见生成环境的垃圾回收器组合"></a>常见生成环境的垃圾回收器组合</h3><p>jdk1.8的默认垃圾回收器时Parallel Scavenge+Parallel Old</p><h3 id="设置垃圾收集器参数"><a href="#设置垃圾收集器参数" class="headerlink" title="设置垃圾收集器参数"></a>设置垃圾收集器参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC，虚拟机运行在Client模式下的默认值，Serial+Serial Old。</span><br><span class="line"></span><br><span class="line">-XX:+UseParNewGC，ParNew+Serial Old，在JDK1.8被废弃，在JDK1.7还可以使用。</span><br><span class="line"></span><br><span class="line">-XX:+UseConcMarkSweepGC，ParNew+CMS+Serial Old。</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelGC，虚拟机运行在Server模式下的默认值，Parallel Scavenge+Serial Old(PS Mark Sweep)。</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC，Parallel Scavenge+Parallel Old。</span><br><span class="line"></span><br><span class="line">-XX:+UseG1GC，G1+G1。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC回收三：垃圾回收器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java内存模型</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2%E3%80%81java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2%E3%80%81java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<ul><li>缓存导致的可见性问题</li><li>线程切换带来的原子性问题，</li><li>指令重排带来的有序性问题。</li></ul><h2 id="1、Java内存模型"><a href="#1、Java内存模型" class="headerlink" title="1、Java内存模型"></a>1、Java内存模型</h2><p>Java虚拟机内部划分为线程栈和堆</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-3.png" alt="image"></p><ul><li>一个局部变量可能是原简单类型，在这种情况下，它总是“呆在”线程栈上。</li><li>一个局部变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。</li><li>一个对象可能包含方法，这些方法可能包含局部变量。这些局部变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。</li><li>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</li><li>静态成员变量跟随着类定义一起也存放在堆上。</li><li>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个局部变量的私有拷贝。</li></ul><h2 id="2、硬件内存架构（CPU缓存导致可见性问题）"><a href="#2、硬件内存架构（CPU缓存导致可见性问题）" class="headerlink" title="2、硬件内存架构（CPU缓存导致可见性问题）"></a>2、硬件内存架构（CPU缓存导致可见性问题）</h2><p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png" alt="image"></p><ol><li>一个现代计算机通常由两个或者多个CPU。其中一些CPU还有多核。从这一点可以看出，在一个有两个或者多个CPU的现代计算机上同时运行多个线程是可能的。每个CPU在某一时刻运行一个线程是没有问题的。这意味着，如果你的Java程序是多线程的，在你的Java程序中每个CPU上一个线程可能同时（并发）执行。</li><li>每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。</li><li>、每个CPU可能还有一个CPU缓存层。实际上，绝大多数的现代CPU都有一定大小的缓存层。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。一些CPU还有多层缓存，但这些对理解Java内存模型如何和内存交互不是那么重要。只要知道CPU中可以有一个缓存层就可以了。</li><li>、一个计算机还包含一个主存。所有的CPU都可以访问主存。主存通常比CPU中的缓存大得多</li></ol><p>==操作流程：<br>当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。==</p><h3 id="缓存导致-可见性问题-："><a href="#缓存导致-可见性问题-：" class="headerlink" title="缓存导致==可见性问题==："></a>缓存导致==可见性问题==：</h3><p>如果两个或者更多的线程在没有正确的使用volatile声明或者同步的情况下共享一个对象，共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中。然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。</p><p>使用volatile解决可见性和有序性问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class VolatileExample &#123;</span><br><span class="line">  int x &#x3D; 0;</span><br><span class="line">  volatile boolean v &#x3D; false;</span><br><span class="line">  public void writer() &#123;</span><br><span class="line">    x &#x3D; 42;</span><br><span class="line">    v &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line">  public void reader() &#123;</span><br><span class="line">    if (v &#x3D;&#x3D; true) &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里 x 会是多少呢？</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何解决：先行发生原则。</p><p>JDK1.5 以前的版本会出现 x = 0 的情况, 1.5 版本对 volatile 语义进行了增强。怎么增强的呢？答案是一项 Happens-Before 先行发生原则，用来解决可见性问题。</p><p>==先行发生原则：前面一个操作的结果对后续操作是可见的==</p><ul><li>程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作</li><li>管程锁定规则：一个unlock操作先行发生与后面对同一个锁的lock操作</li><li>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作</li><li>线程启动规则：Thread对象的start方法先行发生于此线程的每一个动作</li><li>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生</li><li>对象终结规则：一个对象的初始化完成，先行发生于它的finalize()方法的开始</li></ul><h3 id="原子性问题-竞态条件"><a href="#原子性问题-竞态条件" class="headerlink" title="==原子性问题==,竞态条件:"></a>==原子性问题==,竞态条件:</h3><p>如果线程A读一个共享对象的变量count到它的CPU缓存中。再想象一下，线程B也做了同样的事情，但是往一个不同的CPU缓存中。现在线程A将count加1，线程B也做了同样的事情。现在count已经被增在了两个，每个CPU缓存中一次。</p><p>如果这些增加操作被顺序的执行，变量count应该被增加两次，然后原值+2被写回到主存中去。</p><p>然而，两次增加都是在没有适当的同步下并发执行的。无论是线程A还是线程B将count修改后的版本写回到主存中取，修改后的值仅会被原值大1，尽管增加了两次。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h5 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h5><ul><li><p>面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</p></li><li><p>面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</p></li></ul><h5 id="面向对象编程特性（比如继承、多态、封装）"><a href="#面向对象编程特性（比如继承、多态、封装）" class="headerlink" title="面向对象编程特性（比如继承、多态、封装）"></a>面向对象编程特性（比如继承、多态、封装）</h5><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><ol><li>关于封装特性封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</li></ol><h5 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h5><ol start="2"><li>关于抽象特性封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</li></ol><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ol start="3"><li>关于继承特性继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题</li></ol><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><ol start="4"><li>关于多态特性多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。课堂讨论</li></ol><h5 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h5><ul><li>抽象类不允许被实例化，只能被继承。也就是说，你不能 new 一个抽象类的对象出来（Logger logger = new Logger(…); 会报编译错误）。</li><li>抽象类可以包含属性和方法。方法可以是抽象方法和具体方法。</li><li>子类继承抽象类，必须实现抽象类中的所有抽象方法。</li></ul><p>接口不能包含属性（也就是成员变量）。接口只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。</p><p>抽象类实际上就是类，只不过是一种特殊的类.对于接口，有一个更加形象的叫法，那就是协议（contract）。</p><h5 id="如何决定该用抽象类还是接口？"><a href="#如何决定该用抽象类还是接口？" class="headerlink" title="如何决定该用抽象类还是接口？"></a>如何决定该用抽象类还是接口？</h5><p>实际上，判断的标准很简单。如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；</p><p>如果我们要表示一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。</p><p>从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface ImageStore &#123;</span><br><span class="line">  String upload(Image image, String bucketName);</span><br><span class="line">  Image download(String url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AliyunImageStore implements ImageStore &#123;</span><br><span class="line">  &#x2F;&#x2F;...省略属性、构造函数等...</span><br><span class="line"></span><br><span class="line">  public String upload(Image image, String bucketName) &#123;</span><br><span class="line">    createBucketIfNotExisting(bucketName);</span><br><span class="line">    String accessToken &#x3D; generateAccessToken();</span><br><span class="line">    &#x2F;&#x2F;...上传图片到阿里云...</span><br><span class="line">    &#x2F;&#x2F;...返回图片在阿里云上的地址(url)...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Image download(String url) &#123;</span><br><span class="line">    String accessToken &#x3D; generateAccessToken();</span><br><span class="line">    &#x2F;&#x2F;...从阿里云下载图片...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void createBucketIfNotExisting(String bucketName) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...创建bucket...</span><br><span class="line">    &#x2F;&#x2F; ...失败会抛出异常..</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String generateAccessToken() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...根据accesskey&#x2F;secrectkey等生成access token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上传下载流程改变：私有云不需要支持access token</span><br><span class="line">public class PrivateImageStore implements ImageStore  &#123;</span><br><span class="line">  public String upload(Image image, String bucketName) &#123;</span><br><span class="line">    createBucketIfNotExisting(bucketName);</span><br><span class="line">    &#x2F;&#x2F;...上传图片到私有云...</span><br><span class="line">    &#x2F;&#x2F;...返回图片的url...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Image download(String url) &#123;</span><br><span class="line">    &#x2F;&#x2F;...从私有云下载图片...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void createBucketIfNotExisting(String bucketName) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...创建bucket...</span><br><span class="line">    &#x2F;&#x2F; ...失败会抛出异常..</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ImageStore的使用举例</span><br><span class="line">public class ImageProcessingJob &#123;</span><br><span class="line">  private static final String BUCKET_NAME &#x3D; &quot;ai_images_bucket&quot;;</span><br><span class="line">  &#x2F;&#x2F;...省略其他无关代码...</span><br><span class="line">  </span><br><span class="line">  public void process() &#123;</span><br><span class="line">    Image image &#x3D; ...;&#x2F;&#x2F;处理图片，并封装为Image对象</span><br><span class="line">    ImageStore imageStore &#x3D; new PrivateImageStore(...);</span><br><span class="line">    imagestore.upload(image, BUCKET_NAME);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复合优先于继承</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/10%E3%80%81%E5%A4%8D%E5%90%88%E4%BC%98%E5%85%88%E4%BA%8E%E7%BB%A7%E6%89%BF/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/10%E3%80%81%E5%A4%8D%E5%90%88%E4%BC%98%E5%85%88%E4%BA%8E%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="一：继承的缺陷："><a href="#一：继承的缺陷：" class="headerlink" title="一：继承的缺陷："></a>一：继承的缺陷：</h3><ul><li>1、打破封装原则：</li></ul><p>继承使得子类依赖于超类的实现，从这一点来说，就不符合封装的原则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在不应该继承的时候使用继承，会暴露不必要的API给子类。</span><br><span class="line">这一点，Java平台就犯过错，典型的例子就是Properties继承了HashTable，这是不合理的，</span><br><span class="line">属性列表不是散列表，但是Java代码里的Properties却继承了HashTable，导致用户创建Properties实例后，</span><br><span class="line">有put和setProperties两个方法，而put和get方法是不应该给用户暴露的。</span><br></pre></td></tr></table></figure><ul><li>2、子类代码容易受到破坏：</li></ul><p>子类继承的超类随着版本的发布而有所变化，子类就有可能遭到破坏，即使子类自己的代码完全没有改变。</p><p> 如果父类新增了方法，而子类恰好已经提供了一个签名相同但是返回值不同的方法，那么子类将无法通过编译。</p><h3 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h3><p> 一个程序使用了 HashSet，为了调优该程序的性能，需要查询HashSet，统计他被创建以来添加了多少个元素，因此需要覆盖add和addAll</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line"> </span><br><span class="line">public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;用于统计共添加了多少个元素</span><br><span class="line">private int count &#x3D; 0;</span><br><span class="line">public InstrumentedHashSet() &#123;</span><br><span class="line">&#125;</span><br><span class="line">public InstrumentedHashSet(int initCap, float loadFactor) &#123;</span><br><span class="line">super(initCap, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">count++;</span><br><span class="line">return super.add(e);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">count +&#x3D; c.size();</span><br><span class="line">return super.addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public int getCount() &#123;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">InstrumentedHashSet&lt;String&gt; hashSet &#x3D; new InstrumentedHashSet&lt;String&gt;();</span><br><span class="line">hashSet.addAll(Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;));</span><br><span class="line">System.out.println(hashSet.getCount());</span><br><span class="line">&#x2F;&#x2F;添加3个元素，却返回6</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加3个元素，却返回6。</p><p>仔细阅读上面代码发现，这是因为addAll方法是基于add方法来实现的。</p><p>既然HashSet是这样实现的，那么我们就不要复写addAll方法就行了，但是这样虽然可以正常工作，但是它的正确性却依赖于这样的事实。一旦超类修改了addAll实现细节，我们的功能就会有可能受影响。</p><p>二：复合<br>继承的替代方案</p><p>==使用复合的方式，对超类进行修饰，使得子类更加的健壮，同时功能更加强大。==</p><p>首先我们需要一个持有Set对象的一个类，这个类实现了Set接口，实现方法里调用了所持有的Set对象的对应的方法，因此我们也叫它转发类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; &#123;</span><br><span class="line">    private final Set&lt;E&gt; s;</span><br><span class="line">    public ForwardingSet(Set&lt;E&gt; s) &#123; this.s &#x3D; s; &#125;</span><br><span class="line"> </span><br><span class="line">    public void clear()               &#123; s.clear();            &#125;</span><br><span class="line">    public boolean contains(Object o) &#123; return s.contains(o); &#125;</span><br><span class="line">    public boolean isEmpty()          &#123; return s.isEmpty();   &#125;</span><br><span class="line">    public int size()                 &#123; return s.size();      &#125;</span><br><span class="line">    public Iterator&lt;E&gt; iterator()     &#123; return s.iterator();  &#125;</span><br><span class="line">    public boolean add(E e)           &#123; return s.add(e);      &#125;</span><br><span class="line">    public boolean remove(Object o)   &#123; return s.remove(o);   &#125;</span><br><span class="line">    public boolean containsAll(Collection&lt;?&gt; c)</span><br><span class="line">                                   &#123; return s.containsAll(c); &#125;</span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c)</span><br><span class="line">                                   &#123; return s.addAll(c);      &#125;</span><br><span class="line">    public boolean removeAll(Collection&lt;?&gt; c)</span><br><span class="line">                                   &#123; return s.removeAll(c);   &#125;</span><br><span class="line">    public boolean retainAll(Collection&lt;?&gt; c)</span><br><span class="line">                                   &#123; return s.retainAll(c);   &#125;</span><br><span class="line">    public Object[] toArray()          &#123; return s.toArray();  &#125;</span><br><span class="line">    public &lt;T&gt; T[] toArray(T[] a)      &#123; return s.toArray(a); &#125;</span><br><span class="line">    @Override public boolean equals(Object o)</span><br><span class="line">                                       &#123; return s.equals(o);  &#125;</span><br><span class="line">    @Override public int hashCode()    &#123; return s.hashCode(); &#125;</span><br><span class="line">    @Override public String toString() &#123; return s.toString(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着，我们就可以设计具有统计功能的类了，只需要去继承我们刚刚创建的转发类，然后统计的逻辑代码的编写即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt; &#123;</span><br><span class="line">    private int addCount &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">    public InstrumentedSet(Set&lt;E&gt; s) &#123;</span><br><span class="line">        super(s);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override public boolean add(E e) &#123;</span><br><span class="line">        addCount++;</span><br><span class="line">        return super.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        addCount +&#x3D; c.size();</span><br><span class="line">        return super.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAddCount() &#123;</span><br><span class="line">        return addCount;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        InstrumentedSet&lt;String&gt; s &#x3D;</span><br><span class="line">            new InstrumentedSet&lt;String&gt;(new HashSet&lt;String&gt;());</span><br><span class="line">        s.addAll(Arrays.asList(&quot;Snap&quot;, &quot;Crackle&quot;, &quot;Pop&quot;));    </span><br><span class="line">        System.out.println(s.getAddCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样的实现方式，避免了上一节讲的所有问题，由于不使用继承，它不依赖于超类的实现逻辑，也不用担心超类新增新的方法对我们的影响。<br>而且这样写还有一个好处，这个类可以给所有实现了Set接口的类添加统计功能，而不仅仅是HashSet，还包括TreeSet等其他Set。</p><p>其实，这就是装饰模式，InstrumentedSet对Set进行了修饰，给它增加了计数属性。</p>]]></content>
      
      
      <categories>
          
          <category> 类和接口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复合优先于继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中获取request的几种方法</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/spring-mvc/5%E3%80%81Spring%E4%B8%AD%E8%8E%B7%E5%8F%96request%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/SpringMVC/spring-mvc/5%E3%80%81Spring%E4%B8%AD%E8%8E%B7%E5%8F%96request%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>获取request的方式：</p><h2 id="方法1：Controller中加参数"><a href="#方法1：Controller中加参数" class="headerlink" title="方法1：Controller中加参数"></a>方法1：Controller中加参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController &#123;</span><br><span class="line">   @RequestMapping(&quot;&#x2F;test&quot;)</span><br><span class="line">   public void test(HttpServletRequest request) throws InterruptedException &#123;</span><br><span class="line">       &#x2F;&#x2F; 模拟程序执行了一段时间</span><br><span class="line">       Thread.sleep(1000);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法实现的原理是，在Controller方法开始处理请求时，Spring会将request对象赋值到方法参数中。除了request对象，可以通过这种方法获取的参数还有很多，具体可以参见：<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods</a><br>Controller中获取request对象后，如果要在其他方法中（如service方法、工具类方法等）使用request对象，需要在调用这些方法时将request对象作为参数传入。<br>此时request对象是方法参数，相当于局部变量，毫无疑问是线程安全的。<br>优缺点<br>这种方法的主要缺点是request对象写起来冗余太多，主要体现在两点：</p><ol><li>如果多个controller方法中都需要request对象，那么在每个方法中都需要添加一遍request参数</li><li>request对象的获取只能从controller开始，如果使用request对象的地方在函数调用层级比较深的地方，那么整个调用链上的所有方法都需要添加request参数</li></ol><p>实际上，在整个请求处理的过程中，request对象是贯穿始终的；也就是说，除了定时器等特殊情况，request对象相当于线程内部的一个全局变量。而该方法，相当于将这个全局变量，传来传去。</p><h2 id="方法2：自动注入-推荐使用"><a href="#方法2：自动注入-推荐使用" class="headerlink" title="方法2：自动注入(推荐使用)"></a>方法2：自动注入(推荐使用)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController&#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   private HttpServletRequest request; &#x2F;&#x2F;自动注入request</span><br><span class="line">   @RequestMapping(&quot;&#x2F;test&quot;)</span><br><span class="line">   public void test() throws InterruptedException&#123;</span><br><span class="line">       &#x2F;&#x2F;模拟程序执行了一段时间</span><br><span class="line">       Thread.sleep(1000);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：在Spring中，Controller的scope是singleton(单例)，也就是说在整个web系统中，只有一个TestController；但是其中注入的request却是线程安全的，原因在于：<br>使用这种方式，当Bean（本例的TestController）初始化时，Spring并没有注入一个request对象，而是注入了一个代理（proxy）；当Bean中需要使用request对象时，通过该代理获取request对象<br>该方法的主要优点：</p><ol><li>注入不局限于Controller中：在方法1中，只能在Controller中加入request参数。而对于方法2，不仅可以在Controller中注入，还可以在任何Bean中注入，包括Service、Repository及普通的Bean。</li><li>注入的对象不限于request：除了注入request对象，该方法还可以注入其他scope为request或session的对象，如response对象、session对象等；并保证线程安全。</li><li>减少代码冗余：只需要在需要request对象的Bean中注入request对象，便可以在该Bean的各个方法中使用，与方法1相比大大减少了代码冗余。<br>缺点:<br>方法也会存在代码冗余。考虑这样的场景：web系统中有很多controller，每个controller中都会使用request对象（这种场景实际上非常频繁），这时就需要写很多次注入request的代码；如果还需要注入response，代码就更繁琐了。下面说明自动注入方法的改进方法，并分析其线程安全性及优缺点。<h2 id="方法3：基类中自动注入-推荐使用-："><a href="#方法3：基类中自动注入-推荐使用-：" class="headerlink" title="方法3：基类中自动注入(推荐使用)："></a>方法3：基类中自动注入(推荐使用)：</h2></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class BaseController &#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   protected HttpServletRequest request;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：在理解了方法2的线程安全性的基础上，很容易理解方法3是线程安全的：当创建不同的派生类对象时，基类中的域（这里是注入的request）在不同的派生类对象中会占据不同的内存空间，也就是说将注入request的代码放在基类中对线程安全性没有任何影响；测试结果也证明了这一点。线程安全<br>优缺点<br>与方法2相比，避免了在不同的Controller中重复注入request；但是考虑到java只允许继承一个基类，所以如果Controller需要继承其他类时，该方法便不再好用。<br>无论是方法2和方法3，都只能在Bean中注入request；如果其他方法（如工具类中static方法）需要使用request对象，则需要在调用这些方法时将request参数传递进去。下面介绍的方法4，则可以直接在诸如工具类中的static方法中使用request对象（当然在各种Bean中也可以使用）。</p><h2 id="方法4：手动调用"><a href="#方法4：手动调用" class="headerlink" title="方法4：手动调用"></a>方法4：手动调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TestUtil &#123;</span><br><span class="line">   public void test() throws InterruptedException &#123; HttpServletRequest request &#x3D;((ServletRequestAttributes)(RequestContextHolder.currentRequestAttributes())).getRequest();</span><br><span class="line">       &#x2F;&#x2F; 模拟程序执行了一段时间</span><br><span class="line">       Thread.sleep(1000);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：线程安全<br>分析：该方法与方法2（自动注入）类似，只不过方法2中通过自动注入实现，本方法通过手动方法调用实现。因此本方法也是线程安全的<br>优缺点<br>优点：可以在非Bean中直接获取。缺点：如果使用的地方较多，代码非常繁琐；因此可以与其他方法配合使用。</p><h2 id="方法5：-ModelAttribute方法"><a href="#方法5：-ModelAttribute方法" class="headerlink" title="方法5：@ModelAttribute方法"></a>方法5：@ModelAttribute方法</h2>]]></content>
      
      
      <categories>
          
          <category> spring-mvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring中获取request的几种方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="2020/06/21/Study%20notes/6%E3%80%81server/nginx/1%E3%80%81nginx/"/>
      <url>2020/06/21/Study%20notes/6%E3%80%81server/nginx/1%E3%80%81nginx/</url>
      
        <content type="html"><![CDATA[<p>Nginx 是高性能的HTTP和反向代理的服务器，处理高并发能力是十分强大的，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。</p><h3 id="正向代理："><a href="#正向代理：" class="headerlink" title="正向代理："></a>正向代理：</h3><p>客户端通过配置代理服务器，由代理服务器去请求目标服务器。</p><p>如：客户端要访问google,先用代理服务器xxx.com,通过xxx.com访问google.</p><h3 id="反向代理："><a href="#反向代理：" class="headerlink" title="反向代理："></a>反向代理：</h3><p>所谓反向代理正好与正向代理相反，代理服务器是为目标服务器服务的，虽然整体的请求返回路线都是一样的都是Client到Proxy到Server。但对于客户端隐藏了真实服务器 IP 地址。</p><p>Nginx的作用：</p><p>1、反向代理    </p><p>2、负载均衡</p><p>3、动静分离</p><h3 id="一：Nginx的安装"><a href="#一：Nginx的安装" class="headerlink" title="一：Nginx的安装"></a>一：Nginx的安装</h3><ol><li>首先下载 Nginx (<a href="http://nginx.org/en/download.html)%E5%9C%A8Linux%E4%B8%8A%E8%A7%A3%E5%8E%8B">http://nginx.org/en/download.html)在Linux上解压</a> tar zxvf nginx-0.x.xx.tar.gz</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进入解压目录：cd nginx-0.x.xx</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>备注：如果是Windows只需要解压即可完成安装</p><h3 id="二：Nginx的启动："><a href="#二：Nginx的启动：" class="headerlink" title="二：Nginx的启动："></a>二：Nginx的启动：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">以上安装 nginx默认解压在 usr&#x2F;local&#x2F;nginx目录下。</span><br><span class="line">所以启动的时候：usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">-c在这里是指定配置文件的路径，如果不指定，那么就是默认的</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">启动后我们可以通过 ps -ef | grep nginx 来查找Nginx的主进程号</span><br><span class="line">master process代表住进程</span><br></pre></td></tr></table></figure><p>备注：如果是Windows 直接点击解压包中的nginx.exe</p><h3 id="三：Nginx的停止"><a href="#三：Nginx的停止" class="headerlink" title="三：Nginx的停止"></a>三：Nginx的停止</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1) 从容停止Nginx</span><br><span class="line">kill - QUIT &lt;Nginx 主进程号&gt;</span><br><span class="line">或 kill - QUIT &#39;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid&#39;</span><br><span class="line">2) 快速停止Nginx</span><br><span class="line">kill - TEAM &lt;Nginx 主进程号&gt;</span><br><span class="line">kill - TEAM Nginx &#39;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid&#39;</span><br><span class="line">或</span><br><span class="line">kill - INT &lt;Nginx 主进程号&gt;</span><br><span class="line">kill - INT &#39;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid&#39;</span><br><span class="line">3) 强制停止所有Nginx进程</span><br><span class="line">pkill -9 nginx</span><br><span class="line">4) Nginx的平滑重启(因为是从容地重启，因此服务是不中断的)</span><br><span class="line">kill - HUP &lt;Nginx 主进程号&gt;</span><br><span class="line">kill - HUP &#39;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid&#39;</span><br></pre></td></tr></table></figure><p>备注：如果是Windows下退出直接在任务管理器停止进程即可</p><h3 id="四：配置负载均衡"><a href="#四：配置负载均衡" class="headerlink" title="四：配置负载均衡"></a>四：配置负载均衡</h3><p>注：配置文件是nginx.conf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  2;#工作进程的个数，一般与计算机的cpu核数一致，或者是双倍</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;#单个进程最大连接数（最大连接数&#x3D;连接数*进程数）</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types; #文件扩展名与文件类型映射表</span><br><span class="line">    default_type  application&#x2F;octet-stream;#默认文件类型</span><br><span class="line">    sendfile        on;#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I&#x2F;O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span><br><span class="line">keepalive_timeout  65; #长连接超时时间，单位是秒</span><br><span class="line">    gzip  on;#启用Gizp压缩</span><br><span class="line">#服务器的集群</span><br><span class="line">    upstream  netitcast.com &#123;  #服务器集群名字  此处是两个tomcat</span><br><span class="line">        #配置负载策略：如 ip_hash;  </span><br><span class="line">server    127.0.0.1:18080  weight&#x3D;1;#服务器配置   weight是权重的意思，权重越大，分配的概率越大。</span><br><span class="line">server    127.0.0.1:28080  weight&#x3D;2;</span><br><span class="line">&#125;</span><br><span class="line">#当前的Nginx的配置</span><br><span class="line">    server &#123;</span><br><span class="line">        listen  80;#监听80端口，可以改成其他端口</span><br><span class="line">        server_name  localhost;##############当前服务的域名</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;netitcast.com;</span><br><span class="line">            proxy_redirect default;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">        location ~* \.php$ &#123;                                # location匹配将php结尾的交给PHP服务器</span><br><span class="line">                fastcgi_pass 10.10.0.22:9000;</span><br><span class="line">                fastcgi_index index.php;</span><br><span class="line">                fastcgi_param SCRIPT_FILENAME &#x2F;app&#x2F;blog$fastcgi_script_name;</span><br><span class="line">                include fastcgi_params;</span><br><span class="line">        &#125; </span><br><span class="line">        location ~* \.(jpg|gif)$ &#123;                          # location匹配将图片交给Image处理</span><br><span class="line">                proxy_pass http:&#x2F;&#x2F;10.10.0.23:80;            # Image服务器要开启web服务</span><br><span class="line">        &#125;</span><br><span class="line">        error_page 404 &#x2F;404.html;</span><br><span class="line">            location &#x3D; &#x2F;40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page 500 502 503 504 &#x2F;50x.html;</span><br><span class="line">            location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="五：关闭日志操作-可选"><a href="#五：关闭日志操作-可选" class="headerlink" title="五：关闭日志操作(可选)"></a>五：关闭日志操作(可选)</h3><p>由于我们的服务需要在服务器上长久运行，日志文件的产生会导致服务器硬盘空间的不足，并且会对系统稳定性造成一定影响，所以我们可以选择关掉日志文件。<br>Tomcat日志关闭</p><p>将server.xml下的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Valve className&#x3D;&quot;org.apache.catalina.valves.AccessLogValve&quot; directory&#x3D;&quot;logs&quot;</span><br><span class="line">prefix&#x3D;&quot;localhost_access_log&quot; suffix&#x3D;&quot;.txt&quot;</span><br><span class="line">pattern&#x3D;&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>注释掉即可。<br>Nginx日志关闭</p><p>开发环境我默认不写日志，即不配置任何access_log<br>Nginx的http段中，设置access log：access_log off;<br>其他日志可以百度查找相关方法</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU最近最少使用</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/LRU%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/LRU%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：</p><ul><li>先进先出策略 FIFO（First In，First Out）</li><li>最少使用策略 LFU（Least Frequently Used）</li><li>最近最少使用策略 LRU（Least Recently Used）</li></ul><p>【LRU的淘汰规则是基于访问时间，而LFU是基于访问次数的】</p><p>不常用的</p><ul><li>OPT 最佳置换算法 （理想中存在的）</li><li>NRU Clock置换算法</li><li>PBA 页面缓冲算法</li></ul><p>Cache算法和内存页面置换算法的核心思想是一样的：都是在给定一个限定大小的空间的前提下，设计一个原则如何来更新和访问其中的元素。</p><p>LRU算法的设计原则是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。==淘汰最近最少使用的元素==</p><p>基于链表+Hash表实现思路：</p><p>我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。</p><p>当有一个新的数据被访问时，</p><ul><li>数据已经被缓存<br>若这个数据已经被缓存（已经存在于hash表中）,则从hasn表获取该数据对应链表的角标，并将其从原来的链表位置删除，然后再插入到链表的头部。更新hash表数据。</li></ul><ul><li>如果此数据没有在缓存hash表中，又可以分为两种情况：</li></ul><ol><li>如果此时缓存未满，则将此结点直接插入到链表的头部,并将数据和数据所在链表的角标记录在hash表中。</li><li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。并将数据和数据所在链表的角标记录在hash表中。这样我们就用链表实现了一个 LRU 缓存</li></ol><p>将缓存访问的时间复杂度降到 O(1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class LRUCache&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 容量</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int capacity &#x3D; 1024;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Node记录表</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Map&lt;String, ListNode&lt;String, V&gt;&gt; table &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 双向链表头部</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private ListNode&lt;String, V&gt; head;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 双向链表尾部</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private ListNode&lt;String, V&gt; tail;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        this();</span><br><span class="line">        this.capacity &#x3D; capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public LRUCache() &#123;</span><br><span class="line">        head &#x3D; new ListNode&lt;&gt;();</span><br><span class="line">        tail &#x3D; new ListNode&lt;&gt;();</span><br><span class="line">        head.next &#x3D; tail;</span><br><span class="line">        head.prev &#x3D; null;</span><br><span class="line">        tail.prev &#x3D; head;</span><br><span class="line">        tail.next &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public V get(String key) &#123;</span><br><span class="line"></span><br><span class="line">        ListNode&lt;String, V&gt; node &#x3D; table.get(key);</span><br><span class="line">        &#x2F;&#x2F;如果Node不在表中，代表缓存中并没有</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果存在，则需要移动Node节点到表头</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;截断链表，node.prev -&gt; node  -&gt; node.next &#x3D;&#x3D;&#x3D;&#x3D;&gt; node.prev -&gt; node.next</span><br><span class="line">        &#x2F;&#x2F;         node.prev &lt;- node &lt;- node.next  &#x3D;&#x3D;&#x3D;&#x3D;&gt;  node.prev &lt;- node.next</span><br><span class="line">        node.prev.next &#x3D; node.next;</span><br><span class="line">        node.next.prev &#x3D; node.prev;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;移动节点到表头</span><br><span class="line">        node.next &#x3D; head.next;</span><br><span class="line">        head.next.prev &#x3D; node;</span><br><span class="line">        node.prev &#x3D; head;</span><br><span class="line">        head.next &#x3D; node;</span><br><span class="line">        &#x2F;&#x2F;存在缓存表</span><br><span class="line">        table.put(key, node);</span><br><span class="line">        return node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void put(String key, V value) &#123;</span><br><span class="line">        ListNode&lt;String, V&gt; node &#x3D; table.get(key);</span><br><span class="line">        &#x2F;&#x2F;如果Node不在表中，代表缓存中并没有</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            if (table.size() &#x3D;&#x3D; capacity) &#123;</span><br><span class="line">                &#x2F;&#x2F;超过容量了 ,首先移除尾部的节点</span><br><span class="line">                table.remove(tail.prev.key);</span><br><span class="line">                tail.prev &#x3D; tail.next;</span><br><span class="line">                tail.next &#x3D; null;</span><br><span class="line">                tail &#x3D; tail.prev;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            node &#x3D; new ListNode&lt;&gt;();</span><br><span class="line">            node.key &#x3D; key;</span><br><span class="line">            node.value &#x3D; value;</span><br><span class="line">            table.put(key, node);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果存在，则需要移动Node节点到表头</span><br><span class="line">        node.next &#x3D; head.next;</span><br><span class="line">        head.next.prev &#x3D; node;</span><br><span class="line">        node.prev &#x3D; head;</span><br><span class="line">        head.next &#x3D; node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 双向链表内部类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static class ListNode&lt;K, V&gt; &#123;</span><br><span class="line">        private K key;</span><br><span class="line">        private V value;</span><br><span class="line">        ListNode&lt;K, V&gt; prev;</span><br><span class="line">        ListNode&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">        public ListNode(K key, V value) &#123;</span><br><span class="line">            this.key &#x3D; key;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public ListNode() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LRUCache&lt;ListNode&gt; cache &#x3D; new LRUCache&lt;&gt;(4);</span><br><span class="line">        ListNode&lt;String, Integer&gt; node1 &#x3D; new ListNode&lt;&gt;(&quot;key1&quot;, 1);</span><br><span class="line">        ListNode&lt;String, Integer&gt; node2 &#x3D; new ListNode&lt;&gt;(&quot;key2&quot;, 2);</span><br><span class="line">        ListNode&lt;String, Integer&gt; node3 &#x3D; new ListNode&lt;&gt;(&quot;key3&quot;, 3);</span><br><span class="line">        ListNode&lt;String, Integer&gt; node4 &#x3D; new ListNode&lt;&gt;(&quot;key4&quot;, 4);</span><br><span class="line">        ListNode&lt;String, Integer&gt; node5 &#x3D; new ListNode&lt;&gt;(&quot;key5&quot;, 5);</span><br><span class="line">        cache.put(&quot;key1&quot;, node1);</span><br><span class="line">        cache.put(&quot;key2&quot;, node2);</span><br><span class="line">        cache.put(&quot;key3&quot;, node3);</span><br><span class="line">        cache.put(&quot;key4&quot;, node4);</span><br><span class="line">        cache.get(&quot;key2&quot;);</span><br><span class="line">        cache.put(&quot;key5&quot;, node5);</span><br><span class="line">        cache.get(&quot;key2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 页面置换算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LRU最近最少使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java事务的类型</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/Java%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%B1%BB%E5%9E%8B/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/Java%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Java事务的类型：</p><ul><li>JDBC事务、</li><li>JTA（Java Transaction API）事务、</li><li>容器事务:容器事务:主要指的是J2EE应用服务器提供的事务管理，局限于EJB应用使用。</li></ul><h4 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h4><p>　JDBC 事务是用 Connection 对象控制的。JDBC Connection 接口（ java.sql.Connection ）提供了两种事务模式：自动提交和手工提交。 java.sql.Connection 提供了以下控制事务的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setAutoCommit(boolean)  </span><br><span class="line">public boolean getAutoCommit()  </span><br><span class="line">public void commit()  </span><br><span class="line">public void rollback()  </span><br></pre></td></tr></table></figure><p>使用 JDBC 事务界定时，您可以将多个 SQL 语句结合到一个事务中，==缺点是事务的范围局限于一个数据库连接。无法实现分布式事务。==</p><h4 id="JTA事务（java-Transaction-API）-不常用"><a href="#JTA事务（java-Transaction-API）-不常用" class="headerlink" title="JTA事务（java Transaction API）(不常用)"></a>JTA事务（java Transaction API）(不常用)</h4><p>简单的支付流程的操作，其中调用了五个服务，这五个服务都通过RPC的方式调用，==增加了@Transactional注解，但是由于采用调用了分布式服务，该事务并不能达到ACID的效果。==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 支付订单处理 **&#x2F;</span><br><span class="line">@Transactional(rollbackFor &#x3D; Exception.class)</span><br><span class="line">public void completeOrder() &#123;</span><br><span class="line">    orderDao.update(); &#x2F;&#x2F; 订单服务本地更新订单状态</span><br><span class="line">    accountService.update(); &#x2F;&#x2F; 调用资金账户服务给资金帐户加款</span><br><span class="line">    pointService.update(); &#x2F;&#x2F; 调用积分服务给积分帐户增加积分</span><br><span class="line">    accountingService.insert(); &#x2F;&#x2F; 调用会计服务向会计系统写入会计原始凭证</span><br><span class="line">    merchantNotifyService.notify(); &#x2F;&#x2F; 调用商户通知服务向商户发送支付结果通知</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个JTA事务可以有多个参与者，而一个JDBC事务则被限定在一个单一的数据库连接.常见的JTA实现有以下2种：</p><ul><li>1.J2EE容器所提供的JTA实现(JBoss)</li><li>2.独立的JTA实现:如JOTM，Atomikos.这些实现可以应用在那些不使用J2EE应用服务器的环境里用以提供分布事事务保证。如Tomcat,Jetty以及普通的java应用。</li></ul><ul><li>JTA的优点:提供了分布式事务的解决方案，严格的ACID。但</li><li>缺点:</li></ul><p>实现复杂,用 JTA 事务，那么就需要有一个实现 javax.sql.XADataSource 、javax.sql.XAConnection 和 javax.sql.XAResource 接口的 JDBC 驱动程序。</p><p>通常情况下，JTA UserTransaction需要从JNDI获取。这意味着，如果我们使用JTA，就需要同时使用JTA和JNDI。</p><h2 id="spring事务"><a href="#spring事务" class="headerlink" title="spring事务"></a>spring事务</h2><p>Spring并不直接管理事务，而是提供了多种事务管理器 ，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;平台事务管理器接口</span><br><span class="line">Public interface PlatformTransactionManager()...&#123;  </span><br><span class="line">    &#x2F;&#x2F; 根据指定的传播行为，返回当前活动的事务或创建一个新事务。</span><br><span class="line">    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; </span><br><span class="line">    &#x2F;&#x2F; 使用事务目前的状态提交事务</span><br><span class="line">    Void commit(TransactionStatus status) throws TransactionException;  </span><br><span class="line">  &#x2F;&#x2F; transaction（对执行的事务进行回滚）</span><br><span class="line">    Void rollback(TransactionStatus status) throws TransactionException;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h4><p>Spring为不同的持久化框架提供了不同的PlatformTransactionManager如: </p><ul><li>JDBC或iBatis:DataSourceTransactionManager </li><li>Hibernate:HibernateTransactionManager</li><li>JPA：JtaTransactionManager</li></ul><h4 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h4><p>事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionDefinition &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;7种传播行为</span><br><span class="line">    int PROPAGATION_REQUIRED &#x3D; 0;</span><br><span class="line">    int PROPAGATION_SUPPORTS &#x3D; 1;</span><br><span class="line">    int PROPAGATION_MANDATORY &#x3D; 2;</span><br><span class="line">    int PROPAGATION_REQUIRES_NEW &#x3D; 3;</span><br><span class="line">    int PROPAGATION_NOT_SUPPORTED &#x3D; 4;</span><br><span class="line">    int PROPAGATION_NEVER &#x3D; 5;</span><br><span class="line">    int PROPAGATION_NESTED &#x3D; 6;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;5种隔离级别</span><br><span class="line">    </span><br><span class="line">    int ISOLATION_DEFAULT &#x3D; -1;</span><br><span class="line">    int ISOLATION_READ_UNCOMMITTED &#x3D; 1;</span><br><span class="line">    int ISOLATION_READ_COMMITTED &#x3D; 2;</span><br><span class="line">    int ISOLATION_REPEATABLE_READ &#x3D; 4;</span><br><span class="line">    int ISOLATION_SERIALIZABLE &#x3D; 8;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务</span><br><span class="line">    int TIMEOUT_DEFAULT &#x3D; -1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 返回事务的传播行为</span><br><span class="line">    int getPropagationBehavior(); </span><br><span class="line">    &#x2F;&#x2F; 返回事务的隔离级别，</span><br><span class="line">    int getIsolationLevel(); </span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F;返回事务的名字</span><br><span class="line">    String getName()；</span><br><span class="line">    </span><br><span class="line">     &#x2F;&#x2F; 返回事务必须在多少秒内完成</span><br><span class="line">    int getTimeout();  </span><br><span class="line">    &#x2F;&#x2F; 返回是否优化为只读事务。</span><br><span class="line">    boolean isReadOnly();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="TransactionStatus：-事务运行状态"><a href="#TransactionStatus：-事务运行状态" class="headerlink" title="TransactionStatus： 事务运行状态"></a>TransactionStatus： 事务运行状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionStatus&#123;</span><br><span class="line">    &#x2F;&#x2F; 是否是新的事物</span><br><span class="line">    boolean isNewTransaction();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 返回此事务是否内部携带保存点，也就是基于保存点创建为嵌套事务</span><br><span class="line">    boolean hasSavepoint(); </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 设置事务回滚</span><br><span class="line">    void setRollbackOnly();  </span><br><span class="line">    </span><br><span class="line">     &#x2F;&#x2F; 返回事务是否已被标记为仅回滚    </span><br><span class="line">    boolean isRollbackOnly();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 返回此事务是否完成，即是否已经提交或回滚</span><br><span class="line">    boolean isCompleted; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java事务的类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/7%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/7%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。</p><p>　</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(Iterator it&#x3D; list.iterator(); it.hasNext(); )&#123;</span><br><span class="line">   String str &#x3D; (String) it.next();</span><br><span class="line">   System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Iterator接口定义了如下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean hasNext();    判断是否有元素没有被遍历</span><br><span class="line">Object next();    返回游标当前位置的元素，并将游标移动到下一个位置</span><br><span class="line">void remove();    删除游标左面的元素（刚刚遍历完的那个元素），在执行完next之后该操作只能执行一次</span><br></pre></td></tr></table></figure><h4 id="2、内部原理"><a href="#2、内部原理" class="headerlink" title="2、内部原理"></a>2、内部原理</h4><p>ArrayList LinkendList HashSet TreeSet中都有一个内部类实现了Iterator接口</p><p>hasNext()、next()、remove()是在这个内部类里面重写的</p><h4 id="modCount"><a href="#modCount" class="headerlink" title="modCount:"></a>modCount:</h4><p>该字段表示list结构上被修改的次数。结构上的修改指的是那些改变了list的长度大小或者使得遍历过程中产生不正确的结果的其它方式。<br>该字段被Iterator以及ListIterator的实现类所使用，如果该值被意外更改，Iterator或者ListIterator 将抛出ConcurrentModificationException异常，<br>这是jdk在面对迭代遍历的时候为了避免不确定性而采取的快速失败原则。</p><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">       &#x2F;&#x2F;计数器--&gt;指针 游标</span><br><span class="line">        int cursor; </span><br><span class="line">        int lastRet &#x3D; -1; </span><br><span class="line">        int expectedModCount &#x3D; modCount;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return cursor !&#x3D; size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public E next() &#123;</span><br><span class="line">            &#x2F;&#x2F;检查modCount !&#x3D; expectedModCount 快速失败机制</span><br><span class="line">            checkForComodification();</span><br><span class="line">            int i &#x3D; cursor;</span><br><span class="line">            if (i &gt;&#x3D; size)</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            Object[] elementData &#x3D; ArrayList.this.elementData;</span><br><span class="line">            if (i &gt;&#x3D; elementData.length)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            cursor &#x3D; i + 1;</span><br><span class="line">            return (E) elementData[lastRet &#x3D; i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            if (lastRet &lt; 0)</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                ArrayList.this.remove(lastRet);</span><br><span class="line">                cursor &#x3D; lastRet;</span><br><span class="line">                lastRet &#x3D; -1;</span><br><span class="line">                expectedModCount &#x3D; modCount;</span><br><span class="line">            &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123;</span><br><span class="line">            Objects.requireNonNull(consumer);</span><br><span class="line">            final int size &#x3D; ArrayList.this.size;</span><br><span class="line">            int i &#x3D; cursor;</span><br><span class="line">            if (i &gt;&#x3D; size) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            final Object[] elementData &#x3D; ArrayList.this.elementData;</span><br><span class="line">            if (i &gt;&#x3D; elementData.length) &#123;</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            while (i !&#x3D; size &amp;&amp; modCount &#x3D;&#x3D; expectedModCount) &#123;</span><br><span class="line">                consumer.accept((E) elementData[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; update once at end of iteration to reduce heap write traffic</span><br><span class="line">            cursor &#x3D; i;</span><br><span class="line">            lastRet &#x3D; i - 1;</span><br><span class="line">            checkForComodification();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final void checkForComodification() &#123;</span><br><span class="line">            if (modCount !&#x3D; expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    boolean hasNext();</span><br><span class="line"></span><br><span class="line">    E next();</span><br><span class="line"></span><br><span class="line">    boolean hasPrevious();</span><br><span class="line"></span><br><span class="line">    E previous();</span><br><span class="line"></span><br><span class="line">    int nextIndex();</span><br><span class="line"></span><br><span class="line">    int previousIndex();</span><br><span class="line"></span><br><span class="line">    void remove();</span><br><span class="line"></span><br><span class="line">    void set(E e);</span><br><span class="line"></span><br><span class="line">    void add(E e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="和ListIterator主要区别在以下方面："><a href="#和ListIterator主要区别在以下方面：" class="headerlink" title="和ListIterator主要区别在以下方面："></a>和ListIterator主要区别在以下方面：</h4><ul><li><p>　1. iterator()方法在set和list接口中都有定义，但是ListIterator（）仅存在于list接口中（或实现类中）；</p></li><li><p>　　2. ListIterator有add()方法，可以向List中添加对象，而Iterator不能</p></li><li><p>　　3. ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。</p></li><li><p>　　4. ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。</p></li><li><p>　　5. 都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。　　</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迭代器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指令重排</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/3%E3%80%81%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/3%E3%80%81%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<ul><li>缓存导致的可见性问题</li><li>线程切换带来的原子性问题，</li><li>指令重排带来的有序性问题。</li></ul><p>编译器为了优化性能，在不影响最终结果的基础上，有时候会改变程序中语句的先后顺序，例如程序中：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”指令重排并发下的==有序性问题==：</p><p>重排序分3种类型:从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序</p><ul><li>1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句<br>的执行顺序。</li><li>2）处理器的指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level<br>Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应<br>机器指令的执行顺序。</li><li>3）处理器的内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上<br>去可能是在乱序执行。</li></ul><p>示例:单例模式</p><p>非线程安全的单例模式：当两个线程都进入if (instance == null)下一步时，便会创建两个对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  private Singleton()&#123;&#125;</span><br><span class="line">  private static Singleton instance;</span><br><span class="line">  public static  Singleton getInstance()&#123;</span><br><span class="line">        if (instance &#x3D;&#x3D; null)</span><br><span class="line">          instance &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用同步加锁的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  private Singleton()&#123;&#125;</span><br><span class="line">  private static Singleton instance;</span><br><span class="line">  public static  Singleton getInstance()&#123;</span><br><span class="line">        synchronized(Singleton.class)&#123;</span><br><span class="line">            if(singleTon&#x3D;&#x3D;null)&#123;     </span><br><span class="line">             instance &#x3D; new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果getInstance()方法被多个线程频繁的调用，一个线程获取锁，进去创建对象。其他线程将阻塞挂起。导致程序执行性能的下降。</p><p>人们想通过双重检查<br>锁定来降低同步的开销。<br>如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始<br>化操作。因此，可以大幅降低synchronized带来的性能开销</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;双重检测</span><br><span class="line">public class Singleton &#123;</span><br><span class="line">  private Singleton()&#123;&#125;</span><br><span class="line">  private static Singleton instance;</span><br><span class="line">  public static Singleton getInstance()&#123;</span><br><span class="line">        if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">              synchronized(Singleton.class) &#123;</span><br><span class="line">                    if (instance &#x3D;&#x3D; null)</span><br><span class="line">                      instance &#x3D; new Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。</p><p>看似稳的一逼 实际不堪一击。</p><p>instance = new Singleton();操作并不是一个原子性指令，会被分为多个指令：</p><ul><li>分配一块内存 M；</li><li>在内存 M 上初始化 Singleton 对象；</li><li>然后 M 的地址赋值给 instance 变量。</li></ul><p>发生指令重排后：</p><ul><li>分配一块内存 M；</li><li>将 M 的地址赋值给 instance 变量；</li><li>最后在内存 M 上初始化 Singleton 对象。</li></ul><p>所以A线程执行完重排后的第二步，且未执行初始化对象。此时B线程来取instance时，发现instance不为空，于是便直接返回该值，便返回null.</p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>1、基于volatile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  private Singleton()&#123;&#125;</span><br><span class="line">  private volatile static Singleton instance;</span><br><span class="line">  static Singleton getInstance()&#123;</span><br><span class="line">    if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">      synchronized(Singleton.class) &#123;</span><br><span class="line">        if (instance &#x3D;&#x3D; null)</span><br><span class="line">          instance &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile禁止指令重排。</p><h3 id="2、基于类的初始化（饿汉式单例模式）"><a href="#2、基于类的初始化（饿汉式单例模式）" class="headerlink" title="2、基于类的初始化（饿汉式单例模式）"></a>2、基于类的初始化（饿汉式单例模式）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton instance &#x3D; new Singleton();</span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">    return Singleton.instance ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==instance = new Singleton();一样会指令重排，但对于<br>非构造线程是不可见的。==</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指令重排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK动态代理</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/2%E3%80%81JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/2%E3%80%81JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>代理就是在调用实现类的方法时，可以在方法执行前后做额外的工作，这个就是代理。</p><h3 id="静态代理："><a href="#静态代理：" class="headerlink" title="静态代理："></a>静态代理：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 目标对象实现的接口</span><br><span class="line"> * @author jiyukai</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface BussinessInterface &#123;</span><br><span class="line"> </span><br><span class="line">    void execute();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 目标对象实现类</span><br><span class="line"> * @author jiyukai</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Bussiness implements BussinessInterface&#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        System.out.println(&quot;执行业务逻辑...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 代理类，通过实现与目标对象相同的接口</span><br><span class="line"> * 并维护一个代理对象，通过构造器传入实际目标对象并赋值</span><br><span class="line"> * 执行代理对象实现的接口方法，实现对目标对象实现的干预</span><br><span class="line"> * @author jiyukai</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BussinessProxy implements BussinessInterface&#123;</span><br><span class="line">     </span><br><span class="line">    private BussinessInterface bussinessImpl;</span><br><span class="line">     </span><br><span class="line">    public BussinessProxy(BussinessInterface bussinessImpl) &#123;</span><br><span class="line">        this.bussinessImpl &#x3D; bussinessImpl;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        System.out.println(&quot;前拦截...&quot;);</span><br><span class="line">        bussinessImpl.execute();</span><br><span class="line">        System.out.println(&quot;后拦截...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：可以做到不对目标对象进行修改的前提下，对目标对象进行功能的扩展和拦截。</p><p>　　缺点：因为代理对象，需要实现与目标对象一样的接口，会导致代理类十分繁多，不易维护，同时一旦接口增加方法，则目标对象和代理类都需要维护。</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>==JDK动态代理机制是委托机制，在动态生成的实现类里面委托为hanlder去调用原始实现类方法。==</p><p>接口的实现类(即要代理的对象)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package org.dynamicproxy.test;</span><br><span class="line"></span><br><span class="line">public class UserDaoMysqlImpl implements UserDao &#123;</span><br><span class="line"></span><br><span class="line">    public void addUser(User user) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        System.out.println(&quot;connect to MySQL DataBase...&quot;);</span><br><span class="line">        System.out.println(&quot;id为&quot;+user.getId()+&quot;的用户信息成功添加到数据库表中...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface UserDao &#123;</span><br><span class="line">    void addUser(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代理类的方法执行时，能够做额外工作的类，而这个类必须继承InvocationHandler接口  处理类(即能够做额外工作的类)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package org.dynamicproxy.test;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class LogHandler implements InvocationHandler &#123;</span><br><span class="line">    &#x2F;&#x2F; 持有被代理对象的引用（此引用可以有外部灵活制定的）</span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public LogHandler(Object target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">            throws Throwable &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        System.out.println(&quot;开始记录日志，添加用户方法开始执行...&quot;);</span><br><span class="line">        method.invoke(target, args);</span><br><span class="line">        System.out.println(&quot;开始记录日志，添加用户方法执行结束...&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为代理类的实例在调用实现类的方法的时候，不会调真正的实现类的这个方法， 而是转而调用这个类的invoke方法（继承时必须实现的方法），在这个方法中你可以调用真正的实现类的这个方法。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TestProxy&#123;</span><br><span class="line"> </span><br><span class="line">    @Test</span><br><span class="line">    public void testProxy()&#123;</span><br><span class="line">    UserDao userDAO &#x3D; new UserDaoMysqlImpl();</span><br><span class="line">    LogHandler li &#x3D; new LogHandler(userDAO);  &#x2F;&#x2F;创建一个Handerler对象</span><br><span class="line">　　</span><br><span class="line">    UserDao userDAOProxy &#x3D; (UserDao)Proxy.newProxyInstance(userDAO.getClass().getClassLoader(), userDAO.getClass().getInterfaces(), li);</span><br><span class="line">    userDAOProxy.addUser(new User(&quot;001&quot;));</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="newProxyInstance参数含义"><a href="#newProxyInstance参数含义" class="headerlink" title="newProxyInstance参数含义"></a>newProxyInstance参数含义</h4><ul><li>第一个参数：代理的类加载器，必须和被代理的对象是一个类加载器</li><li>第二个参数含义:代理对象要实现的那些接口</li><li>第三个参数：指派方法调用的调用处理程序</li></ul><h4 id="代理调用过程"><a href="#代理调用过程" class="headerlink" title="代理调用过程"></a>代理调用过程</h4><ul><li>得到UserDaoMysqlImpl这个类的一个代理类userDAOProxy，同时为代理类绑定了一个处理类LogHandler li</li><li>每次调用UserDaoMysqlImpl这个子类的addUser方法时， </li><li>不是userDAO这个UserDaoMysqlImpl类的实例去调用， </li><li>而是这个UserDaoMysqlImpl的代理类userDAOProxy去调用它自己的invoke方法, </li><li>这个invoke方法里呢可以调用userDAO这个实例的addUser方法</li></ul><h3 id="动态代理原理："><a href="#动态代理原理：" class="headerlink" title="动态代理原理："></a>动态代理原理：</h3>]]></content>
      
      
      <categories>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/8%E3%80%81volatile/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/8%E3%80%81volatile/</url>
      
        <content type="html"><![CDATA[<p>被 volatile 修饰的变量具备两种特性：</p><ul><li>1、保证该变量对所有线程的可见性；</li></ul><p>CPU修改数据，首先是对缓存的修改，然后再同步回主存，在同步回主存的时候，如果其他CPU也缓存了这个数据，就会导致其他CPU缓存上的数据失效，这样，当其他CPU再去它的缓存读取这个数据的时候，就必须从主存重新获取</p><ul><li>2、禁止指令重排序优化。</li></ul><p>==想要线程安全必须保证原子性，可见性，有序性==。而volatile只能保证可见性和有序性。所以基于 volatile 变量的运算在并发下不一定是安全的</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileTest &#123;</span><br><span class="line"></span><br><span class="line">    private static final int THREADS_COUNT &#x3D; 20;</span><br><span class="line"></span><br><span class="line">    private static volatile int race &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private static void increase() &#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Thread[] threads &#x3D; new Thread[THREADS_COUNT];</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (Thread.activeCount() &gt; 1) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;race &#x3D; &quot; + race);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>race++的操作分解：</p><ul><li>a）读取 race 的值；</li><li>b）将 race 值加一；</li><li>c）将 race 值写回内存。</li></ul><p>volatile 关键字能够保证 a）操作读取的 race 的值在这一时刻是正确的，但在执行 b）、c）操作时，可能有其他的线程已经对 race 的值进行了修改，导致了 c）操作可能把较小的 race 值同步回主内存之中。所以要想保证结果的正确性，需要在 increase() 方法加锁才行。</p><h3 id="因此使用volatile的场景："><a href="#因此使用volatile的场景：" class="headerlink" title="因此使用volatile的场景："></a>因此使用volatile的场景：</h3><ul><li><p>运算结果并不依赖变量的当前值，或者能够保证确保只有单一的线程修改变量的值。</p></li><li><p>变量不需要与其他的状态变量共同参与不变约束。 </p></li><li></li></ul><p>olatile的写-读相当于锁的释放-获取有相同的内存效果</p><p>==从JDK5开始，volatile变量的写-读可以实现线程之间的通信==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Example &#123;</span><br><span class="line">    private boolean stop &#x3D; false;</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        System.out.println(&quot;thread1 start loop.&quot;);</span><br><span class="line">        while(!getStop()) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;thread1 finish loop,i&#x3D;&quot; + i);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean getStop() &#123;</span><br><span class="line">        return stop; &#x2F;&#x2F; 对普通变量的读</span><br><span class="line">    &#125;</span><br><span class="line">    public void setStop(boolean flag) &#123;</span><br><span class="line">        this.stop &#x3D; flag; &#x2F;&#x2F; 对普通变量的写</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class VolatileExample &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        final Example example &#x3D; new Example();</span><br><span class="line">        Thread t1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                example.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        System.out.println(&quot;主线程即将置stop值为true...&quot;);</span><br><span class="line">        example.setStop(true);</span><br><span class="line">        System.out.println(&quot;主线程已将stop值为：&quot; + example.getStop());</span><br><span class="line">        System.out.println(&quot;主线程等待线程1执行完...&quot;);</span><br><span class="line"></span><br><span class="line">        t1.join();</span><br><span class="line">        System.out.println(&quot;线程1已执行完毕，整个流程结束...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==想要理解透volatile特性有一个很好的方法，就是把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步。==</p><h3 id="volatile写-读的内存语义"><a href="#volatile写-读的内存语义" class="headerlink" title="volatile写-读的内存语义"></a>volatile写-读的内存语义</h3><ul><li><p>当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</p></li><li><p>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mycat分库分表、读写分离配置</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/MyCat/3%E3%80%81mycat%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E3%80%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E9%85%8D%E7%BD%AE/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/MyCat/3%E3%80%81mycat%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E3%80%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>用mycat做读写分离：基于 MySQL主从复制</p><h3 id="修改schema-xml："><a href="#修改schema-xml：" class="headerlink" title="修改schema.xml："></a>修改schema.xml：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;</span><br><span class="line">&lt;mycat:schema xmlns:mycat&#x3D;&quot;http:&#x2F;&#x2F;io.mycat&#x2F;&quot;&gt;</span><br><span class="line">       &lt;!-- mycat逻辑库--&gt;</span><br><span class="line">        &lt;schema name&#x3D;&quot;mycatdb&quot; checkSQLschema&#x3D;&quot;false&quot; sqlMaxLimit&#x3D;&quot;100&quot;&gt;</span><br><span class="line">               &lt;!-- mycay逻辑表，配置表区分--&gt;</span><br><span class="line">                &lt;!-- 自动取模分片 --&gt;</span><br><span class="line">                &lt;table name&#x3D;&quot;t_person&quot; dataNode&#x3D;&quot;dn1,dn2,dn3&quot; rule&#x3D;&quot;mod-long&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">                &lt;!-- 一致性hash分片，分片列不要使用MySQL原生函数 --&gt;</span><br><span class="line">                &lt;table name&#x3D;&quot;t_user&quot; primaryKey&#x3D;&quot;id&quot; dataNode&#x3D;&quot;dn1,dn2&quot; rule&#x3D;&quot;sharding-by-murmur&quot; &#x2F;&gt;</span><br><span class="line">                &lt;!-- 全局表 --&gt;</span><br><span class="line">                &lt;table name&#x3D;&quot;province&quot; type&#x3D;&quot;global&quot; dataNode&#x3D;&quot;dn1,dn2,dn3&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- E-R关系分片 --&gt;</span><br><span class="line">                &lt;table name&#x3D;&quot;customer&quot; dataNode&#x3D;&quot;dn1,dn2,dn3&quot; rule&#x3D;&quot;auto-sharding-long-customer&quot;&gt;</span><br><span class="line">                        &lt;childTable name&#x3D;&quot;orders&quot; joinKey&#x3D;&quot;customer_id&quot; parentKey&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;table&gt;</span><br><span class="line">                &lt;!-- E-R关系分片，多表 --&gt;</span><br><span class="line">                &lt;table name&#x3D;&quot;user&quot; primaryKey&#x3D;&quot;id&quot; dataNode&#x3D;&quot;dn1,dn2&quot; rule&#x3D;&quot;mod-long-test&quot;&gt;</span><br><span class="line">                        &lt;childTable name&#x3D;&quot;cell&quot; joinKey&#x3D;&quot;user_id&quot; parentKey&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">                        &lt;childTable name&#x3D;&quot;note&quot; joinKey&#x3D;&quot;user_id&quot; parentKey&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">                        &lt;childTable name&#x3D;&quot;lit&quot; joinKey&#x3D;&quot;user_id&quot; parentKey&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">                        &lt;childTable name&#x3D;&quot;lit_usr&quot; joinKey&#x3D;&quot;user_id&quot; parentKey&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line">        &lt;&#x2F;schema&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 分片节点信息 --&gt;</span><br><span class="line">        &lt;dataNode name&#x3D;&quot;dn1&quot; dataHost&#x3D;&quot;localhost1&quot; database&#x3D;&quot;db1&quot; &#x2F;&gt;</span><br><span class="line">        &lt;dataNode name&#x3D;&quot;dn2&quot; dataHost&#x3D;&quot;localhost1&quot; database&#x3D;&quot;db2&quot; &#x2F;&gt;</span><br><span class="line">        &lt;dataNode name&#x3D;&quot;dn3&quot; dataHost&#x3D;&quot;localhost1&quot; database&#x3D;&quot;db3&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        &lt;!-- 连接MySQL的信息 &amp;&amp; 读写分离策略 --&gt;</span><br><span class="line">        &lt;dataHost name&#x3D;&quot;localhost1&quot; maxCon&#x3D;&quot;500&quot; minCon&#x3D;&quot;100&quot; balance&#x3D;&quot;0&quot;</span><br><span class="line">                          writeType&#x3D;&quot;0&quot; dbType&#x3D;&quot;mysql&quot; dbDriver&#x3D;&quot;native&quot; switchType&#x3D;&quot;1&quot;  slaveThreshold&#x3D;&quot;100&quot;&gt;</span><br><span class="line">                &lt;heartbeat&gt;select user();&lt;&#x2F;heartbeat&gt;</span><br><span class="line">                &lt;writeHost host&#x3D;&quot;hostM1&quot; url&#x3D;&quot;localhost:3306&quot; user&#x3D;&quot;root&quot; password&#x3D;&quot;abcdef&quot;&gt;</span><br><span class="line">                        &lt;readHost host&#x3D;&quot;hostS1&quot; url&#x3D;&quot;localhost:3306&quot; user&#x3D;&quot;root&quot; password&#x3D;&quot;123456&quot; &#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;writeHost&gt;</span><br><span class="line">        &lt;&#x2F;dataHost&gt;</span><br><span class="line">&lt;&#x2F;mycat:schema&gt;</span><br></pre></td></tr></table></figure><p>以上为最简单的配置，一主一从结构。<br>MyCat支持双主多从，配置两个writeHost兄弟节点，多个readHost节点即可</p><h3 id="此处有三点需要注意："><a href="#此处有三点需要注意：" class="headerlink" title="此处有三点需要注意："></a>此处有三点需要注意：</h3><p>balance=”1”，writeType=”0” ,switchType=”1” </p><h4 id="balance："><a href="#balance：" class="headerlink" title="balance："></a>balance：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">balance&#x3D;&quot;0&quot;, 不开启读写分离机制，所有读操作都发送到当前可用的writeHost 上。</span><br><span class="line">balance&#x3D;&quot;1&quot;，全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡，简单的说，当双主双从模式(M1 -&gt;S1 ， M2-&gt;S2，并且 M1 与 M2 互为主备)，正常情况下， M2,S1,S2 都参与 select 语句的负载均衡。</span><br><span class="line">balance&#x3D;&quot;2&quot;，所有读操作都随机的在 writeHost、 readhost 上分发。</span><br><span class="line">balance&#x3D;&quot;3&quot;， 所有读请求随机的分发到 wiriterHost 对应的 readhost 执行,writerHost 不负担读压力，注意 balance&#x3D;3 只在 1.4 及其以后版本有， 1.3 没有。</span><br></pre></td></tr></table></figure><h4 id="writeType："><a href="#writeType：" class="headerlink" title="writeType："></a>writeType：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">writeType&#x3D;&quot;0&quot;, 所有写操作发送到配置的第一个 writeHost，第一个挂了切到还生存的第二个writeHost，重新启动后已切换后的为准，切换记录在配置文件中:dnindex.properties .</span><br><span class="line">writeType&#x3D;&quot;1&quot;，所有写操作都随机的发送到配置的 writeHost。</span><br><span class="line">writeType&#x3D;&quot;2&quot;，所有写操作都随机的在writeHost、readhost分上发</span><br></pre></td></tr></table></figure><h4 id="switchType："><a href="#switchType：" class="headerlink" title="switchType："></a>switchType：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1 表示不自动切换</span><br><span class="line">1 默认值，自动切换</span><br><span class="line">2 基于mycal主从同步的状态决定是否切换（如果同步状态正常，就按配置的，如果不正常，读写就自动切换到能用的一者了）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyCat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mycat分库分表、读写分离配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式原则</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/13%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>设计模式遵循的七大原则：</p><h3 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h3><p>出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p><ul><li>类中的代码行数、函数或者属性过多；</li><li>类依赖的其他类过多，或者依赖类的其他类过多；</li><li>私有方法过多；</li><li>比较难给类起一个合适的名字；</li><li>类中大量的方法都是集中操作类中的某几个属性。</li></ul><p>单一职责原则 要求一个接口或类只有一个原因引起变化</p><p>对类来说的，即一个类应该只负责一项职责。<br>意在原子性，降低类之间的耦合度。</p><h3 id="2、里氏替换原则"><a href="#2、里氏替换原则" class="headerlink" title="2、里氏替换原则"></a>2、里氏替换原则</h3><p>==翻译就是：复合优于继承，因为继承会增加类的耦合性。==</p><p>里氏替换原则为良好的继承定义了一个规范.</p><p>1.子类必须完全实现父类的方法,如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发 生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。</p><p>2.子类可以有自己的个性</p><p>3.覆盖或实现父类的方法时输入参数可以被放大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Father &#123;</span><br><span class="line">    public Collection doSomething(HashMap map)&#123;</span><br><span class="line">        System.out.println(&quot;父类被执行...&quot;);</span><br><span class="line">        return map.values();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Son extends Father &#123;</span><br><span class="line">&#x2F;&#x2F;放大输入参数类型</span><br><span class="line">    public Collection doSomething(HashMap map)&#123;</span><br><span class="line">        System.out.println(&quot;子类被执行...&quot;);</span><br><span class="line">        return map.values();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;父类存在的地方，子类就应该能够存在</span><br><span class="line">Father f &#x3D; new Father(); </span><br><span class="line">HashMap map &#x3D; new HashMap();</span><br><span class="line">f.doSomething(map);</span><br><span class="line">&#x2F;&#x2F;父类被执行</span><br><span class="line"></span><br><span class="line">Son f &#x3D;new Son(); </span><br><span class="line">HashMap map &#x3D; new HashMap();</span><br><span class="line">f.doSomething(map);</span><br><span class="line">&#x2F;&#x2F;父类被执行</span><br></pre></td></tr></table></figure><ol start="4"><li>覆写或实现父类的方法时输出结果可以被缩小</li></ol><p>如果是覆写，父类和子类的同名方法的 输入参数是相同的，两个方法的范围值S小于等于T，这是覆写的要求，</p><p>如果是重载，则要求方法的输入参数类型或数量不相同，在 里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这 个方法是不会被调用的</p><p>==总结==：在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，这个子 类和父类之间的关系就很难调和了</p><h3 id="3、依赖倒转原则"><a href="#3、依赖倒转原则" class="headerlink" title="3、依赖倒转原则"></a>3、依赖倒转原则</h3><p>翻译就是：注重面向接口编程</p><p>具体依赖倒置原则在Java语言中的表现就是：</p><ul><li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过 接口或抽象类产生的； </li><li>接口或抽象类不依赖于实现类； </li><li>实现类依赖接口或抽象类。</li></ul><h3 id="4、接口隔离原则"><a href="#4、接口隔离原则" class="headerlink" title="4、接口隔离原则"></a>4、接口隔离原则</h3><p>尽量使用多个隔离的接口，比融合使用单个接口要好。也是意在原子性，降低类之间的耦合度。</p><h3 id="5、开闭原则"><a href="#5、开闭原则" class="headerlink" title="5、开闭原则"></a>5、开闭原则</h3><p>一个类应该对调用方扩展开放，对修改关闭。即在程序需要进行功能拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。注重面向接口编程</p><h3 id="6、迪米特法则"><a href="#6、迪米特法则" class="headerlink" title="6、迪米特法则"></a>6、迪米特法则</h3><p>又称最少知道原则。即一个类对自己依赖的类知道的<br>越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public 方法，不对外泄露任何信息。注重封装性</p><h3 id="7、合成复用原则"><a href="#7、合成复用原则" class="headerlink" title="7、合成复用原则"></a>7、合成复用原则</h3><p>尽量使用合成/聚合的方式，而不是使用继承。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式原则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息广播</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/3%E3%80%81RocketMQ/8%E3%80%81%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/3%E3%80%81RocketMQ/8%E3%80%81%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<p>上面发送消息，我们测试的时候，可以发现消息只有一个消费者能收到，如果我们想实现消息广播，让每个消费者都能收到消息也是可以实现的。而且上面发送消息的时候，每次都是发送单条Message对象，能否批量发送呢？答案是可以的。</p><h3 id="广播生产者："><a href="#广播生产者：" class="headerlink" title="广播生产者："></a>广播生产者：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class BroadcastingProducer &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;nameserver地址</span><br><span class="line">    private static String namesrvaddress&#x3D;&quot;192.168.211.143:9876;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws UnsupportedEncodingException, MQClientException, RemotingException, InterruptedException, MQBrokerException &#123;</span><br><span class="line">        &#x2F;&#x2F;创建DefaultMQProducer</span><br><span class="line">        DefaultMQProducer producer &#x3D; new DefaultMQProducer(&quot;broadcasting_producer_group&quot;);</span><br><span class="line">        &#x2F;&#x2F;指定nameserver地址</span><br><span class="line">        producer.setNamesrvAddr(namesrvaddress);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;启动</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建消息</span><br><span class="line">        List&lt;Message&gt; messages &#x3D; new ArrayList&lt;Message&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt;20 ; i++) &#123;</span><br><span class="line">            Message message &#x3D; new Message(</span><br><span class="line">                    &quot;Topic_broadcasting&quot;,</span><br><span class="line">                    &quot;TagBroad&quot;,</span><br><span class="line">                    &quot;KeyBroad&quot;+i,</span><br><span class="line">                    (i+&quot;--hello brodcasting&quot;).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;将消息添加到集合中</span><br><span class="line">            messages.add(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;批量发送消息</span><br><span class="line">        producer.send(messages);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;关闭</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><p>==广播消费模式其实就是每个消费者都能读取到消息，我们这里只需要将消费者的消费模式设置成广播模式即可。==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class BroadcastingConsumerDemo1 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;广播模式</span><br><span class="line">    private static String namesrvaddress&#x3D;&quot;192.168.211.143:9876;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws MQClientException &#123;</span><br><span class="line">        &#x2F;&#x2F;创建DefaultMQConsumer</span><br><span class="line">        DefaultMQPushConsumer consumer &#x3D; new DefaultMQPushConsumer(&quot;broadcasting_consumer_group&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;指定nameserver地址</span><br><span class="line">        consumer.setNamesrvAddr(namesrvaddress);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;指定要消费的消息主体</span><br><span class="line">        consumer.subscribe(&quot;Topic_broadcasting&quot;,&quot;*&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;指定消费顺序</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;指定一次拉取条数</span><br><span class="line">        consumer.setConsumeMessageBatchMaxSize(2);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;指定消费模式    集群模式&#x2F;广播模式</span><br><span class="line">        consumer.setMessageModel(MessageModel.BROADCASTING);</span><br><span class="line">        &#x2F;&#x2F;创建监听，监听消息</span><br><span class="line">        consumer.setMessageListener(new MessageListenerConcurrently() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">                for (MessageExt msg : msgs) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        String topic &#x3D; msg.getTopic();</span><br><span class="line">                        String tags &#x3D; msg.getTags();</span><br><span class="line">                        String keys &#x3D; msg.getKeys();</span><br><span class="line">                        String body &#x3D; new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);</span><br><span class="line">                        System.out.println(&quot;demo1        topic:&quot;+topic+&quot;,tags:&quot;+tags+&quot;,keys:&quot;+keys+&quot;,body:&quot;+body);</span><br><span class="line">                    &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;启动</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息广播 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringTask</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/8%E3%80%81%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/SpringTask/SpringTask/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/8%E3%80%81%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/SpringTask/SpringTask/</url>
      
        <content type="html"><![CDATA[<p>定时任务的几种实现：</p><ul><li>java自带的Timer</li><li>Quartz</li><li>轻量级的Quartz：Spring Task</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Timer().schedule(new TimerTask() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">&#x2F;&#x2F;业务实现</span><br><span class="line">&#125;</span><br><span class="line">&#125;, date, long);</span><br></pre></td></tr></table></figure><h3 id="1、添加定时任务"><a href="#1、添加定时任务" class="headerlink" title="1、添加定时任务"></a>1、添加定时任务</h3><ul><li>1、启动类中开启定时任务：@EnableScheduling</li><li>2、新建任务类，加入spring.在方法上添加注解：@Scheduled</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class TestJob &#123;</span><br><span class="line">    private static final Logger log &#x3D; LoggerFactory.getLogger(TestJob.class);</span><br><span class="line">    private static int count;</span><br><span class="line"></span><br><span class="line">    @Scheduled(cron &#x3D; &quot;0&#x2F;10 * * * * ?&quot;)</span><br><span class="line">    public void cron() &#123;</span><br><span class="line">        log.info(&quot;spring anno task execute times &#123;&#125;&quot;, count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Scheduled所支持的参数：</p><ul><li>cron：cron表达式，指定任务在特定时间执行；</li><li>fixedDelay：表示上一次任务执行完成后多久再次执行，参数类型为long，单位ms；</li><li>fixedDelayString：与fixedDelay含义一样，只是参数类型变为String；</li><li>fixedRate：表示按一定的频率执行任务，参数类型为long，单位ms；</li><li>fixedRateString: 与fixedRate的含义一样，只是将参数类型变为String；</li><li>initialDelay：表示延迟多久再第一次执行任务，参数类型为long，单位ms；</li><li>initialDelayString：与initialDelay的含义一样，只是将参数类型变为String；</li><li>zone：时区，默认为当前时区，一般没有用到。</li></ul><h3 id="2、动态修改cron-参数："><a href="#2、动态修改cron-参数：" class="headerlink" title="2、动态修改cron 参数："></a>2、动态修改cron 参数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class TaskCronChange implements SchedulingConfigurer &#123;</span><br><span class="line">    &#x2F;&#x2F;原cron</span><br><span class="line">    private String expression &#x3D; &quot;* * * * * *&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;动态修改</span><br><span class="line">    @RequestMapping(&quot;changeExpression&quot;)</span><br><span class="line">    public void changeExpression() &#123;</span><br><span class="line">        expression &#x3D; &quot;0&#x2F;10 * * * * *&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123;</span><br><span class="line"></span><br><span class="line">        taskRegistrar.addTriggerTask(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F;执行的任务</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, new Trigger() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Date nextExecutionTime(TriggerContext triggerContext) &#123;</span><br><span class="line">                CronTrigger trigger &#x3D; new CronTrigger(expression);</span><br><span class="line">                return trigger.nextExecutionTime(triggerContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、动态添加-删除定时任务"><a href="#3、动态添加-删除定时任务" class="headerlink" title="3、动态添加 删除定时任务"></a>3、动态添加 删除定时任务</h3><ul><li>ThreadPoolTaskScheduler，线程任务调度类，能开启线程池进行任务调度。</li><li>ThreadPoolTaskScheduler.Schedule()方法会创建一个定时计划ScheduledFuture。这个计划可以停止定时任务。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@EnableScheduling</span><br><span class="line">@RequestMapping(&quot;&#x2F;DynamicTask&quot;)</span><br><span class="line">public class DynamicTask &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    ThreadPoolTaskScheduler poolTaskScheduler;</span><br><span class="line">    private ScheduledFuture&lt;?&gt; schedule;</span><br><span class="line">    private String cron &#x3D; &quot;* * * * * *&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    private ThreadPoolTaskScheduler poolTaskScheduler() &#123;</span><br><span class="line">        return new ThreadPoolTaskScheduler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;startTask&quot;)</span><br><span class="line">    private String startTask() &#123;</span><br><span class="line">        schedule &#x3D;poolTaskScheduler.schedule(new MyRunnable(), new CronTrigger(cron));</span><br><span class="line">        return &quot;startTask&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;stopTask&quot;)</span><br><span class="line">    private String stopTask() &#123;</span><br><span class="line">        if (schedule !&#x3D; null) &#123;</span><br><span class="line">            schedule.cancel(true);</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;stopTask&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;changeCron&quot;)</span><br><span class="line">    private String changeCron() &#123;</span><br><span class="line">        stopTask();</span><br><span class="line">        cron &#x3D; &quot;0&#x2F;5 * * * * *&quot;;</span><br><span class="line">        startTask();</span><br><span class="line">        return &quot;change Cron&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class MyRunnable implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.err.println(&quot;DynamicTask run&quot; + new Date());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringTask </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringTask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户管理</title>
      <link href="2020/06/21/Study%20notes/7%E3%80%81linux/linux/2%E3%80%81%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/7%E3%80%81linux/linux/2%E3%80%81%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><h5 id="添加账号"><a href="#添加账号" class="headerlink" title="添加账号"></a>添加账号</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd 选项 用户名</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">选项:</span><br><span class="line">-c comment 指定一段注释性描述。</span><br><span class="line">-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</span><br><span class="line">-g 用户组 指定用户所属的用户组。</span><br><span class="line">-G 用户组，用户组 指定用户所属的附加组。</span><br><span class="line">-s Shell文件 指定用户的登录Shell。</span><br><span class="line">-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># useradd appuser</span><br><span class="line"># useradd –d  &#x2F;home&#x2F;appuser -m sam</span><br><span class="line"># useradd -s &#x2F;bin&#x2F;sh -g group –G adm,root appuser</span><br></pre></td></tr></table></figure><h5 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">passwd 选项 用户名</span><br><span class="line"></span><br><span class="line">选项</span><br><span class="line">-l 锁定口令，即禁用账号。</span><br><span class="line">-u 口令解锁。</span><br><span class="line">-d 使账号无口令。</span><br><span class="line">-f 强迫用户下次登录时修改口令。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># passwd appuser </span><br><span class="line">New password:******* </span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure><h5 id="删除帐号"><a href="#删除帐号" class="headerlink" title="删除帐号"></a>删除帐号</h5><p>删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># userdel -r appuser</span><br><span class="line"></span><br><span class="line">#选项 -r，它的作用是否需要把用户的主目录一起删除。</span><br></pre></td></tr></table></figure><h5 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usermod 选项 用户名</span><br><span class="line">#选项与添加账户的一致</span><br></pre></td></tr></table></figure><h5 id="查询用户："><a href="#查询用户：" class="headerlink" title="查询用户："></a>查询用户：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id appuser</span><br></pre></td></tr></table></figure><h5 id="切换用户："><a href="#切换用户：" class="headerlink" title="切换用户："></a>切换用户：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - appuser</span><br></pre></td></tr></table></figure><h5 id="添加用户组"><a href="#添加用户组" class="headerlink" title="添加用户组"></a>添加用户组</h5><p>每个用户都必须属于一个用户组，不能独立于组外。系统可以对一个用户组中的所有用户进行集中管理</p><p>groupadd 选项 用户组</p><p>g GID 指定新用户组的组标识号（GID）。<br>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># groupadd -g 101 appuserGroup</span><br></pre></td></tr></table></figure><h5 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel appuserGroup</span><br></pre></td></tr></table></figure><h5 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">groupmod 选项 用户组</span><br><span class="line"></span><br><span class="line">选项</span><br><span class="line">-g GID 为用户组指定新的组标识号。</span><br><span class="line">-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</span><br><span class="line">-n新用户组 将用户组的名字改为新名字</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#组appuserGroup的标识号改为10000，组名修改为appuserGroupNew</span><br><span class="line"># groupmod –g 10000 -n appuserGroup appuserGroupNew</span><br></pre></td></tr></table></figure><h5 id="linux找回root密码"><a href="#linux找回root密码" class="headerlink" title="linux找回root密码"></a>linux找回root密码</h5><p>首先需要知道linux的运行级别：</p><p>linux的init进程就是根据/etc/inittab这个文件来在不同的运行级别启动相应的进程或执行相应的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id：runlevels：action：process</span><br></pre></td></tr></table></figure><ul><li>id：它是每个登记项的标识符，用于唯一标识每个登记项，不能重复</li><li>runlevels：系统的运行级别，表示process的action要在哪个级别下运行，该段中可以定义多个运行级别，各级别之间直接写不用分隔符；如果为空，表示在所有的运行级别运行。Linux的运行级别有：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0：表示关机</span><br><span class="line">1：表示单用户模式，在这个模式中，用户登录不需要密码，默认网卡驱动是不被加载，一些服务不能用。</span><br><span class="line">2：表示多用户模式，NFS服务不开启</span><br><span class="line">3，表示命令行模式（常用）</span><br><span class="line">4，这个模式保留未用</span><br><span class="line">5，表示图形用户模式（常用）</span><br><span class="line">6，表示重启系统</span><br></pre></td></tr></table></figure><p>切换到指定的运行级别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init 1</span><br></pre></td></tr></table></figure><p>进入单用户模式，使用passwd指令修改root密码</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用户管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8%E3%80%81%E5%9B%BE/1%E3%80%81%E5%9B%BE/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8%E3%80%81%E5%9B%BE/1%E3%80%81%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h5 id="相关术语："><a href="#相关术语：" class="headerlink" title="相关术语："></a>相关术语：</h5><ul><li>顶点：树中的元素我们称为节点，图中的元素我们就叫作顶点。例如微博中的一个用户</li><li>边：顶点可以与任意其他顶点建立连接关系。我们把这种建立的关系叫作边。例如微博用户 A 关注了用户 B</li><li>无向图（图的边无方向）：单纯的A与B相连：例如微信用户A与B为好有关系</li><li>有向图（图的边有方向）：顶点A指向B，例如微博用户A关注了B，但B未关注A</li><li>度（degree）：顶点相连接的边的条数。有向图中分。入度（In-degree）：有多少边的箭头指向自己，出度（Out-degree）：有多少边的箭头，从自己指向他人</li><li>带权图（weighted graph）：每条边都有一个权重，例如QQ用户A与B为好有关系有亲密度值</li></ul><h4 id="图的存储方式"><a href="#图的存储方式" class="headerlink" title="图的存储方式"></a>图的存储方式</h4><h5 id="邻接矩阵："><a href="#邻接矩阵：" class="headerlink" title="邻接矩阵："></a>邻接矩阵：</h5><p>邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j]和 A[j][i]标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j]标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i]标记为 1。对于带权图，数组中就存储相应的权重</p><p>缺点：浪费存储空间</p><p>对于无向图来说，如果 A[i][j]等于 1，那 A[j][i]也肯定等于 1。实际上，我们只需要存储一个就可以了。也就是说，无向图的二维数组中，如果我们将其用对角线划分为上下两部分，那我们只需要利用上面或者下面这样一半的空间就足够了，另外一半白白浪费掉了。<br>如何优化：稀疏数组。前面提到的二维数组存储替代方案就是稀疏数组</p><p>优点：简单、直观、方便计算</p><p>因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。比如求解最短路径问题<br>可以利用矩阵循环相乘若干次得到结果。<br>例如：查询否存在一条从顶点 2 到顶点 4 的边，<br>而采用邻接矩阵则只需要看二维数据[2][3]是否存在值即可<br>采用邻接表则要遍历顶点 2 对应的那条链表，看链表中是否存在顶点 4</p><h5 id="邻接表存储"><a href="#邻接表存储" class="headerlink" title="邻接表存储"></a>邻接表存储</h5><p>每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。</p><p>优点:节省存储空间</p><p>缺点:查询否存在一条从顶点 2 到顶点 4 的边，<br>采用邻接表则要遍历顶点 2 对应的那条链表，看链表中是否存在顶点 4<br>而采用邻接矩阵则只需要看二维数据[2][3]是否存在值即可</p><p>优化版:链表换成更加高效的动态数据结构，比如平衡二叉查找树、跳表、散列表等</p><p>逆邻接表:</p><p>微博为有向图，采用邻接表存储，我们去查找某个用户关注了哪些用户非常容易，但是如果要想知道某个用户都被哪些用户关注了，也就是用户的粉丝列表，是非常困难的。</p><p>邻接表中存储了用户的关注关系，逆邻接表中存储的是用户的被关注关系。</p>]]></content>
      
      
      <categories>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtomicInteger</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/11%E3%80%81AtomicInteger/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/JUC/11%E3%80%81AtomicInteger/</url>
      
        <content type="html"><![CDATA[<p>jdk5之后 java.util.concurrent.atomic下提供了很多常用原子变量</p><ul><li>AtomicBoolean 、AtomicInteger 、AtomicLong 、 AtomicReference</li><li>AtomicIntegerArray 、AtomicLongArray </li><li>AtomicMarkableReference </li><li>AtomicReferenceArray </li><li>AtomicStampedReference</li></ul><p>底层线程安全原理：</p><ul><li><p>1、volatile修饰保证内存可见性（可见性和有序性）</p></li><li><p>2、CAS算法保证数据的原子性</p><p>  CAS： 当且仅当内存值等于预估值时，将更新值赋给内存值，否则什么操作都不做。</p></li></ul><p>AtomicInteger为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicInteger extends Number implements java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 6214790243416807050L;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    *调用指针类Unsafe</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private static final Unsafe unsafe &#x3D; Unsafe.getUnsafe();</span><br><span class="line">    &#x2F;*</span><br><span class="line">    *变量value的内存偏移量</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line">    </span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            valueOffset &#x3D; unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    *volatile修饰的int变量value</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private volatile int value;</span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *带参数的构造函数</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public AtomicInteger(int initialValue) &#123;</span><br><span class="line">        value &#x3D; initialValue;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    *不带参数的构造函数</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public AtomicInteger() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *获取当前最新值</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final int get() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *设置当前值</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final void set(int newValue) &#123;</span><br><span class="line">        value &#x3D; newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *最终把值设置为newValue，使用该方法后，其他线程在一段时间内还会获取到旧值</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final void lazySet(int newValue) &#123;</span><br><span class="line">        unsafe.putOrderedInt(this, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *设置新值并返回旧值</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final int getAndSet(int newValue) &#123;</span><br><span class="line">        return unsafe.getAndSetInt(this, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    *如果当前值为expect，则设置为update</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *当前值加1返回旧值</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final int getAndIncrement() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *当前值减1返回旧值</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final int getAndDecrement() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, -1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *当前值增加delta，返回旧值</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final int getAndAdd(int delta) &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, delta);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *当前值增加1返回新值</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final int incrementAndGet() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    *当前值减1，返回新值</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public final int decrementAndGet() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, -1) - 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AtomicInteger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper常用命令</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/7%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/zookeeper/4%E3%80%81zookeeper%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/7%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/zookeeper/4%E3%80%81zookeeper%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>用给定的路径创建一个znode。flag参数指定创建的znode是临时的，持久的还是顺序的。节点创建后临时和永久特性不能被更改</p><ul><li><p>默认情况下，所有znode都是持久的。</p></li><li><p>临时节点：当会话过期或客户端断开连接时，临时节点（flag：-e）将被自动删除。所以临时节点下不允许创建子节点</p></li><li><p>顺序节点保证znode路径将是唯一的。<br>ZooKeeper集合将向znode路径填充10位序列号。例如，znode路径 /myapp 将转换为/myapp0000000001，下一个序列号将为/myapp0000000002。如果没有指定flag，则znode被认为是持久的。</p></li></ul><h3 id="1、创建znode"><a href="#1、创建znode" class="headerlink" title="1、创建znode"></a>1、创建znode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create &#x2F;FirstZnode “Myfirstzookeeper-app&quot;</span><br></pre></td></tr></table></figure><p>要创建顺序节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -s &#x2F;FirstZnode “second-data&quot;</span><br></pre></td></tr></table></figure><p>创建临时节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -e &#x2F;SecondZnode “Ephemeral-data&quot;</span><br></pre></td></tr></table></figure><p>创建znode的子节点</p><p>创建子节点类似于创建新的znode。唯一的区别是，子znode的路径也将具有父路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create &#x2F;FirstZnode&#x2F;Child1 “firstchildren&quot;</span><br></pre></td></tr></table></figure><h3 id="2、查询节点"><a href="#2、查询节点" class="headerlink" title="2、查询节点"></a>2、查询节点</h3><p>cZxid和mZxid</p><p>ephemeralOwner </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">get &#x2F;FirstZnode</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] get &#x2F;FirstZnode</span><br><span class="line">“Myfirstzookeeper-app&quot;</span><br><span class="line"></span><br><span class="line">#czxid-创建节点的事务id</span><br><span class="line">cZxid &#x3D; 0x7f</span><br><span class="line"></span><br><span class="line">#ctime - znode被创建的毫秒数(从1970年开始)</span><br><span class="line">ctime &#x3D; Tue Sep 29 16:15:47 IST 2015</span><br><span class="line"></span><br><span class="line">#znode最后更新的事务id</span><br><span class="line">mZxid &#x3D; 0x7f</span><br><span class="line"></span><br><span class="line">#znode最后修改的毫秒数(从1970年开始)</span><br><span class="line">mtime &#x3D; Tue Sep 29 16:15:47 IST 2015</span><br><span class="line"></span><br><span class="line">#znode最后更新的子节点zxid</span><br><span class="line">pZxid &#x3D; 0x7f</span><br><span class="line"></span><br><span class="line">#znode子节点变化号，znode子节点修改次数</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line"></span><br><span class="line"># znode数据变化号   </span><br><span class="line">dataVersion &#x3D; 0</span><br><span class="line"></span><br><span class="line">#znode访问控制列表的变化号</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line"></span><br><span class="line"># 如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0。</span><br><span class="line">ephemeralOwner &#x3D; 0x0</span><br><span class="line"></span><br><span class="line">#znode的数据长度</span><br><span class="line">dataLength &#x3D; 22</span><br><span class="line"></span><br><span class="line">#znode子节点数量</span><br><span class="line">numChildren &#x3D; 0</span><br></pre></td></tr></table></figure><p>要访问顺序节点，必须输入znode的完整路径。：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get &#x2F;FirstZnode0000000023</span><br></pre></td></tr></table></figure><p>列出znode的子节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &#x2F;path</span><br></pre></td></tr></table></figure><h3 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set &#x2F;FirstZnode Data-updated</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 删除空节点，节点下不能有节点</span><br><span class="line">delete &#x2F;FirstZnode&#x2F;Child1</span><br><span class="line"></span><br><span class="line"># 递归删除节点</span><br><span class="line">rmr &#x2F;FirstZnode</span><br></pre></td></tr></table></figure><h3 id="监视znode的变化"><a href="#监视znode的变化" class="headerlink" title="监视znode的变化"></a>监视znode的变化</h3><p>当指定的znode或znode的子数据更改时，监视器会显示通知。你只能在 get 命令中设置watch。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：get &#x2F;path [watch] 1</span><br><span class="line">示例：get &#x2F;FirstZnode 1</span><br></pre></td></tr></table></figure><h3 id="检查状态"><a href="#检查状态" class="headerlink" title="检查状态"></a>检查状态</h3><p>状态描述指定的znode的元数据。它包含时间戳，版本号，ACL，数据长度和子znode等细项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">stat &#x2F;path</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] stat &#x2F;FirstZnode</span><br><span class="line">cZxid &#x3D; 0x7f</span><br><span class="line">ctime &#x3D; Tue Sep 29 16:15:47 IST 2015</span><br><span class="line">mZxid &#x3D; 0x7f</span><br><span class="line">mtime &#x3D; Tue Sep 29 17:14:24 IST 2015</span><br><span class="line">pZxid &#x3D; 0x7f</span><br><span class="line">cversion &#x3D; 0</span><br><span class="line">dataVersion &#x3D; 1</span><br><span class="line">aclVersion &#x3D; 0</span><br><span class="line">ephemeralOwner &#x3D; 0x0</span><br><span class="line">dataLength &#x3D; 23</span><br><span class="line">numChildren &#x3D; 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>批处理</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/JDBC/%E6%89%B9%E5%A4%84%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/JDBC/%E6%89%B9%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>需要进行批量增删改的操作</p><ul><li>拼接SQL的方式：sql长度有限制，clob类型不能这样使用，只能用于insert语句</li><li>JDBC批处理：</li></ul><p>可以向数据库发送多条不同的ＳＱＬ语句。<br>使用数据库自增主键则无法获得返回的主键<br>增删改操作无法返回影响行数，因为batchExecutor中update方法默认返回的是一个int常量。(其原因都是因为此时sql尚未在数据库执行，所以无法获得这些信息)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcBatchHandleByPrepareStatement &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testJdbcBatchHandleByPrepareStatement()&#123;</span><br><span class="line">        long starttime &#x3D; System.currentTimeMillis();</span><br><span class="line">        Connection conn &#x3D; null;</span><br><span class="line">        PreparedStatement st &#x3D; null;</span><br><span class="line">        ResultSet rs &#x3D; null;</span><br><span class="line">        </span><br><span class="line">        try&#123;</span><br><span class="line">            conn &#x3D; JdbcUtils.getConnection();</span><br><span class="line">            String sql &#x3D; &quot;insert into testbatch(id,name) values(?,?)&quot;;</span><br><span class="line">            st &#x3D; conn.prepareStatement(sql);</span><br><span class="line">            for(int i&#x3D;1;i&lt;1000008;i++)&#123;  &#x2F;&#x2F;i&#x3D;1000  2000</span><br><span class="line">                st.setInt(1, i);</span><br><span class="line">                st.setString(2, &quot;aa&quot; + i);</span><br><span class="line">                st.addBatch();</span><br><span class="line">                if(i%1000&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    st.executeBatch();</span><br><span class="line">                    st.clearBatch();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            st.executeBatch();</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            JdbcUtils.release(conn, st, rs);</span><br><span class="line">        &#125;</span><br><span class="line">        long endtime &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;程序花费时间：&quot; + (endtime-starttime)&#x2F;1000 + &quot;秒！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring和mybatis集成后的批处理方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private SqlSessionTemplate sqlSession;</span><br><span class="line">public void saveBatch(List&lt;TBsImpNews&gt; modelList) &#123;</span><br><span class="line">     SqlSession session &#x3D;sqlSession.getSqlSessionFactory().openSession(ExecutorType.BATCH, false);</span><br><span class="line">     try&#123;</span><br><span class="line">       &#x2F;&#x2F;批量生成新闻主键</span><br><span class="line">       for(TBsImpNews tBsImpNews : modelList)&#123;</span><br><span class="line">         &#x2F;&#x2F;批量生成新闻主键</span><br><span class="line">         String impnewsId &#x3D;String.valueOf(Long.valueOf(getSequenceNextId(SEQ_T_BS_IMP_NEWS)));</span><br><span class="line">         tBsImpNews.setImpnewsId(impnewsId);</span><br><span class="line">         sqlSession.insert(&quot;com.rocktrue.fastdev.wvsp.impnews.TBsImpNewsMapper.insertTBsImpNews&quot;, tBsImpNews);</span><br><span class="line">         for(String url:tBsImpNews.getImgList())&#123;</span><br><span class="line">            &#x2F;&#x2F;批量生成新闻图片主键</span><br><span class="line">            String imniId &#x3D;String.valueOf(Long.valueOf(getSequenceNextId(SEQ_T_BS_IMP_NEWS_IMG)));</span><br><span class="line">            TBsImpNewsImg tBsImpNewsImg&#x3D;new TBsImpNewsImg();</span><br><span class="line">            tBsImpNewsImg.setImniId(imniId);</span><br><span class="line">            tBsImpNewsImg.setImpnewsId(impnewsId);</span><br><span class="line">            tBsImpNewsImg.setImniSrc(url);</span><br><span class="line">            sqlSession.insert(&quot;com.rocktrue.fastdev.wvsp.impnews.TBsImpNewsImgMapper.insertTBsImpNewsImg&quot;, tBsImpNewsImg);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     session.commit();</span><br><span class="line">     &#x2F;&#x2F;清理缓存，防止溢出</span><br><span class="line">     session.clearCache();</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">       session.rollback();</span><br><span class="line">     &#125;finally &#123;</span><br><span class="line">      session.close();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 批处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TreeMap</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/14%E3%80%81TreeMap/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/14%E3%80%81TreeMap/</url>
      
        <content type="html"><![CDATA[<p>TreeMap的实现是红黑树算法的实现</p><p> 红黑树又称红-黑二叉树，它首先是一颗二叉树，。同时红黑树更是一颗自平衡的排序二叉树。</p><p> 二叉树他们都需要满足一个基本性质–即树中的任何节点的值大于它的左子节点，且小于它的右子节点。按照这个基本性质使得树的检索效率大大提高。我们知道在生成二叉树的过程是非常容易失衡的，最坏的情况就是一边倒（只有右/左子树），这样势必会导致二叉树的检索效率大大降低（O(n)）<br> <img src="https://img-blog.csdn.net/20140523092231125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbnNzeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><p> 平衡二叉树必须具备如下特性：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个等等子节点，其左右子树的高度都相近。</p><p>  红黑树顾名思义就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持着二叉树的平衡</p><p>  <img src="https://img-blog.csdn.net/20140523092244406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbnNzeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p><p>  红黑二叉树的特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、每个节点都只能是红色或者黑色</span><br><span class="line"></span><br><span class="line">2、根节点是黑色</span><br><span class="line"></span><br><span class="line">3、每个叶节点（NIL节点，空节点）是黑色的。</span><br><span class="line"></span><br><span class="line">4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。</span><br><span class="line"></span><br><span class="line">5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</span><br></pre></td></tr></table></figure><p>TreeMap:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class TreeMap&lt;K,V&gt;</span><br><span class="line">    extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>成员属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;比较器，因为TreeMap是有序的，通过comparator接口我们可以对TreeMap的内部排序进行精密的控制</span><br><span class="line">        private final Comparator&lt;? super K&gt; comparator;</span><br><span class="line">        &#x2F;&#x2F;TreeMap红-黑节点，为TreeMap的内部类</span><br><span class="line">        private transient Entry&lt;K,V&gt; root &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;容器大小</span><br><span class="line">        private transient int size &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;TreeMap修改次数</span><br><span class="line">        private transient int modCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;红黑树的节点颜色--红色</span><br><span class="line">        private static final boolean RED &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F;红黑树的节点颜色--黑色</span><br><span class="line">        private static final boolean BLACK &#x3D; true;</span><br></pre></td></tr></table></figure><p>TreeMap的内部类叶子节点Entry的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;键</span><br><span class="line">K key;</span><br><span class="line">&#x2F;&#x2F;值</span><br><span class="line">V value;</span><br><span class="line">&#x2F;&#x2F;左孩子</span><br><span class="line">Entry&lt;K,V&gt; left &#x3D; null;</span><br><span class="line">&#x2F;&#x2F;右孩子</span><br><span class="line">Entry&lt;K,V&gt; right &#x3D; null;</span><br><span class="line">&#x2F;&#x2F;父亲</span><br><span class="line">Entry&lt;K,V&gt; parent;</span><br><span class="line">&#x2F;&#x2F;颜色</span><br><span class="line">boolean color &#x3D; BLACK;</span><br></pre></td></tr></table></figure><p>treeMap的put()、delete()方法。通过这两个方法我们会了解红黑树增加、删除节点的核心算法。</p>]]></content>
      
      
      <categories>
          
          <category> java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TreeMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM介绍</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/1%E3%80%81JVM%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/1%E3%80%81JVM%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/leesf456/p/5338951.html">https://www.cnblogs.com/leesf456/p/5338951.html</a></p><h2 id="1-什么是jvm"><a href="#1-什么是jvm" class="headerlink" title="1.什么是jvm?"></a>1.什么是jvm?</h2><ul><li>（1）jvm是一种用于计算设备的规范，它是一个虚构出来的机器，是通过在实际的计算机上仿真模拟各种功能实现的。</li><li>（2）jvm包含一套字节码指令集，一组寄存器，一个栈，一个垃圾回收堆和一个存储方法域。</li><li>（3）JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。<br>JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</li></ul><p>==Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果==</p><p>JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。</p><p>JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><h2 id="2、JVM的内部体系结构分为三部分，"><a href="#2、JVM的内部体系结构分为三部分，" class="headerlink" title="2、JVM的内部体系结构分为三部分，"></a>2、JVM的内部体系结构分为三部分，</h2><ul><li>（1）类装载器（ClassLoader）子系统： 用来装载.class文件</li><li>（2）执行引擎：执行字节码，或者执行本地方法</li><li>（3）运行时数据区：<br>方法区，堆，java栈，PC寄存器，本地方法栈</li></ul><p><img src="https://images2015.cnblogs.com/blog/724399/201610/724399-20161018224805045-165730412.jpg" alt="image"></p><h2 id="2、JVM原理"><a href="#2、JVM原理" class="headerlink" title="2、JVM原理"></a>2、JVM原理</h2><ul><li>（1）jvm是java的核心和基础，在java编译器和os平台之间的虚拟处理器，可在上面执行字节码程序。</li><li>（2）java编译器只要面向jvm，生成jvm能理解的字节码文件。java源文件经编译成字节码程序，通过jvm将每条指令翻译成不同的机器码<br>，通过特定平台运行。</li></ul><h2 id="3、JVM的生命周期"><a href="#3、JVM的生命周期" class="headerlink" title="3、JVM的生命周期"></a>3、JVM的生命周期</h2><ul><li>1、 JVM实例对应了一个独立运行的java程序它是进程级别 </li><li>a) 启动。启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void<br>main(String[] args)函数的class都可以作为JVM实例运行的起点 </li><li>b) 运行。main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以表明自己创建的线程是守护线程 </li><li>c) 消亡。当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出 </li><li>2、 JVM执行引擎实例则对应了属于用户运行程序的线程它是线程级别的</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传统JDBC编程</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/1%E3%80%81%E4%BC%A0%E7%BB%9FJDBC%E7%BC%96%E7%A8%8B/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/3%E3%80%81%E6%8C%81%E4%B9%85%E5%B1%82/MyBatis/1%E3%80%81%E4%BC%A0%E7%BB%9FJDBC%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="传统JDBC编程"><a href="#传统JDBC编程" class="headerlink" title="传统JDBC编程"></a>传统JDBC编程</h3><ul><li>1、加载数据库驱动</li><li>2、创建并获取数据库链接</li><li>3、创建jdbc statement对象</li><li>4、设置sql语句</li><li>5、设置sql语句中的参数(使用preparedStatement)</li><li>6、通过statement执行sql并获取结果</li><li>7、对sql执行结果进行解析处理</li><li>8、释放资源(resultSet、preparedstatement、connection)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">    Connection connection &#x3D; null;</span><br><span class="line">    PreparedStatement preparedStatement &#x3D; null;</span><br><span class="line">    ResultSet resultSet &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">       &#x2F;&#x2F; 加载数据库驱动</span><br><span class="line">       Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">       &#x2F;&#x2F; 通过驱动管理类获取数据库链接</span><br><span class="line">       connection &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?characterEncoding&#x3D;utf-8&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">       &#x2F;&#x2F; 定义sql语句 ?表示占位符</span><br><span class="line">       String sql &#x3D; &quot;select * from user where username &#x3D; ?&quot;;</span><br><span class="line">       &#x2F;&#x2F; 获取预处理statement</span><br><span class="line">       preparedStatement &#x3D; connection.prepareStatement(sql);</span><br><span class="line">       &#x2F;&#x2F; 设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值</span><br><span class="line">       preparedStatement.setString(1, &quot;王五&quot;);</span><br><span class="line">       &#x2F;&#x2F; 向数据库发出sql执行查询，查询出结果集</span><br><span class="line">       resultSet &#x3D; preparedStatement.executeQuery();</span><br><span class="line">       &#x2F;&#x2F; 遍历查询结果集</span><br><span class="line">       while (resultSet.next()) &#123;</span><br><span class="line">           System.out.println(resultSet.getString(&quot;id&quot;) + &quot;  &quot; + resultSet.getString(&quot;username&quot;));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">       &#x2F;&#x2F; 释放资源</span><br><span class="line">       if (resultSet !&#x3D; null) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">              resultSet.close();</span><br><span class="line">           &#125; catch (SQLException e) &#123;</span><br><span class="line">              &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (preparedStatement !&#x3D; null) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">              preparedStatement.close();</span><br><span class="line">           &#125; catch (SQLException e) &#123;</span><br><span class="line">              &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (connection !&#x3D; null) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">              connection.close();</span><br><span class="line">           &#125; catch (SQLException e) &#123;</span><br><span class="line">              &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>数据库连接频繁创建、释放频繁造成系统资源浪费如果使用数据库连接池可解决此问题。</li><li>Sql语句在代码中硬编码</li><li>对结果集解析存在硬编码（查询列名）</li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 传统JDBC编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6%E3%80%81%E6%A0%91/1%E3%80%81%E6%A0%91/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6%E3%80%81%E6%A0%91/1%E3%80%81%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>数组和链表的特点：</p><ul><li><p>数组因为有下标，所以查询快，但是增删慢，因为增删数据时其他数据的位置也相应的移动。</p></li><li><p>链表的插入和删除很快，我们只需要改变一些指针的指向就行了<br>但是查找数据却很慢了，因为不管我们查找什么数据，都需要从链表的第一个或最后一个数据项开始查询，遍历到找到所需数据项为止，这个查找也是平均需要比较N/2次。</p></li></ul><h2 id="树："><a href="#树：" class="headerlink" title="树："></a>树：</h2><p>因此希望有一种数据结构能同时具备数组查找快的优点以及链表插入和删除快的优点，就是   树</p><p>从树的根到任意节点有且只有一条路径可以到达。</p><p><img src="https://img2018.cnblogs.com/blog/1120165/201903/1120165-20190317103508280-1532806856.png" alt="image"></p><p>①、路径：顺着节点的边从一个节点走到另一个节点，所经过的节点的顺序排列就称为“路径”。</p><p>　　②、根：树顶端的节点称为根。==<strong>一棵树只有一个根</strong>==，如果要把一个节点和边的集合称为树，那么从根到其他任何一个节点都必须有且只有一条路径。A是根节点。</p><p>　　③、父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；B是D的父节点。</p><p>　　④、子节点：一个节点含有的子树的根节点称为该节点的子节点；D是B的子节点。</p><p>　　⑤、兄弟节点：具有相同父节点的节点互称为兄弟节点；比如上图的D和E就互称为兄弟节点。</p><p>　　⑥、叶节点：没有子节点的节点称为叶节点，也叫叶子节点，比如上图的H、E、F、G都是叶子节点。</p><p>　　⑦、子树：每个节点都可以作为子树的根，它和它所有的子节点、子节点的子节点等都包含在子树中。</p><p>　　⑧、节点的层次：从根开始定义，根为第一层，根的子节点为第二层，以此类推。</p><p>　　⑨、深度：“深度”这个概念在生活中是从上往下度量的，比如水中鱼的深度，是从水平面开始度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是 0。</p><p>　　⑩、高度：“高度”这个概念，其实就是从下往上度量，比如我们要度量第 10 层楼的高度、第 13 层楼的高度，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是 0。　　　　</p><p>“层数”跟深度的计算类似，不过，计数起点是 1，也就是说根节点的位于第 1 层。　　　　</p><p>　　</p><p><img src="https://static001.geekbang.org/resource/image/50/b4/50f89510ad1f7570791dd12f4e9adeb4.jpg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper分布式锁</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/7%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/zookeeper/6%E3%80%81zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/7%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/zookeeper/6%E3%80%81zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<ul><li>有序节点：假如当前有一个父节点为/lock，我们可以在这个父节点下面创建子节点；zookeeper提供了一个可选的有序特性，例如我们可以创建子节点“/lock/node-”并且指明有序，那么zookeeper在生成子节点时会根据当前的子节点数量自动添加整数序号，也就是说如果是第一个创建的子节点，那么生成的子节点为/lock/node-0000000000，下一个节点则为/lock/node-0000000001，依次类推。</li><li>临时节点：客户端可以建立一个临时节点，在会话结束或者会话超时后，zookeeper会自动删除该节点。</li><li>事件监听：在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，zookeeper会通知客户端。当前zookeeper有如下四种事件：1）节点创建；2）节点删除；3）节点数据修改；4）子节点变更。</li></ul><p>zookeeper实现分布式锁的算法流程</p><ul><li>客户端连接zookeeper，并在/lock下创建临时的且有序的子节点，第一个客户端对应的子节点为/lock/lock-0000000000，第二个为/lock/lock-0000000001，以此类推。</li><li>客户端获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听/lock的子节点变更消息，获得子节点变更通知后重复此步骤直至获得锁；</li><li>执行业务代码；</li><li>完成业务流程后，删除对应的子节点释放锁。</li></ul><p>虽然zookeeper原生客户端暴露的API已经非常简洁了，但是实现一个分布式锁还是比较麻烦.</p><p>直接使用curator这个开源项目提供的zookeeper分布式锁实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-recipes&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> public int lock() &#123;</span><br><span class="line">    &#x2F;&#x2F;创建zookeeper的客户端</span><br><span class="line">    RetryPolicy retryPolicy &#x3D; new ExponentialBackoffRetry(1000, 3);</span><br><span class="line">    CuratorFramework client &#x3D; CuratorFrameworkFactory.newClient(&quot;127.0.0.1:2181&quot;, retryPolicy);</span><br><span class="line">    client.start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建分布式锁, 锁空间的根节点路径为&#x2F;curator&#x2F;lock</span><br><span class="line">    InterProcessMutex mutex &#x3D; new InterProcessMutex(client, &quot;&#x2F;curator&#x2F;lock&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        mutex.acquire();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取分布式锁失败</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取分布式锁成功, 进行业务流程</span><br><span class="line">    System.err.println(&quot;执行业务。。。。&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;释放分布式锁</span><br><span class="line">        mutex.release();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        &#x2F;&#x2F;释放分布式锁失败</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;关闭客户端</span><br><span class="line">    client.close();</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络模型</title>
      <link href="2020/06/21/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/1%E3%80%81%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
      <url>2020/06/21/Study%20notes/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/1%E3%80%81%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>以太网OSI参考模型。</p><p> OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，就能互联了。</p><p> 每一层实现的协议和对应不同的设备</p><ol><li><p>物理层：实现计算机系统与网络间的物理连接</p></li><li><p>数据链路层：进行数据打包与解包，形成信息帧</p></li><li><p>网络层：提供数据通过的路由</p></li><li><p>传输层：提供传输顺序信息与响应</p></li><li><p>会话层：建立和中止连接</p></li><li><p>表示层：数据转换、确认数据格式</p></li><li><p>应用层：提供用户程序接口</p><p><img src="https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234827195-1493107425.png" alt="image"></p></li></ol><h3 id="HTTP和TCP协议"><a href="#HTTP和TCP协议" class="headerlink" title="HTTP和TCP协议"></a>HTTP和TCP协议</h3><p>TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http是用来收发数据，即实际应用上来的。</p><p>TCP是有状态的长连接，而HTTP是基于TCP的，HTTP却成了无状态的短连接？</p><p>在 HTTP/1.0 中因为每个Http请求，Http会通过TCP建立起一个连接通道，但请求结束后Http会立即将TCP连接断开。（每次都是一个建立新的TCP连接，所以无法内存中记录信息所以也是无状态的）代价过大。</p><p>响应中Keep-Alive首部是可选的，但只有在提供Connection：Keep-Alive时才能使用它。</p><p>Connection:Keep-Alive<br>Keep-Alive:max=5,timeout=120<br>这个例子说明了服务器最多还会为另外5个事务保持连接的打开状态，或者将打开状态保持到连接空闲了2分钟以后。</p><p>==HTTP/1.1（持久连接）==<br>，HTTP/1.1 把 Connection 头写进标准，并且默认开启持久连接。除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。</p><p>而通过Socket编程使用TCP协议的时候,可以通过代码区控制什么时候打开连接什么时候关闭连接。（Socket只是使得程序员更方便地使用TCP/IP协议）</p><h5 id="浏览器对同一-Host-建立-TCP-连接到数量有没有限制？"><a href="#浏览器对同一-Host-建立-TCP-连接到数量有没有限制？" class="headerlink" title="浏览器对同一 Host 建立 TCP 连接到数量有没有限制？"></a>浏览器对同一 Host 建立 TCP 连接到数量有没有限制？</h5><p>假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？</p><p>肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受</p><p>但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了</p><p>要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。</p><p>所以答案是：有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。</p>]]></content>
      
      
      <categories>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC回收二：回收算法</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/9%E3%80%81GC%E5%9B%9E%E6%94%B6%E4%BA%8C%EF%BC%9A%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/9%E3%80%81GC%E5%9B%9E%E6%94%B6%E4%BA%8C%EF%BC%9A%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="二、如何回收（回收算法）"><a href="#二、如何回收（回收算法）" class="headerlink" title="二、如何回收（回收算法）"></a>二、如何回收（回收算法）</h3><p> 判断了对象存活的状态，就需要通过gc回收算法，将垃圾回收</p><h4 id="2-1、标记-清除算法"><a href="#2-1、标记-清除算法" class="headerlink" title="2.1、标记-清除算法"></a>2.1、标记-清除算法</h4><p>  该算法先标记，后清除，将所有需要==回收的对象进行标==记，然后清除；这种算法的缺点是：效率比较低（标记和清楚的效率都不高）；标记清除后会出现大量不连续的内存空间碎片，这些碎片太多将来到需要分配较大对象时，无法找到连续的内存，而不得再次触发GC，造成内存浪费以及时间的消耗。（记忆：唐太宗标记需要杀掉的功臣，掌权后进行清除）</p><h4 id="2-2、复制算法"><a href="#2-2、复制算法" class="headerlink" title="2.2、复制算法"></a>2.2、复制算法</h4><p>复制算法先将可用内存按容量划分为大小相等的AB两块，每次只使用其中的一半。</p><p>当A的内存用完了需要垃圾回收的时候，就将还存活着的对象复制到另外一块B上面，然后就把A一次清洗完。</p><p>后续当B用完了需要回收的时候再将还存活着的对象复制到另外一块A上面 如此循环。</p><p>这种算法适用于对象存活率低的场景，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p><p>但是这种算法代价过高，不会产生内存碎片，但需要将可用内存缩小一半，浪费空间。对象存活率较高时，需要持续的复制工作，效率比较低。</p><h4 id="2-3、标记整理算法"><a href="#2-3、标记整理算法" class="headerlink" title="2.3、标记整理算法"></a>2.3、标记整理算法</h4><p>在标记-清除算法基础上，不直接清理，而是使存活对象往一端游走，然后清除一端边界以外的内存，这样既可以避免内存碎片，还可以避免对象存活率较高时的持续复制。这种算法可以避免100%对象存活的极端状况，因此==老年代不能直接使用该算法。==</p><ul><li>标记整理算法与标记-清除算法区别：<br>标记清除算法不进行对象的移动，并且仅对不存活的对象进行处理；而标记整理算法会将所有的存活对象移动到一端，并对不存活对象进行处理，因此其不会产生内存碎片。</li></ul><p>效率比复制算法低，因为内存整理很耗资源</p><p>2.4、分代收集算法（以上算法的集合选择使用）</p><p> 分代收集算法就是目前虚拟机使用的回收算法，它解决了标记整理不适用于老年代的问题，将内存分为各个年代，在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率搞，没有额外空间对它进行分配担保，所以只能使用标记清除或者标记整理算法。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC回收二：回收算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口幂等性五种解决方案</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E4%BA%94%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E4%BA%94%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>例如在电商系统下单支付过程中，点击支付按钮由于网络等原因导致请求结果未及时返回，这时用户又重复点击，导致最后在用户同一订单支付两次。为了防止重试对数据状态的改变，需要将接口的设计为幂等的。</p><h5 id="保证幂等策略"><a href="#保证幂等策略" class="headerlink" title="保证幂等策略"></a>保证幂等策略</h5><p>==幂等需要通过唯一的业务单号来保证==。先检查，后操作。实现幂等很简单：<br>先检查订单是否已经支付过，②如果已经支付过，则返回支付成功；<br>如果没有支付，进行支付流程<br>但上述先检查后更新为非原子性操作有线程安全问题。剩下就是解决线程安全的问题了。</p><h5 id="【推荐】分布式锁"><a href="#【推荐】分布式锁" class="headerlink" title="- 【推荐】分布式锁"></a>- 【推荐】分布式锁</h5><p>Redis分布式锁。使用唯一业务单号进行加锁，</p><p>请求加锁成功：则说明订单未支付，然后去支付，支付结果成功/失败、异常都释放锁。</p><p>请求加锁失败：说明订单处于支付过程中，返回请勿重复支付</p><p>==注意：==<br>其实这里还会涉及到减库存问题。因为支付结果通知通常是异步。所以加锁最多加到发起支付成功回流便要释放锁，等不到支付结果。</p><p>会导致正在三方支付的过程中，业务代码释放锁，这时用户重复提交。还是会传该单号，这里三方支付都会处理，会校验重复单号支付问题。所以这个不用考虑。</p><h5 id="【推荐】数据库乐观锁"><a href="#【推荐】数据库乐观锁" class="headerlink" title="- 【推荐】数据库乐观锁"></a>- 【推荐】数据库乐观锁</h5><ul><li>（特殊情况下乐观锁存在失效的情况ABA问题）</li></ul><p>如果只是更新已有的数据，没有必要对业务进行加锁，设计表结构时使用乐观锁，一般通过version来做乐观锁，这样既能保证执行效率，又能保证幂等。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE tab1 SET col1&#x3D;1,version&#x3D;version+1 WHERE version&#x3D;#version#</span><br></pre></td></tr></table></figure><p>不过，乐观锁存在失效的情况，就是常说的ABA问题，不过如果version版本一直是自增的就不会出现ABA的情况。</p><h5 id="数据库悲观锁"><a href="#数据库悲观锁" class="headerlink" title="- 数据库悲观锁"></a>- 数据库悲观锁</h5><p>不推荐，会造成锁表的情况）</p><h5 id="利用数据库的唯一索引来保证幂"><a href="#利用数据库的唯一索引来保证幂" class="headerlink" title="利用数据库的唯一索引来保证幂"></a>利用数据库的唯一索引来保证幂</h5><p>使用业务订单号orderNo做为去重表的唯一索引，利用数据库的唯一索引添加记录成功与否，来判断是否为重复支付</p><h5 id="token令牌"><a href="#token令牌" class="headerlink" title="token令牌"></a>token令牌</h5><p>这种方式分成两个阶段：申请token阶段和支付阶段。</p><p>第一步：在支付之前，需要订单系统根据用户信息向支付系统发起一次申请token的请求，支付系统将token保存到Redis缓存中，为第二阶段支付使用。</p><p>第二步：订单系统拿着申请到的token发起支付请求，支付系统会检查Redis中是否存在该token，如果存在，表示第一次发起支付请求，删除缓存中token后开始支付逻辑处理；如果缓存中不存在，表示非法请求。</p>]]></content>
      
      
      <categories>
          
          <category> 高频点问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 接口幂等性五种解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux的crond调度</title>
      <link href="2020/06/21/Study%20notes/7%E3%80%81linux/linux/5%E3%80%81linux%E7%9A%84crond%E8%B0%83%E5%BA%A6/"/>
      <url>2020/06/21/Study%20notes/7%E3%80%81linux/linux/5%E3%80%81linux%E7%9A%84crond%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>linux的任务调度：linux系统在某个特定的时间执行指定的命令或程序。</p><h5 id="用户任务调度："><a href="#用户任务调度：" class="headerlink" title="用户任务调度："></a>用户任务调度：</h5><p>配置文件在 /var/spool/cron目录中。其文件名与用户名一致</p><p>例如：</p><ul><li>定期mysql的备份</li><li>定时邮件提醒</li></ul><h5 id="系统任务调度："><a href="#系统任务调度：" class="headerlink" title="系统任务调度："></a>系统任务调度：</h5><p>配置文件在/etc/crontab文件<br>例如：</p><ul><li>定期病毒扫描</li><li>日志清理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;crontab</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#前四行是用来配置crond任务运行的环境变量</span><br><span class="line"></span><br><span class="line">#第一行SHELL变量指定了系统要使用哪个shell，这里是bash</span><br><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">#第二行PATH变量指定了系统执行命令的路径</span><br><span class="line">PATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin</span><br><span class="line"></span><br><span class="line">#第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，为空则表示不发送任务执行信息给用户</span><br><span class="line">MAILTO&#x3D;root</span><br><span class="line"></span><br><span class="line">#第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。</span><br><span class="line">#星号（*）：代表所有可能的值，如month字段为星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</span><br><span class="line">#逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</span><br><span class="line">#中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</span><br><span class="line">#正斜线（&#x2F;）：可以用正斜线指定时间的间隔频率，例如“0-23&#x2F;2”表示每两小时执行一次。</span><br><span class="line">HOME&#x3D;&#x2F;</span><br><span class="line"></span><br><span class="line"># For details see man 4 crontabs</span><br><span class="line"></span><br><span class="line"># Example of job definition:</span><br><span class="line"># .---------------- minute (0 - 59)</span><br><span class="line"># |  .------------- hour (0 - 23)</span><br><span class="line"># |  |  .---------- day of month (1 - 31)</span><br><span class="line"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line"># |  |  |  |  .---- day of week (0 - 6) (Sunday&#x3D;0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line"># |  |  |  |  |</span><br><span class="line"># *  *  *  *  * user-name  command to be executed</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="crontab任务维护"><a href="#crontab任务维护" class="headerlink" title="crontab任务维护"></a>crontab任务维护</h5><p>安装crontab服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install crontabs</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;sbin&#x2F;service crond start &#x2F;&#x2F;启动服务</span><br><span class="line"> </span><br><span class="line">&#x2F;sbin&#x2F;service crond stop &#x2F;&#x2F;关闭服务</span><br><span class="line"> </span><br><span class="line">&#x2F;sbin&#x2F;service crond restart &#x2F;&#x2F;重启服务</span><br><span class="line"> </span><br><span class="line">&#x2F;sbin&#x2F;service crond reload &#x2F;&#x2F;重新载入配置</span><br><span class="line"></span><br><span class="line">chkconfig –level 35 crond on &#x2F;&#x2F;开机自启动</span><br><span class="line"></span><br><span class="line">service crond status &#x2F;&#x2F;查看crontab服务状态</span><br></pre></td></tr></table></figure><p>查看定时任务列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure><p>编辑/新增 定时任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root</span><br><span class="line">#每隔2分钟输出时间到文件</span><br><span class="line">*&#x2F;2 * * * * echo &#96;date&#96; &gt;&gt; $HOME&gt;test.txt</span><br></pre></td></tr></table></figure><p>删除定时任务<br>crontab -r </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从&#x2F;var&#x2F;spool&#x2F;cron目录中删除用户的crontab文件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux的crond调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT的实现原理</title>
      <link href="2020/06/21/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/JWT/JWT%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/8%E3%80%81%E5%B7%A5%E5%85%B7%E7%AF%87/JWT/JWT%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="传统的-session-流程"><a href="#传统的-session-流程" class="headerlink" title="传统的 session 流程"></a>传统的 session 流程</h4><ul><li>浏览器发起请求登陆</li><li>服务端验证身份，生成身份验证信息，存储在服务端，并且告诉浏览器写入 Cookie</li><li>浏览器发起请求获取用户资料，此时 Cookie 内容也跟随这发送到服务器</li><li>服务器发现 Cookie 中有身份信息，验明正身</li><li>服务器返回该用户的用户资料</li></ul><h4 id="JWT-流程"><a href="#JWT-流程" class="headerlink" title="JWT 流程"></a>JWT 流程</h4><ul><li>浏览器发起请求登陆</li><li>服务端验证身份，根据算法，将用户标识符打包生成 token, 并且返回给浏览器</li><li>浏览器发起请求获取用户资料，把刚刚拿到的 token 一起发送给服务器</li><li>服务器发现数据中有 token，验明正身</li><li>服务器返回该用户的用户资料</li></ul><h4 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h4><ul><li>session 存储在服务端占用服务器资源，而 JWT 存储在客户端</li><li>session 存储在 Cookie 中，存在伪造跨站请求伪造攻击的风险</li><li>session 只存在一台服务器上，那么下次请求就必须请求这台服务器，不利于分布式应用</li><li>存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性</li></ul><p>JWT token数据格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpcCI6IjEyNy4wLjAuMSIsInV1aWQiOiJmZjEyMTJmNS1kOGQxLTQ0OTYtYmY0MS1kMmRkYTczZGUxOWEiLCJpYXQiOjE1Mjc1MjMwMTd9.1C01cpOf1N3M9YAYvQjfcLbDGHZ4iPVncCGIoG-lpO0jHOIAZHtSMDvK1nzArLpGK5syQSwExsZJz2FJsd2W2TUiHQYtzmQTU8OBXX6mfSZRlkts675W5WhIiOEwz69GFSD0AKXZifCRgIpKLC0n273MRMr0wJnuBi9ScfJ7YjSiqCr7qyQ5iXeOdS3ObT3wdjjk-Wu9wbWM7R25TFb-7PEZY7re8jmczPCVcNbOYegedu73T4d30kRn2jKufTGntD5hR6T9AQsgAMwVR1edEFflWb772TmrHI7WZOAivsBCN9sr4YiyYMvE8lczmBsgsunugGiHA3DGxB2ORbjIC8NPm8FI25zGOh9JIM2rjFFTIm9GiuKtC8Ck8N3-eWi9u1NgBxwLdgN5JyCORnIOlciQEsScg-3SdCTM5LHj6CeqQNwJxT4-oENzqLSTDJbP-SOj9nnx8HnJ5wh3n64rAvtc89CeTk7PhWFjksHDifngN-cnaszl5lqoF1enz5i9FYYELSjM-G7jns2SyY1MQeLRjuEDriPZtFaGmTW-RLH3gJfQXtbdpEo0nHBqXEohwoNFLKo4BNrEwshpyA7vkBpCQC0QALKyC1_L1Q5qduR6dDcqRozAo2VqJXmAKN0rvhLuIEHZkicOZY0Ds4So4GCcleqvFcxm1HQ</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据格式是这样的 header.payload.signature：</p><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;alg&quot;:&quot;RS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>alg: 声明加密的算法<br>typ: 声明类型</p><p>对这个头部信息进行 base64，即可得到 header 部分：eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9</p><h4 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h4><p>payload 是主体部分，意为载体，承载着有效的 JWT 数据包，它包含三个部分</p><p>标准声明<br>公共声明<br>私有声明</p><h4 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h4><p>signature 是签证信息，该签证信息是通过header和payload，加上secret，通过算法加密生成。</p>]]></content>
      
      
      <categories>
          
          <category> JWT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT的实现原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>happens-before</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/happens-before/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/happens-before/</url>
      
        <content type="html"><![CDATA[<p>Java内存模型中所有的有序性都仅仅靠volatile和synchronized来完成，那么有一些操作将会变得很烦琐，但是我们在编写Java并发代码的时候并没有感觉到这一点，这是因为Java语言中有一个“先行发生”（happens-before）的原则。 这个原则非常重要，它是判断数据是否存在竞争、 线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p><h1 id="前面一个操作的结果对后续操作是可见的"><a href="#前面一个操作的结果对后续操作是可见的" class="headerlink" title="==前面一个操作的结果对后续操作是可见的=="></a>==前面一个操作的结果对后续操作是可见的==</h1><p>happens-before和程序员相关的规则有6项：</p><h3 id="1-程序的顺序性规则"><a href="#1-程序的顺序性规则" class="headerlink" title="1. 程序的顺序性规则"></a>1. 程序的顺序性规则</h3><p>这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class VolatileExample &#123;</span><br><span class="line">  int x &#x3D; 0;</span><br><span class="line">  volatile boolean v &#x3D; false;</span><br><span class="line">  public void writer() &#123;</span><br><span class="line">    x &#x3D; 42;</span><br><span class="line">    v &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line">  public void reader() &#123;</span><br><span class="line">    if (v &#x3D;&#x3D; true) &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里 x 会是多少呢？</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这还是比较容易理解的，按照程序的顺序，第 6 行代码 “x = 42;” Happens-Before 于第 7 行代码 “v = true;”，这就是规则 1 的内容，也比较符合单线程里面的思维：程序前面对某个变量的修改一定是对后续操作可见的。</p><h3 id="2-volatile-变量规则"><a href="#2-volatile-变量规则" class="headerlink" title="2. volatile 变量规则"></a>2. volatile 变量规则</h3><p>这条规则是指对一个 volatile 变量的写操作，相对于后续对这个 volatile 变量的读操作可见</p><h3 id="3-传递性"><a href="#3-传递性" class="headerlink" title="3. 传递性"></a>3. 传递性</h3><p>这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。</p><h3 id="4、管程中锁的规则："><a href="#4、管程中锁的规则：" class="headerlink" title="4、管程中锁的规则："></a>4、管程中锁的规则：</h3><p>指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。</p><h3 id="5-线程-start-规则"><a href="#5-线程-start-规则" class="headerlink" title="5. 线程 start() 规则"></a>5. 线程 start() 规则</h3><p>这条是关于线程启动的。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。</p><p>换句话说就是，如果线程 A 调用线程 B 的 start() 方法（即在线程 A 中启动线程 B），那么该 start() 操作 Happens-Before 于线程 B 中的任意操作。</p><h3 id="6-线程-join-规则"><a href="#6-线程-join-规则" class="headerlink" title="6. 线程 join() 规则"></a>6. 线程 join() 规则</h3><p>这条是关于线程等待的。它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作。</p><p>换句话说就是，如果在线程 A 中，调用线程 B 的 join()并成功返回，那么线程 B 中的任意操作 Happens-Before 于该 join() 操作的返回。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> happens-before </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL优化</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/MySQL%E4%BC%98%E5%8C%96/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql/MySQL%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>谈谈你对数据库的优化：从以下几个方面入手：</p><h3 id="1、sql语句的优化"><a href="#1、sql语句的优化" class="headerlink" title="1、sql语句的优化"></a>1、sql语句的优化</h3><p>一：sql语句的优化（索引的使用）</p><p>再实际项目中 如何分析mysql的哪些查询语句的效率比较低？</p><p>1、首先再mysql配置文件中，开启慢查询日志，设置阕值，只要查询时间大于设置的阕值，该语句就会被记录到慢查询日志中。</p><p>2、使用expln工具逐条分析该语句<br>语法：explain select * from tb1</p><p>属性解释：</p><ul><li>id:sql的执行顺序 越大就越先执行 相同表示同级</li><li>select_type:  simple表示简单查询</li><li>primary:最外面的select,在有子查询的语句中，最外面的select查询就是primary,</li><li>table:输出的行所用的表</li><li>==type: system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all 性能从最佳到最差==</li><li>–system:表仅有一行，这是const类型的特列，平时不会出现，这个也可以忽略不计</li><li>–const:表最多有一个匹配行，const用于比较primary key 或者unique索引。因为只匹配一行数据  记住一定是用到primary key 或者unique</li><li>possible_keys:可能用到的索引</li><li>key：实际用到的索引</li><li>key_len:用到的索引的长度</li><li>ref: ref列显示使用哪个列或常数与key一起从表中选择行。</li><li>==rows:mysql执行查询的行数，越多越差，说明没好索引==</li><li>Extra:该列包含MySQL解决查询的详细信息。</li><li>-using filesort    :字段排列</li><li>-using temporary：临时表</li><li>-using index：用到索引</li></ul><h3 id="2、存储引擎的优化"><a href="#2、存储引擎的优化" class="headerlink" title="2、存储引擎的优化"></a>2、存储引擎的优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyISAM和InnoDB等存储引擎的选择。</span><br><span class="line">MyISAM：非事务的引擎</span><br><span class="line">InnoDB是事务的引擎</span><br><span class="line">MySQL中MyISAM与InnoDB的区别，面试题：至少五点</span><br><span class="line">1.InnoDB支持事务，MyISAM不支持事务。</span><br><span class="line">2.InnoDB支持行级锁，MyISAM支持表级锁。</span><br><span class="line">3.InnoDB支持MVCC, MyISAM不支持。</span><br><span class="line">4.InnoDB支持外键，MyISAM不支持。</span><br><span class="line">5.InnoDB不支持全文索引，MyISAM支持。</span><br></pre></td></tr></table></figure><h3 id="3、数据库结构优化，"><a href="#3、数据库结构优化，" class="headerlink" title="3、数据库结构优化，"></a>3、数据库结构优化，</h3><p>字段类型的合适选择，字段的冗余、分区、分库、分表（水平拆分和垂直拆分）、读写分离。数据库集群</p><p>水平拆分：设计的问题是两表的事务问题，字段冗余解决</p><p>垂直拆分：拆分后去那张表处理业务。可以使用动态数据源、mycat解决</p><h3 id="4、数据库缓存"><a href="#4、数据库缓存" class="headerlink" title="4、数据库缓存"></a>4、数据库缓存</h3><p>根据业务是否开启数据查询的缓存。（看业务更新数据的频率）</p><h3 id="5、硬件的优化"><a href="#5、硬件的优化" class="headerlink" title="5、硬件的优化"></a>5、硬件的优化</h3><p>配置内存、CPU等参数</p><h3 id="6、服务器参数"><a href="#6、服务器参数" class="headerlink" title="6、服务器参数"></a>6、服务器参数</h3>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件权限管理</title>
      <link href="2020/06/21/Study%20notes/7%E3%80%81linux/linux/4%E3%80%81%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/7%E3%80%81linux/linux/4%E3%80%81%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>明确：</p><ul><li>linux中每个用户都必须属于一个用户组，不能独立于组外。</li><li>linux中的每个文件都有所有者，所在组，其他组的概念</li></ul><p>1、所有者：一般为文件的创建者，谁创建了该文件自然就成了该文件的所有者</p><h5 id="查看文件的所有者："><a href="#查看文件的所有者：" class="headerlink" title="查看文件的所有者："></a>查看文件的所有者：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls –l</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-rw------- 1 root  root   28077480 Dec 12 15:34 heap-dump1212.bin</span><br><span class="line">drwxr-xr-x 2 root  root       4096 Dec 12 15:29 mp-demo</span><br><span class="line">-rwxr-xr-x 1 mysql mysql 644930593 Nov 28 10:30 mysql-5.7.24-linux-glibc2.12-x86_64.tar.gz</span><br><span class="line">-rw-r--r-- 1 root  root    3432673 Jan  8 15:21 rocketmq-all-4.6.0-source-release.zip</span><br><span class="line">drwxr-xr-x 2 root  root       4096 Nov 27 19:19 xxljobadmin</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/363003_1227493859FdXT.png" alt="image"></p><h5 id="修改文件的所有者"><a href="#修改文件的所有者" class="headerlink" title="修改文件的所有者"></a>修改文件的所有者</h5><p>1、chgrp：更改文件属组</p><p>2、chown：更改文件属主，也可以同时更改文件属组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown [–R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure><h5 id="修改文件与文件夹权"><a href="#修改文件与文件夹权" class="headerlink" title="修改文件与文件夹权"></a>修改文件与文件夹权</h5><p>3、==chmod命令修改文件与文件夹权限==<br>语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod [who] [操作符] [mode] 文件名</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">chmod 777 index.html</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>who:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u 表示“用户（user）”，即文件或目录的所有者。</span><br><span class="line">g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。</span><br><span class="line">o 表示“其他（others）用户”。</span><br><span class="line">a 表示“所有（all）用户”。它是系统默认值。</span><br></pre></td></tr></table></figure><p>操作符号可以是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ 添加某个权限。</span><br><span class="line">- 取消某个权限。</span><br><span class="line">&#x3D; 赋予给定权限并取消其他所有权限（如果有的话）。</span><br></pre></td></tr></table></figure><p>设置mode所表示的权限可用下述字母的任意组合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r 可读。</span><br><span class="line">w 可写。</span><br><span class="line">x 可执行。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#eg: 给所有用户添加index.html文件的可读权限</span><br><span class="line">chmod a + r index.html</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-rw——- (600) 只有所有者才有读和写的权限</span><br><span class="line">-rw-r–r– (644) 只有所有者才有读和写的权限，组群和其他人只有读的权限</span><br><span class="line">-rwx—— (700) 只有所有者才有读，写，执行的权限</span><br><span class="line">-rwxr-xr-x (755) 只有所有者才有读，写，执行的权限，组群和其他人只有读和执行的权限</span><br><span class="line">-rwx–x–x (711) 只有所有者才有读，写，执行的权限，组群和其他人只有执行的权限</span><br><span class="line">-rw-rw-rw- (666) 每个人都有读写的权限</span><br><span class="line">-rwxrwxrwx (777) 每个人都有读写和执行的权限</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">chmod 777 index.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件权限管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>junit</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/11%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2%E3%80%81junit/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/11%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/2%E3%80%81junit/</url>
      
        <content type="html"><![CDATA[<p>JUnit4 Annotation的使用</p><p>1、@Test: 测试方法<br>//捕获异常<br>a)(expected=XXException.class)<br>//超时<br>b)(timeout=xxx)</p><p>2、@Ignore: 被忽略的测试方法，假如有个模块，未开发完成，先不测试该模块，忽略方法</p><p>3、@Before: ==每一个测试方法==之前运行</p><p>4、@After: ==每一个测试方法==之后运行</p><p>5、@BeforeClass: 所有测试开始之前运行，比如在测试之前，要与数据建立连接</p><p>6、@AfterClass: 所有测试结束之后运行，，比如在测试之后，释放与数据库的连接</p><p>jdk1.5之后可静态导入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;静态导入</span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line">import org.junit.Assert;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class TestOneTest &#123;</span><br><span class="line">@Test  &#x2F;&#x2F;一个类的多个Test方法，是同时测试，这点main方法做不到</span><br><span class="line">public void test() &#123;</span><br><span class="line">fail(&quot;Not yet implemented&quot;);&#x2F;&#x2F;上面的静态导入，所以可直接使用该方法</span><br><span class="line">Assert.fail(&quot;Not yet implemented&quot;);</span><br><span class="line">int result&#x3D;new TestOne().add(1, 2);</span><br><span class="line">&#x2F;&#x2F;junit核心：断言-检测期望值与测试实际结果值是否一致。</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(4, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;捕获异常</span><br><span class="line">@Test@Test(expected&#x3D;Exception.class)</span><br><span class="line">public void test() &#123;</span><br><span class="line"></span><br><span class="line">int result&#x3D;new TestOne().div(1, 2);</span><br><span class="line">Assert.assertEquals(4, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>断言语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a)assertThat( n, allOf( greaterThan(1), lessThan(15) ) ); &#x2F;&#x2F;满足所有条件</span><br><span class="line">assertThat( n, anyOf( greaterThan(16), lessThan(8) ) ); &#x2F;&#x2F;满足任意一个条件</span><br><span class="line">assertThat( n, anything() ); &#x2F;&#x2F;任何值都行</span><br><span class="line">assertThat( str, is( &quot;bjsxt&quot; ) );</span><br><span class="line">assertThat( str, not( &quot;bjxxt&quot; ) );</span><br><span class="line"></span><br><span class="line">b)assertThat( str, containsString( &quot;bjsxt&quot; ) );</span><br><span class="line">assertThat( str, endsWith(&quot;bjsxt&quot; ) ); </span><br><span class="line">assertThat( str, startsWith( &quot;bjsxt&quot; ) ); </span><br><span class="line">assertThat( n, equalTo( nExpected ) ); </span><br><span class="line">assertThat( str, equalToIgnoringCase( &quot;bjsxt&quot; ) ); </span><br><span class="line">assertThat( str, equalToIgnoringWhiteSpace( &quot;bjsxt&quot; ) );</span><br><span class="line"></span><br><span class="line">c)assertThat( d, closeTo( 3.0, 0.3 ) ); &#x2F;&#x2F;接近3  误差在0.3</span><br><span class="line">assertThat( d, greaterThan(3.0) );</span><br><span class="line">assertThat( d, lessThan (10.0) );</span><br><span class="line">assertThat( d, greaterThanOrEqualTo (5.0) );</span><br><span class="line">assertThat( d, lessThanOrEqualTo (16.0) );</span><br><span class="line"></span><br><span class="line">d)assertThat( map, hasEntry( &quot;bjsxt&quot;, &quot;bjsxt&quot; ) );</span><br><span class="line">assertThat( iterable, hasItem ( &quot;bjsxt&quot; ) );</span><br><span class="line">assertThat( map, hasKey ( &quot;bjsxt&quot; ) );</span><br><span class="line">assertThat( map, hasValue ( &quot;bjsxt&quot; ) );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 单元测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> junit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java对象引用四个级别（强、软、弱、虚）</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/6%E3%80%81Java%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E5%9B%9B%E4%B8%AA%E7%BA%A7%E5%88%AB%EF%BC%88%E5%BC%BA%E3%80%81%E8%BD%AF%E3%80%81%E5%BC%B1%E3%80%81%E8%99%9A%EF%BC%89/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/5%E3%80%81JVM/6%E3%80%81Java%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E5%9B%9B%E4%B8%AA%E7%BA%A7%E5%88%AB%EF%BC%88%E5%BC%BA%E3%80%81%E8%BD%AF%E3%80%81%E5%BC%B1%E3%80%81%E8%99%9A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Java对象引用四个级别别由高到低依次为：</p><h4 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h4><p>强引用就是我们平常最基本的对象引用，如果是强引用，那回收器不会回收带有强引用的对象。即使内存不足抛出OutOfMemoryError异常也不会回收强引用对象，存在即合理吧。<br>如：</p><ol><li>User user = new User(“Java技术栈”);<br>这就是强引用，user持有了这个对象的存储地址的引用。<h4 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h4>一个对象只有软引用，如果内存空间足够情况下垃圾回收器就不会回收它，如果内存空间不够了就会对这些只有软引用的对象进行回收。只要垃圾回收器没有回收，该软引用对象就可以继续被程序使用。</li></ol><p>所以软引用一般用来实现一些内存敏感的缓存，只要内存空间足够，对象就会保持不被回收掉。</p><h4 id="弱引用（WeakReference）软引用就是加载当中"><a href="#弱引用（WeakReference）软引用就是加载当中" class="headerlink" title="弱引用（WeakReference）软引用就是加载当中"></a>弱引用（WeakReference）软引用就是加载当中</h4><p>弱引用的对象具有更短暂的生命周期，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以用来实现一些规范化映射，如WeakHashMap，当key或者value不再被引用时可以自动被回收。</p><h4 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h4><p>虚引用顾名思义就是形同虚设，虚引用并不决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><p>虚引用主要用来跟踪对象被垃圾回收器回收的活动，虚引用必须和引用队列（ReferenceQueue）联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>强引用永不回收普通对象引用</p><p>软引用内在不足回收缓存对象</p><p>弱引用垃圾回收时缓存对象</p><p>虚引用不确定不确定</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java对象引用四个级别（强、软、弱、虚） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/1%E3%80%81AOP/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring/AOP/1%E3%80%81AOP/</url>
      
        <content type="html"><![CDATA[<p>==1、AOP面向切面编程，与传统OOP（面向对象）相比，功能拓展OOP是自上而下的纵向抽取（继承），这样会产生很多与业务关系不大的冗余代码。AOP的编程思想就是将功能拓展的代码与主业务逻辑分离，达到解耦。==</p><ul><li>Aspect（切面）： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。</li><li>Joint point（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。</li><li>Pointcut（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。</li><li>Advice（增强）：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。</li><li>Target（目标对象）：织入 Advice 的目标对象.。</li><li>Weaving（织入）：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程</li></ul><p>Advice 的类型</p><ul><li>1前置通知：<a href="aop:before">aop:before</a>先执行方面逻辑，再执行目标方法；</li><li>2后置通知：<a href="aop:after-returning">aop:after-returning</a>先执行目标方法，如果不出现异常，再执行方面逻辑；</li><li>3异常通知：<a href="aop:after-throwing">aop:after-throwing</a>先执行目标方法，如果出现异常，再执行方面逻辑；</li><li>4最终通知：<a href="aop:after">aop:after</a>先执行目标方法，有无异常都再执行方面逻辑；（类似于finally的作用）</li><li>5环绕通知（around advice）：前置+后置，先执行方面的前一部分，再执行目标方法，最后执行方面的剩余部分。</li></ul><p>在Spring中，通过动态代理和动态字节码技术实现了AOP.</p><ul><li>如果代理类实现的接口：则是用jdk动态代理技术</li><li>如果代理类未实现的接口：则是cglib动态代理技术</li></ul><p>什么时候被代理的？在spring容器初始化对象的时候。debug源码验证</p>]]></content>
      
      
      <categories>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bus消息总线</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/7%E3%80%81bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/Bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/1%E3%80%81spring/spring-cloud/7%E3%80%81bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/Bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>使用bus构建一个主题,所有服务都连接到这个主题上去，当我们向该主题发送消息时，所有订阅该主题的服务都会收到消息并进行消费.Spring Cloud Bus 配合 Spring Cloud Config 使用可以实现配置的动态刷新。目前 Spring Cloud Bus 支持两种消息代理：RabbitMQ 和 Kafka</p><h4 id="动态刷新配置"><a href="#动态刷新配置" class="headerlink" title="动态刷新配置"></a>动态刷新配置</h4><p>使用 Spring Cloud Bus 动态刷新配置需要配合 Spring Cloud Config 一起使用</p><p>config-server添加消息总线支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8904</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-server</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https:&#x2F;&#x2F;gitee.com&#x2F;macrozheng&#x2F;springcloud-config.git</span><br><span class="line">          username: macro</span><br><span class="line">          password: 123456</span><br><span class="line">          clone-on-start: true # 开启启动时直接从git获取配置</span><br><span class="line">  rabbitmq: #rabbitmq相关配置</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 5672</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8001&#x2F;eureka&#x2F;</span><br><span class="line">management:</span><br><span class="line">  endpoints: #暴露bus刷新配置的端点</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#39;bus-refresh&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给config-client添加消息总线支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9004</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-client</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      profile: dev #启用环境名称</span><br><span class="line">      label: dev #分支名称</span><br><span class="line">      name: config #配置文件名称</span><br><span class="line">      discovery:</span><br><span class="line">        enabled: true</span><br><span class="line">        service-id: config-server</span><br><span class="line">  rabbitmq: #rabbitmq相关配置</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 5672</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8001&#x2F;eureka&#x2F;</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#39;refresh&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> bus消息总线 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bus消息总线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法执行效率分析</title>
      <link href="2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90/"/>
      <url>2020/06/21/Study%20notes/1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/2%E3%80%81%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>如何分析一个“排序算法”？</p><h3 id="1-最好情况、最坏情况、平均情况时间复杂度"><a href="#1-最好情况、最坏情况、平均情况时间复杂度" class="headerlink" title="1. 最好情况、最坏情况、平均情况时间复杂度"></a>1. 最好情况、最坏情况、平均情况时间复杂度</h3><p>我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。</p><ul><li>有些排序算法会区分，为了好对比，都做一下区分。</li><li>对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。</li></ul><h3 id="2-时间复杂度的系数、常数-、低阶"><a href="#2-时间复杂度的系数、常数-、低阶" class="headerlink" title="2. 时间复杂度的系数、常数 、低阶"></a>2. 时间复杂度的系数、常数 、低阶</h3><p>实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。</p><h3 id="3-比较次数和交换（或移动）次数"><a href="#3-比较次数和交换（或移动）次数" class="headerlink" title="3. 比较次数和交换（或移动）次数"></a>3. 比较次数和交换（或移动）次数</h3><p>基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。</p><h3 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h3><p>原地排序（Sorted in place）。==原地排序算法，就是特指空间复杂度是 O(1)== 的排序算法。</p><h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><p>稳定性：==如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。==</p><p>我通过一个例子来解释一下。比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。</p><p>这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法；如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。</p>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法执行效率分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx原理</title>
      <link href="2020/06/21/Study%20notes/6%E3%80%81server/nginx/Nginx%E5%8E%9F%E7%90%86/"/>
      <url>2020/06/21/Study%20notes/6%E3%80%81server/nginx/Nginx%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>nginx启动后，在后台其实启动了一个master进程和多个worker进程</p><ul><li>master只做任务分配给worker</li><li>worker是负责处理nginx部分的请求。</li></ul><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>客户端发送请求到nginx的master,master将任务分配给地下的各个worker,分配方式为各个worker争抢模式，某worker争取到任务后，走代理等到对应的tomcat请求数据逼格返回。</p><h3 id="master-workers的设计优点："><a href="#master-workers的设计优点：" class="headerlink" title="master-workers的设计优点："></a>master-workers的设计优点：</h3><p>首先，对于每个 worker 进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，且某worker进程异常退出后，<br>只会导致当前 worker 上的所有请求失败，其余worker上的请求是可以正常处理的，索引nginx服务还是可用的。</p><h3 id="合理配置worker"><a href="#合理配置worker" class="headerlink" title="合理配置worker"></a>合理配置worker</h3><p>Nginx 同 redis 类似都采用了 io 多路复用机制，每个 worker 都是一个独立的进程，但每个进<br>程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话<br>下。</p><p>==每个 worker 的线程可以把一个 cpu 的性能发挥到极致。所以 worker 数和服务器的 cpu<br>数相等是最为适宜的==。设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗。</p><h3 id="合理配置worker-connection"><a href="#合理配置worker-connection" class="headerlink" title="合理配置worker_connection"></a>合理配置worker_connection</h3><p>这个值是表示每个worker进程所能建立连接的最大值，所以，一个 nginx 能建立的最大连接数，应该是 worker_connections * worker_processes。</p><ul><li><p>对于HTTP 请 求 本 地 资 源 来 说 ， 能 够 支 持 的 最 大 并 发 数 量 是 worker_connections *<br>worker_processes</p></li><li><p>http1.1 的浏览器每次访问要占两个连接，所以普通的静态访<br>问最大并发数是： worker_connections * worker_processes /2，</p></li><li><p>而如果是 HTTP 作 为反向代<br>理来说，最大并发数量应该是 worker_connections *<br>worker_processes/4。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服<br>务的连接，会占用两个连接。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建对象的方式</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Java中创建对象的几种方式</p><h3 id="1、使用构造器（new-关键字）"><a href="#1、使用构造器（new-关键字）" class="headerlink" title="1、使用构造器（new 关键字）"></a>1、使用构造器（new 关键字）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectName obj &#x3D; new ObjectName();</span><br></pre></td></tr></table></figure><p>将构造器封装成静态工厂，获取对象的实例：（推荐使用代替构造器）<br>使用静态工厂的优势：</p><ul><li>静态工厂有名称，当有多个构造器方法重载时，静态工厂可确切描述返回的对象，提高可读性</li><li>可以使用单例，不必每次都创建对象</li><li>可返回原来类型的任何子类</li><li>在创建参数化类型实例的时候，它们使代码变得更加简<br>洁。如：</li></ul><p>随着类型参数变得越来越长，越来越复杂，这一冗长的说明也很快变得痛苦起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;string, list&lt;string&gt;&gt;m m</span><br><span class="line">new Hashmap&lt;string, list&lt;string&gt;&gt;();</span><br></pre></td></tr></table></figure><p>静态工厂:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static&lt;k, V&gt; Hashmap&lt;k, V&gt; newinstance() &#123;</span><br><span class="line">return new Hashmap&lt;k, V&gt;();</span><br></pre></td></tr></table></figure><p>使用静态工厂的缺点：</p><ul><li>类如果不含有公有的，或受保护的构造器，就不能被实例化</li><li>与其他静态方法实际上并无区别（严格遵守命令规范，可弥补这个缺点） 如：String.valueOf()  静态工厂的getType()  与实际类的getType不易区分</li></ul><h3 id="2、使用Class类的newInstance方法"><a href="#2、使用Class类的newInstance方法" class="headerlink" title="2、使用Class类的newInstance方法"></a>2、使用Class类的newInstance方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student stu &#x3D; Student.class.newInstance();</span><br><span class="line">&#x2F;&#x2F;Class类的内部调用Constructor的newInstance方法</span><br></pre></td></tr></table></figure><h3 id="3、使用Constructor类的newInstance方法："><a href="#3、使用Constructor类的newInstance方法：" class="headerlink" title="3、使用Constructor类的newInstance方法："></a>3、使用Constructor类的newInstance方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;Student&gt; constructor &#x3D; Student.class.getInstance(); Student stu &#x3D; constructor.newInstance();　</span><br></pre></td></tr></table></figure><h3 id="4、使用Clone的方法"><a href="#4、使用Clone的方法" class="headerlink" title="4、使用Clone的方法"></a>4、使用Clone的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectName obj &#x3D; obj.clone();&#x2F;&#x2F;这也是原型模式的应用    </span><br></pre></td></tr></table></figure><h3 id="5、使用反序列化："><a href="#5、使用反序列化：" class="headerlink" title="5、使用反序列化："></a>5、使用反序列化：</h3><p>当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象，在反序列化时，JVM创建对象并不会调用任何构造函数。为了反序列化一个对象，我们需要让我们的类实现Serializable接口。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream in &#x3D; new ObjectInputStream (new FileInputStream(&quot;data.obj&quot;)); </span><br><span class="line">Student stu3 &#x3D; (Student)in.readObject();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建对象的方式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nignx 负载均衡的几种算法介绍</title>
      <link href="2020/06/21/Study%20notes/6%E3%80%81server/nginx/2%E3%80%81nignx%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/06/21/Study%20notes/6%E3%80%81server/nginx/2%E3%80%81nignx%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>一、Nginx负载均衡算法</p><pre><code>1、轮询（默认）    每个请求按时间顺序逐一分配到不同的后端服务，如果后端某台服务器死机，自动剔除故障系统，使用户访问不受影响。2、weight（轮询权值）    weight的值越大分配到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。或者仅仅为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。    upstream bakend &#123;      server 192.168.0.14 weight=10;      server 192.168.0.15 weight=10;      &#125;3、ip_hash    每个请求按访问IP的哈希结果分配，使来自同一个IP的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的session共享问题。    upstream bakend &#123;      ip_hash;      server 192.168.0.14:88;      server 192.168.0.15:80;      &#125; 4、fair    比 weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间 来分配请求，响应时间短的优先分配。Nginx本身不支持fair，如果需要这种调度算法，则必须安装upstream_fair模块。    upstream backend &#123;      server server1;      server server2;      fair;      &#125;5、url_hash    按访问的URL的哈希结果来分配请求，使每个URL定向到一台后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身不支持url_hash，如果需要这种调度算法，则必须安装Nginx的hash软件包。    upstream backend &#123;      server squid1:3128;      server squid2:3128;      hash $request_uri;      hash_method crc32;</code></pre>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nignx 负载均衡的几种算法介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>simple-queue</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/2%E3%80%81RabbitMQ/3%E3%80%81simple-queue/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/2%E3%80%81RabbitMQ/3%E3%80%81simple-queue/</url>
      
        <content type="html"><![CDATA[<p>简单消息队列：</p><h1 id="消息生产者："><a href="#消息生产者：" class="headerlink" title="消息生产者："></a>消息生产者：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Send &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消息队列 名称</span><br><span class="line">private static final String QUEUE_NAME&#x3D;&quot;queue_02&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取连接</span><br><span class="line">Connection connection &#x3D; ConnectionUtils.getConnection();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取通道</span><br><span class="line">Channel channel &#x3D; connection.createChannel();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生命消息队列</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">String msg&#x3D;&quot;workQueue消息&quot;+i;</span><br><span class="line">&#x2F;&#x2F;发送消息到队列中</span><br><span class="line">channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes());</span><br><span class="line">System.err.println(&quot;send:&quot;+msg);</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;关闭连接 释放资源</span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消费者："><a href="#消费者：" class="headerlink" title="消费者："></a>消费者：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Receiver &#123;</span><br><span class="line">&#x2F;&#x2F;消息队列 名称</span><br><span class="line">private static final String QUEUE_NAME&#x3D;&quot;queue_02&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取连接</span><br><span class="line">Connection connection &#x3D; ConnectionUtils.getConnection();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取通道</span><br><span class="line">Channel channel &#x3D; connection.createChannel();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生命队列</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消费者监听器</span><br><span class="line">DefaultConsumer consumer&#x3D;new DefaultConsumer(channel)&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body)</span><br><span class="line">throws IOException &#123;</span><br><span class="line">System.err.println(&quot;消费者1：&quot;+new String(body));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;添加监听</span><br><span class="line">channel.basicConsume(QUEUE_NAME, true,consumer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单消息队列模型是：点对点，生产者将消息发送到队列中，消费者消费掉消息之后，该消息就不存在了。简单消息队列模型中，如果有多个消费者，默认采用轮询分发消息给多个消费者。</p><p>公平分发：</p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> simple-queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>roceketmq消息机制</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/3%E3%80%81RocketMQ/4%E3%80%81roceketmq%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/3%E3%80%81RocketMQ/4%E3%80%81roceketmq%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>RocketMQ有2种常见的消费模式,分别是DefaultMQPushConsumer和DefaultMQPullConsumer模式。这里有个误区，其实无论是Push还是Pull，其本质都是拉取消息，只是实现机制不一样</p><h3 id="DefaultMQPushConsumer模式"><a href="#DefaultMQPushConsumer模式" class="headerlink" title="DefaultMQPushConsumer模式"></a>DefaultMQPushConsumer模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">其实并不是broker主动向consumer推送消息，</span><br><span class="line">而是consumer向broker发出请求，保持了一种长链接，</span><br><span class="line">broker会每5秒会检测一次是否有消息，</span><br><span class="line">如果有消息，则将消息推送给consumer。</span><br><span class="line">使用DefaultMQPushConsumer实现消息消费，broker会主动记录消息消费的偏移量。</span><br></pre></td></tr></table></figure><h3 id="DefaultMQPullConsumer模式"><a href="#DefaultMQPullConsumer模式" class="headerlink" title="DefaultMQPullConsumer模式"></a>DefaultMQPullConsumer模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">消费方主动去broker拉取数据，一般会在本地使用定时任务实现，</span><br><span class="line">使用它获得消息状态方便、负载均衡性能可控 ，但消息的及时性差,而且需要手动记录消息消费的偏移量信息 ，</span><br><span class="line">所以在工作中多数情况推荐使用Push模式</span><br></pre></td></tr></table></figure><p>==RocketMQ发送的消息默认会存储到4个队列中，当然创建几个队列存储数据，可以自己定义==</p><p>RocketMQ作为MQ消息中间件，ack机制必不可少，在RocketMQ中常见的应答状态如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalTransactionState:主要针对事务消息的应答状态</span><br><span class="line"></span><br><span class="line">public enum LocalTransactionState &#123;</span><br><span class="line">    COMMIT_MESSAGE,&#x2F;&#x2F;消息提交</span><br><span class="line">    ROLLBACK_MESSAGE,&#x2F;&#x2F;消息回滚</span><br><span class="line">    UNKNOW,   &#x2F;&#x2F;未知状态，一般用于处理超时等现象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ConsumeConcurrentlyStatus:主要针对消息消费的应答状态</span><br><span class="line"></span><br><span class="line">public enum ConsumeConcurrentlyStatus &#123;</span><br><span class="line">    &#x2F;&#x2F;消息消费成功</span><br><span class="line">    CONSUME_SUCCESS,</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;消息重试，一般消息消费失败后，RocketMQ为了保证数据的可靠性，具有重试机制</span><br><span class="line">    RECONSUME_LATER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> roceketmq消息机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>端口和防火墙</title>
      <link href="2020/06/21/Study%20notes/7%E3%80%81linux/%E7%AB%AF%E5%8F%A3%E5%92%8C%E9%98%B2%E7%81%AB%E5%A2%99/"/>
      <url>2020/06/21/Study%20notes/7%E3%80%81linux/%E7%AB%AF%E5%8F%A3%E5%92%8C%E9%98%B2%E7%81%AB%E5%A2%99/</url>
      
        <content type="html"><![CDATA[<p>关闭防火墙，就可以外部访问了。不受端口限制。生产环境，最好开启防火墙，开启部分端口。</p><h4 id="查看防火墙状态：service方式"><a href="#查看防火墙状态：service方式" class="headerlink" title="查看防火墙状态：service方式"></a>查看防火墙状态：service方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables status</span><br></pre></td></tr></table></figure><h4 id="开启-关闭防火墙【永久有效】"><a href="#开启-关闭防火墙【永久有效】" class="headerlink" title="开启/关闭防火墙【永久有效】"></a>开启/关闭防火墙【永久有效】</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启： chkconfig iptables on </span><br><span class="line">关闭： chkconfig iptables off</span><br></pre></td></tr></table></figure><h5 id="开启-关闭防火墙【临时生效】"><a href="#开启-关闭防火墙【临时生效】" class="headerlink" title="开启/关闭防火墙【临时生效】"></a>开启/关闭防火墙【临时生效】</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启： service iptables start </span><br><span class="line">关闭： service iptables stop </span><br></pre></td></tr></table></figure><h5 id="查看防火墙状态：iptables方式"><a href="#查看防火墙状态：iptables方式" class="headerlink" title="查看防火墙状态：iptables方式"></a>查看防火墙状态：iptables方式</h5><p>先进入init.d目录，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;init.d&#x2F;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#查看防火墙状态：</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;iptables status</span><br><span class="line"></span><br><span class="line">#暂时关闭防火墙</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;iptables stop</span><br><span class="line"></span><br><span class="line">#暂时开启防火墙</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;iptables start</span><br><span class="line"></span><br><span class="line">#重启iptables：</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;iptables restart</span><br></pre></td></tr></table></figure><h4 id="3-开启部分端口"><a href="#3-开启部分端口" class="headerlink" title="3.开启部分端口"></a>3.开启部分端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;iptables</span><br><span class="line"></span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 6379 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 8081 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 8082 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables restart </span><br></pre></td></tr></table></figure><h4 id="4、查看开放端口"><a href="#4、查看开放端口" class="headerlink" title="4、查看开放端口"></a>4、查看开放端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">netstat -nupl (UDP类型的端口)</span><br><span class="line">netstat -ntpl (TCP类型的端口)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">a 表示所有</span><br><span class="line"></span><br><span class="line">n表示不查询dns</span><br><span class="line"></span><br><span class="line">t表示tcp协议</span><br><span class="line"></span><br><span class="line">u表示udp协议</span><br><span class="line"></span><br><span class="line">p表示查询占用的程序</span><br><span class="line"></span><br><span class="line">l表示查询正在监听的程序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">netstat -nuplf|grep 3306   &#x2F;&#x2F;这个表示查找处于监听状态的，端口号为3306的进程</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 端口和防火墙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker介绍</title>
      <link href="2020/06/21/Study%20notes/9%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/docker/1%E3%80%81docker%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/06/21/Study%20notes/9%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/docker/1%E3%80%81docker%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>docker：</p><ul><li>虚拟机是模拟一整套硬件，在其基础上运行的一个完整的操作系统</li><li>docker容器是直接运行在宿主内核中的，没有进行硬件虚拟，也没有自己的内容。只是将需要软件配置等统一打包</li></ul><p>docker官网：<a href="http://www.docker.com/">http://www.docker.com</a><br>docker中文网站：<a href="https://www.docker-cn.com/">https://www.docker-cn.com/</a><br>Docker Hub官网: <a href="https://hub.docker.com/">https://hub.docker.com/</a><br>Docker的架构图：</p><h3 id="docker安装："><a href="#docker安装：" class="headerlink" title="docker安装："></a>docker安装：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#先安装docker依赖：</span><br><span class="line">yum install -y epel-release</span><br><span class="line">#安装docker:</span><br><span class="line">yum install -y docker-io</span><br><span class="line"></span><br><span class="line">#安装后的配置文件：</span><br><span class="line">&#x2F;etc&#x2F;sysconfig&#x2F;docker</span><br><span class="line"></span><br><span class="line">#检测安装成功，查看版本：</span><br><span class="line">docker version</span><br><span class="line">#docker信息</span><br><span class="line">docker info</span><br><span class="line">#docker帮助命令</span><br><span class="line">docker --help</span><br><span class="line"></span><br><span class="line">#启动Docker后台服务：</span><br><span class="line">service docker start</span><br><span class="line">或</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">#设置开机自起</span><br><span class="line">systemctl  enable docker</span><br></pre></td></tr></table></figure><h3 id="配置镜像加速："><a href="#配置镜像加速：" class="headerlink" title="配置镜像加速："></a>配置镜像加速：</h3><p>docker镜像文件仓库默认是docker.hub ,配置切换至国内的阿里云</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">进入阿里云的镜像管理中心：</span><br><span class="line">https:&#x2F;&#x2F;cr.console.aliyun.com&#x2F;?spm&#x3D;5176.1971733.0.2.6c045aaamyGClV#&#x2F;accelerator</span><br><span class="line"></span><br><span class="line">复制加速地址：https:&#x2F;&#x2F;c24l0xe6.mirror.aliyuncs.com</span><br><span class="line"></span><br><span class="line">配置到docker的配置文件</span><br><span class="line">mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;c24l0xe6.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#重加载</span><br><span class="line">systemctl daemon-reload </span><br><span class="line">#重启</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="卸载docker："><a href="#卸载docker：" class="headerlink" title="卸载docker："></a>卸载docker：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker </span><br><span class="line">yum -y remove docker-ce</span><br><span class="line">rm -rf &#x2F;var&#x2F;lib&#x2F;docker</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重入锁</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/8%E3%80%81%E9%87%8D%E5%85%A5%E9%94%81/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/8%E3%80%81%E9%87%8D%E5%85%A5%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁</p><h3 id="1、可重入锁原理："><a href="#1、可重入锁原理：" class="headerlink" title="1、可重入锁原理："></a>1、可重入锁原理：</h3><p>==为每个锁关联一个获取计数值和一个所有者的线程。当计数值为0时，该锁未被任何线程持有。当一个线程请求一个未被持有的锁时，JVM会记下锁的持有者和计数值+1 ，如果是同一个线程再次获取这个锁时，计数值递增。当线程退出同步代码块时，计数值递减。当计数值为0时，这个锁被释放。==</p><h3 id="2、synchronized可重入锁示例"><a href="#2、synchronized可重入锁示例" class="headerlink" title="2、synchronized可重入锁示例"></a>2、synchronized可重入锁示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">public synchronized void get()&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getId());</span><br><span class="line">set();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void set()&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">get();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Test ss&#x3D;new Test();</span><br><span class="line">new Thread(ss).start();</span><br><span class="line">new Thread(ss).start();</span><br><span class="line">new Thread(ss).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、ReentrantLock可重入锁示例"><a href="#3、ReentrantLock可重入锁示例" class="headerlink" title="3、ReentrantLock可重入锁示例"></a>3、ReentrantLock可重入锁示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Test implements Runnable &#123;</span><br><span class="line">ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">public void get() &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(Thread.currentThread().getId());</span><br><span class="line">set();</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void set() &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(Thread.currentThread().getId());</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Test ss &#x3D; new Test();</span><br><span class="line">new Thread(ss).start();</span><br><span class="line">new Thread(ss).start();</span><br><span class="line">new Thread(ss).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重入锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串练习</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81String/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%83%E4%B9%A0/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81String/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><ul><li>遍历一次字符串，统计空格的总数，计算出替换后字符串总长度。</li><li>从字符串后面开始复制和替换，首先准备两个指针，p1，p2，p1指向原始字符串末尾，p2指向替换后字符串末尾，p1指向的字符不为空，复制到p2所在的位置，之后两者向前移动一个位置。</li><li>为空时，p2插入字符串%20，向前移动三个位置，p1向前移动一个位置，直到p1p2指向同一个位置或者p1遍历了所有的字符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void replaceSpace(char *str,int length) &#123;</span><br><span class="line">        int i, pastlength &#x3D; 0, afterlength, k, spacelength &#x3D; 0;</span><br><span class="line">        i &#x3D; 0;</span><br><span class="line">        while(str[i] !&#x3D; &#39;\0&#39;)</span><br><span class="line">        &#123;</span><br><span class="line">            pastlength++;&#x2F;&#x2F;替换前长度</span><br><span class="line">            if(str[i] &#x3D;&#x3D; &#39; &#39;)</span><br><span class="line">                spacelength++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        afterlength &#x3D; pastlength + spacelength * 2; &#x2F;&#x2F;替换之后字符串的长度</span><br><span class="line">        if(afterlength&gt;length)  </span><br><span class="line">            return;  </span><br><span class="line">        int j&#x3D;afterlength;  </span><br><span class="line">        for(i&#x3D;pastlength;i&gt;&#x3D;0 &amp;&amp; j &gt; i;i--)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if(str[i]!&#x3D;&#39; &#39;)  </span><br><span class="line">                str[j--]&#x3D;str[i];  </span><br><span class="line">            else  </span><br><span class="line">            &#123;  </span><br><span class="line">                str[j--]&#x3D;&#39;0&#39;;  </span><br><span class="line">                str[j--]&#x3D;&#39;2&#39;;  </span><br><span class="line">                str[j--]&#x3D;&#39;%&#39;;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>始终要覆盖toString</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/4%E3%80%81Object%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/2%E3%80%81%E5%A7%8B%E7%BB%88%E8%A6%81%E8%A6%86%E7%9B%96toString/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/3%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87/4%E3%80%81Object%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/2%E3%80%81%E5%A7%8B%E7%BB%88%E8%A6%81%E8%A6%86%E7%9B%96toString/</url>
      
        <content type="html"><![CDATA[<p>java.lang.Object提供了toString方法的一个实现，但他返回的字符串通常并不是类的用户所期望看到的。它包含类的名称，以及一个“@”符号，接着是散列码的无符号十六进制表示法，例如“PhoneNumber@163b91”</p><h4 id="约定："><a href="#约定：" class="headerlink" title="约定："></a>约定：</h4><p>toString的通用约定指出，被返回的字符串应该是一个“简洁地，但信息丰富，并且易于阅读的表达形式”==建议所有的子类都覆盖这个方法。==</p><p>在实现toString的时候，文档中指定返回值的格式</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>他可以被用做一种标准的、明确地、适合人约定的对象表示法。这种表示法可以用于输入和输出，以及用在永久的适合于人类阅读的数据对象中，例如XML文档。</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>如果这个类已经被广泛使用，一旦指定格式，就必须始终如一地坚持这种格式。程序员将会编写相应的代码来解析这种字符串表示法，产生字符串表示法，以及把字符串表示法嵌入到持久的数据库中。如果将来发型版本中改变了这种表示法，就会破坏他们的代码和数据</p><p>所以无论是否决定指定格式，都应该在文档中明确的表明你的意图。如果你要指定格式，则应该严格地这样去做（写注释）</p>]]></content>
      
      
      <categories>
          
          <category> Object中的方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 始终要覆盖toString </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>count实现</title>
      <link href="2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%9E%B6%E6%9E%84/count%E5%AE%9E%E7%8E%B0/"/>
      <url>2020/06/21/Study%20notes/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%9E%B6%E6%9E%84/count%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>在不同的引擎中，count(*) 有不同的实现方式</p><ul><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；(语句没加where条件)</li><li>而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li></ul><h4 id="为什么-InnoDB-不跟-MyISAM-一样，也把总数存起来呢？"><a href="#为什么-InnoDB-不跟-MyISAM-一样，也把总数存起来呢？" class="headerlink" title="为什么 InnoDB 不跟 MyISAM 一样，也把总数存起来呢？"></a>为什么 InnoDB 不跟 MyISAM 一样，也把总数存起来呢？</h4><p>因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的<img src="https://static001.geekbang.org/resource/image/5e/97/5e716ba1d464c8224c1c1f36135d0e97.png" alt="image"></p><p>三个会话 A、B、C 会同时查询表 t 的总行数，但拿到的结果却不同。</p><p>这和 InnoDB 的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是 MVCC 来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于 count(*) 请求来说，InnoDB 只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</p>]]></content>
      
      
      <categories>
          
          <category> mysql架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> count实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/4%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/4%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>缓存导致的可见性问题</li><li>线程切换带来的原子性问题，</li><li>指令重排带来的有序性问题。</li><li><h4 id="线程安全产生原因："><a href="#线程安全产生原因：" class="headerlink" title="线程安全产生原因："></a>线程安全产生原因：</h4><h3 id="多线程操作共享可变状态数据"><a href="#多线程操作共享可变状态数据" class="headerlink" title="==多线程操作共享可变状态数据=="></a>==多线程操作共享可变状态数据==</h3></li></ul><p>解决线程安全的方式：</p><p>==解决原子性，可见性，有序性==</p><h3 id="1、不在线程之间共享该状态变量"><a href="#1、不在线程之间共享该状态变量" class="headerlink" title="1、不在线程之间共享该状态变量"></a>1、不在线程之间共享该状态变量</h3><p>如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭（Thread Confinement），它是实现线程安全型的最简单方式之一。java提供的机制：例如局部变量和 ThreadLocal 类等</p><h3 id="2、将状态变量修改为不可变状态的变量"><a href="#2、将状态变量修改为不可变状态的变量" class="headerlink" title="2、将状态变量修改为不可变状态的变量"></a>2、将状态变量修改为不可变状态的变量</h3><p>不可变对象一定是线程安全的，如何保证对象状态不可变</p><ul><li>1、对象的创建是正确的，不会出现对象溢出</li><li>2、对象创建以后其状态就不可修改</li><li>3、对象所有的域都是final类型</li><li>4、确保可见性，volatile</li></ul><h3 id="3、互斥同步（加锁）"><a href="#3、互斥同步（加锁）" class="headerlink" title="3、互斥同步（加锁）"></a>3、互斥同步（加锁）</h3><p>synchronized与Lock</p><h3 id="4、非阻塞同步（CAS算法）"><a href="#4、非阻塞同步（CAS算法）" class="headerlink" title="4、非阻塞同步（CAS算法）"></a>4、非阻塞同步（CAS算法）</h3>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中间件的组件</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/3%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E7%BB%84%E4%BB%B6/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/4%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/3%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>消息中间件的组成</p><pre><code>  2.1 Broker</code></pre><p>消息服务器，作为server提供消息核心服务</p><pre><code>  2.2 Producer</code></pre><p>消息生产者，业务的发起方，负责生产消息传输给broker，</p><pre><code>  2.3 Consumer</code></pre><p>消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理</p><pre><code>  2.4 Topic</code></pre><p>主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的       广播</p><pre><code>  2.5 Queue</code></pre><p>队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收</p><pre><code>  2.6 Message</code></pre><p>消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件的组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/5%E3%80%81vector/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/5%E3%80%81vector/</url>
      
        <content type="html"><![CDATA[<h3 id="Vector与ArrayList比较"><a href="#Vector与ArrayList比较" class="headerlink" title="Vector与ArrayList比较"></a>Vector与ArrayList比较</h3><ul><li><p>Vector与ArrayList的最大区别就是Vector是线程安全的，而ArrayList不是线程安全的(非复合操作)。==Vector 的方法都具有 synchronized 关键修饰。但对于复合操作，Vector 仍然需要进行同步处理。==</p></li><li><p>ArrayList不可以设置扩展的容量，默认1.5倍； Vector可以设置扩展的容量，，默认2倍</p></li><li><p>ArrayList的无参构造方法中初始容量为0（初次调用add()会更新为10）；Vector的无参构造方法中初始容量为10</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务-最大努力通知</title>
      <link href="2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/8%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5/"/>
      <url>2020/06/21/Study%20notes/4%E3%80%81%E6%A1%86%E6%9E%B6/11%E3%80%81%E9%AB%98%E9%A2%91%E7%82%B9%E9%97%AE%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/8%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>按规律进行通知，不保证数据一定能通知成功，但会提供可查询操作接口进行核对。这种方案主要用在与第三方系统通讯时，比如：调用微信或支付宝支付后的支付结果通知。这种方案也是结合MQ进行实现，例如：通过MQ发送http请求，设置最大通知次数。达到通知次数后即不再通知。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式事务解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务-最大努力通知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具类：Collections</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/18%E3%80%81%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9ACollections/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/4%E3%80%81java%E5%AE%B9%E5%99%A8/18%E3%80%81%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9ACollections/</url>
      
        <content type="html"><![CDATA[<ul><li>1、sort 排序</li><li>2、binarySearch 二分查找(折半查找)</li><li>3、equals 比较</li><li>4、fill 填充</li><li>5、asList 转列表 记得一个toArray吗？</li><li>6、indexOf str首次出现的位置</li><li>6、hash 哈希(重点)</li><li>7、toString 重写Object中方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具类：Collections </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无标题Markdown</title>
      <link href="2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/"/>
      <url>2020/06/21/Study%20notes/3%E3%80%81java/6%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/</url>
      
        <content type="html"><![CDATA[<p>线程间通信，同机器进程间通信，跨机器进程间通信</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无标题Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx+Keepalived高可用集群</title>
      <link href="2020/06/21/Study%20notes/6%E3%80%81server/nginx/3%E3%80%81Nginx+Keepalived%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/"/>
      <url>2020/06/21/Study%20notes/6%E3%80%81server/nginx/3%E3%80%81Nginx+Keepalived%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_32447301/article/details/83656443">https://blog.csdn.net/qq_32447301/article/details/83656443</a></p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx+Keepalived高可用集群 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
